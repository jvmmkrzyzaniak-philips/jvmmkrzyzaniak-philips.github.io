import { clientCSDecorator } from './clientCS';
import { validateKey } from '../utils/inputValidation/key';
import { getMatching, keyParser } from '../utils/key';
import { sdkClientFactory } from './sdkClient';
import { objectAssign } from '../utils/lang/objectAssign';
import { RETRIEVE_CLIENT_DEFAULT, NEW_SHARED_CLIENT, RETRIEVE_CLIENT_EXISTING, LOG_PREFIX_CLIENT_INSTANTIATION } from '../logger/constants';
import { SDK_SEGMENTS_ARRIVED } from '../readiness/constants';
import { buildInstanceId } from './identity';
/**
 * Factory of client method for the client-side API variant where TT is ignored.
 * Therefore, clients don't have a bound TT for the track method.
 */
export function sdkClientMethodCSFactory(params) {
    var clients = params.clients, storage = params.storage, syncManager = params.syncManager, sdkReadinessManager = params.sdkReadinessManager, _a = params.settings, key = _a.core.key, log = _a.log;
    var mainClientInstance = clientCSDecorator(log, sdkClientFactory(params), key);
    var parsedDefaultKey = keyParser(key);
    var defaultInstanceId = buildInstanceId(parsedDefaultKey);
    // Cache instances created per factory.
    clients[defaultInstanceId] = mainClientInstance;
    return function client(key) {
        if (key === undefined) {
            log.debug(RETRIEVE_CLIENT_DEFAULT);
            return mainClientInstance;
        }
        // Validate the key value
        var validKey = validateKey(log, key, LOG_PREFIX_CLIENT_INSTANTIATION);
        if (validKey === false) {
            throw new Error('Shared Client needs a valid key.');
        }
        var instanceId = buildInstanceId(validKey);
        if (!clients[instanceId]) {
            var matchingKey = getMatching(validKey);
            var sharedSdkReadiness_1 = sdkReadinessManager.shared();
            var sharedStorage = storage.shared && storage.shared(matchingKey, function (err) {
                if (err) {
                    sharedSdkReadiness_1.readinessManager.timeout();
                    return;
                }
                // Emit SDK_READY in consumer mode for shared clients
                sharedSdkReadiness_1.readinessManager.segments.emit(SDK_SEGMENTS_ARRIVED);
            });
            // 3 possibilities:
            // - Standalone mode: both syncManager and sharedSyncManager are defined
            // - Consumer mode: both syncManager and sharedSyncManager are undefined
            // - Consumer partial mode: syncManager is defined (only for submitters) but sharedSyncManager is undefined
            // @ts-ignore
            var sharedSyncManager = syncManager && sharedStorage && syncManager.shared(matchingKey, sharedSdkReadiness_1.readinessManager, sharedStorage);
            // As shared clients reuse all the storage information, we don't need to check here if we
            // will use offline or online mode. We should stick with the original decision.
            clients[instanceId] = clientCSDecorator(log, sdkClientFactory(objectAssign({}, params, {
                sdkReadinessManager: sharedSdkReadiness_1,
                storage: sharedStorage || storage,
                syncManager: sharedSyncManager,
            }), true), validKey);
            log.info(NEW_SHARED_CLIENT);
        }
        else {
            log.debug(RETRIEVE_CLIENT_EXISTING);
        }
        return clients[instanceId];
    };
}
