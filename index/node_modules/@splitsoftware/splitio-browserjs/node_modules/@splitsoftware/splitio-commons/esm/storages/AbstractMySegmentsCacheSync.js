/**
 * This class provides a skeletal implementation of the ISegmentsCacheSync interface
 * to minimize the effort required to implement this interface.
 */
var AbstractMySegmentsCacheSync = /** @class */ (function () {
    function AbstractMySegmentsCacheSync() {
    }
    /**
     * clear the cache.
     */
    AbstractMySegmentsCacheSync.prototype.clear = function () {
        this.resetSegments({});
    };
    // No-op. Not used in client-side.
    AbstractMySegmentsCacheSync.prototype.registerSegments = function () { return false; };
    AbstractMySegmentsCacheSync.prototype.update = function () { return false; };
    /**
     * For server-side synchronizer: the method is not used.
     * For client-side synchronizer: it resets or updates the cache.
     */
    AbstractMySegmentsCacheSync.prototype.resetSegments = function (segmentsData) {
        var _this = this;
        this.setChangeNumber(segmentsData.cn);
        var _a = segmentsData, added = _a.added, removed = _a.removed;
        if (added && removed) {
            var isDiff_1 = false;
            added.forEach(function (segment) {
                isDiff_1 = _this.addSegment(segment) || isDiff_1;
            });
            removed.forEach(function (segment) {
                isDiff_1 = _this.removeSegment(segment) || isDiff_1;
            });
            return isDiff_1;
        }
        var names = (segmentsData.k || []).map(function (s) { return s.n; }).sort();
        var storedSegmentKeys = this.getRegisteredSegments().sort();
        // Extreme fast => everything is empty
        if (!names.length && !storedSegmentKeys.length)
            return false;
        var index = 0;
        while (index < names.length && index < storedSegmentKeys.length && names[index] === storedSegmentKeys[index])
            index++;
        // Quick path => no changes
        if (index === names.length && index === storedSegmentKeys.length)
            return false;
        // Slowest path => add and/or remove segments
        for (var removeIndex = index; removeIndex < storedSegmentKeys.length; removeIndex++) {
            this.removeSegment(storedSegmentKeys[removeIndex]);
        }
        for (var addIndex = index; addIndex < names.length; addIndex++) {
            this.addSegment(names[addIndex]);
        }
        return true;
    };
    return AbstractMySegmentsCacheSync;
}());
export { AbstractMySegmentsCacheSync };
