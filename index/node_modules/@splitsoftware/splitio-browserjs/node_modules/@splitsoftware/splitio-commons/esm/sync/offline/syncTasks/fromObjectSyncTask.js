import { forOwn } from '../../../utils/lang';
import { syncTaskFactory } from '../../syncTask';
import { CONTROL } from '../../../utils/constants';
import { SDK_SPLITS_ARRIVED, SDK_SEGMENTS_ARRIVED, SDK_SPLITS_CACHE_LOADED } from '../../../readiness/constants';
import { SYNC_OFFLINE_DATA, ERROR_SYNC_OFFLINE_LOADING } from '../../../logger/constants';
/**
 * Offline equivalent of `splitChangesUpdaterFactory`
 */
export function fromObjectUpdaterFactory(splitsParser, storage, readiness, settings) {
    var log = settings.log, splitsCache = storage.splits;
    var startingUp = true;
    return function objectUpdater() {
        var splits = [];
        var loadError = null;
        var splitsMock = {};
        try {
            splitsMock = splitsParser(settings);
        }
        catch (err) {
            loadError = err;
            log.error(ERROR_SYNC_OFFLINE_LOADING, [err]);
        }
        if (!loadError && splitsMock) {
            log.debug(SYNC_OFFLINE_DATA, [JSON.stringify(splitsMock)]);
            forOwn(splitsMock, function (val, name) {
                // @ts-ignore Split changeNumber and seed is undefined in localhost mode
                splits.push({
                    name: name,
                    status: 'ACTIVE',
                    killed: false,
                    trafficAllocation: 100,
                    defaultTreatment: CONTROL,
                    conditions: val.conditions || [],
                    configurations: val.configurations,
                    trafficTypeName: val.trafficTypeName
                });
            });
            return Promise.all([
                splitsCache.clear(),
                splitsCache.update(splits, [], Date.now())
            ]).then(function () {
                readiness.splits.emit(SDK_SPLITS_ARRIVED);
                if (startingUp) {
                    startingUp = false;
                    var isCacheLoaded_1 = storage.validateCache ? storage.validateCache() : false;
                    Promise.resolve().then(function () {
                        // Emits SDK_READY_FROM_CACHE
                        if (isCacheLoaded_1)
                            readiness.splits.emit(SDK_SPLITS_CACHE_LOADED);
                        // Emits SDK_READY
                        readiness.segments.emit(SDK_SEGMENTS_ARRIVED);
                    });
                }
                return true;
            });
        }
        else {
            return Promise.resolve(true);
        }
    };
}
/**
 * PollingManager in Offline mode
 */
export function fromObjectSyncTaskFactory(splitsParser, storage, readiness, settings) {
    return syncTaskFactory(settings.log, fromObjectUpdaterFactory(splitsParser, storage, readiness, settings), settings.scheduler.offlineRefreshRate, 'offlineUpdater');
}
