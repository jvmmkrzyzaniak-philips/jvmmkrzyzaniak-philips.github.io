import t from "../common/base-provider.js";
import { newInAppMessageFromJson as ut } from "../InAppMessage/in-app-message-factory.js";
import ve from "../models/braze-event.js";
import {
  isArray as z,
  isEqual as ii,
  validateValueIsFromEnum as ta,
} from "../util/code-utils.js";
import { STORAGE_KEYS as s } from "../managers/storage-manager.js";
import wt from "../InAppMessage/models/templated-in-app-message.js";
import pt from "./models/trigger.js";
import et from "./models/trigger-events.js";
import { logger as N } from "../../shared-lib/index.js";
export default class gr extends t {
  constructor(t, i, s, e, r) {
    super(),
      (this.tg = t),
      (this.Ts = i),
      (this.C = s),
      (this.Fi = e),
      (this.ig = r),
      (this.tg = t),
      (this.Ts = i),
      (this.C = s),
      (this.Fi = e),
      (this.ig = r),
      (this.sg = []),
      (this.eg = []),
      (this.hg = null),
      (this.ng = {}),
      (this.og = {}),
      (this.triggers = []),
      (this.lg = 0),
      this.ag(),
      this.gg();
  }
  fg() {
    if (this.C) {
      (this.hg = this.C.ft(s.gt.aE) || this.hg),
        (this.ng = this.C.ft(s.gt.iE) || this.ng),
        (this.og = this.C.ft(s.gt.nE) || this.og);
      for (let t = 0; t < this.triggers.length; t++) {
        const i = this.triggers[t];
        i.id && null != this.og[i.id] && i.ad(this.og[i.id]);
      }
    }
  }
  ag() {
    if (!this.C) return;
    this.lg = this.C.ft(s.gt.oE) || 0;
    const t = this.C.ft(s.gt.rE) || [],
      i = [];
    for (let s = 0; s < t.length; s++) i.push(pt.En(t[s]));
    (this.triggers = i), this.fg();
  }
  gg() {
    const t = this,
      i = function (i, s, e, r, h) {
        return function () {
          t.cg(i, s, e, r, h);
        };
      },
      e = {};
    for (const t of this.triggers) t.id && (e[t.id] = t);
    let r = !1;
    for (let t = 0; t < this.triggers.length; t++) {
      const s = this.triggers[t];
      if (s.id && null != this.ng[s.id]) {
        const t = this.ng[s.id],
          h = [];
        for (let r = 0; r < t.length; r++) {
          const n = t[r],
            o = s.ud(n.Jr || 0);
          if (o > 0) {
            let t, r;
            h.push(n),
              null != n.ug && (t = n.ug),
              null != n.dg && ve.RE(n.dg) && (r = ve.En(n.dg));
            const l = [];
            if (n.pg && z(n.pg))
              for (let t = 0; t < n.pg.length; t++) {
                const i = e[n.pg[t]];
                null != i && l.push(i);
              }
            this.eg.push(window.setTimeout(i(s, n.Jr || 0, t, r, l), o));
          }
        }
        this.ng[s.id].length > h.length &&
          ((this.ng[s.id] = h),
          (r = !0),
          0 === this.ng[s.id].length && delete this.ng[s.id]);
      }
    }
    r && this.C && this.C.Bt(s.gt.iE, this.ng);
  }
  mg() {
    if (!this.C) return;
    const t = [];
    for (let i = 0; i < this.triggers.length; i++)
      t.push(this.triggers[i].bt());
    (this.lg = new Date().valueOf()),
      this.C.Bt(s.gt.rE, t),
      this.C.Bt(s.gt.oE, this.lg);
  }
  bg() {
    if (!this.C) return;
    (this.C.ft(s.gt.oE) || 0) > this.lg ? this.ag() : this.fg();
  }
  U(t) {
    let i = !1;
    if (null != t && t.triggers) {
      this.ig.Zr(), this.fg();
      const e = {},
        r = {};
      this.triggers = [];
      for (let s = 0; s < t.triggers.length; s++) {
        const h = pt.fromJson(t.triggers[s]);
        if (h) {
          h.id &&
            null != this.og[h.id] &&
            (h.ad(this.og[h.id]), (e[h.id] = this.og[h.id])),
            h.id && null != this.ng[h.id] && (r[h.id] = this.ng[h.id]);
          for (let t = 0; t < h.sd.length; t++)
            if (h.sd[t]._c(et.Bs, null)) {
              i = !0;
              break;
            }
          this.triggers.push(h);
        }
      }
      ii(this.og, e) || ((this.og = e), this.C && this.C.Bt(s.gt.nE, this.og)),
        ii(this.ng, r) ||
          ((this.ng = r), this.C && this.C.Bt(s.gt.iE, this.ng)),
        this.mg(),
        i &&
          (N.info("Trigger with test condition found, firing test."),
          this.Ce(et.Bs)),
        this.Ce(et.OPEN);
      const h = this.sg;
      let n;
      this.sg = [];
      for (let t = 0; t < h.length; t++)
        (n = Array.prototype.slice.call(h[t])), this.Ce(...n);
    }
  }
  cg(t, i, s, e, r) {
    const h = (e) => {
        this.fg();
        const r = new Date().valueOf();
        t.dd(i) ||
          (!1 === navigator.onLine && t.type === pt.Xr.Or && e.imageUrl
            ? N.info(
                `Not showing ${t.type} trigger action ${t.id} due to offline state.`,
              )
            : t.nd(r) && this.wg(t, r, s)
            ? 0 === this.Ts.uc()
              ? N.info(
                  `Not displaying trigger ${t.id} because neither automaticallyShowInAppMessages() nor subscribeToInAppMessage() were called.`,
                )
              : (this.Ts.X([e]), this.yg(t, r))
            : N.info(
                `Not displaying trigger ${t.id} because display time fell outside of the acceptable time window.`,
              ));
      },
      n = () => {
        this.fg();
        const h = r.pop();
        if (null != h)
          if ((this.Tg(h, i, s, e, r), h.dd(i))) {
            let t = `Server aborted in-app message display, but the timeout on fallback trigger ${h.id} has already elapsed.`;
            r.length > 0 && (t += " Continuing to fall back."), N.info(t), n();
          } else {
            N.info(
              `Server aborted in-app message display. Falling back to lower priority ${h.type} trigger action ${t.id}.`,
            );
            const n = 1e3 * h.ed - (new Date().valueOf() - i);
            n > 0
              ? this.eg.push(
                  window.setTimeout(() => {
                    this.cg(h, i, s, e, r);
                  }, n),
                )
              : this.cg(h, i, s, e, r);
          }
      };
    let o, l, a;
    switch (t.type) {
      case pt.Xr.Or:
        if (((o = ut(t.data)), null == o)) {
          N.error(
            `Could not parse trigger data for trigger ${t.id}, ignoring.`,
          );
          break;
        }
        if (((l = this.ig.Mr(o)), l)) {
          N.error(l), n();
          break;
        }
        h(o);
        break;
      case pt.Xr.md:
        if (((a = wt.fromJson(t.data, h, n, i, t.Kr || 0)), null == a)) {
          N.error(
            `Could not parse trigger data for trigger ${t.id}, ignoring.`,
          );
          break;
        }
        this.ig.Er(a, s, e);
        break;
      default:
        N.error(`Trigger ${t.id} was of unexpected type ${t.type}, ignoring.`);
    }
  }
  Ce(t, i = null, s) {
    if (!ta(et, t, "Cannot fire trigger action.", "TriggerEvents")) return;
    if (this.Fi && this.Fi.Zl())
      return (
        N.info(
          "Trigger sync is currently in progress, awaiting sync completion before firing trigger event.",
        ),
        void this.sg.push(arguments)
      );
    this.bg();
    const e = new Date().valueOf(),
      r = e - (this.hg || 0);
    let h = !0,
      n = !0;
    const o = [];
    for (let s = 0; s < this.triggers.length; s++) {
      const r = this.triggers[s],
        l = e + 1e3 * r.ed;
      if (
        r.nd(l) &&
        (null == r.startTime || r.startTime.valueOf() <= e) &&
        (null == r.endTime || r.endTime.valueOf() >= e)
      ) {
        let s = !1;
        for (let e = 0; e < r.sd.length; e++)
          if (r.sd[e]._c(t, i)) {
            s = !0;
            break;
          }
        s && ((h = !1), this.wg(r, l, t) && ((n = !1), o.push(r)));
      }
    }
    if (h)
      return void N.info(
        `Trigger event ${t} did not match any trigger conditions.`,
      );
    if (n)
      return void N.info(
        `Ignoring ${t} trigger event because a trigger was displayed ${
          r / 1e3
        }s ago.`,
      );
    o.sort((t, i) => t.priority - i.priority);
    const l = o.pop();
    null != l &&
      (N.info(
        `Firing ${l.type} trigger action ${l.id} from trigger event ${t}.`,
      ),
      this.Tg(l, e, t, s, o),
      0 === l.ed
        ? this.cg(l, e, t, s, o)
        : this.eg.push(
            window.setTimeout(() => {
              this.cg(l, e, t, s, o);
            }, 1e3 * l.ed),
          ));
  }
  changeUser(t = !1) {
    if (((this.triggers = []), this.C && this.C.Ut(s.gt.rE), !t)) {
      (this.sg = []), (this.hg = null), (this.og = {}), (this.ng = {});
      for (let t = 0; t < this.eg.length; t++) clearTimeout(this.eg[t]);
      (this.eg = []),
        this.C && (this.C.Ut(s.gt.aE), this.C.Ut(s.gt.nE), this.C.Ut(s.gt.iE));
    }
  }
  clearData() {
    (this.triggers = []), (this.hg = null), (this.og = {}), (this.ng = {});
    for (let t = 0; t < this.eg.length; t++) clearTimeout(this.eg[t]);
    this.eg = [];
  }
  wg(t, i, s) {
    if (null == this.hg) return !0;
    if (s === et.Bs)
      return (
        N.info(
          "Ignoring minimum interval between trigger because it is a test type.",
        ),
        !0
      );
    let e = t.hd;
    return null == e && (e = this.tg), i - this.hg >= 1e3 * e;
  }
  Tg(t, i, e, r, h) {
    this.fg(), t.id && (this.ng[t.id] = this.ng[t.id] || []);
    const n = {};
    let o;
    (n.Jr = i), (n.ug = e), null != r && (o = r.bt()), (n.dg = o);
    const l = [];
    for (const t of h) t.id && l.push(t.id);
    (n.pg = l),
      t.id && this.ng[t.id].push(n),
      this.C && this.C.Bt(s.gt.iE, this.ng);
  }
  yg(t, i) {
    this.fg(),
      t.ad(i),
      (this.hg = i),
      t.id && (this.og[t.id] = i),
      this.C && (this.C.Bt(s.gt.aE, i), this.C.Bt(s.gt.nE, this.og));
  }
}
