import ve from "../models/braze-event.js";
import _t from "../models/identifier.js";
import {
  isArray as z,
  keys as y,
  validateValueIsFromEnum as ta,
  values as Rt,
} from "../util/code-utils.js";
import { logger as N, EventTypes as d } from "../../shared-lib/index.js";
import { User } from "../User/index.js";
import ro from "../util/browser-detector.js";
import { getErrorMessage as si } from "../util/error-utils.js";
export const STORAGE_KEYS = {
  iu: {
    su: "ab.storage.userId",
    Ia: "ab.storage.deviceId",
    Nl: "ab.storage.sessionId",
  },
  gt: {
    ac: "ab.test",
    tE: "ab.storage.events",
    eE: "ab.storage.attributes",
    sE: "ab.storage.attributes.anonymous_user",
    ic: "ab.storage.device",
    vu: "ab.storage.sdk_metadata",
    pu: "ab.storage.session_id_for_cached_metadata",
    qn: "ab.storage.pushToken",
    qi: "ab.storage.newsFeed",
    zi: "ab.storage.lastNewsFeedRefresh",
    Zt: "ab.storage.cardImpressions",
    cl: "ab.storage.serverConfig",
    rE: "ab.storage.triggers",
    oE: "ab.storage.triggers.ts",
    Hl: "ab.storage.messagingSessionStart",
    Is: "ab.storage.cc",
    Qs: "ab.storage.ccLastFullSync",
    Vs: "ab.storage.ccLastCardUpdated",
    xu: "ab.storage.globalRateLimitCurrentTokenCount",
    Gu: "ab.storage.dynamicRateLimitCurrentTokenCount",
    Kt: "ab.storage.ccClicks",
    Yt: "ab.storage.ccImpressions",
    Vt: "ab.storage.ccDismissals",
    nE: "ab.storage.lastDisplayedTriggerTimesById",
    aE: "ab.storage.lastDisplayedTriggerTime",
    iE: "ab.storage.triggerFireInstancesById",
    xh: "ab.storage.signature",
    EE: "ab.storage.brazeSyncRetryCount",
    fi: "ab.storage.sdkVersion",
    Xe: "ab.storage.ff",
    Ge: "ab.storage.ffImpressions",
    Ze: "ab.storage.ffLastRefreshAt",
    Ve: "ab.storage.ff.sessionId",
    lE: "ab.storage.lastReqToEndpoint",
    SE: "ab.storage.requestAttempts",
    Lr: "ab.storage.deferredIam",
    Eu: "ab.storage.lastSdkReq",
    _E: "ab.storage.alias",
    vt: "ab.storage.banners",
    kt: "ab.storage.banners.impressions",
    yt: "ab.storage.banners.sessionId",
  },
  me: "ab.optOut",
};
export default class ne {
  constructor(t, e) {
    (this.uE = t), (this.cE = e), (this.uE = t), (this.cE = e);
  }
  Ya(t) {
    const e = y(STORAGE_KEYS.iu),
      s = new ne.se(t);
    for (const t of e) s.remove(STORAGE_KEYS.iu[t]);
  }
  uu(t, e) {
    let s = null;
    null != e && e instanceof _t && (s = e.bt()), this.uE.store(t, s);
  }
  TE(t) {
    const e = this.tu(t);
    null != e && ((e.ql = new Date().valueOf()), this.uu(t, e));
  }
  tu(t) {
    const e = this.uE.gr(t),
      s = ((t) => {
        let e;
        try {
          e = JSON.parse(t);
        } catch (t) {
          e = null;
        }
        return e;
      })(e);
    let r;
    if (s) (r = _t.En(s) || null), r && this.uu(t, r);
    else {
      const s = _t.hE(e);
      (r = _t.En(s) || null), s !== e && r && this.uu(t, r);
    }
    return r;
  }
  Il(t) {
    this.uE.remove(t);
  }
  Ha() {
    const t = y(STORAGE_KEYS.iu);
    let e;
    for (const s of t)
      (e = this.tu(STORAGE_KEYS.iu[s])),
        null != e && this.uu(STORAGE_KEYS.iu[s], e);
  }
  Vo(t) {
    let e;
    if (null == t || 0 === t.length) return !1;
    e = z(t) ? t : [t];
    let s = this.cE.gr(STORAGE_KEYS.gt.tE);
    (null != s && z(s)) || (s = []);
    for (let t = 0; t < e.length; t++) s.push(e[t].bt());
    return this.cE.store(STORAGE_KEYS.gt.tE, s);
  }
  Al(t) {
    return null != t && this.Vo([t]);
  }
  AE() {
    let t = this.cE.gr(STORAGE_KEYS.gt.tE);
    this.cE.remove(STORAGE_KEYS.gt.tE), null == t && (t = []);
    const e = [];
    let s = !1,
      r = null;
    if (z(t))
      for (let s = 0; s < t.length; s++)
        ve.RE(t[s]) ? e.push(ve.En(t[s])) : (r = s);
    else s = !0;
    if (s || null != r) {
      let o = "Stored events could not be deserialized as Events";
      s &&
        (o += ", was " + Object.prototype.toString.call(t) + " not an array"),
        null != r &&
          (o += ", value at index " + r + " does not look like an event"),
        (o +=
          ", serialized values were of type " +
          typeof t +
          ": " +
          JSON.stringify(t)),
        e.push(new ve(null, d.bu, new Date().valueOf(), null, { e: o }));
    }
    return e;
  }
  Bt(t, e) {
    return (
      !!ta(
        STORAGE_KEYS.gt,
        t,
        "StorageManager cannot store object.",
        "STORAGE_KEYS.OBJECTS",
      ) && this.cE.store(t, e)
    );
  }
  ft(t) {
    return (
      !!ta(
        STORAGE_KEYS.gt,
        t,
        "StorageManager cannot retrieve object.",
        "STORAGE_KEYS.OBJECTS",
      ) && this.cE.gr(t)
    );
  }
  Ut(t) {
    return (
      !!ta(
        STORAGE_KEYS.gt,
        t,
        "StorageManager cannot remove object.",
        "STORAGE_KEYS.OBJECTS",
      ) && (this.cE.remove(t), !0)
    );
  }
  clearData() {
    const t = y(STORAGE_KEYS.iu),
      e = y(STORAGE_KEYS.gt);
    for (let e = 0; e < t.length; e++) {
      const s = t[e];
      this.uE.remove(STORAGE_KEYS.iu[s]);
    }
    for (let t = 0; t < e.length; t++) {
      const s = e[t];
      this.cE.remove(STORAGE_KEYS.gt[s]);
    }
  }
  gE(t) {
    return t || STORAGE_KEYS.gt.sE;
  }
  wu(t) {
    let e = this.cE.gr(STORAGE_KEYS.gt.eE);
    null == e && (e = {});
    const s = this.gE(t[User.Qn]),
      r = e[s];
    for (const o in t)
      o !== User.Qn &&
        (null == e[s] || (r && null == r[o])) &&
        this.mu(t[User.Qn], o, t[o]);
  }
  mu(t, e, s) {
    let r = this.cE.gr(STORAGE_KEYS.gt.eE);
    null == r && (r = {});
    const o = this.gE(t);
    let n = r[o];
    if (
      (null == n && ((n = {}), null != t && (n[User.Qn] = t)), e === User.lu)
    ) {
      null == n[e] && (n[e] = {});
      for (const t in s) n[e][t] = s[t];
    } else n[e] = s;
    return (r[o] = n), this.cE.store(STORAGE_KEYS.gt.eE, r);
  }
  OE() {
    const t = this.cE.gr(STORAGE_KEYS.gt.eE);
    this.cE.remove(STORAGE_KEYS.gt.eE);
    const e = [];
    for (const s in t) null != t[s] && e.push(t[s]);
    return e;
  }
  ru(t) {
    const e = this.cE.gr(STORAGE_KEYS.gt.eE);
    if (null != e) {
      const s = this.gE(null),
        r = e[s];
      null != r &&
        ((e[s] = void 0),
        this.cE.store(STORAGE_KEYS.gt.eE, e),
        (r[User.Qn] = t),
        this.wu(r));
    }
    const s = this.tu(STORAGE_KEYS.iu.Nl);
    let r = null;
    null != s && (r = s.eu);
    const o = this.AE();
    if (null != o)
      for (let e = 0; e < o.length; e++) {
        const s = o[e];
        null == s.userId && s.sessionId == r && (s.userId = t), this.Al(s);
      }
  }
  IE() {
    return this.cE.dE;
  }
}
(ne.lc = class {
  constructor(t) {
    (this.un = t), (this.un = t), (this.dE = ro.fE() ? 3 : 10);
  }
  bE(t) {
    return t + "." + this.un;
  }
  store(t, e) {
    const s = { v: e };
    try {
      return localStorage.setItem(this.bE(t), JSON.stringify(s)), !0;
    } catch (t) {
      return N.info("Storage failure: " + si(t)), !1;
    }
  }
  gr(t) {
    try {
      let e = null;
      const s = localStorage.getItem(this.bE(t));
      return null != s && (e = JSON.parse(s)), null == e ? null : e.v;
    } catch (t) {
      return N.info("Storage retrieval failure: " + si(t)), null;
    }
  }
  remove(t) {
    try {
      localStorage.removeItem(this.bE(t));
    } catch (t) {
      return N.info("Storage removal failure: " + si(t)), !1;
    }
  }
}),
  (ne.gc = class {
    constructor() {
      (this.KE = {}), (this.mE = 5242880), (this.dE = 3);
    }
    store(t, e) {
      const s = { value: e },
        r = this.YE(e);
      return r > this.mE
        ? (N.info(
            "Storage failure: object is â‰ˆ" +
              r +
              " bytes which is greater than the max of " +
              this.mE,
          ),
          !1)
        : ((this.KE[t] = s), !0);
    }
    YE(t) {
      const e = [],
        s = [t];
      let r = 0;
      for (; s.length; ) {
        const t = s.pop();
        if ("boolean" == typeof t) r += 4;
        else if ("string" == typeof t) r += 2 * t.length;
        else if ("number" == typeof t) r += 8;
        else if ("object" == typeof t && -1 === e.indexOf(t)) {
          let r, o;
          e.push(t);
          for (const e in t) (o = t), (r = e), s.push(o[r]);
        }
      }
      return r;
    }
    gr(t) {
      const e = this.KE[t];
      return null == e ? null : e.value;
    }
    remove(t) {
      this.KE[t] = null;
    }
  }),
  (ne.se = class {
    constructor(t, e) {
      (this.un = t),
        (this.NE = e),
        (this.un = t),
        (this.GE = this.DE()),
        (this.CE = 576e3),
        (this.NE = !!e);
    }
    bE(t) {
      return null != this.un ? t + "." + this.un : t;
    }
    DE() {
      let t = 0,
        e = document.location.hostname;
      const s = e.split("."),
        r = "ab._gd";
      for (; t < s.length - 1 && -1 === document.cookie.indexOf(r + "=" + r); )
        t++,
          (e = "." + s.slice(-1 - t).join(".")),
          (document.cookie = r + "=" + r + ";domain=" + e + ";");
      return (
        (document.cookie =
          r + "=;expires=" + new Date(0).toUTCString() + ";domain=" + e + ";"),
        e
      );
    }
    le() {
      const t = new Date();
      return t.setTime(t.getTime() + 60 * this.CE * 1e3), t.getFullYear();
    }
    ME() {
      const t = Rt(STORAGE_KEYS.iu),
        e = document.cookie.split(";");
      for (let s = 0; s < e.length; s++) {
        let r = e[s];
        for (; " " === r.charAt(0); ) r = r.substring(1);
        let o = !1;
        for (let e = 0; e < t.length; e++)
          if (0 === r.indexOf(t[e])) {
            o = !0;
            break;
          }
        if (o) {
          const t = r.split("=")[0];
          -1 === t.indexOf("." + this.un) && this.pE(t);
        }
      }
    }
    store(t, e) {
      this.ME();
      const s = new Date();
      s.setTime(s.getTime() + 60 * this.CE * 1e3);
      const r = "expires=" + s.toUTCString(),
        o = "domain=" + this.GE;
      let n;
      n = this.NE ? e : encodeURIComponent(e);
      const a = this.bE(t) + "=" + n + ";" + r + ";" + o + ";path=/";
      return a.length >= 4093
        ? (N.info(
            "Storage failure: string is " +
              a.length +
              " chars which is too large to store as a cookie.",
          ),
          !1)
        : ((document.cookie = a), !0);
    }
    gr(t) {
      const e = [],
        s = this.bE(t) + "=",
        r = document.cookie.split(";");
      for (let o = 0; o < r.length; o++) {
        let n = r[o];
        for (; " " === n.charAt(0); ) n = n.substring(1);
        if (0 === n.indexOf(s))
          try {
            let t;
            (t = this.NE
              ? n.substring(s.length, n.length)
              : decodeURIComponent(n.substring(s.length, n.length))),
              e.push(t);
          } catch (e) {
            return (
              N.info("Storage retrieval failure: " + si(e)),
              this.remove(t),
              null
            );
          }
      }
      return e.length > 0 ? e[e.length - 1] : null;
    }
    remove(t) {
      this.pE(this.bE(t));
    }
    pE(t) {
      const e = t + "=;expires=" + new Date(0).toUTCString();
      (document.cookie = e), (document.cookie = e + ";path=/");
      const s = e + ";domain=" + this.GE;
      (document.cookie = s), (document.cookie = s + ";path=/");
    }
  }),
  (ne.cc = class {
    constructor(t, e, s) {
      (this.un = t),
        (this.vE = []),
        e && this.vE.push(new ne.se(t)),
        s && this.vE.push(new ne.lc(t)),
        this.vE.push(new ne.gc());
    }
    store(t, e) {
      let s = !0;
      for (let r = 0; r < this.vE.length; r++) s = this.vE[r].store(t, e) && s;
      return s;
    }
    gr(t) {
      for (let e = 0; e < this.vE.length; e++) {
        const s = this.vE[e].gr(t);
        if (null != s) return s;
      }
      return null;
    }
    remove(t) {
      new ne.se(this.un).remove(t);
      for (let e = 0; e < this.vE.length; e++) this.vE[e].remove(t);
    }
  });
