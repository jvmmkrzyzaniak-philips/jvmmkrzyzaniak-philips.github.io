import { useState, useEffect } from 'react'
import { useEffectiveUser } from '@fs/zion-user'
import Cache from '@fs/zion-cache'
import { getPersonObj } from '@fs/zion-person-service'
import CacheService from '@fs/zion-cache-service'
import { i18n } from '@fs/zion-locale'
import axios from '@fs/zion-axios'
import { targetEnv } from '@fs/zion-config'
import { useGroupsContext, useTreeStartingPid } from '@fs/zion-tree-groups'

const cache = new CacheService({
  cache: { storeName: 'recentsList', type: 'session' },
  strategy: 'cache-and-network',
})

const localCache = new Cache({ encrypted: true, storeName: 'temporary' })

const testingPersonsForDevelopment = {
  int: [
    { name: '404 - NOT FOUND', id: 'XXXX-XXX' },
    { name: '403 - PRIVATE PERSON', id: 'KW3B-FNR' },
    { name: '410 - DELETED PERSON', id: 'L581-3TL' },
    { name: 'LONG NAME - PICASSO', id: 'LRHS-T8W' },
    // { name: 'MANY WIVES - ??', id: '' }, // This is a valuable testing scenario, but it's expensive to set up
    { name: 'READ ONLY', id: 'KWQ9-5VZ' },
    { name: 'ALL CONCLUSIONS', id: 'L5FG-MPX' },
    { name: 'NAME TEMPLATES', id: 'L5DH-838' },
    { name: 'LOOPING PEDIGREE', id: 'L5X4-NGD' },
  ],
  prod: [
    // These PIDs should work for both beta and prod
    { name: '404 - NOT FOUND', id: 'XXXX-XXX' },
    { name: '403 - PRIVATE PERSON', id: 'KW65-CMF' }, // Clif's wife
    { name: '410 - DELETED PERSON', id: 'BM92-5BB' },
    { name: 'LONG NAME - PICASSO', id: 'LH17-95K' },
    { name: 'MANY WIVES - HEBER', id: 'KWNP-GNM' },
    { name: 'READ ONLY - WASHINGTON', id: 'KNDX-MKG' },
    { name: 'LONG LOADING - PRINCESS DI', id: 'L5XN-6LV' },
    // Feel free to find someone in production matching this criteria, but keep in mind that beta refreshes generally only occur once a year, and so if you create someone, they will not be available in beta until after the next refresh.
    // { name: 'ALL CONCLUSIONS', id: '' },
    // { name: 'MANY MEMORIES - ??', id: '' },
  ],
}

let testingPersons = {}

switch (targetEnv) {
  case 'int':
    testingPersons = { int: testingPersonsForDevelopment.int }
    break
  case 'beta':
  case 'prod':
    testingPersons = { prod: testingPersonsForDevelopment.prod }
    break
  default:
    // zion-config#3 stupidly returns "local" when running locally instead of the TARGET environment...so we just inject both lists
    testingPersons = {
      int: testingPersonsForDevelopment.int,
      prod: testingPersonsForDevelopment.prod,
    }
    break
}

/**
 * Call the chain of endpoints to get the history list data.
 * @param {EffectiveUser} effectiveUser - The data returned from the `useEffectiveUser` hook
 * @param {Function} handler - callback method to handle both the server and cache promises from the cache
 */
/* istanbul ignore next -- Until testing of React Hooks is manageable */
async function getHistory({ cisId, loggedInPersonId, startingPersonId, currentTreeId }, handler) {
  try {
    const treeIdent = currentTreeId ?? 'PRIVATE'

    const url = `/service/tree/tree-data/history-list/v2/${cisId}/all?filteredId=${loggedInPersonId}&filteredId=${startingPersonId}&locale=${i18n.language}`

    const dataHandler = (data) => {
      if (!data?.history) return {}
      return handler(data)
    }

    // TF-3512 - If the service is down, or we get some other 400+ error, stop loading
    const dataFailureHandler = () => {
      return handler({})
    }

    const [serverPromise, cachePromise] = await cache.get(url, `${treeIdent}:UserHistory`)
    cachePromise.then(dataHandler).catch(console.error)
    serverPromise.then(dataHandler).catch(dataFailureHandler)
  } catch (err) {
    console.error(err)
  }
}

let lastHistoryPersonReferenced = '' // Keep a handle of the most-recently referenced PID as a quick cache. We BELIEVE this is stable enough to use like a singleton.

let lastUsedCisId // Keep a handle of the most-recently used cisId to know when to clear the temporary history list.

/**
 * Manage resetting of the helper mode temporary history list manually via localStorage, not localStorage, because we want the list reset when a browser session is finished, as well. Because this behavior is cisId-based, things can be a little weird if you help yourself, but I consider this a hidden feature.
 * @param {String} cisId - The cisId of the effective user.
 */
async function reinitializeTemporaryHistoryIfNeeded(cisId) {
  if (!lastUsedCisId) {
    // Unfortunately, the nature of zion-cache is to over-compartmentalize, even if we don't want that behavior because we want to know that last-used cisId across the browser session, not the last-used cisId from the storage of the current (last-used) cisId. So we need to use localStorage directly.
    lastUsedCisId = localStorage.getItem('last-used-cisId')
  }

  if (cisId !== lastUsedCisId) {
    try {
      localCache.clear('temporary')
      lastUsedCisId = cisId
      localStorage.setItem('last-used-cisId', cisId)
    } catch (err) {
      console.error('UNABLE TO MANAGE LOCAL CACHE:', err)
    }
  }
}

/**
 * Adds a new item to the user's history list.
 * @param {String} personId - The personId of the person to add to the history list.
 * @param {String} cisId - The cisId of the user.
 * @param {Boolean} storeLocally - Optional override flag to add recent persons from helper mode sessions to a local cache.
 */
export async function addToHistory(personId, cisId, storeLocally) {
  if (storeLocally) {
    await reinitializeTemporaryHistoryIfNeeded(cisId)

    const [cachedPersonDataPromise] = await getPersonObj(personId, 'summary', true)
    cachedPersonDataPromise
      .then((person) => {
        // Read in the current history list, so that we can update it correctly
        localCache.getItem('history-list').then((list) => {
          if (list?.length) {
            const indexOfPersonAlreadyInList = list.findIndex((historyPerson) => historyPerson.id === person.id)

            const MAX_TEMPORARY_LIST_SIZE = 10

            if (list?.length >= MAX_TEMPORARY_LIST_SIZE) {
              list.splice(MAX_TEMPORARY_LIST_SIZE)
            }

            if (indexOfPersonAlreadyInList >= 0) {
              list.splice(indexOfPersonAlreadyInList, 1)
            }
          } else {
            list = []
          }

          list.unshift({
            id: person.id,
            name: person.name,
            gender: person.gender,
            lifespan: person.lifespan || person.lifeSpan,
          })

          return localCache.setItem('history-list', list)
        })
      })
      .catch(() => {
        // This occurs if we pass in a bad pid
        return false
      })
    return true
  }

  // Users are able to switch between various client-side routes regularly (like person sub-pages), and as long as they stay on the same person, there is no need to blast the service over and over with unnecessary updates.
  if (personId !== lastHistoryPersonReferenced) {
    lastHistoryPersonReferenced = personId
    return axios.put(`/service/tree/tree-data/history-list/${cisId}/person/${personId}`)
  }

  return Promise.resolve()
}

/**
 * Removes an item from the user's history list.
 * @param {PersonId} personId - The personId of the person to remove from the history list
 * @param {CisId} cisId - The cisId of the user
 */
export async function deleteFromHistory(personId, cisId) {
  return axios.delete(`/service/tree/tree-data/history-list/${cisId}/person/${personId}`)
}

/* Filter out non-current-tree-persons when not on fullPageView */
function getHandler({ currentTreeId, isResearcherGroup, fullPageView, setHandler }) {
  if (fullPageView) return setHandler

  return (data) => {
    Object.entries(data || {}).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        data[key] = value.filter((person) => {
          const fromCurrentTree = person.treeId
            ? person.treeId === currentTreeId
            : !currentTreeId || currentTreeId === 'PRIVATE'
          return isResearcherGroup ? fromCurrentTree : fromCurrentTree || !person.treeId
        })
      }
    })
    setHandler?.(data)
  }
}

/**
 * Get the History List of the Effective User from Tree Data.
 * @returns {object} - { history, loggedInPersonId, startingPersonId, loading, user<EffectiveUser>, deleteItem }
 */
/* istanbul ignore next -- Until testing of React Hooks is manageable */
export default function useHistory(fullPageView) {
  const user = useEffectiveUser()
  const { userLoading, cisId, personId } = user
  const [history, setHistory] = useState(null)
  const [temporaryHistory, setTemporaryHistory] = useState(null)
  const { currentTreeId, isResearcherGroup } = useGroupsContext()
  const { loading: startingPersonLoading, data } = useTreeStartingPid(currentTreeId || 'PRIVATE')

  const loggedInPersonId = personId
  const startingPersonId = data?.personId

  const deleteItem = async (id, temporaryEntry) => {
    // Manage our own data and cache if the entry being removed is one of our custom temporary ones
    if (temporaryEntry) {
      let copyOfTemporaryHistory = [...temporaryHistory]

      copyOfTemporaryHistory = copyOfTemporaryHistory.filter((entry) => {
        return entry.id !== id
      })

      setTemporaryHistory(copyOfTemporaryHistory)
      localCache.setItem('history-list', copyOfTemporaryHistory)
    } else {
      await deleteFromHistory(id, cisId)
      getHistory(
        { cisId, loggedInPersonId, startingPersonId, currentTreeId },
        getHandler({ currentTreeId, isResearcherGroup, fullPageView, setHandler: setHistory })
      )
    }
  }

  useEffect(() => {
    async function execute() {
      if (cisId) {
        await reinitializeTemporaryHistoryIfNeeded(cisId)
      }
    }
    execute()

    localCache.getItem('history-list').then((list) => {
      setTemporaryHistory(list)
    })
  }, [cisId])

  useEffect(() => {
    if (!userLoading && !startingPersonLoading) {
      getHistory(
        { cisId, loggedInPersonId, startingPersonId, currentTreeId },
        getHandler({ currentTreeId, isResearcherGroup, fullPageView, setHandler: setHistory })
      )
    }
  }, [
    cisId,
    loggedInPersonId,
    startingPersonLoading,
    startingPersonId,
    user,
    userLoading,
    fullPageView,
    currentTreeId,
    isResearcherGroup,
  ])

  return {
    user,
    loading: startingPersonLoading || userLoading || history === null,
    history,
    temporaryHistory,
    testingPersons,
    loggedInPersonId,
    startingPersonId: startingPersonId !== loggedInPersonId && startingPersonId,
    deleteItem,
  }
}

export function useMiniHistory() {
  const { history, loading } = useHistory()
  const totalLength = history?.history?.length
  return { history: totalLength ? history.history.slice(0, 3) : null, totalLength, loading }
}
