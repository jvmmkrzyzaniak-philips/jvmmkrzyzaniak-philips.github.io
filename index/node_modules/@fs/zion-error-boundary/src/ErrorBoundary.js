import React, { Component } from 'react'
import PropTypes from 'prop-types'
import * as Sentry from '@sentry/browser'
import { i18n } from '@fs/zion-locale'
import { Trans } from 'react-i18next/icu.macro'
import { getUser } from '@fs/zion-user'
import { NoticeWarning } from '@fs/zion-icon'
import { css } from '@linaria/core'
import reportError from './lib/reportError'

// This is currently a class component instead of a functional component because getDerivedStateFromError is not yet supported in functional components:
// https://reactjs.org/docs/hooks-faq.html#how-do-lifecycle-methods-correspond-to-hooks

const containerCss = css`
  background: #ebecec;
  display: flex;
  color: #434547;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  padding: 16px 8px;
  width: 100%;
  max-width: 100%;
  height: 100%;
`

const centeredCss = css`
  text-align: center;
  margin-top: 16px;
`

const oopsCss = css`
  font-size: 14px;
  line-height: 28px;
`

const errorCss = css`
  max-height: 500px;
  overflow: scroll;
  padding: 8px 16px;
  border: solid 1px #b00;
  background-color: #fee;
  border-radius: 4px;
  max-width: 600px;
  width: 100%;
  color: #433;
  h3 {
    font-size: 15px;
    font-style: italic;
    color: #822;
  }

  p {
    margin: 0;
  }
`

const stackFontCss = css`
  white-space: pre;
  font-size: 12px;
  line-height: 20px;
  margin-top: -12px !important; // Call stack has an extra carriage return in it.
`

export default class ErrorBoundary extends Component {
  constructor(props) {
    super(props)
    this.state = {}
    this.isComponentMounted = false
    i18n.on('languageChanged', () => {
      if (this.isComponentMounted) {
        this.forceUpdate()
      }
    })
  }

  static getDerivedStateFromError() {
    return { hasError: true }
  }

  async componentDidMount() {
    this.isComponentMounted = true
    try {
      const { cisId: id, contactName } = await getUser()
      // Making sure we are still mounted after the await is done in the previous line.
      if (this.isComponentMounted) {
        this.setState({ user: { id, contactName } })
      }
    } catch (err) {
      // we can ignore no user for Sentry
      // console.error('getuser err', err)
    }
  }

  componentDidCatch(error, errorInfo) {
    const { errorHandler = reportError } = this.props

    if (typeof errorHandler === 'function') {
      try {
        /* istanbul ignore next: Ignoring ternary; canâ€™t reproduce missing info in test environment. */
        errorHandler.call(this, error, errorInfo ? errorInfo.componentStack : '')
      } catch (ignoredError) {
        // console.warn('Error calling errorHandler:', ignoredError)
      }
    }

    Sentry.withScope((scope) => {
      const { user } = this.state
      scope.setExtras(errorInfo)
      scope.setTag('locale', i18n.language)
      if (user) {
        scope.setUser(user)
      }
      const eventId = Sentry.captureException(error)
      this.setState({ error, errorInfo, eventId })
    })
  }

  componentWillUnmount() {
    this.isComponentMounted = false
  }

  render() {
    const { children, FallbackComponent } = this.props
    const { hasError, errorInfo, error, eventId } = this.state

    // Use a webpack trick to make the stack trace disappear in a production build.
    const stackTrace = process.env.NODE_ENV !== 'production' && (
      <div className={errorCss}>
        <h3>{error?.message}</h3>
        <p className={stackFontCss}>{errorInfo?.componentStack || ''}</p>
        <p>Sentry ID: {eventId}</p>
      </div>
    )

    if (hasError && FallbackComponent) {
      return (
        <>
          <FallbackComponent error={error} />
          {stackTrace}
        </>
      )
    }

    if (hasError) {
      return (
        <div className={containerCss}>
          <NoticeWarning size="md" />
          <div className={centeredCss}>
            <p className={oopsCss}>
              <Trans i18nKey="errorboundary.message">
                Oops, something went wrong. <br />
                Please refresh the page.
              </Trans>
            </p>
          </div>
          {stackTrace}
        </div>
      )
    }

    return children || null
  }
}

ErrorBoundary.propTypes = {
  /** Function to call when an error is caught */
  errorHandler: PropTypes.func,

  /** Function to call when an error is caught */
  FallbackComponent: PropTypes.elementType,
}
