import React, { lazy, useState, useEffect } from 'react'
import { useIsHelping } from '@fs/zion-user'
import debugLib from '@fs/zion-debug'
import ErrorBoundary from '@fs/zion-error-boundary'
import { useExperiment } from '@fs/zion-experiments'
import Header from '../Header2019/Header2019'
import NavigationProvider, { useNavigationContext } from '../shared/NavigationProvider'

const AdminMode = lazy(() => import('@fs/zion-admin-mode'))
const debug = debugLib('header2019')

function HeaderWithDataRenderer({ config, storybookOverride = {} }) {
  const [notificationsIcon] = useExperiment('notificationsIcon')
  const isHelping = useIsHelping()
  const [lastNotificationTime, setLastNotificationTime] = useState()
  const [notificationCount, setNotificationCount] = useState(notificationsIcon ? 0 : null)
  const [canSeeTemple, setCanSeeTemple] = useState(false)
  const [restrictedTemple, setRestrictedTemple] = useState(false)
  const [portraitUrl, setPortraitUrl] = useState('')
  const [adminRoles, setAdminRoles] = useState([])
  const [activeRole, setActiveRole] = useState('')
  const [userProfileEx] = useExperiment('userProfileEx')

  const headerConfig = {
    ...config,
    notificationCount,
    lastNotificationTime,
    canSeeTemple,
    restrictedTemple,
    portraitUrl,
    adminRoles,
    activeRole,
    ...storybookOverride,
  }

  // notification count
  useEffect(() => {
    let mounted = true
    const fetchData = async () => {
      if (headerConfig.signedIn) {
        import('@fs/zion-messages').then(async ({ getAlertsCounts, getLastMessageAndNotificationTime }) => {
          if (notificationsIcon) {
            const { latest_notification_time: latestNotificationTime = null } =
              await getLastMessageAndNotificationTime()
            setLastNotificationTime(latestNotificationTime)
          } else {
            getAlertsCounts()
              .then(([newNotificationCount]) => {
                if (mounted) {
                  setNotificationCount(newNotificationCount)
                }
              })
              .catch((error) => {
                console.error('Alert count error:', error)
                setNotificationCount(0)
              })
          }
        })
      }
    }
    fetchData()
    return () => {
      mounted = false
    }
  }, [headerConfig.signedIn, notificationsIcon, setLastNotificationTime])

  // temple permissions
  useEffect(() => {
    let mounted = true
    const fetchData = async () => {
      if (headerConfig.signedIn) {
        import('@fs/zion-permissions')
          .then(({ showTemple, canAddPersonalData }) =>
            Promise.allSettled([showTemple(), canAddPersonalData('FamilyTree')])
          )
          .then(([showTempleResponse, permissionResponse]) => {
            if (!mounted) return
            if (showTempleResponse.status === 'fulfilled') {
              setCanSeeTemple(showTempleResponse.value)
            }
            if (permissionResponse.status === 'fulfilled') {
              setRestrictedTemple(!permissionResponse.value)
            }
          })
          .catch((error) => {
            console.error('Temple permission error in header:', error)
          })
      }
    }
    fetchData()
    return () => {
      mounted = false
    }
  }, [headerConfig.signedIn])

  // admin mode
  useEffect(() => {
    if (headerConfig.signedIn && !isHelping) {
      // TODO: Use localstorage to prevent some of these calls
      import('@fs/zion-admin-mode')
        .then(({ getRoles, getActiveRole }) => Promise.all([getRoles(), getActiveRole()]))
        .then(([roles, currentRole]) => {
          setAdminRoles(roles)
          setActiveRole(currentRole)
        })
        .catch((error) => {
          debug('Admin Mode Error in Header2010WithData.js:', error)
        })
    }
  }, [headerConfig.signedIn, isHelping])

  // user portrait
  useEffect(() => {
    let mounted = true
    const fetchData = async () => {
      if (headerConfig.signedIn && !isHelping) {
        import('@fs/zion-portrait-service')
          .then(async ({ getPortraitThumb, getProfilePortrait }) => {
            const userTreeImage = await getPortraitThumb(headerConfig.personId)
            const userProfileImage = await getProfilePortrait(headerConfig.cisId)
            return { userTreeImage, userProfileImage }
          })
          .then(({ userTreeImage, userProfileImage }) => {
            if (mounted && userProfileEx && userProfileImage && userProfileImage.avatarUrl.length !== 0) {
              setPortraitUrl(userProfileImage.avatarUrl)
            } else if (mounted && userTreeImage) {
              setPortraitUrl(userTreeImage)
            }
          })
          .catch((error) => debug('Error getting portrait', error))
      }
    }
    fetchData()
    return () => {
      mounted = false
    }
  }, [headerConfig.signedIn, headerConfig.personId, isHelping, headerConfig.cisId, userProfileEx])

  return (
    <>
      {headerConfig.activeRole && <AdminMode roleName={headerConfig.activeRole} />}
      <NavigationProvider
        canSeeTemple={canSeeTemple}
        nonReligiousMode={headerConfig.nonReligiousMode}
        restrictedTemple={restrictedTemple}
        signedIn={headerConfig.signedIn}
      >
        <HeaderWrapper>
          <Header {...headerConfig} {...storybookOverride} />
        </HeaderWrapper>
      </NavigationProvider>
    </>
  )
}

function handleError(error, info) {
  debug('Header2019 Error', error, info)
}
function Fallback() {
  return <span id="header2019-error" />
}

function HeaderWrapper({ children }) {
  const { dynamicLinksOn, isLoading: dynamicLinksIsLoading, isError: dynamicLinksIsError } = useNavigationContext()
  // This is for a prototype. When this becomes a real boy, we'll need to handle the loading and error state appropriately
  if (dynamicLinksOn && (dynamicLinksIsLoading || dynamicLinksIsError)) {
    return null
  }
  return <>{children}</>
}

/**
 * Wrapper to get async, lower-priority data for use in Header2019
 * @param {} config
 */
export default function HeaderWithData({ config, storybookOverride }) {
  return (
    <ErrorBoundary errorHandler={handleError} fallbackComponent={Fallback}>
      <HeaderWithDataRenderer config={config} storybookOverride={storybookOverride} />
    </ErrorBoundary>
  )
}
