import { useReducer, useCallback, useLayoutEffect } from 'react'
import { useResizeObserver } from '@fs/zion-frontend-friends'

const breakpointAction = {
  widthChange: 'widthChange',
  headerWidthChange: 'headerWidthChange',
  upshift: 'upshift',
  downshift: 'downshift',
}
const screenSize = {
  desktop: 'desktop',
  tablet: 'tablet',
  mobile: 'mobile',
}
const initialBreakpointState = {
  leftWidth: 0,
  rightWidth: 0,
  currentBreakpoint: screenSize.desktop,
  breakpoints: {
    desktop: 0,
    tablet: 0,
  },
}
function reducer(state, { type, breakpoints, leftWidth, rightWidth, headerWidth }) {
  switch (type) {
    case breakpointAction.headerWidthChange:
      return {
        ...state,
        headerWidth,
      }
    case breakpointAction.upshift:
      return {
        ...state,
        currentBreakpoint: state.currentBreakpoint === screenSize.mobile ? screenSize.tablet : screenSize.desktop,
      }
    case breakpointAction.downshift:
      return {
        ...state,
        breakpoints,
        currentBreakpoint: state.currentBreakpoint === screenSize.desktop ? screenSize.tablet : screenSize.mobile,
      }
    case breakpointAction.widthChange:
      return {
        ...state,
        breakpoints,
        leftWidth,
        rightWidth,
      }
    default:
      throw new Error(`Unhandled action type ${type} in useHeaderBreakString reducer`)
  }
}

// used to estimate padding at specific sizes as padding changes at a different rate than the left/right components but roughly at the same time
const paddingAtSize = { desktop: 24, tablet: 12, mobile: 12 }
function estimateWidth(left, right, currentBreakpoint) {
  const padding = paddingAtSize[currentBreakpoint]
  return left + right + 2 * padding
}
// setBreakpoints uses data from setLeftWidth and setRightWidth to estimate breakpoints to progress from mobile => tablet => desktop
function setBreakpoints({
  dispatch,
  breakpointState: { leftWidth, rightWidth, breakpoints, currentBreakpoint },
  newLeftWidth = leftWidth,
  newRightWidth = rightWidth,
}) {
  const newEstimatedBreakpointCalculation = estimateWidth(newLeftWidth, newRightWidth, currentBreakpoint)
  const newBreakpoints = { ...breakpoints }
  if (currentBreakpoint === screenSize.desktop || currentBreakpoint === screenSize.tablet) {
    newBreakpoints[currentBreakpoint] = newEstimatedBreakpointCalculation
  }
  dispatch({
    type: breakpointAction.widthChange,
    breakpoints: newBreakpoints,
    leftWidth: newLeftWidth,
    rightWidth: newRightWidth,
  })
}
/**
  We can know to move from desktop => tablet or tablet => mobile if there isn't enough space between the left and right side elements in the header.
  But what do we do when trying to know when to move from mobile => tablet or tablet => desktop? If we keep loading desktop or table elements and checking it loads the images over and over.
  That is the issue useBreakPointReducer is trying to fix.
  @useBreakpointReducer - keeps track of break points to know when to move up or down a device size
  @return {object} reducer state and functions to manage reducer
    @ObjectFunctions
    @upshiftScreenSize is used to determine when to 'upshift' the device string. mobile => tablet => desktop
    @downshiftScreenSize is used to 'downShift' the device string. desktop => tablet => mobile
    @setLeftWidth is given to a resizeObserver to get the left element width. Used to used in connection with @setRightWidth and @setBreakpoints to determine how wide the header should be before going from desktop => tablet => mobile
    @setRightWidth is given to a resizeObserver to get the right element width. Used to used in connection with @setLeftWidth and @setBreakpoints to determine how wide the header should be before going from desktop => tablet => mobile
    @setHeaderWidth is given to a resizeObserver to get the header element width. headerWidth is used in @upshiftScreenSize to calculate if there is enough space in the header before going from mobile => tablet => desktop
*/
function useBreakpointReducer() {
  const [breakpointState, dispatch] = useReducer(reducer, initialBreakpointState)

  const upshiftScreenSize = useCallback(() => {
    const { currentBreakpoint, breakpoints, headerWidth } = breakpointState
    if (
      (currentBreakpoint === screenSize.mobile && headerWidth > breakpoints.tablet) ||
      (currentBreakpoint === screenSize.tablet && headerWidth > breakpoints.desktop)
    ) {
      dispatch({ type: breakpointAction.upshift })
    }
  }, [breakpointState])
  const downshiftScreenSize = useCallback(
    (newLeftWidth, newRightWidth) => {
      const { currentBreakpoint, breakpoints } = breakpointState
      const newBreakpoints = {
        ...breakpoints,
        [currentBreakpoint]: estimateWidth(newLeftWidth, newRightWidth, currentBreakpoint),
      }
      dispatch({ type: breakpointAction.downshift, breakpoints: newBreakpoints })
    },
    [breakpointState]
  )
  const setLeftWidth = useCallback(
    ({ contentRect: { width: newLeftWidth } }) => {
      const { leftWidth } = breakpointState
      if (newLeftWidth !== leftWidth) {
        setBreakpoints({ dispatch, breakpointState, newLeftWidth })
      }
    },
    [breakpointState]
  )
  const setRightWidth = useCallback(
    ({ contentRect: { width: newRightWidth } }) => {
      const { rightWidth } = breakpointState
      if (newRightWidth !== rightWidth) {
        setBreakpoints({ dispatch, breakpointState, newRightWidth })
      }
    },
    [breakpointState]
  )
  const setHeaderWidth = useCallback(
    ({ contentRect: { width: newHeaderWidth } }) => {
      if (newHeaderWidth !== breakpointState.headerWidth) {
        dispatch({
          type: breakpointAction.headerWidthChange,
          headerWidth: newHeaderWidth,
        })
      }
    },
    [breakpointState]
  )

  return { breakpointState, setHeaderWidth, setRightWidth, setLeftWidth, downshiftScreenSize, upshiftScreenSize }
}

export const useHeaderBreakString = ({ headerRef, leftSectionRef, rightSectionRef }) => {
  const {
    breakpointState: { currentBreakpoint, headerWidth, breakpoints },
    setHeaderWidth,
    setRightWidth,
    setLeftWidth,
    downshiftScreenSize,
    upshiftScreenSize,
  } = useBreakpointReducer()

  // check to see if content can fit current space.
  useLayoutEffect(() => {
    if (leftSectionRef.current && rightSectionRef.current) {
      const { right, width: leftWidth } = leftSectionRef.current.getBoundingClientRect()
      const { left, width: rightWidth } = rightSectionRef.current.getBoundingClientRect()
      const distance = left - right
      if (distance <= 0 && currentBreakpoint !== screenSize.mobile) {
        downshiftScreenSize(leftWidth, rightWidth)
      } else if (distance > 0 && currentBreakpoint !== screenSize.desktop) {
        upshiftScreenSize()
      }
    }
  }, [
    leftSectionRef,
    rightSectionRef,
    currentBreakpoint,
    headerWidth,
    breakpoints,
    downshiftScreenSize,
    upshiftScreenSize,
  ])

  // Left and right observers are for initial load, to adjust the break point as content is lazy loaded.
  // Once the content is loaded, the header observer is looking for screen resizes to then adjust the break point.
  useResizeObserver(headerRef, setHeaderWidth)
  useResizeObserver(rightSectionRef, setRightWidth)
  useResizeObserver(leftSectionRef, setLeftWidth)

  return currentBreakpoint
}
