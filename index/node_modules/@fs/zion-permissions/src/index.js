import { getSessionId, getSession, getAnonSession, extractCorrelationId } from '@fs/zion-session'
import { useEffect, useState } from 'react'
import { showEx } from '@fs/zion-experiments'
import { geoData } from '@fs/zion-config'
import zionDebug from '@fs/zion-debug'
import { i18n } from '@fs/zion-locale'
import Cookies from 'js-cookie'
import cacheService from './permissionsCache'

export { cacheService }

const debug = zionDebug('geo-restrict')

const noSessionIdForContextErrorText = 'A sessionId must be supplied to getFamilyTreeCasContext!'
// NOTE: Keep list of affected countries, so we can fastpass the unaffected ones
const NRM_COUNTRIES_TO_CHECK = ['CN', 'ID', 'IN', 'MY']

/**
 * Get authorization based on permission(s) and context passed in.
 * @param  {Array|string} permissions The permission as a string or permissions as an array of strings.
 * @param  {string} [casContext=getFamilyTreeCasContext()] Optional context, defaults to FtNormalUserContext unless elevated to admin.
 * @param {Array|string} casData Optional data values, defaults to an empty array.
 * @return {Promise} CAS Authorization object.
 */
export default async function getPermission(permissions, casContext = getFamilyTreeCasContext(), casData = []) {
  const sessionId = getSessionId()
  if (!permissions) throw new Error('No permissions passed in.')
  const perms = Array.isArray(permissions) ? permissions : [permissions]
  const context = await casContext
  const data = Array.isArray(casData) ? casData : [casData]

  // axios turns a params array into perm=[]permission1&perm[]permission2 so we have to use URLSearchParams or https://npm.im/qs
  const params = new URLSearchParams()
  params.append('context', context)
  params.append('sessionId', sessionId)
  perms.forEach((perm) => params.append('perm', perm))
  data.forEach((dataParam) => params.append('data', dataParam))

  const axiosConfig = {
    params,
  }
  const url = `/service/ident/cas/cas-public-api/authorization/v1/authorize/`
  const key = `${extractCorrelationId(sessionId)}${context}${perms.join('|')}`
  const queueId = `${url}${key}`
  return cacheService.get(url, key, {
    axiosConfig,
    queueId,
  })
}

/**
 * Custom error to improve the developer experience in an error situation
 * @param {Object} error - original error
 * @param  {Array|string} permissions The permission as a string or permissions as an array of strings.
 * @constructor
 */
function PermissionsError(error, permissions) {
  this.message = `Error getting the '${permissions}' permission(s): ${error.message}`
  this.origError = error
}

/**
 * Function for clearing the cache service (such as between unit tests)
 * @returns {*}
 */
export const clearPermissionsCache = () => {
  return cacheService.cacheInstance.clear()
}

/**
 * Custom hooke to facilitate FamilySearch permission checking
 * @param  {Array|string} permissions The permission as a string or permissions as an array of strings.
 * @param casContext
 * @returns {Array} permission check results [Boolean, "loading" or "loaded" or "error", Error]
 */
export function usePermission(permissions, casContext) {
  const [state, setState] = useState([false, 'loading', null]) // data, state, error

  useEffect(() => {
    let cancelled = false

    // Get the data and handle success/error appropriately
    getPermission(permissions, casContext)
      .then(({ authorized }) => {
        if (!cancelled) {
          setState([authorized === true, 'loaded', null])
        }
      })
      .catch((error) => {
        if (!cancelled) {
          const newError = new PermissionsError(error, permissions)
          setState([false, 'error', newError])
        }
      })

    return () => {
      cancelled = true
    }
  }, [permissions, casContext])

  return state
}

/**
 * Get the casContext for 'FamilyTree'.
 *
 * @returns {Promise} - The cas context from the v4 session or FtUserNormalContext.
 * @throws Error if no session or invalid session
 */
export async function getFamilyTreeCasContext() {
  const sessionId = getSessionId()
  if (!sessionId) {
    throw new Error(noSessionIdForContextErrorText)
  }

  const { session } = (await getSession()) ?? {}

  if (Array.isArray(session?.values) && session.values.length > 0) {
    const contextArr = session.values
      .filter((val) => val.restricted && val.name === 'FamilyTree')
      .map((val) => val.value)

    // sometimes session values can have a value of '', so we check if the mapping above returned an empty array
    if (contextArr.length) {
      return contextArr[0]
    }
  }
  return 'FtNormalUserContext'
}

/**
 * Hook used to see if the user has permissions to show temple data
 * @returns {Array} temple permission check results [Boolean, "loading" or "loaded" or "error", Error]
 */
export function useShowTemple() {
  const [state, setState] = useState([false, 'loading', null]) // data, state, error

  useEffect(() => {
    let cancelled = false
    showTemple()
      .then((resp) => {
        if (!cancelled) {
          setState([resp, 'loaded', null])
        }
      })
      .catch((e) => {
        if (!cancelled) {
          setState([false, 'error', new PermissionsError(e, 'ViewTempleUIPermission')])
        }
      })
    return () => {
      cancelled = true
    }
  }, [])

  return state
}

export async function showTemple() {
  // only import preferences if showTemple is called
  const { getPreference } = await import('@fs/zion-preferences')

  // eslint-disable-next-line prefer-const -- one is reassigned, so it needs to be a let
  let [templePerm, templePref] = await Promise.all([
    getPermission('ViewTempleUIPermission').catch((err) => {
      // it is possible to use showTemple() or the useShowTemple hook on a public page and user may not be logged in.
      // Instead of logging an uncaught error into the console, we can just have the hook catch this particular
      // error, return authorized: false, and continue on
      if (err.message === noSessionIdForContextErrorText) {
        return { authorized: false }
      }
      throw err
    }),
    getPreference('tree.showLDSTempleInfo'),
  ])

  // if temple pref is not set, default to true
  if (templePref === '') {
    templePref = true
  }
  return templePerm?.authorized === true && templePref
}

/**
 * Override using cookie to test and simulate nonreligious mode
 * @returns {String|Null} of cookie simulation mode
 */
export function getNRMCookie() {
  const validValEnum = ['off', 'on']
  const nrmCookie = Cookies.get('NRM')
  if (nrmCookie && validValEnum.includes(nrmCookie)) {
    return nrmCookie
  }
  return null
}

// TODO: the language parameter isn't used for anything at the moment. If it will not be used in the future, it should be removed
/**
 * NonReligiousMode pure function checks logical cases
 * @param {String} country - country code from geolocation service
 * @param {String} language - language code from zion-locale
 * @param {Boolean} isMember - is the user a member of the LDS Church
 * @returns {Boolean} true if nonreligious mode is on
 */
export function getIsNonReligiousModePure(country, language, isMember) {
  debug('getIsNonReligiousModePure -> country:', country)
  debug('getIsNonReligiousModePure -> language:', language)
  debug('getIsNonReligiousModePure -> isMember:', isMember)
  let isRestricted = false

  //  Geo === Mainland China && Simplified Chinese Language && NOT logged-in Church Member
  //  Geo === Indonesia, India, or Malaysia && NOT logged-in Church Member
  if (NRM_COUNTRIES_TO_CHECK.includes(country) && !isMember) {
    isRestricted = true
  }
  debug('getIsNonReligiousModePure -> isRestricted', isRestricted)
  return isRestricted
}

/**
 * NonReligiousMode smart function gets values from services to pass
 *  to getIsNonReligiousModePure pure function to evaluate against logical cases
 * @returns {Boolean} true if nonreligious mode is on
 */
export async function getIsNonReligiousMode() {
  // SUNSET: These 2 experiments are to be removed soon after nonreligious mode launch
  const nonReligiousModeWrapperEx = showEx('nonReligiousModeWrapper')
  const nonReligiousDetectEx = showEx('nonReligiousModeDetect')

  // start restricted for safety
  let isRestricted = true
  if (!nonReligiousModeWrapperEx) {
    return false
  }

  // Check if value is already from cookie simulation
  const cookieSimVal = await getNRMCookie()
  if (cookieSimVal !== null) {
    return cookieSimVal === 'on'
  }

  const country = geoData?.country

  // only do expensive work if country is in countriesToCheck
  if (nonReligiousDetectEx && NRM_COUNTRIES_TO_CHECK.includes(country)) {
    const language = i18n.language
    let isMember = false
    let session = false

    try {
      session = await getSession()
    } catch (e) {
      // Proceed with no session
    }

    // only do expensive work if user is logged in
    if (session) {
      // get member status
      const permission = await getPermission('FtMemberUiPermission')
      isMember = permission.authorized
    }
    isRestricted = getIsNonReligiousModePure(country, language, isMember)

    // note: we also need to read from this to benefit from cached value
    // commented out until the cache will actually work; see SITE-3547
    // await cache.setItem('geoRestrict', isRestricted)
  } else {
    // not in countriesToCheck, so not restricted
    isRestricted = false
  }
  return isRestricted
}

/**
 * Hook to use in components to see if nonreligious mode should be applied
 * @returns {Array} nonreligiousmode check results [Boolean, "loading" or "loaded" or "error", Error]
 */
export function useNonReligiousMode() {
  // [data], 'state', error
  // start true for safety
  const [state, setState] = useState([true, 'loading', null])

  useEffect(() => {
    let cancelled = false

    getIsNonReligiousMode()
      .then((nonReligiousMode) => {
        if (!cancelled) {
          setState([nonReligiousMode, 'loaded', null])
        }
      })
      .catch((error) => {
        if (!cancelled) {
          setState([[], 'error', error])
        }
      })

    return () => {
      cancelled = true
    }
  }, [])

  return state
}

/**
 * Hook used to see if the user has permissions to add personal data
 * @returns {Array} add personal data permission check results [Boolean, "loading" or "loaded" or "error", Error]
 */
export function useCanAddPersonalData(context = undefined) {
  const [state, setState] = useState([null, 'loading', null]) // data, state, error

  useEffect(() => {
    let cancelled = false
    canAddPersonalData(context)
      .then((resp) => {
        if (!cancelled) {
          setState([resp, 'loaded', null])
        }
      })
      .catch((e) => {
        if (!cancelled) {
          setState([false, 'error', new PermissionsError(e, 'CanAddPersonalDataPermission')])
        }
      })
    return () => {
      cancelled = true
    }
  }, [context])

  return state
}

export async function canAddPersonalData(context) {
  await getAnonSession()
  const canAddPersonalDataPerm = await getPermission('CanAddPersonalDataPermission', context)
  return canAddPersonalDataPerm?.authorized === true
}
