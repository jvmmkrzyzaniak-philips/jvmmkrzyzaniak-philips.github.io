import type { ReactNode } from 'react'
import React, { createContext, useContext, useEffect, useMemo, useRef } from 'react'
import { useEvent, useRandomId } from '@fs/zion-frontend-friends'
import { type SuggestionGetter, isImmediateSuggestions, isSuggestionPromise } from './Autosuggest'
import { type AutosuggestConfig, privateProps } from './AutosuggestState'

export type AutosuggestProviderProps = {
  children: ReactNode
  config: AutosuggestConfig
  getSuggestions: SuggestionGetter
  highlightMatchingText?: boolean
  showListWhenFocused?: boolean
  id?: string
}

type AutosuggestContextValue = {
  config: AutosuggestConfig
  getSuggestions: SuggestionGetter
  highlightMatchingText: boolean
  id: string
}

const AutosuggestContext = createContext<AutosuggestContextValue | null>(null)

// https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-list/
export function AutosuggestProvider({
  children,
  getSuggestions: unstableGetSuggestions,
  highlightMatchingText = false,
  showListWhenFocused = false,
  config,
  id: incomingId,
}: AutosuggestProviderProps): JSX.Element {
  if (!config) {
    throw new Error('AutosuggestProvider requires a config object from useAutosuggest() in order to function')
  }

  const id = useRandomId(incomingId)
  const { [privateProps]: api, userInput } = config
  const { inputIsFocused, setShowListWhenFocused } = api
  useEffect(() => setShowListWhenFocused(showListWhenFocused), [showListWhenFocused, setShowListWhenFocused])

  const getSuggestions = useEvent(unstableGetSuggestions)
  const { updateSuggestions, setIsLoading, suggestionsAreStale } = api

  // Keep track of whether input value has changed, to know if
  // we should accept suggestions coming in.
  const userInputRef = useRef(userInput)
  useEffect(() => {
    userInputRef.current = userInput
  }, [userInput])

  // Prevent state updates after unmount
  useEffect(
    () => () => {
      userInputRef.current = ''
    },
    []
  )

  useEffect(() => {
    const currentUserInput = userInput

    if (inputIsFocused && suggestionsAreStale) {
      const gotSuggestions = getSuggestions(userInput)
      if (isImmediateSuggestions(gotSuggestions)) {
        updateSuggestions(gotSuggestions || [])
      } else if (isSuggestionPromise(gotSuggestions)) {
        setIsLoading(true)
        gotSuggestions.then((s) => {
          if (currentUserInput === userInputRef.current) updateSuggestions(s || [])
        })
      } else {
        // This is an array of promises
        let unsettledCount = gotSuggestions.length
        setIsLoading(true)
        gotSuggestions.forEach((promise) => {
          promise
            .then((result) => {
              currentUserInput === userInputRef.current && updateSuggestions(result || [], true)
            })
            .finally(() => {
              unsettledCount -= 1
              if (unsettledCount === 0) setIsLoading(false)
            })
        })
      }
    }
  }, [inputIsFocused, suggestionsAreStale, userInput, getSuggestions, setIsLoading, updateSuggestions])

  const contextValue = useMemo(
    () => ({ id, config, getSuggestions, highlightMatchingText }),
    [config, id, highlightMatchingText, getSuggestions]
  )
  return <AutosuggestContext.Provider value={contextValue}>{children}</AutosuggestContext.Provider>
}

export const useAutosuggestContext = (): AutosuggestContextValue => {
  const context = useContext(AutosuggestContext)
  if (!context) throw new Error('this component must be wrapped in an AutosuggestProvider')
  return context
}
