import { useCallback, useMemo, useReducer } from 'react'
import { useEvent } from '@fs/zion-frontend-friends'
import { type Suggestion } from './Autosuggest'

/** Symbol to be used for private properties on the AutosuggestConfig */
export const privateProps = Symbol('DO NOT USE private internals DO NOT USE')

export type AutosuggestConfig = {
  /** The text showing in the value of the input */
  fieldValue: string

  /** Whether suggestions are currently being loaded */
  isLoading: boolean

  /** The suggestion that the user really likes. "If you were a booger, I would pick you! */
  selectedItem: Suggestion | null

  /** When you want to manually set the state. */
  set: (value: { userInput?: string; selectedItem?: Suggestion | null }) => void

  /** The suggestions available to the user */
  suggestions: Suggestion[]

  /** What the user actually typed. This may or may not be the same as fieldValue */
  userInput: string

  [privateProps]: {
    /** Call when the input is blurred */
    blur: () => void

    /** Call when the user presses escape, or clicks away from the overlay */
    cancel: () => void

    /** Call when the input is focused */
    focus: () => void

    /** The index of the current item in the suggestion list. -1 Represents nothing being selected */
    focusedIndex: number

    /** Whether the input field is currently focused */
    inputIsFocused: boolean

    /** Whether the list of suggestions is currently showing */
    listIsShowing: boolean

    /** Call when the user presses the up or down arrows */
    move: (direction: 1 | -1) => void

    /** Call when the user presses enter or tab, or clicks on a suggestion */
    select: (index?: number) => void

    /** Set whether suggestions are currently being loaded */
    setIsLoading: (isLoading: boolean) => void

    /** Show the list when the input is focused */
    setShowListWhenFocused: (show: boolean) => void

    /** Whether to show the list when the input is focused */
    showListWhenFocused: boolean

    /** Whether the input is waiting for a new list of suggestions.
     * NOTE: This is not redundant to 'isLoading'. This is more of a flag
     * to signify if the current list of suggestions is stale, so we don't
     * ask for new suggestions every time the input focuses. */
    suggestionsAreStale: boolean

    /** Update when the user types in the input, or to programatically set a value */
    updateUserInput: (input: string) => void

    /** Provide a new list of suggestsion */
    updateSuggestions: (suggestions: Suggestion[], isLoading?: boolean) => void
  }
}

type AutosuggestState = {
  suggestions: Suggestion[]
  suggestionsAreStale: boolean
  isLoading: boolean
  selectedItem: Suggestion | null
  userInput: string
  focusedIndex: number
  listIsShowing: boolean
  inputIsFocused: boolean
  showListWhenFocused: boolean
}

const baseState: AutosuggestState = {
  suggestions: [],
  suggestionsAreStale: true,
  isLoading: false,
  selectedItem: null,
  userInput: '',
  focusedIndex: -1,
  listIsShowing: false,
  inputIsFocused: false,
  showListWhenFocused: true,
}

type FocusAction = { type: 'FOCUS'; data: boolean }
type UserMoveAction = { type: 'MOVE'; data: 1 | -1 }
type UserInputAction = { type: 'INPUT'; data: string }
type SuggestionsAction = { type: 'SUGGESTIONS'; data: Suggestion[]; isLoading: boolean }
type IsLoadingAction = { type: 'IS_LOADING'; data: boolean }
type UserSelectAction = { type: 'SELECT'; data?: number }
type UserCancelAction = { type: 'CANCEL'; data: undefined }
type ShowListWhenFocusAction = { type: 'SHOW_WHEN_FOCUSED'; data: boolean }
type SetAction = { type: 'SET'; data: { userInput: string; selectedItem: Suggestion | null } }

type AutosuggestAction =
  | FocusAction
  | ShowListWhenFocusAction
  | UserMoveAction
  | UserInputAction
  | IsLoadingAction
  | SuggestionsAction
  | UserSelectAction
  | UserCancelAction
  | SetAction

const getIndexOfSelectedItem = ({
  suggestions,
  selectedItem,
}: Pick<AutosuggestState, 'suggestions' | 'selectedItem'>): number => {
  if (!selectedItem) return -1
  return suggestions.findIndex(
    ({ id, key, primaryText }) =>
      (id != null && id === selectedItem.id) ||
      (key != null && key === selectedItem.key) ||
      primaryText === selectedItem.primaryText
  )
}

export const AutosuggestReducer = (state: AutosuggestState, action: AutosuggestAction): AutosuggestState => {
  const { type, data } = action
  switch (type) {
    case 'SUGGESTIONS': {
      if (data === state.suggestions && !state.suggestionsAreStale) return state
      const prevFocused = state.suggestions[state.focusedIndex]
      let newFocusedIndex = -1
      if (prevFocused) newFocusedIndex = getIndexOfSelectedItem({ suggestions: data, selectedItem: prevFocused })
      return {
        ...state,
        focusedIndex: newFocusedIndex,
        suggestions: data,
        suggestionsAreStale: false,
        isLoading: action.isLoading,
      }
    }

    case 'IS_LOADING':
      if (state.isLoading === data) return state
      return { ...state, isLoading: data }

    case 'FOCUS': {
      const { showListWhenFocused, inputIsFocused } = state
      // If focus didn't change, do nothing
      if (inputIsFocused === data) return state

      // If blurring, hide the list
      if (!data) return { ...state, inputIsFocused: false, listIsShowing: false, focusedIndex: -1 }

      // Simple focus
      if (!showListWhenFocused) return { ...state, inputIsFocused: true }

      // Focus and open the list
      return { ...state, inputIsFocused: true, listIsShowing: true, focusedIndex: getIndexOfSelectedItem(state) }
    }

    case 'MOVE': {
      if (!state.listIsShowing) {
        // This Means that the list needs to be opened, and we should't auto-focus the first item
        return { ...state, listIsShowing: true, focusedIndex: getIndexOfSelectedItem(state) }
      }

      let { focusedIndex } = state
      focusedIndex += data
      const size = state.suggestions?.length
      if (focusedIndex === size) focusedIndex = -1
      if (focusedIndex < -1) focusedIndex = size - 1
      return { ...state, focusedIndex }
    }

    case 'INPUT': {
      const { inputIsFocused } = state

      /**
       * Because we compute the fieldValue from the selectedItem and userInput, we need to account
       * for the edge case where the users selects something from the list without typing anything,
       * and then highlights the text & deletes it without typing anything else.
       *
       * In that case `data` and the `userInput` would both be the empty string. If we kept this
       * line of code, we would neglect to clear the selectedItem, and thus `fieldValue` would be
       * the selectedItem until the user types something (other than delete or backspace). Not a
       * great user experience, to have to first type something else to clear the input.
       *
       * I'm leaving this here incase we ever try to "optimize", like we do elsewhere
       */
      // if (data === userInput) return state

      return {
        ...state,
        userInput: data,
        focusedIndex: -1,
        selectedItem: null,
        listIsShowing: inputIsFocused,
        suggestionsAreStale: true,
      }
    }

    case 'SELECT': {
      if (!state.listIsShowing && data == null) return state
      const index = data ?? state.focusedIndex
      const selectedItem = state.suggestions[index]
      return { ...state, selectedItem, focusedIndex: -1, listIsShowing: false }
    }

    case 'CANCEL':
      if (!state.listIsShowing) return state
      return { ...state, focusedIndex: -1, listIsShowing: false }

    case 'SHOW_WHEN_FOCUSED': {
      if (state.showListWhenFocused === data) return state
      return { ...state, showListWhenFocused: data }
    }

    case 'SET': {
      const { userInput = state.userInput, selectedItem = state.selectedItem } = data
      if (state.userInput === userInput && state.selectedItem === selectedItem) return state
      return { ...state, userInput, selectedItem }
    }

    default: {
      // we are doing an exhaustive check to make sure we don't miss a case
      const exhaustiveCheck: never = action
      throw new Error(`Unsupported Action: ${JSON.stringify(exhaustiveCheck)}`)
    }
  }
}

export type SelectionHandler = (selected: Suggestion | null, userInput: string) => string

export const defaultHandleSelection: SelectionHandler = (suggestion, input) =>
  suggestion ? suggestion.primaryText : input

export type UseAutosuggestProps = {
  /** The initial state of the input */
  initialState?: Partial<Pick<AutosuggestState, 'userInput' | 'selectedItem'>>

  /** The fuction needed to transform a given suggestion into a string, to be used to populate the input */
  handleSelection?: SelectionHandler
}

export const useAutosuggest = ({
  initialState,
  handleSelection = defaultHandleSelection,
}: UseAutosuggestProps = {}): AutosuggestConfig => {
  const [state, dispatch] = useReducer(AutosuggestReducer, { ...baseState, ...initialState })
  const { isLoading, selectedItem, suggestions, userInput, ...rest } = state

  const privateApi = useMemo<
    Omit<
      AutosuggestConfig[typeof privateProps],
      'focusedIndex' | 'inputIsFocused' | 'listIsShowing' | 'showListWhenFocused' | 'suggestionsAreStale'
    >
  >(
    () => ({
      updateUserInput: (input) => dispatch({ type: 'INPUT', data: input }),
      focus: () => dispatch({ type: 'FOCUS', data: true }),
      blur: () => dispatch({ type: 'FOCUS', data: false }),
      move: (direction) => dispatch({ type: 'MOVE', data: direction }),
      select: (index) => dispatch({ type: 'SELECT', data: index }),
      cancel: () => dispatch({ type: 'CANCEL', data: undefined }),
      updateSuggestions: (newSuggestions, newIsLoading = false) =>
        dispatch({ type: 'SUGGESTIONS', data: newSuggestions, isLoading: newIsLoading }),
      setIsLoading: (newIsLoading) => dispatch({ type: 'IS_LOADING', data: newIsLoading }),
      setShowListWhenFocused: (show) => dispatch({ type: 'SHOW_WHEN_FOCUSED', data: show }),
    }),
    []
  )

  const set = useCallback((orig) => dispatch({ type: 'SET', data: orig }), [])

  const stableHandleSelection = useEvent(handleSelection)
  const { focusedIndex, listIsShowing } = state
  const fieldValue = useMemo(() => {
    let currentSelectedItem = selectedItem
    if (listIsShowing) currentSelectedItem = suggestions[focusedIndex]
    return stableHandleSelection(currentSelectedItem, userInput)
  }, [userInput, selectedItem, listIsShowing, focusedIndex, suggestions, stableHandleSelection])

  return useMemo<AutosuggestConfig>(
    () => ({
      fieldValue,
      isLoading,
      selectedItem,
      suggestions,
      userInput,
      set,
      [privateProps]: { ...rest, ...privateApi },
    }),
    [fieldValue, isLoading, selectedItem, suggestions, userInput, rest, set, privateApi]
  )
}
