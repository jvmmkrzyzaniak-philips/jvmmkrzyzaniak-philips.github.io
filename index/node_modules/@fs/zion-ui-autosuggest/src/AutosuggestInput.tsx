import React, { forwardRef, useRef } from 'react'
import type { ChangeEvent, KeyboardEvent, FocusEvent } from 'react'
import { TextField } from '@fs/zion-ui'
import { useEvent, useForwardRef } from '@fs/zion-frontend-friends'
import { useAutosuggestContext } from './AutosuggestProvider'
import { type ZionUiInputProps } from './types'
import AutosuggestOverlay from './AutosuggestOverlay'
import { privateProps } from './AutosuggestState'

export const AutosuggestInput = forwardRef<HTMLInputElement, ZionUiInputProps>(
  ({ onChange, onKeyDown, onFocus, onBlur, clearable, onClear, ...props }, ref) => {
    if (props.type === 'password') {
      throw new Error(
        'Autosuggest should not be used with sensitive data. Please use a regular input instead if you need type="password".'
      )
    }

    const inputRef = useForwardRef(ref)
    const {
      id,
      config: { fieldValue, [privateProps]: api, set },
    } = useAutosuggestContext()

    const handleKeyboardControls = useEvent((event: KeyboardEvent<HTMLInputElement>) => {
      const { key } = event
      switch (key) {
        case 'ArrowDown':
        case 'ArrowUp': {
          event.preventDefault()
          event.stopPropagation()
          // deliberately treating the `alt+arrow` behavior the same as without the `alt`
          // this is a diverge from the spec, but we feel is a minor improvement to the
          // user experience, see:
          // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-both/#kbd_label
          api.move(key === 'ArrowUp' ? -1 : 1)
          break
        }

        case 'Tab': {
          api.select()
          break
        }
        case 'Enter': {
          if (!inputRef.current?.closest('form')) {
            api.select()
          } else if (api.listIsShowing) {
            event.preventDefault()
            event.stopPropagation()
            api.select()
          }
          break
        }
        case 'Escape': {
          event.preventDefault()
          api.cancel()
          break
        }
        default:
      }

      // fire the consumer's handler after ours, so if they throw an error, our logic will still fire correctly.
      onKeyDown?.(event)
    })

    const handleChange = useEvent((evt: ChangeEvent<HTMLInputElement>) => {
      api.updateUserInput(evt.target.value)
      onChange?.(evt)
    })

    const handleFocus = useEvent((e) => {
      api.focus()
      onFocus?.(e)
    })

    const handleBlur = useEvent((e: FocusEvent<HTMLInputElement>) => {
      /**
       * We don't want to fire the blur handler if we clicked inside the AutosuggestList,
       * since we haven't blurred, the entire affordance, just the field.
       *
       * Without this, api.blur() will close the overlay before the user's mouse events
       * have finished firing all the way, which can make it difficult for the user to
       * select an item from the list.
       * See https://icseng.atlassian.net/browse/FRONTIER-1601
       *
       * If the user clicks on a suggestion, the `relatedTarget` will be the suggestion.
       * If the user clicks outside the list, the `relatedTarget` will be null or another
       * element.
       */
      const clickedOutside = !e.relatedTarget?.closest?.('[role="listbox"] [role="option"]')
      if (clickedOutside) {
        api.blur()
        onBlur?.(e)
      }
    })

    const handleClear = useEvent(() => {
      set({ userInput: '', selectedItem: null })
      onClear?.()
    })

    const { focusedIndex } = api

    return (
      <TextField
        {...props}
        ref={inputRef}
        value={fieldValue}
        onChange={handleChange}
        onKeyDown={handleKeyboardControls}
        role="combobox"
        aria-autocomplete="list"
        aria-controls={`listbox-${id}`}
        id={id}
        aria-activedescendant={focusedIndex != null ? `li-${focusedIndex}-${id}` : null}
        onFocus={handleFocus}
        onBlur={handleBlur}
        clearable={clearable}
        onClear={handleClear}
      />
    )
  }
)

export const AutosuggestInputWithOverlay = forwardRef<HTMLInputElement, ZionUiInputProps>((props, ref) => {
  const inputRef = useForwardRef(ref)
  const anchorRef = useRef<HTMLDivElement>(null)
  return (
    <>
      <AutosuggestInput {...props} inputContainerRef={anchorRef} ref={inputRef} />
      <AutosuggestOverlay anchorRef={anchorRef} inputRef={inputRef} />
    </>
  )
})
