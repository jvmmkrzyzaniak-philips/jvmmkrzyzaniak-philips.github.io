import Cache from '@fs/zion-cache'
import { unidirectionalHash } from './util'

/**
 * Data surrounding a UserRecord in the cache, users internally to calculate confidence
 * @typedef {Object} UserRecordMetaData
 * @property {Hash} referenceId - This records id
 * @property {Number} interactionCount - The number of times we have observed the user interacting with the site (full page reloads)
 * @property {Number} lastInteraction - The last time we observed the user interacting with the site
 * @property {Number} [confidence] - computed confidence score
 */

/**
 * Statistics about a user who has logged into this device in the past
 * @see https://www.familysearch.org/service/home/pb/json_UserSegment.html for more information
 * @typedef {Object} UserRecord
 * @property {UserRecordMetaData} [_meta] - The meta data for the record used internally to Previous User Service
 * @property {('HELPER'|'CONTRIBUTOR'|'NON_CONTRIBUTOR')} userLevel - Name of the User's Calculated Expertise Level
 * @property {('FULL'|'SPARSE'|'EMPTY')} treeLevel - Name of the User's Calculated Tree Level
 * @property {Boolean} newUser - true if user has logged in 3 (or fewer) times in the last year
 * @property {Boolean} member - true if user is a member of the church
 * @property {Object} contributions - Object representing the number of contributions made by the user
 * @property {Number} contributions.sources - Sources Attached by the user in the last year
 * @property {Number} contributions.memories - Memories Attached by the user in the last year
 * @property {Number} contributions.reservations - Temple Ordinances reserved by the user in the last year
 * @property {Object} lastActivity - Object representing the last time activities were performed by the user
 * @property {Number} lastActivity.sources - Sources Attached last time stamp
 * @property {Number} lastActivity.memories - Memories Attached  last time stamp
 * @property {Number} lastActivity.reservations - Temple Ordinances reserved  last time stamp
 */

const MAX_SHARED_DEVICE_USERS = 3
const TEMPORAL_CONFIDENCE_WEIGHT = 1
const ACTIVITY_CONFIDENCE_WEIGHT = 1

const lifetime = 1000 * 60 * 60 * 24 * 365 // ~ 12 months (365 days)
const users = new Cache({ dbName: 'pus', storeName: 'users', type: 'local', lifetime })
const meta = new Cache({ dbName: 'pus', storeName: 'meta', type: 'local', lifetime })

/**
 * Get the meta data surrounding a user's record in the cache
 * @async
 * @param {Hash} referenceId
 * @returns {UserRecordMetaData}
 */
async function getMetaData(referenceId) {
  return (await meta.getItemData(referenceId)) || { interactionCount: 0, lastInteraction: 0 }
}

/**
 * Computes a score for how confident we are that the logged out user viewing the page is
 * the same person as this record from the cache.
 * @param {Object} config
 * @param {Object} config.lastInteraction -
 * @param {Object} config.interactionCount -
 * @param {Object} config.maxTime -
 * @param {Object} config.minTime -
 * @param {Object} config.maxCount -
 * @param {Object} config.minCount -
 * @returns {Number} - a score between 0 and 1
 */
function computeConfidence({ lastInteraction, interactionCount, maxTime, minTime, maxCount, minCount }) {
  // The most recent user has a temporal confidence of 1, the least recent has a confidence of 0
  // and the rest have a linear interpolation between 0 and 1
  // temporal confidence represents where they line up in time with the other users
  const temporalConfidence = (lastInteraction - minTime) / (maxTime - minTime)

  // Likewise, we can interpolate between the number of interactions per user
  // to provide weight to those who use the site more frequently
  const activityConfidence = (interactionCount - minCount) / (maxCount - minCount)

  // The final confidence is a weighted the sum of the two, normalized to be between 0 and 1
  const totalConfidence =
    (temporalConfidence * TEMPORAL_CONFIDENCE_WEIGHT + activityConfidence * ACTIVITY_CONFIDENCE_WEIGHT) /
    (TEMPORAL_CONFIDENCE_WEIGHT + ACTIVITY_CONFIDENCE_WEIGHT)

  // In the wild this could be NaN if min/max's are the same
  return Number.isNaN(totalConfidence) ? 0 : totalConfidence
}

/**
 * Sort the UserRecord objects in the cache by their confidence score
 * @param {UserRecord[]} deviceUsers - The users who have logged into this device
 * @returns {UserRecord[]} - The users sorted by confidence
 */
function sortByConfidence(deviceUsers) {
  // If there is only one user, we can be pretty confident they are a match
  if (deviceUsers.length === 1) {
    // We use the underscore here to indicate that the meta data should be considered private
    // and should not be used outside of this package
    // eslint-disable-next-line no-underscore-dangle
    deviceUsers[0]._meta.confidence = 1
    return deviceUsers
  }

  const maxTime = deviceUsers.reduce(
    (current, { _meta: { lastInteraction = 0 } = {} }) => Math.max(lastInteraction, current),
    -Infinity
  )
  const minTime = deviceUsers.reduce(
    (current, { _meta: { lastInteraction = 0 } = {} }) => Math.min(lastInteraction, current),
    Infinity
  )
  const maxCount = deviceUsers.reduce(
    (current, { _meta: { interactionCount = 0 } = {} }) => Math.max(interactionCount, current),
    -Infinity
  )
  const minCount = deviceUsers.reduce(
    (current, { _meta: { interactionCount = 0 } = {} }) => Math.min(interactionCount, current),
    Infinity
  )

  const confidences = deviceUsers.map(
    ({ _meta: { lastInteraction = 0, interactionCount = 0, referenceId = null } = {} }) => ({
      referenceId,
      confidence: computeConfidence({ lastInteraction, interactionCount, maxTime, minTime, maxCount, minCount }),
    })
  )

  return confidences
    .sort((a, b) => b.confidence - a.confidence)
    .map(({ referenceId, confidence }) => {
      const data = deviceUsers.find(({ _meta }) => _meta.referenceId === referenceId)
      // We use the underscore here to indicate that the meta data should be considered private
      // and should not be used outside of this package
      // eslint-disable-next-line no-underscore-dangle
      data._meta.confidence = confidence
      return data
    })
}

/**
 * Record the fact that a user has logged in, and loaded a page
 * @async
 * @param {Hash} referenceId - The id of the user record
 * @returns
 */
async function recordInteraction(referenceId) {
  const metaData = await getMetaData(referenceId)
  return meta.setItemData(referenceId, {
    ...metaData,
    lastInteraction: Date.now(),
    interactionCount: (metaData.interactionCount || 0) + 1,
    referenceId,
  })
}

/**
 * Retrieve all the the UserRecords from the cache
 * @returns {UserRecord[]} - List of users who have logged into this device - sorted by confidence
 */
export async function getAllDeviceUsers() {
  const referenceIds = await users.keys()
  const deviceUsers = await Promise.all(
    referenceIds.map(async (referenceId) => {
      const [data, metaData] = await Promise.all([users.getItemData(referenceId), getMetaData(referenceId)])
      // We use the underscore here to indicate that the meta data should be considered private
      // and should not be used outside of this package
      // eslint-disable-next-line no-underscore-dangle
      data._meta = metaData
      return data
    })
  )

  return sortByConfidence(deviceUsers)
}

/**
 * Retrieve the UserRecord from the cache for the given cisId
 * @async
 * @param {string} cisId - user's CIS ID
 * @returns {UserRecord|null} - The user found user record, or null if not found
 */
export async function getDataById(cisId) {
  const referenceId = unidirectionalHash(cisId)
  return users.getItemData(referenceId)
}

/**
 * Retrieve the UserRecord from the cache for the given cisId
 * or for the most confident user if the cisId is not provided
 * @async
 * @param {string} cisId - user's CIS ID
 * @returns {UserRecord|null} - The user record of the most likely candidate
 */
export async function getProbableUser(cisId) {
  const confirmedUser = cisId && (await getDataById(cisId))
  if (confirmedUser) return confirmedUser
  const deviceUsers = await getAllDeviceUsers()
  if (deviceUsers.length <= MAX_SHARED_DEVICE_USERS) return deviceUsers[0]
  return null
}

/**
 * Record a UserRecord in the cache for the given cisId
 * As a side-effect, this will also record an interaction in the meta data
 * @async
 * @param {string} cisId - user's CIS ID
 * @returns {UserRecord} - The user record of the most likely candidate
 */
export async function setProbableUserData(cisId, data) {
  const referenceId = unidirectionalHash(cisId)
  recordInteraction(referenceId)
  return users.setItemData(referenceId, data)
}
