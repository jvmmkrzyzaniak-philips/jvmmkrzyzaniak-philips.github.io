import React, { useRef, useEffect } from 'react'
import { css } from '@linaria/core'
import { VisuallyHidden } from '@reach/visually-hidden'
import {
  Button,
  Card,
  DataBlock,
  Divider,
  FlowGrid,
  Grid,
  H2,
  LayoutBand,
  Paragraph,
  Row,
  Separator,
  Skeleton,
  colors,
  useContainerWidth,
  useOverlayUpdate,
} from '@fs/zion-ui'
import { useFeatureFlag } from '@fs/zion-flags'
import { useHistory } from '@fs/zion-router'
import { Person } from '@fs/zion-person'
import { Trans, useTranslation } from 'react-i18next'
import { boolAttr } from '@fs/zion-frontend-friends'
import { getNameStringFromFormValues } from '@fs/zion-name-template'
import { useGroupsContext } from '@fs/zion-tree-groups'
import { FIND_BY_NAME, FIND_BY_ID, SEARCH_DOWN_NON_BLOCKING_ERROR, FIND_FLOW } from '../services/AddFindFlowService'
import { getResultAction, WarningWrapper } from '../components/ResultsAction'
import { useAddFindFlowContext } from '../hooks/AddFindFlowContext'
import AddFindFlowDisplayError from './DisplayErrorView'
import useCustomEscHandler from '../hooks/useCustomEsc'

const wrapperCss = css`
  background-color: ${colors.gray03};
  [infosheet] {
    min-height: 100vh;
  }
`

// format a standards picker object into a search result event object, which is different than a normal tree data or conclusion event object
const getEventObject = (values, eventName) => {
  const place = values[`${eventName}Place`]?.originalText || values[`${eventName}Place`]?.standard?.standardizedText
  const date = values[`${eventName}Date`]?.originalText || values[`${eventName}Date`]?.standard?.standardizedText
  if (place || date) {
    return {
      [`${eventName}Type`]: eventName.toUpperCase(),
      [`${eventName}Date`]: date,
      [`${eventName}Place`]: place,
    }
  }
  return {}
}

// format form values into a search result person, which is different than a normal tree data person, for use in the userEntered result.
function createPersonFromFindByNameForm({ sex = '', ...values }) {
  return {
    alreadyRelated: false,
    person: {
      id: 'PRIVATE', // TODO: Document this use case inside of zion-person
      ...getEventObject(values, 'birth'),
      ...getEventObject(values, 'burial'),
      ...getEventObject(values, 'death'),
      gender: sex.toUpperCase(),
      name: getNameStringFromFormValues(values),
    },
    type: 'PERSON',
  }
}

/**
 * JSX add/find flow find-by-name form content and validation.
 * @param {object} props - The props passed into the element.
 * @param {string} props.addFindFlowStageTwoPath
 * @returns {HTMLElement} - JSX.
 */
export default function FindResults({ addFindFlowStageTwoPath, updateInfoSheetFooter }) {
  const atWidth = useContainerWidth()
  const [t] = useTranslation()
  const { errors, clearErrors, tabIndex, mode, searchResults, values, loading, isCopying, inInfoSheet } =
    useAddFindFlowContext()
  useCustomEscHandler()

  const findByNamePerson = mode === FIND_BY_NAME ? createPersonFromFindByNameForm(values) : null
  const findByNameLivingStatus = findByNamePerson && values?.status === 'living'
  const resultsFound = Boolean(searchResults?.length)
  const nonBlockingError = errors?.[SEARCH_DOWN_NON_BLOCKING_ERROR]
  const history = useHistory()
  const { length } = history
  const { currentTreeId } = useGroupsContext()
  const updateDialogFooter = useOverlayUpdate('footer')
  const updateFooter = inInfoSheet ? updateInfoSheetFooter : updateDialogFooter

  useEffect(() => {
    clearErrors(FIND_BY_ID)
    clearErrors(FIND_BY_NAME)
    updateFooter()
  }, [clearErrors, length, updateFooter])

  if (errors?.[FIND_FLOW]) {
    return (
      <AddFindFlowDisplayError
        updateInfoSheetFooter={updateInfoSheetFooter}
        titleKey={errors[`${FIND_FLOW}-title`]?.messageKey}
        messageKey={errors[FIND_FLOW]?.messageKey}
        link={errors[FIND_FLOW]?.link}
      />
    )
  }

  return (
    <LayoutBand
      top
      bottom
      className={wrapperCss}
      infosheet={boolAttr(inInfoSheet)}
      color="colors.gray03"
      data-testid="add-find-flow:results"
    >
      {findByNameLivingStatus ? (
        <>
          <H2 size="H6">{t('add-find-flow.info.living-people.heading')}</H2>
          <Separator size="xs" />
          <Paragraph size="sm">
            {/* This looks a bit funny, but using the string interpolation adds a space between the two sentences. */}
            {`${t('add-find-flow.info.living-people')} `}
            {t(
              currentTreeId
                ? 'add-find-flow.info.living-people-privacy.groups'
                : 'add-find-flow.info.living-people-privacy.standard'
            )}
          </Paragraph>
          <Separator size="md" />
          <Row alignItemsY="middle" gutters="lg">
            <H2 size="H6">{t('add-find-flow.find-results.title.you-entered')}</H2>
            <Button emphasis="low" data-testid="back-button" onClick={() => history.goBack()}>
              {t('add-find-flow.button.refine-search')}
            </Button>
          </Row>
          <Separator size="xs" />
          <FindResult living={findByNameLivingStatus} result={findByNamePerson} userEntered error={nonBlockingError} />
        </>
      ) : null}
      {/* searchResults is set to null before searching, that way we know the
          loading is from a search, not from creating or adding match. This is
          important for a11y since an aria-live announces "Searching for
          matches." */}
      {!findByNameLivingStatus && loading && searchResults === null ? (
        <>
          <VisuallyHidden aria-live="assertive">{t('add-find-flow.searching-for-matches')}</VisuallyHidden>
          <Separator size="xs" />
          <Skeleton.H5 />
          <Separator size="xs" />
          <Card>
            <Skeleton.PersonBlock />
            <Skeleton.Paragraph maxWidth={100} size="sm" />
            <Skeleton.Paragraph lineCount={2} size="md" />
            <Separator size="xs" />
            <Skeleton.PersonBlock />
            <Skeleton.PersonBlock />
            <Separator size="xs" />
            <Divider />
            <Separator size="xs" />
            <Skeleton.Button />
          </Card>
        </>
      ) : null}
      {!findByNameLivingStatus && resultsFound ? (
        <Grid>
          {findByNamePerson ? (
            <section
              data-testid="you-searched-option"
              columns={atWidth({
                default: 12,
                lg: tabIndex === 1 ? 12 : 4,
              })}
            >
              <Row alignItemsY="middle" gutters="lg">
                <H2 size="H6">{t('add-find-flow.find-results.title.you-entered')}</H2>
                <Button emphasis="low" data-testid="back-button" onClick={() => history.goBack()}>
                  {t('add-find-flow.button.refine-search')}
                </Button>
              </Row>

              <Separator size="nano" />
              <FindResult
                living={findByNameLivingStatus}
                result={findByNamePerson}
                userEntered
                error={nonBlockingError}
              />
              <Separator size="xs" />
              <Paragraph size="sm">{t('add-find-flow.create-new.description')}</Paragraph>
            </section>
          ) : null}
          <section
            data-testid="find-results"
            columns={atWidth({
              default: 12,
              lg: !findByNamePerson || tabIndex === 1 ? 12 : 8,
            })}
          >
            <Separator size="nano" />
            <H2 size="H6">
              {isCopying
                ? t('add-find-flow.title.add-from-private-pedigree')
                : `${t('add-find-flow.possible-matches-found.title')} (${searchResults?.length})`}
            </H2>
            <Separator size="xs" />
            {searchResults.map((result) => (
              <FindResult nextRoutePath={addFindFlowStageTwoPath} key={result?.person?.id} result={result} />
            ))}
          </section>
        </Grid>
      ) : null}
      {!findByNameLivingStatus && !loading && searchResults !== null && !resultsFound && !nonBlockingError ? (
        <>
          <section data-testid="find-results">
            <H2 size="H6">{t('add-find-flow.no-match-found.title')}</H2>
            <Separator size="xs" />
            <Paragraph size="sm">{t('add-find-flow.no-match-found.description')}</Paragraph>
            <Separator size="sm" />
            <Button emphasis="medium" data-testid="back-button" onClick={() => history.goBack()}>
              {t('add-find-flow.button.refine-search')}
            </Button>
          </section>
          {findByNamePerson ? (
            <>
              <Separator size="md" />
              <Divider />
              <section data-testid="you-searched-option">
                <Separator size="md" />
                <Paragraph size="sm">{t('add-find-flow.no-match-found.suggest-create-person')}</Paragraph>
                <Separator size="xs" />
                <FindResult
                  living={findByNameLivingStatus}
                  result={findByNamePerson}
                  userEntered
                  error={nonBlockingError}
                />
              </section>
            </>
          ) : null}
        </>
      ) : null}
    </LayoutBand>
  )
}

const vitalTranslationKeyMap = {
  BIRTH: 'add-find-flow.find-results.label.BIRTH',
  BURIAL: 'add-find-flow.find-results.label.BURIAL',
  CHRISTENING: 'add-find-flow.find-results.label.CHRISTENING',
  DEATH: 'add-find-flow.find-results.label.DEATH',
}
/**
 * A single result from the search.
 * @param {object} props - props.
 * @param {object} props.nextRoutePath - next step when copying in add find flow
 * @param {object} props.result - the search result to display.
 * @param {bool} props.userEntered - flag for if this is not a real search result but is instead is the information the user entered.
 * @returns {HTMLElement} - JSX.
 */
function FindResult({ nextRoutePath, living, result, userEntered }) {
  const [t] = useTranslation()
  const { isOn: addBurialFields } = useFeatureFlag('ginkgo_addFindFlow_addBurialFields')
  const { operationType, errors, values, relationshipInfo, isCopying } = useAddFindFlowContext()
  const ResultAction = getResultAction({
    searchResult: result,
    operationType,
    userEntered,
    relationshipInfo,
    isCopying,
  })
  const eventNames = addBurialFields && values?.template === 'zh' ? ['birth', 'death', 'burial'] : ['birth', 'death']
  const atWidth = useContainerWidth()
  const columnCount = atWidth({ default: 1, md: living ? 1 : 2, lg: userEntered ? 1 : 2 })
  const numParents = [result?.person?.parents?.parent1, result?.person?.parents?.parent2].filter(Boolean).length
  const focusRef = useRef()
  // Autofocus on the create button if person is living
  useEffect(() => {
    if (living) {
      // TW-5488 - Wait to focus on button until the view transition finishes so we don't get negative left margin.
      setTimeout(() => {
        focusRef?.current?.focus()
      }, 400)
    }
  }, [living])

  return (
    <>
      <Card edges={!living && userEntered ? 'border' : undefined}>
        <Person
          personObj={result.person}
          hideLifespan={userEntered}
          hidePid={userEntered}
          openPersonOverlay={!userEntered}
          avatarSize="smaller"
          linksOpenNewTab
        />
        <div>
          <FlowGrid columnCount={columnCount} guttersY="none">
            {eventNames.map((eventName) => {
              if (eventName === 'burial' && result?.person?.deathType === 'BURIAL') return null
              const date = result?.person?.[`${eventName}Date`]
              const place = result?.person?.[`${eventName}Place`]
              if (date || place) {
                const eventType = eventName === 'burial' ? 'BURIAL' : result?.person?.[`${eventName}Type`]
                return (
                  <DataBlock
                    key={`${eventName}-event`}
                    data-testid={`${eventName}-event`}
                    heading={t(vitalTranslationKeyMap[eventType])}
                    data={
                      <>
                        {date}
                        {date && place && <br />}
                        {place}
                      </>
                    }
                  />
                )
              }
              return null
            })}
          </FlowGrid>
          {(result.spouses || result.person.parents) && <Divider marginY="sm" />}
          <FlowGrid columnCount={columnCount} guttersY="none">
            {result.spouses && (
              <div data-testid="spouses">
                <small>{t('add-find-flow.find-results.label.spouse', { count: result.spouses.length })}</small>
                {result.spouses?.map((spouse) => (
                  <Person key={spouse.id} personObj={spouse} openPersonOverlay linksOpenNewTab componentSize="sm" />
                ))}
              </div>
            )}
            {result.person.parents && (
              <div data-testid="parents">
                <small>{t('add-find-flow.find-results.label.parents', { count: numParents })}</small>
                {result.person.parents?.parent1 && (
                  <Person
                    personObj={result.person.parents.parent1}
                    openPersonOverlay
                    linksOpenNewTab
                    componentSize="sm"
                  />
                )}
                {result.person.parents?.parent2 && (
                  <Person
                    personObj={result.person.parents.parent2}
                    openPersonOverlay
                    linksOpenNewTab
                    componentSize="sm"
                  />
                )}
              </div>
            )}
          </FlowGrid>
        </div>
        {errors?.messageKey && (
          <WarningWrapper>
            <Trans i18nKey={errors.messageKey} />
          </WarningWrapper>
        )}
        <Separator size="xs" />
        <ResultAction nextRoutePath={nextRoutePath} searchResult={result} ref={focusRef} />
      </Card>
      <Separator size="xs" />
    </>
  )
}
