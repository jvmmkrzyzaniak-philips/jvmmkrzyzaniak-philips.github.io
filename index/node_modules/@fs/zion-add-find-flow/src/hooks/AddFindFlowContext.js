import React, { createContext, useContext, useReducer, useCallback, useEffect, useRef, useMemo } from 'react'
import Cache from '@fs/zion-cache'
import { useZionAxios } from '@fs/zion-axios'
import { useGroupsContext } from '@fs/zion-tree-groups'
import { getPersonObj } from '@fs/zion-person-service'
import { isValidPid } from '@fs/zion-pid'
import { COPY_FROM_MY_TREE, FIND_BY_NAME, FIND_BY_ID } from '../services/AddFindFlowService'

const tabsCache = new Cache({ storeName: 'addFindFlowTabs' })
export const AddFindFlowContext = createContext()

export const useAddFindFlowContext = () => {
  return useContext(AddFindFlowContext)
}

const initialState = {
  treeId: '',
  noGroupTabs: false,
  selectedPrivatePerson: null,
  loading: false,
  searchResults: null,
  stage2Result: null,
  tabIndex: 0,
  mode: FIND_BY_NAME,
  abortController: new AbortController(),
  reasonDialogStoreName: 'treeWebReplaceRelationshipReason',
}

const reducer = (state, action) => {
  // Yup, this tabs logic is hacky. Tabs onChange is reliant on the index though, and design wants copy from tree to be first.
  // Without this, the SearchView footer will not be accurate in some cases.
  const groupTabs = [FIND_BY_NAME, COPY_FROM_MY_TREE, FIND_BY_ID]
  const defaultTabs = [FIND_BY_NAME, FIND_BY_ID]
  const actualTabs = state.treeId && !state.isResearcherGroup && !state.noGroupTabs ? groupTabs : defaultTabs

  switch (action.type) {
    case 'RESET':
      return { ...action.initialState }
    case 'SET_LOADING':
      return { ...state, loading: action.loading }
    case 'SET_READY':
      return { ...state, isReady: true }
    case 'SET_TAB':
      return {
        ...state,
        isReady: typeof state.isReady !== 'undefined' ? state.isReady : action.isReady,
        tabIndex: action.index || 0,
        mode: actualTabs[action.index] || FIND_BY_NAME,
        isCopying: COPY_FROM_MY_TREE === actualTabs[action.index],
      }
    case 'SET_IS_COPYING':
      return { ...state, isCopying: action.isCopying }
    case 'SET_FORM_VALUES':
      return { ...state, values: action.values }
    case 'SET_RESULTS':
      return { ...state, searchResults: action.searchResults }
    case 'SET_SELECTED_PRIVATE_PERSON':
      return { ...state, selectedPrivatePerson: action.selectedPrivatePerson }
    case 'SET_ERROR':
      return { ...state, errors: { ...state.errors, [action.key]: action.err } }
    case 'CLEAR_ERRORS': {
      let newErrors = { ...state.errors }

      if (Array.isArray(action.keys)) {
        action.keys?.map?.((key) => delete newErrors[key])
      } else if (action.keys) {
        delete newErrors[action.keys]
      } else {
        newErrors = {}
      }

      return { ...state, errors: newErrors }
    }
    case 'SET_STAGE_2_RESULT':
      return { ...state, stage2Result: action.result }
    case 'RESET_ABORT_CONTROLLER':
      return { ...state, abortController: action.newAbortController || new AbortController() }
    case 'SET_RELATIONSHIP_INFO':
      return { ...state, relationshipInfo: { ...state.relationshipInfo, ...action.newRelationshipInfo } }
    default:
      return { ...state }
  }
}

export default function AddFindFlowProvider({
  children,
  noGroupTabs,
  operationType,
  relatedParent1,
  relatedParent2,
  relatedChildOrSpouse,
  spouseToReplace,
  relationshipId,
  recordInfo,
  ...props
}) {
  const relationshipInfo = { relatedParent1, relatedParent2, relatedChildOrSpouse, spouseToReplace, relationshipId }
  const reasonDialogDataBaseKey = `${relationshipInfo.relatedParent1}_${relationshipInfo.relatedParent2}_${relationshipInfo.spouseToReplace}:${operationType}:add-reason:${relationshipInfo.relationshipId}`
  const { currentTreeId, isResearcherGroup } = useGroupsContext()
  // These headers are what is being used in many record-details package calls, so we're doing the same thing here.
  const headers = { Accept: 'application/x-gedcomx-v1+json', 'x-fs-feature-tag': 'records.use.sls' }
  const url = recordInfo?.recordURL && `${recordInfo?.recordURL}?useSLS=true`

  const [{ data }] = useZionAxios({ url, headers })

  const [state, dispatch] = useReducer(reducer, {
    ...initialState,
    treeId: currentTreeId,
    noGroupTabs,
    reasonDialogDataBaseKey,
    relationshipInfo,
    isCreatingRelationship: Boolean(
      relatedParent1 || relatedParent2 || relatedChildOrSpouse || spouseToReplace || relationshipId
    ),
    operationType,
    mode: FIND_BY_NAME,
    isResearcherGroup,
    isCopying: false,
    recordInfo,
    ...props,
  })
  const tabCacheKey = currentTreeId && !noGroupTabs ? 'tabIndexTree' : 'tabIndex'
  const isMounted = useRef()

  useEffect(() => {
    isMounted.current = true
    return () => {
      isMounted.current = false
    }
  }, [])

  useEffect(() => {
    const checkAndFetchPerson = async (key) => {
      const id = state.relationshipInfo?.[key]?.id
      const shouldFetch = isValidPid(id) && !state.relationshipInfo[key].loading && !state.relationshipInfo[key].name

      if (!shouldFetch) return

      dispatch({ type: 'SET_RELATIONSHIP_INFO', newRelationshipInfo: { [key]: { id, loading: true } } })

      try {
        const [serverPromise] = await getPersonObj(id, 'summary')
        const person = await serverPromise
        isMounted.current && dispatch({ type: 'SET_RELATIONSHIP_INFO', newRelationshipInfo: { [key]: person } })
      } catch (err) {
        console.error(err)
      }
    }

    checkAndFetchPerson('relatedParent1')
    checkAndFetchPerson('relatedParent2')
    checkAndFetchPerson('relatedChildOrSpouse')
  }, [state.relationshipInfo])

  useEffect(() => {
    tabsCache
      .getItem(tabCacheKey)
      .then((index) => {
        if (index === null) return isMounted.current && dispatch({ type: 'SET_READY' })
        // if tabindex was cached when there were 3 tabs, just reset to search by name.
        if (!currentTreeId && noGroupTabs && index === 2) {
          index = 0
        }
        // If we are in simple mode we don't want to set any tabs at all
        return isMounted.current && !state?.simpleMode && dispatch({ type: 'SET_TAB', index, isReady: true })
      })
      .catch(() => {
        isMounted.current && dispatch({ type: 'SET_READY' })
      })
  }, [currentTreeId, noGroupTabs, tabCacheKey, state?.simpleMode])

  const setLoading = useCallback((isLoading) => {
    dispatch({ type: 'SET_LOADING', loading: isLoading })
  }, [])

  const setSelectedPrivatePerson = useCallback((privatePerson) => {
    dispatch({ type: 'SET_SELECTED_PRIVATE_PERSON', selectedPrivatePerson: privatePerson })
  }, [])

  const setSearchResults = useCallback((searchResults) => {
    dispatch({ type: 'SET_RESULTS', searchResults })
  }, [])

  const handleTabChange = useCallback(
    (index) => {
      tabsCache.setItem(tabCacheKey, index)
      dispatch({ type: 'SET_TAB', index })
    },
    [tabCacheKey]
  )

  const setFormValues = useCallback((values) => {
    dispatch({ type: 'SET_FORM_VALUES', values })
  }, [])

  const setStage2Result = useCallback((result) => {
    dispatch({ type: 'SET_STAGE_2_RESULT', result })
  }, [])
  const setError = useCallback((key, err) => {
    dispatch({ type: 'SET_ERROR', key, err })
  }, [])
  const clearErrors = useCallback((keys) => {
    dispatch({ type: 'CLEAR_ERRORS', keys })
  }, [])
  const resetAbortController = useCallback((newAbortController) => {
    dispatch({ type: 'RESET_ABORT_CONTROLLER', newAbortController })
  }, [])
  const setIsCopying = useCallback((isCopying) => {
    dispatch({ type: 'SET_IS_COPYING', isCopying })
  }, [])

  const value = useMemo(
    () => ({
      setLoading,
      ...state,
      setSelectedPrivatePerson,
      setStage2Result,
      setFormValues,
      setSearchResults,
      handleTabChange,
      setError,
      clearErrors,
      resetAbortController,
      setIsCopying,
      recordData: data,
    }),
    [
      clearErrors,
      handleTabChange,
      resetAbortController,
      setError,
      setFormValues,
      setIsCopying,
      setLoading,
      setSearchResults,
      setSelectedPrivatePerson,
      setStage2Result,
      state,
      data,
    ]
  )

  return <AddFindFlowContext.Provider value={value}>{children}</AddFindFlowContext.Provider>
}
