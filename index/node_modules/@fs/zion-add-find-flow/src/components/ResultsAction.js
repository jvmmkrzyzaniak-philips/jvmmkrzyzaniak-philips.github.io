import React, { useCallback, forwardRef } from 'react'
import { css } from '@linaria/core'
import { colors, Button, useOverlay, useStatusOverlay } from '@fs/zion-ui'
import { useTranslation } from 'react-i18next'
import { trackEvent } from '@fs/zion-analytics'
import { useHistory } from '@fs/zion-router'
import { useEvent } from '@fs/zion-frontend-friends'
import axios from '@fs/zion-axios'
import { isChildRelated, isSpouseRelated } from '../services/relationships'
import { coupleOperationTypes, setFormError, FIND_BY_ID } from '../services/AddFindFlowService'
import { useAddFindFlowContext } from '../hooks/AddFindFlowContext'
import {
  copyPersonFromUserPrivateSpace,
  createNewPerson,
  createRelationship,
  valuesToPersonObj,
  stage2ResultToPersonObj,
} from '../services/creationService'
import ReplaceReasonDialog from './ReasonDialog/ReasonDialog'
import { ADD_FIND_FLOW_LOADING } from '../AddFindFlow'

const warningTextStyle = css`
  color: ${colors.danger60};
  white-space: normal;
`

function getPersonPid(relationship) {
  if (relationship.id) {
    return relationship.id
  }
  if (relationship.children && relationship.children[0] && relationship.children[0].id) {
    return relationship.children[0].id
  }
  return null
}

function getParentPids({ parents }) {
  const pids = []
  if (parents) {
    if (parents.parent1Id) {
      pids.push(parents.parent1Id)
    }
    if (parents.parent2Id) {
      pids.push(parents.parent2Id)
    }
  }
  return pids
}

function getRelationshipPids(relationship) {
  if (!relationship) {
    return []
  }
  const pid = getPersonPid(relationship)
  const pids = pid ? [pid] : []
  return pids.concat(getParentPids(relationship))
}

const ADD_RELATIONSHIP_TYPE_EVENTS = {
  addChild: 'child',
  addSpouse1: 'spouse',
  addSpouse2: 'spouse',
  addSibling: 'sibling',
  addParents: 'parent',
}
// analytics for creating a person
function fireCreatePersonMetrics(operationType, isLiving, pids) {
  const relationship = ADD_RELATIONSHIP_TYPE_EVENTS[operationType]
  return trackEvent({
    event_name: isLiving ? 'living_person_added' : 'deceased_person_added',
    link_name: `add person: ${isLiving ? 'living' : 'deceased'}${relationship ? `: ${relationship}` : ''}`,
    pid_ids: pids,
  })
}

// do all the logic to create the relationship for the person, including analytics and error handling
export function useCreateRelationship(actionContext, handleSuccessAndError = true) {
  const [t] = useTranslation()
  const {
    setError,
    clearErrors,
    treeId,
    operationType,
    relationshipInfo,
    isCreatingRelationship,
    setLoading = () => {},
    close = () => {},
    mode,
    onSuccess = () => {},
    abortController,
  } = useAddFindFlowContext()
  const history = useHistory()

  const showStatusOverlay = useStatusOverlay()
  const handleSuccess = useEvent((e) => {
    if (!handleSuccessAndError) return
    // The timeout here is so screen readers have time before the aria-live starts
    setTimeout(() => {
      showStatusOverlay({
        message: isCreatingRelationship
          ? t('add-find-flow.alert.relationship-created')
          : t('add-find-flow.alert.person-created'),
        type: 'success',
      })
    }, 500)
    onSuccess?.(e)
  })
  return useEvent((person, reason, personCreatedInFlow) => {
    if (actionContext === 'createRelationship') {
      trackEvent({
        link_name: `Match Found${mode === FIND_BY_ID ? ' by ID' : ''}: Add ${person?.spouse ? 'Couple' : 'Person'}`,
      })
    }

    history.push(ADD_FIND_FLOW_LOADING)

    // TODO: Are we tracking addUnconnected/addUnconnectedCustom/addFirstAncestor events?
    setLoading(true)
    return createRelationship({
      personGettingAdded: person,
      treeId,
      operationType,
      relationshipInfo,
      onSuccess: handleSuccess,
      reason,
      abortController,
      personCreatedInFlow,
    })
      .then((personAndRelationship) => {
        if (actionContext === 'createPerson') {
          fireCreatePersonMetrics(
            operationType,
            person.isLiving,
            getRelationshipPids(personAndRelationship.relationship)
          )
        }
        // handle replace maybe? maybe createRelationship will handle it
        close(undefined, true) // we must pass true in here so we know the dialog isn't being 'dismissed' when it closes
        if (operationType === 'addUnconnected') {
          // This will cause a refresh even if we are on person route. We may need to address this later again after r9 person page is more developed.
          window.location = `/tree/person/${personAndRelationship.person.id}`
        }
        return personAndRelationship
      })
      .catch((err) => {
        setFormError({ err, setError, clearErrors, actionContext })
        if (personCreatedInFlow && person.id) {
          // Delete just created person because the full action was not able to be completed.
          axios.delete(`/service/tree/tree-data/v8/person/${person.id}`)
        }
        setLoading(false)
        return err
      })
  })
}

// do all the logic to create the relationship for the person, including analytics and error handling
export function useCopy() {
  const [t] = useTranslation()
  const {
    setError,
    clearErrors,
    treeId,
    isCreatingRelationship,
    operationType,
    relationshipInfo,
    setLoading = () => {},
    close = () => {},
    onSuccess = () => {},
  } = useAddFindFlowContext()
  const history = useHistory()
  const createRelationshipHandler = useCreateRelationship('createRelationship', false)
  const showStatusOverlay = useStatusOverlay()

  /**
   * @type {({person: import('@fs/zion-tree-types').BasePerson, coupleId: string | undefined}) => void}
   */
  const handleSuccess = useEvent((data) => {
    // The timeout here is so screen readers have time before the aria-live starts
    setTimeout(() => {
      showStatusOverlay({
        message: isCreatingRelationship
          ? t('add-find-flow.alert.relationship-created')
          : t('add-find-flow.alert.person-created'),
        type: 'success',
        transient: true,
      })
    }, 500)
    close()
    onSuccess?.(data)
  })

  return useEvent((person, reason) => {
    history.replace(ADD_FIND_FLOW_LOADING)
    const pids = [person.id]
    if (person?.spouse) {
      pids.push(person?.spouse.id)
    }
    // TODO: Are we tracking addUnconnected/addUnconnectedCustom/addFirstAncestor events?
    setLoading(true)
    const doCopy = async () => {
      let personCopyResults
      let person1Id
      let person2Id
      let childId
      if (operationType.includes('Parent')) {
        childId = relationshipInfo?.relatedChildOrSpouse?.id
        person1Id = pids[0]
        person2Id = pids[1]
      } else if (operationType.includes('Spouse')) {
        person1Id = relationshipInfo?.relatedChildOrSpouse?.id
        person2Id = pids[0]
      } else if (operationType.includes('Child')) {
        person1Id = relationshipInfo?.relatedParent1?.id
        person2Id = relationshipInfo?.relatedParent2?.id
        childId = pids[0]
      }

      try {
        const { data } = await copyPersonFromUserPrivateSpace({ treeId, pids, childId, person1Id, person2Id })
        personCopyResults = data?.personCopyResults || {}
        person.id = personCopyResults[person?.id]?.copyPersonId
        if (person?.spouse) {
          // We conditionally set it back to person.spouse.id in case the spouse is deceased (not copied)
          person.spouse.id = personCopyResults[person?.spouse?.id]?.copyPersonId || person?.spouse?.id
        }
      } catch (err) {
        if (err.message === 'TOMBSTONED') {
          return setFormError({ err: { message: 'COPY_PERSON_TOMBSTONED' }, setError, clearErrors })
        }
        // Includes "FAILED" and "NOT_IN_PRIVATE_SPACE"
        // Route user to general error page
        return setFormError({ err: { message: 'COPY_PERSON_FAIL' }, setError, clearErrors })
      }

      let coupleId
      if (operationType.includes('Spouse')) {
        coupleId = await isSpouseRelated({ personId: relationshipInfo?.relatedChildOrSpouse?.id, spouseId: person?.id })
        if (!coupleId) {
          const res = await createRelationshipHandler(person, reason)
          coupleId = `${res?.relationship?.parents?.parent1Id}~${res?.relationship?.parents?.parent2Id}`
        }
      }
      if (operationType.includes('Child')) {
        const parentIds = [relationshipInfo?.relatedParent1?.id, relationshipInfo?.relatedParent2?.id].filter(Boolean)
        if (!(await isChildRelated({ childId: person?.id, parentIds }))) {
          await createRelationshipHandler(person, reason)
        }
      }
      if (operationType.includes('Parent')) {
        const parentIds = [person?.id, person?.spouse?.id].filter(Boolean)
        if (!(await isChildRelated({ childId: relationshipInfo?.relatedChildOrSpouse?.id, parentIds }))) {
          await createRelationshipHandler(person, reason)
        }
      }

      return handleSuccess({ person, coupleId })
    }
    return doCopy()
  })
}

// button that will create a new person and then add to the relationship if relationship exists
const CreateNewButton = forwardRef((props, ref) => {
  const [t] = useTranslation()
  const {
    values,
    setError,
    clearErrors,
    searchResults,
    setLoading,
    operationType,
    reasonDialogStoreName,
    reasonDialogDataBaseKey,
    treeId,
    loading,
    recordInfo,
    recordData,
  } = useAddFindFlowContext()
  const replaceReasonOverlay = useOverlay()
  const readTf =
    operationType === 'addUnconnectedCustom' ||
    operationType === 'addFirstAncestor' ||
    operationType === 'addAssociation'
  const createRelationshipHandler = useCreateRelationship('createPerson')
  const createPerson = useEvent(async (reason) => {
    if (searchResults?.length > 0) {
      trackEvent({
        link_name: 'Match Found: Ignore Match and Add New',
      })
    }

    setLoading(true)
    const personObj = valuesToPersonObj(values)
    const createdPersonObj = await createNewPerson(personObj, readTf, treeId, recordInfo, recordData)
    await createRelationshipHandler(createdPersonObj, reason, true)
  })

  const onErrorCallback = (err) => {
    setFormError({ err, setError, clearErrors, actionContext: 'createPerson' })
    setLoading(false)
  }

  const createPersonWithErrorHandling = async () => {
    try {
      createPerson()
    } catch (err) {
      onErrorCallback(err)
    }
  }

  const onClickFunc = operationType.includes('replace')
    ? replaceReasonOverlay.handleClick
    : createPersonWithErrorHandling

  return (
    <>
      <Button
        disabled={loading}
        onClick={onClickFunc}
        ref={ref}
        data-testid="create-new-button"
        emphasis={searchResults?.length > 0 ? 'medium' : 'high'}
      >
        {t('add-find-flow.find-results.button.create-new')}
      </Button>
      <ReplaceReasonDialog
        submitFunction={createPerson}
        onErrorCallback={onErrorCallback}
        databaseKey={reasonDialogDataBaseKey}
        storeName={reasonDialogStoreName}
        overlay={replaceReasonOverlay}
        submitButtonText={t('add-find-flow.button.replace')}
        suggestedReasonsProps={{ type: 'removeReplaceChild' }}
      />
    </>
  )
})

const doesSelectedMatchOmitField = (input, result) => {
  const birthDate = (input?.birthDate?.originalText || input?.birthDate?.standard) && !result?.birthDate
  const birthPlace = (input?.birthPlace?.originalText || input?.birthPlace?.standard) && !result?.birthPlace
  const deathDate = (input?.deathDate?.originalText || input?.deathDate?.standard) && !result?.deathDate
  const deathPlace = (input?.deathPlace?.originalText || input?.deathPlace?.standard) && !result?.deathPlace
  return birthDate || birthPlace || deathDate || deathPlace
}

const addSelectedMatchEvent = ({ values, searchResult }) => {
  const selectedMatchOmitsField = doesSelectedMatchOmitField(values, searchResult?.person)
  if (selectedMatchOmitsField) trackEvent({ event_name: 'Omitted field in selected match' })
}

// stage 1 add couple button which deceptively doesn't add and instead sends you to stage 2
export const AddCoupleMatchButton = forwardRef(({ nextRoutePath, searchResult }, ref) => {
  const [t] = useTranslation()
  const { setStage2Result, mode, values, isCopying } = useAddFindFlowContext()
  const ariaText = useAriaButtonTextForAdd(searchResult)
  const history = useHistory()

  const moveToStage2 = useCallback(() => {
    setStage2Result(searchResult)
    history.push(nextRoutePath)
    addSelectedMatchEvent({ values, searchResult })
  }, [searchResult, setStage2Result, history, values, nextRoutePath])

  const onClickFuncWithEvent = () => {
    addSelectedMatchEvent({ values, searchResult })
    moveToStage2()
  }
  const label = isCopying
    ? t('add-find-flow.button.copy-to-pedigree')
    : t('add-find-flow.find-results.button.add-match')
  return (
    <Button
      ref={ref}
      title={ariaText}
      aria-label={ariaText}
      linkName={isCopying ? 'AddFindFlow: Copy to Pedigree' : undefined}
      onClick={onClickFuncWithEvent}
      data-testid="add-couple-match-button"
      emphasis={mode === FIND_BY_ID ? 'high' : 'medium'}
    >
      {label}
    </Button>
  )
})

// stage 1 add person button
export const AddPersonMatchButton = forwardRef(({ searchResult }, ref) => {
  const [t] = useTranslation()
  const { values, mode, operationType, reasonDialogStoreName, reasonDialogDataBaseKey, loading, isCopying } =
    useAddFindFlowContext()
  const replaceReasonOverlay = useOverlay()
  const ariaText = useAriaButtonTextForAdd(searchResult)
  const createRelationshipHandler = useCreateRelationship('createRelationship')
  const copyPerson = useCopy()

  const addPersonMatch = useEvent((reason) => {
    if (isCopying) {
      copyPerson(searchResult?.person, reason)
    } else {
      createRelationshipHandler(searchResult?.person, reason)
    }
  })
  const onClickFunc = operationType.includes('replace') ? replaceReasonOverlay.handleClick : addPersonMatch
  const onClickFuncWithEvent = () => {
    addSelectedMatchEvent({ values, searchResult })
    onClickFunc()
  }

  const label = isCopying
    ? t('add-find-flow.button.copy-to-pedigree')
    : t('add-find-flow.find-results.button.add-match')
  return (
    <>
      <Button
        disabled={loading}
        ref={ref}
        title={ariaText}
        aria-label={ariaText}
        linkName={isCopying ? 'AddFindFlow: Copy to Pedigree' : undefined}
        onClick={onClickFuncWithEvent}
        data-testid="add-person-match-button"
        emphasis={mode === FIND_BY_ID ? 'high' : 'medium'}
      >
        {label}
      </Button>
      <ReplaceReasonDialog
        submitFunction={addPersonMatch}
        onErrorCallback={console.error}
        databaseKey={reasonDialogDataBaseKey}
        storeName={reasonDialogStoreName}
        overlay={replaceReasonOverlay}
        submitButtonText={t('add-find-flow.button.replace')}
        suggestedReasonsProps={{ type: 'removeReplaceChild' }}
      />
    </>
  )
})

// stage 2 add couple button
export const SelectCoupleButton = forwardRef(({ stage2Result }, ref) => {
  const [t] = useTranslation()
  const createRelationshipHandler = useCreateRelationship('createRelationship')
  const copyPerson = useCopy()
  const { operationType, reasonDialogStoreName, reasonDialogDataBaseKey, loading, isCopying } = useAddFindFlowContext()
  const replaceReasonOverlay = useOverlay()
  const personToAdd = stage2ResultToPersonObj(stage2Result)
  const ariaText = useAriaButtonTextForAdd({ person: personToAdd })
  const addCoupleMatch = useEvent((reason) => {
    if (isCopying) {
      copyPerson(personToAdd, reason)
    } else {
      createRelationshipHandler(personToAdd, reason)
    }
  })

  const onClickFunc = operationType.includes('replace') ? replaceReasonOverlay.handleClick : addCoupleMatch
  const label = isCopying ? t('add-find-flow.button.copy-couple') : t('add-find-flow.find-results.button.select-couple')
  return (
    <>
      <Button
        disabled={loading}
        ref={ref}
        onClick={onClickFunc}
        data-testid="stage-2-add-couple-match-button"
        title={ariaText}
        aria-label={ariaText}
      >
        {label}
      </Button>
      <ReplaceReasonDialog
        submitFunction={addCoupleMatch}
        onErrorCallback={console.error}
        databaseKey={reasonDialogDataBaseKey}
        storeName={reasonDialogStoreName}
        overlay={replaceReasonOverlay}
        submitButtonText={t('add-find-flow.button.replace')}
        suggestedReasonsProps={{ type: 'removeReplaceChild' }}
      />
    </>
  )
})

// stage 2 add person button
export const SelectPersonButton = forwardRef(({ stage2Result }, ref) => {
  const [t] = useTranslation()
  const createRelationshipHandler = useCreateRelationship('createRelationship')
  const copyPerson = useCopy()
  const { operationType, reasonDialogStoreName, reasonDialogDataBaseKey, loading, isCopying } = useAddFindFlowContext()
  const replaceReasonOverlay = useOverlay()
  const ariaText = useAriaButtonTextForAdd(stage2Result)
  const addPersonMatch = useEvent((reason) => {
    if (isCopying) {
      copyPerson(stage2Result?.person, reason)
    } else {
      createRelationshipHandler(stage2Result?.person, reason)
    }
  })
  const onClickFunc = operationType.includes('replace') ? replaceReasonOverlay.handleClick : addPersonMatch

  const label = isCopying ? t('add-find-flow.button.copy-person') : t('add-find-flow.find-results.button.select-person')

  return (
    <>
      <Button
        disabled={loading}
        ref={ref}
        onClick={onClickFunc}
        title={ariaText}
        aria-label={ariaText}
        data-testid="stage-2-add-person-match-button"
      >
        {label}
      </Button>
      <ReplaceReasonDialog
        submitFunction={addPersonMatch}
        onErrorCallback={console.error}
        databaseKey={reasonDialogDataBaseKey}
        storeName={reasonDialogStoreName}
        overlay={replaceReasonOverlay}
        submitButtonText={t('add-find-flow.button.replace')}
        suggestedReasonsProps={{ type: 'removeReplaceChild' }}
      />
    </>
  )
})

// TODO: figure out how to get rid of this. We already have an AddUnconnectedCustomButton defined in AddFindFlowButton.js
// stage 1 button for add first ancestor result because we just want to send people to the result
export const AddUnconnectedCustomButton = forwardRef(({ searchResult }, ref) => {
  const [t] = useTranslation()
  const { mode, operationType, reasonDialogStoreName, values, reasonDialogDataBaseKey } = useAddFindFlowContext()
  const replaceReasonOverlay = useOverlay()
  const ariaText = useAriaButtonTextForAdd(searchResult)

  const createRelationshipHandler = useCreateRelationship('addUnconnectedCustom') // This overloads the createRelationshipHandler name, because adding an first ancestor does not do anything with relationships
  const addMatch = useCallback(
    (reason) => {
      return createRelationshipHandler(searchResult?.person, reason)
    },
    [createRelationshipHandler, searchResult]
  )
  const onClickFunc = operationType.includes('replace') ? replaceReasonOverlay.handleClick : addMatch
  const onClickFuncWithEvent = () => {
    addSelectedMatchEvent({ values, searchResult })
    onClickFunc()
  }
  return (
    <>
      <Button
        ref={ref}
        title={ariaText}
        aria-label={ariaText}
        onClick={onClickFuncWithEvent}
        data-testid="view-person-button"
        emphasis={mode === FIND_BY_ID ? 'high' : 'medium'}
      >
        {t('add-find-flow.find-results.button.add-match')}
      </Button>
      <ReplaceReasonDialog
        submitFunction={addMatch}
        onErrorCallback={console.error}
        databaseKey={reasonDialogDataBaseKey}
        storeName={reasonDialogStoreName}
        overlay={replaceReasonOverlay}
        submitButtonText={t('add-find-flow.button.replace')}
        suggestedReasonsProps={{ type: 'removeReplaceChild' }}
      />
    </>
  )
})

// stage 1 button for add unconnected result because we just want to send people to the result
export const ViewPersonButton = forwardRef(({ searchResult }, ref) => {
  const [t] = useTranslation()
  return (
    <Button
      ref={ref}
      to={`/tree/person/${searchResult.person.id}`}
      data-testid="view-person-button"
      title={t('add-find-flow.find-results.button.aria-label.view-person', { person: searchResult.person.name })}
      aria-label={t('add-find-flow.find-results.button.aria-label.view-person', { person: searchResult.person.name })}
      external
    >
      {t('add-find-flow.find-results.button.view-person')}
    </Button>
  )
})

export const WarningWrapper = forwardRef(({ children }, ref) => {
  return (
    <p ref={ref} className={warningTextStyle}>
      {children}
    </p>
  )
})

// text to display in place of a button if already related
const AlreadyRelatedWarning = forwardRef((props, ref) => {
  const [t] = useTranslation()
  return <WarningWrapper ref={ref}>{t('add-find-flow.error.already-related')}</WarningWrapper>
})

// text to display in place of a button if the search result has an unknown gender and result would be added into a couple relationship somehow
const UnknownSexWarning = forwardRef((props, ref) => {
  const [t] = useTranslation()
  return <WarningWrapper ref={ref}>{t('add-find-flow.find-results.warning.unknown-sex')}</WarningWrapper>
})

/**
 * @typedef operationType
 * @type {('addChild'|'addSpouse'|'addSpouse1'|'addSpouse2'|'replaceSpouse1'|'replaceSpouse2'|'addParents'|'addParent1'|'addParent2'|'replaceParents'|'replaceParent1'|'replaceParent2'|'addUnconnectedCustom'|'addUnconnected'|'addFirstAncestor')}
 */

/**
 * Get the proper component to render for the search result button.
 * @param {object} props
 * @param {object} props.searchResult - the search result we want to get the button for.
 * @param {operationType} props.operationType - the operation type of the add flow.
 * @param {boolean} props.userEntered - if this is the user entered result.
 * @param {boolean} props.isCopying
 * @returns {JSX.Element} - component function (that is unrendered)
 */
export function getResultAction({ searchResult, operationType, userEntered, relationshipInfo, isCopying }) {
  const { relatedParent1, relatedParent2 } = relationshipInfo || {}
  if (userEntered) {
    return CreateNewButton
  }
  if (searchResult.alreadyRelated) {
    return AlreadyRelatedWarning
  }
  if (
    /^replaceAssociatePerson\d$/.test(operationType) ||
    (/^addUnconnectedCustom$|^addFirstAncestor$/.test(operationType) && !isCopying)
  ) {
    return AddUnconnectedCustomButton
  }
  if (operationType === 'addUnconnected' && !isCopying) {
    return ViewPersonButton
  }
  // persons in a couple relationship must have a gender that is male or female, so we must check that state
  if (searchResult?.person?.gender === 'UNKNOWN' && coupleOperationTypes.includes(operationType)) {
    return UnknownSexWarning
  }
  const isExistingRelationship = relatedParent1?.id || relatedParent2?.id
  if (
    !['addParents', 'replaceParents'].includes(operationType) ||
    (operationType === 'addParents' && isExistingRelationship) ||
    !searchResult.stage2Results ||
    (operationType === 'addUnconnected' && isCopying) ||
    (/^addUnconnectedCustom$|^addFirstAncestor$/.test(operationType) && isCopying)
  ) {
    return AddPersonMatchButton
  }
  return AddCoupleMatchButton
}

/**
 * Get the proper component to render for the stage 2 search result button.
 * @param {object} result - the search result we want to get the button for.
 * @returns {Function} - component function (that is unrendered)
 */
export function getStage2ResultAction(result) {
  if (result.alreadyRelated) {
    return AlreadyRelatedWarning
  }
  if (result.type === 'COUPLE') {
    return SelectCoupleButton
  }
  return SelectPersonButton
}

// hook to get the aria text for the add couple, add person, select couple and select person buttons
function useAriaButtonTextForAdd(searchResult = {}) {
  const [t] = useTranslation()
  const { operationType, relationshipInfo = {}, getAriaAddPersonText } = useAddFindFlowContext()
  const { relatedParent1 = {}, relatedParent2 = {}, relatedChildOrSpouse = {} } = relationshipInfo
  const { person: resultPerson = {} } = searchResult
  switch (operationType) {
    case 'addChild':
      return relatedParent1.name && relatedParent2.name
        ? t('add-find-flow.find-results.button.aria-label.add-person-as-child-of-couple', {
            person: resultPerson.name,
            person1: relatedParent1.name,
            person2: relatedParent2.name,
          })
        : t('add-find-flow.find-results.button.aria-label.add-person-as-child-of-person', {
            person: resultPerson.name,
            person1: relatedParent1.name || relatedParent2.name,
          })
    case 'replaceParent1':
    case 'replaceParent2':
    case 'replaceParents':
    case 'addParent1':
    case 'addParent2':
    case 'addParents':
      return resultPerson?.spouse
        ? t('add-find-flow.find-results.button.aria-label.add-couple-as-parents-of-person', {
            person1: resultPerson.name,
            person2: resultPerson?.spouse.name,
            person: relatedChildOrSpouse.name,
          })
        : t('add-find-flow.find-results.button.aria-label.add-person-as-parent-of-person', {
            person: resultPerson.name,
            person1: relatedChildOrSpouse.name,
          })
    case 'replaceSpouse1':
    case 'replaceSpouse2':
    case 'addSpouse':
    case 'addSpouse1':
    case 'addSpouse2':
      return t('add-find-flow.find-results.button.aria-label.add-person-as-spouse-of-person', {
        person: resultPerson.name,
        person1: relatedChildOrSpouse.name,
      })
    case 'replaceAssociatePerson1':
    case 'replaceAssociatePerson2':
    case 'addFirstAncestor':
    case 'addUnconnectedCustom':
      return getAriaAddPersonText?.({
        personName: resultPerson.name,
      })
    default:
      return null
  }
}
