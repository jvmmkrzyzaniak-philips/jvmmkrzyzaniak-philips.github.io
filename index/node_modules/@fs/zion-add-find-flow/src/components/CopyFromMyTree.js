import React, { useCallback, useEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { Paragraph, Ghost, List, ListItem, Skeleton, Separator, H3 } from '@fs/zion-ui'
import { useHistory } from '@fs/zion-router'
import { PersonListItem } from '@fs/zion-person'
import { ArrowCaret } from '@fs/zion-icon'
import { PrivatePersonsSearch, usePrivatePersons } from '@fs/zion-tree-groups'
import { getPersonObj } from '@fs/zion-person-service'
import { useAddFindFlowContext } from '../hooks/AddFindFlowContext'
import { createStage2 } from '../services/creationService'
import { FIND_FLOW } from '../services/AddFindFlowService'

const fieldId = 'copy-from-my-tree'

/**
 * JSX add/find flow copy-from-my-tree form content and validation.
 * @param {object} props - The props passed into the element.
 * @param {string} props.nextRoutePath
 * @returns {HTMLElement} - JSX.
 */
export default function CopyFromMyTree({ nextRoutePath }) {
  const [t] = useTranslation()
  const history = useHistory()
  const { loading, privatePersons, filterText } = usePrivatePersons()
  const { setSearchResults, setLoading, setError, setIsCopying } = useAddFindFlowContext()
  // currentLength is used to keep the height of the overlay the same until the new results come back when filtering
  const [currentLength, setCurrentLength] = useState()
  const listIsEmpty = !loading && !privatePersons.length

  useEffect(() => {
    setCurrentLength(privatePersons.length)
  }, [privatePersons.length])

  const handleSelectPrivatePerson = useCallback(
    ({ id }) => {
      setIsCopying(true)
      history.push(nextRoutePath)
      setLoading(true)
      getPersonObj(id, 'full')
        .then(([serverPromise]) => serverPromise)
        .then((person) => {
          const results = createStage2(person)
          setSearchResults(results)
          setLoading(false)
        })
        .catch((err) => {
          if (err?.response?.status >= 400 && err?.response?.status < 500) {
            setError(FIND_FLOW, {
              messageKey: 'add-find-flow.error.id-not-found',
            })
          } else {
            setError(FIND_FLOW, {
              messageKey: 'add-find-flow.error.general',
            })
          }

          setLoading(false)
        })
    },
    [history, nextRoutePath, setError, setLoading, setSearchResults, setIsCopying]
  )

  return (
    <section data-testid={fieldId}>
      <H3 size="H5">{t('add-find-flow.header.private-people-from-my-tree')}</H3>
      <Separator size="nano" />
      {(!listIsEmpty || filterText) && <PrivatePersonsSearch />}
      {/* If list is empty after loading, display empty list message */}
      {listIsEmpty &&
        (filterText ? (
          <Paragraph data-testid="private-people-empty-list-message">
            {t('add-find-flow.no-match-found.title')}
          </Paragraph>
        ) : (
          <Paragraph data-testid="private-people-empty-list-message">
            {t('add-find-flow.empty-private-people-list')}
          </Paragraph>
        ))}
      {/* If list is not empty, Display list or skeleton while loading */}
      {!listIsEmpty && (
        <List data-testid="private-persons-list">
          {loading
            ? Array(currentLength || 5)
                .fill('')
                .map((_, index) => {
                  const key = index
                  return <Skeleton.ListItem key={key} dense hasAvatar hasEndIcon hasSecondLine />
                })
            : privatePersons.map((person) => (
                <Ghost key={person.id} heightEstimate={60}>
                  <PersonListItem
                    key={person.id}
                    doNotLinkToPersonPage
                    onClick={() => handleSelectPrivatePerson(person)}
                    personObj={person}
                    endElement={<ListItem.Icon Icon={ArrowCaret} direction="forward" />}
                  />
                </Ghost>
              ))}
        </List>
      )}
    </section>
  )
}
