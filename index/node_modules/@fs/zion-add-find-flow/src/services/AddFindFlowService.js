/**
 * AddFindFlowService
 * Manages data fetching and manipulation for the add/find flow.
 */

import axios from '@fs/zion-axios'
import { convertFormToTreeData } from '@fs/zion-name-template'
import { formatStandardSuggestToTreeData } from '@fs/zion-tree-converter'

export const COPY_FROM_MY_TREE = 'copy-from-my-tree'
export const FIND_FLOW = 'find-flow'
export const FIND_BY_NAME = 'find-by-name'
export const FIND_BY_ID = 'find-by-id'
export const FIND_RESULTS = 'find-results'
export const STAGE_2_RESULTS = 'stage-2-results'
export const SEARCH_DOWN_NON_BLOCKING_ERROR = 'search-down-non-blocking-error'
/**
 * @typedef operationType
 * @type {('addChild'|'addSpouse'|'addSpouse1'|'addSpouse2'|'replaceSpouse1'|'replaceSpouse2'|'addParents'|'addParent1'|'addParent2'|'replaceParents'|'replaceParent1'|'replaceParent2'|'addUnconnectedCustom'|'addUnconnected'|'addFirstAncestor'|'addAssociation'|'replaceAssociatePerson1'|'replaceAssociatePerson2')}
 */
export const operationTypes = [
  'addChild',
  'addSpouse',
  'addSpouse1',
  'addSpouse2',
  'replaceSpouse1',
  'replaceSpouse2',
  'addParents',
  'addParent1',
  'addParent2',
  'replaceParents',
  'replaceParent1',
  'replaceParent2',
  'addUnconnected',
  'addUnconnectedCustom',
  'addFirstAncestor',
  'addAssociation',
  'replaceAssociatePerson1',
  'replaceAssociatePerson2',
]

export const coupleOperationTypes = [
  'addSpouse',
  'addSpouse1',
  'addSpouse2',
  'replaceSpouse1',
  'replaceSpouse2',
  'addParents',
  'addParent1',
  'addParent2',
  'replaceParents',
  'replaceParent1',
  'replaceParent2',
]

/**
 * @typedef setFormErrorOptions
 * @type {object}
 * @property {Error} err - Extended axios error (see AddFindFlowService::parseStatus)
 * @property {Function} setFieldError - Provided from ZionForm
 * @property {Function} t - Provided from useTranslation
 * @property {('searchByName'|'searchById'|'createRelationship'|'createPerson')} actionContext - What the user was doing when the error occurred.
 */

/**
 * Bind an error to the entire form.
 * @param {setFormErrorOptions} options - The arguments necessary to bind an error to the form.
 * @returns {undefined} - sets form data directly via setFieldError.
 */
export function setFormError({ err, setError, clearErrors, actionContext }) {
  // If error comes from abortController, just return.
  if (err?.message === 'canceled') return undefined

  let messageKey
  const possibleErrorNames = [SEARCH_DOWN_NON_BLOCKING_ERROR, FIND_FLOW]
  let errorName = FIND_FLOW

  const errMessageKeys = {
    COPY_PERSON_ALREADY_COPIED: 'add-find-flow.error.person-already-copied',
    COPY_PERSON_TOMBSTONED: 'add-find-flow.error.person-is-tombstoned',
    COPY_PERSON_FAIL: 'add-find-flow.error.failed-to-copy-person',
    CREATING_RELATIONSHIP_WITH_SELF: 'add-find-flow.error.cannot-have-relationship-with-self',
    RESOURCE_LIMITS_EXCEEDED_CHILD_COUNT: 'add-find-flow.error.resource-limits-exceeded.child-count',
    CONFLICT: 'add-find-flow.error.already-related',
    NOT_AUTHORIZED: 'add-find-flow.error.read-only.not-authorized',
    TF_444: 'add-find-flow-error.TF_444',
    TF_435: 'add-find-flow.error.TF_435',
    TF_441: 'add-find-flow.error.TF_441',
    TF_705: 'add-find-flow.error.read-only.not-authorized',
    PARTIAL_CONTENT: 'add-find-flow.error.partial-success',
    'Failed to fetch': 'add-find-flow.error.general',
  }

  const readOnlyUrl = 'https://www.familysearch.org/help/helpcenter/article/what-are-read-only-records-in-family-tree'

  const errLinks = {
    NOT_AUTHORIZED: readOnlyUrl,
    TF_705: readOnlyUrl,
  }

  // `err.message` gets overwritten in creationService::parseStatus callback
  if (
    err.response?.status === 400 &&
    err.response?.headers?.warning === '309 tf "A relationship with the same persons already exist"'
  ) {
    messageKey = 'add-find-flow.error.same-other-relationship-exists'
  } else if (
    err.response?.status === 400 &&
    err.response?.headers?.warning === '406 tf "Operation would result in an invalid relationship state"'
  ) {
    messageKey = 'add-find-flow.error.invalid-other-relationship-state'
  } else if (
    err.response?.status === 400 &&
    err.response?.headers?.warning ===
      '441 tf "Living persons cannot be related to a person born before 1800 or died before 1850"'
  ) {
    messageKey = 'add-find-flow.living-too-old.error'
  } else if (err.response?.status === 401 && actionContext === 'searchByName') {
    messageKey = 'add-find-flow.error.general'
  } else if (err.response?.status === 412) {
    // Handle when find-by-id returns a "precondition failed" response because the ID is of the person the relationship is being added to.
    messageKey = 'add-find-flow.error.cannot-have-relationship-with-self'
  } else if (err.response?.status === 500 || err.response?.status === 502) {
    if (actionContext.startsWith('create')) {
      messageKey = 'add-find-flow.error.connection'
    } else if (actionContext === 'searchById') {
      messageKey = 'add-find-flow.error.general'
    } else {
      errorName = SEARCH_DOWN_NON_BLOCKING_ERROR
      messageKey = 'add-find-flow.error.unable-to-search.message'
    }
  } else {
    messageKey = errMessageKeys[err.message ?? 'Failed to fetch'] ?? errMessageKeys['Failed to fetch']
  }

  clearErrors(possibleErrorNames)
  setError(errorName, { messageKey, link: errLinks[err.message], shouldFocus: false })
  return errorName
}

/**
 * Function to get the context based off the operationType.
 * @param {operationType} operationType - The operationType the add flow will perform.
 * @returns {string} The context ('s', 'p', or undefined - in the case of addUnconnected, we don't need to pass a context).
 */
export function getContextType(operationType = '') {
  let context

  // child and spouse use the same query param
  if (operationType === 'addChild' || operationType.includes('Spouse')) {
    context = 's'
  }

  if (operationType.includes('Parent')) {
    context = 'p'
  }

  return context
}

/**
 * When adding a spouse to an individual with children those children may just need to be moved to an already existing couple. This is the shortcut for such actions.
 * addSpouse1, and addSpouse2 are mostly used in the family members section.
 * @param {operationType} operationType - the operation type
 * @returns {bool} - should ignore.
 */
export function getIgnoreAlreadyRelated(operationType) {
  return Boolean(operationType === 'addSpouse1' || operationType === 'addSpouse2')
}

/**
 * Collect the IDs of related people.
 * @param {object} contextInfo - contains relationship data and operation type
 * @param {operationType} contextInfo.operationType - What the action type is
 * @param {object} contextInfo.relatedParent1 - parent1 data
 * @param {object} contextInfo.relatedParent2 - parent2 data
 * @param {object} contextInfo.relatedChildOrSpouse - child or spouse data
 * @returns {object} - { relatedPersonId } || { relatedParent1Id, relatedParent2Id }
 */
export function getRelatedPeople({ operationType, relatedParent1, relatedParent2, relatedChildOrSpouse }) {
  // replacing any parents needs to have everything since we need the parents that are not being replace ids for the API call
  // finding needs the relatedPersonId
  if (operationType.includes('replaceParent')) {
    return {
      relatedParent1Id: relatedParent1?.id,
      relatedParent2Id: relatedParent2?.id,
      relatedPersonId: relatedChildOrSpouse?.id,
    }
  }
  // we should only pass parent1/parent2 OR person
  // the only time we will send parents is if we are adding a child.
  return operationType === 'addChild'
    ? {
        relatedParent1Id: relatedParent1?.id,
        relatedParent2Id: relatedParent2?.id,
      }
    : {
        relatedPersonId: relatedChildOrSpouse?.id,
      }
}

/**
 * Format form values to match what TreeData is expecting.
 * @param {object} values - form field values (specifically parent1, parent2, spouse)
 * @param {Array<object>} nameForms - these are the name forms from NameTemplate. we need the language and script from the first nameForm to use as the language of the people we are putting in our additional search options
 * @returns {object} - { spouseNameDetails, spouseGender, parent1NameDetails, parent1Gender, parent2NameDetails, parent2Gender }
 */
export function getAdditionalFindOptions({ parent1, parent2, spouse }, [{ lang, script } = {}] = []) {
  const format = (part, { givenName = '', surname = '', sex } = {}) =>
    givenName || surname
      ? {
          [`${part}NameDetails`]: {
            detailsType: 'NameDetails',
            nameForms: [
              {
                givenPart: givenName,
                familyPart: surname,
                prefixPart: '',
                suffixPart: '',
                script,
                lang,
              },
            ],
          },
          [`${part}Gender`]: {
            detailsType: 'GenderDetails',
            gender: sex.toUpperCase(),
          },
        }
      : {}

  return {
    ...format('parent1', parent1),
    ...format('parent2', parent2),
    ...format('spouse', spouse),
  }
}

/**
 * Format the POST data for a TreeData search.
 * @param {object} contextInfo - contains relationship data and operation type
 * @param {operationType} contextInfo.operationType - What the action type is
 * @param {boolean} contextInfo.isForFindByName - are we searching by name or by id
 * @param {object} contextInfo.existingRelationshipHasTwoParents - two parents already exist
 * @param {object} contextInfo.relatedParent1 - parent1 data
 * @param {object} contextInfo.relatedParent2 - parent2 data
 * @param {object} contextInfo.relatedChildOrSpouse - child or spouse data
 * @param {object} values - form field values
 * @returns {object} - the body of the POST call we want to make to TreeData
 */
export function createSearchObject(contextInfo, values) {
  let { operationType } = contextInfo
  const { isForFindByName, existingRelationshipHasTwoParents } = contextInfo

  const { sex, birthDate, birthPlace, burialDate, burialPlace, deathDate, deathPlace } = values

  const nameForms = convertFormToTreeData(values)

  // Re-map addUnconnectedCustom to addUnconnected when making the service call
  operationType = operationType === 'addUnconnectedCustom' ? 'addUnconnected' : operationType

  const commonSearchCriteria = {
    operationType,
    context: getContextType(operationType),
    existingRelationshipHasTwoParents: Boolean(existingRelationshipHasTwoParents),
    ignoreAlreadyRelated: getIgnoreAlreadyRelated(operationType),
    ...getRelatedPeople(contextInfo),
  }

  if (isForFindByName) {
    // add birthDetails, burialDetails (when available), deathDetails, genderDetails, nameDetails, spouseNameDetails, spouseGender, parent1NameDetails, parent1Gender, parent2NameDetails, parent2Gender
    const burialDetails = !!burialDate &&
      !!burialPlace && {
        burialDetails: {
          detailsType: 'EventDetails',
          type: 'BURIAL',
          date: formatStandardSuggestToTreeData(burialDate),
          place: formatStandardSuggestToTreeData(burialPlace),
        },
      }
    const birthDetails = (birthDate || birthPlace) && {
      detailsType: 'EventDetails',
      type: 'BIRTH',
      date: formatStandardSuggestToTreeData(birthDate),
      place: formatStandardSuggestToTreeData(birthPlace),
    }
    const deathDetails = (deathDate || deathPlace) && {
      detailsType: 'EventDetails',
      type: 'DEATH',
      date: formatStandardSuggestToTreeData(deathDate),
      place: formatStandardSuggestToTreeData(deathPlace),
    }

    return {
      ...commonSearchCriteria,

      birthDetails,
      deathDetails,
      genderDetails: {
        gender: sex.toUpperCase(),
        detailsType: 'GenderDetails',
      },
      nameDetails: {
        detailsType: 'NameDetails',
        nameForms,
      },
      ...burialDetails,
      ...getAdditionalFindOptions(values, nameForms),
    }
  }

  return commonSearchCriteria
}

/**
 * Find the person and their spouses, if any, of the person defined by the parameter 'personObj'.
 * The found people, if any, are returned through the promise defined in the return object.
 * @param {object} searchObj - The data that defines the person to search for.
 * @param {boolean} isLiving - if the subject of search is living or not
 * @returns {object} Search results - An object that includes the search results.
 */
export function findByNameCall({ searchObj, isLiving, abortController, cetTreeId }) {
  // we shouldn't search for living people
  if (isLiving) {
    return Promise.resolve([])
  }
  const cetQuery = cetTreeId ? `?collection=cet&treeId=${cetTreeId}` : ''

  return axios({
    url: `/service/tree/tree-data/v9/search/by-name-with-spouses${cetQuery}`,
    method: 'post',
    headers: {
      'FS-USER-AGENT-CHAIN': `fs-person-search-service.findByNameCall:${window.location.pathname}`,
    },
    signal: abortController.signal,
    data: searchObj,
  })
}
