import axios from '@fs/zion-axios'
import { i18n } from '@fs/zion-locale'
import { trackEvent } from '@fs/zion-analytics'
import { convertFormToTreeData } from '@fs/zion-name-template'
import { publish, events } from '@fs/zion-tree-pubsub'
// import { createAndAttachSource } from '@fs/zion-source-list'
import { formatStandardSuggestToTreeData } from '@fs/zion-tree-converter'
import updateOtherRelationship from './relationships'

/**
 * @typedef operationType
 * @type {('addChild'|'addSpouse'|'addSpouse1'|'addSpouse2'|'replaceSpouse1'|'replaceSpouse2'|'addParents'|'addParent1'|'addParent2'|'replaceParents'|'replaceParent1'|'replaceParent2'|'addUnconnected')}
 */
const evt = events.addPerson
const creationService = {}

/**
 * This function unwraps tree-data responses from the legacy tree-data api.
 * @param {object} res - axios response
 * @returns {object} - The unwrapped response or the original response if it didn't need to be unwrapped.
 */
export function parseStatus({ res, pid, personCreatedInFlow, recordInfo, recordData }) {
  const data = res.data
  // if response uses real status codes just return res.
  if (typeof data.status === 'undefined') {
    return res
  }
  // tree data puts the true response status in the body
  if (data.status !== 'OK') {
    const code = data.statuses?.[0]?.code
    if (code === 'TF_441' || code === 'TF_405') {
      // User tried to add a living person to someone who died 150+ years ago.
      // We really should just not create the person on the front end if we can detect this, (would save 3 calls) but currently we don't have death info in the addFindFlowContext.
      pid && personCreatedInFlow && axios.delete(`/service/tree/tree-data/v8/person/${pid}`)
    }
    throw new Error(code || data.status)
  }
  if (recordInfo && recordData) {
    // Find correct source description for the record
    // const arkURL = new URL(recordInfo?.recordURL)
    // const srcDesc = recordData?.sourceDescriptions.find((src) => {
    //   const srcURL = src?.about && new URL(src.about)
    //   return arkURL?.pathname === srcURL?.pathname
    // })
    // const title = srcDesc?.titles?.[0]?.value || recordInfo?.name
    // Attach the source to the person's name conclusion
    // In the future we will want to track and attach to other conclusions as well.
    try {
      // createAndAttachSource({
      //   entityType: 'person',
      //   entityId: res.data?.data?.id,
      //   source: { title, sourceType: 'FSREADONLY', uri: { uri: recordInfo.recordURL } },
      //   vitalTags: ['http://gedcomx.org/Name'],
      // })
      trackEvent({ event_name: 'add_find_with_record_attached' })
    } catch (e) {
      console.error('Failed to attach source to created person')
    }
  }

  return data.data
  // let the caller handle the error
}

/**
 * This function decides what function to call and what to call it with. It also has the side effect of publishing the event and calling the onSuccess callback.
 * @param {object} personGettingAdded - the new person being added to a relationship.
 * @param {operationType} operationType - what the add flow will do.
 * @param {object} relationshipInfo - relatedParent1, relatedParent2, relatedChildOrSpouse, spouseToReplace, and relationshipId.
 * @param {Function} onSuccess - Function to run on successful add/replace.
 * @param {string} reason - The reason for the replacing operations.
 * @returns {Promise} - the result of the call to create the relationship, which will resolve with an object with the new relationship and the person added.
 */
export function createRelationship({
  personGettingAdded,
  treeId,
  operationType,
  relationshipInfo,
  onSuccess = () => {},
  reason,
  abortController,
  personCreatedInFlow = false,
}) {
  if (typeof reason !== 'string') reason = ''
  // If person is unconnected do not create relationship
  // If search service is down, create relationship. Warning is displayed to check for duplicates.
  // We shouldn't get in the state that searching is down. but if we do, the user has a better experience.
  if (operationType === 'addUnconnected') {
    return Promise.resolve({ person: personGettingAdded })
  }

  const { relatedParent1 = {}, relatedParent2 = {}, relatedChildOrSpouse = {}, relationshipId = '' } = relationshipInfo

  if (/^replaceAssociatePerson\d$/.test(operationType)) {
    return updateOtherRelationship(
      /1/.test(operationType) ? '1' : '2',
      relationshipId,
      personGettingAdded.id,
      reason,
      abortController
    ).then(() => {
      onSuccess(personGettingAdded.id)
      return { person: personGettingAdded, operationType }
    })
  }

  let functionToCall = () => {}
  let pid = ''
  const relationship = {}

  switch (operationType) {
    case 'addChild':
      pid = personGettingAdded.id
      relationship.parent1Id = relatedParent1.id || undefined
      relationship.parent2Id = relatedParent2.id || undefined
      functionToCall = creationService.createChildRelationship
      break

    /**
     * TW-1099. The values 'replaceParents' & 'replaceParent' make it so we can search with the correct
     * context ('p') and that we are replacing a parent that may also be a spouse (to the other parent).
     */
    case 'replaceParent1':
      functionToCall = creationService.replaceParents
      relationship.parent1Id = personGettingAdded.id
      relationship.parent2Id = relationshipInfo.relatedParent2?.id
      relationship.relationshipId = relationshipId
      relationship.addingParent1 = true
      break
    case 'replaceParent2':
      functionToCall = creationService.replaceParents
      relationship.parent1Id = relationshipInfo.relatedParent1?.id
      relationship.parent2Id = personGettingAdded.id
      relationship.relationshipId = relationshipId
      break
    case 'addParent1':
    case 'addParent2':
      functionToCall = creationService.addParentToChild
      pid = relatedChildOrSpouse.id
      relationship.relationshipId = relationshipId
      relationship.spouseId = personGettingAdded.id
      relationship.type = operationType.includes('Parent1') ? 'parent1' : 'parent2'
      break
    case 'replaceParents':
      functionToCall = creationService.replaceParents
      if (!personGettingAdded.spouse?.id) {
        if (personGettingAdded.gender === 'MALE') {
          relationship.parent1Id = personGettingAdded.id
          relationship.parent2Id = undefined
        } else {
          relationship.parent1Id = undefined
          relationship.parent2Id = personGettingAdded.id
          relationship.addingParent1 = true
        }
      } else {
        relationship.parent1Id = personGettingAdded.id
        relationship.parent2Id = personGettingAdded.spouse.id
      }
      relationship.relationshipId = relationshipId
      break
    case 'addParents': {
      // This condition let's us use the addParent button to update existing child-parent relationships with an additional parent by calling the createSpouseRelationship endpoint
      const ids = [relatedParent1?.id, relatedParent2?.id].filter(Boolean)
      if (ids.length === 1) {
        pid = relatedParent1?.id ?? relatedParent2?.id
        functionToCall = creationService.addParentToChild
        relationship.type = relatedParent1?.id ? 'parent2' : 'parent1'
        relationship.relationshipId = relationshipId
        relationship.spouseId = personGettingAdded.id
        relationship.justification = reason
      } else {
        functionToCall = creationService.createParentRelationship
        pid = relatedChildOrSpouse.id
        if (!personGettingAdded.spouse) {
          // we are adding a single parent - but the parents relationship type indicates this the user didn't
          // specify which parent position they were adding to, so we want to assign them the traditional position
          // based on their gender
          relationship.parent1Id = personGettingAdded.gender === 'MALE' ? personGettingAdded.id : undefined
          relationship.parent2Id = personGettingAdded.gender === 'FEMALE' ? personGettingAdded.id : undefined
        } else {
          relationship.parent1Id =
            personGettingAdded.gender === 'FEMALE' ? personGettingAdded.spouse.id : personGettingAdded.id
          relationship.parent2Id =
            personGettingAdded.gender === 'FEMALE' ? personGettingAdded.id : personGettingAdded.spouse.id
        }
      }
      break
    }
    case 'replaceSpouse1':
      functionToCall = creationService.replaceSpouse
      pid = relatedChildOrSpouse.id
      relationship.spouseId = personGettingAdded.id
      relationship.spouseInPositionOne = true
      relationship.relationshipId = relationshipId
      break
    case 'addSpouse1':
      functionToCall = creationService.createSpouseRelationship
      pid = relatedChildOrSpouse.id
      relationship.spouseId = personGettingAdded.id
      relationship.spouseInPositionOne = true
      break
    case 'replaceSpouse2':
      functionToCall = creationService.replaceSpouse
      pid = relatedChildOrSpouse.id
      relationship.spouseId = personGettingAdded.id
      relationship.spouseInPositionOne = false
      relationship.relationshipId = relationshipId
      break
    case 'addSpouse2':
      functionToCall = creationService.createSpouseRelationship
      pid = relatedChildOrSpouse.id
      relationship.spouseId = personGettingAdded.id
      relationship.spouseInPositionOne = false
      break
    case 'addSpouse':
      functionToCall = creationService.createSpouseRelationship
      pid = relatedChildOrSpouse.id
      relationship.spouseId = personGettingAdded.id
      if (relatedChildOrSpouse.gender === personGettingAdded.gender) {
        relationship.spouseInPositionOne = false
      } else {
        relationship.spouseInPositionOne = personGettingAdded.gender === 'MALE'
      }
      // do not include any children that belong to this person as a single parent in this relationship
      relationship.excludeUnknownChildren = true
      break
    case 'addAssociation':
    case 'addUnconnectedCustom':
    case 'addFirstAncestor':
      // we do not actually create a relationship with an first ancestor - the view just changes.
      functionToCall = () => Promise.resolve()
      break
    default:
      break
  }

  if (
    operationType !== 'addUnconnectedCustom' &&
    operationType !== 'addFirstAncestor' &&
    operationType !== 'addAssociation' &&
    (Object.keys(relationship).length === 0 ||
      Object.keys(relationship).filter((key) => relationship[key]).length === 0)
  ) {
    console.error(
      `We managed to not add anything to the relationship:
      personGettingAdded = ${personGettingAdded},
      operationType = ${operationType},
      functionToCall = ${functionToCall},
      pid = ${pid},
      relatedParent1 = ${JSON.stringify(relatedParent1)},
      relatedParent2 = ${JSON.stringify(relatedParent2)},
      relatedChildOrSpouse ${JSON.stringify(relatedChildOrSpouse)}`
    )
  }

  if (pid && (relationship.spouseId === pid || relationship.parent1Id === pid || relationship.parent2Id === pid)) {
    return Promise.reject({ message: 'CREATING_RELATIONSHIP_WITH_SELF' }) // eslint-disable-line prefer-promise-reject-errors -- We deliberately chose to reject this way
  }

  if (operationType.includes('replace')) {
    relationship.relatedSpouseOrParentId = pid
    relationship.justification = reason
    return functionToCall(relationship).then(() => {
      publish({ evt, data: relationship })
      onSuccess(relationship)

      return { relationship, person: personGettingAdded, operationType }
    })
  }
  return functionToCall(pid, relationship, treeId, personCreatedInFlow).then((newRelationship) => {
    const relationshipAndPerson = { relationship: newRelationship, person: personGettingAdded, operationType }
    publish({ evt, data: relationshipAndPerson })
    onSuccess(relationshipAndPerson)

    return relationshipAndPerson
  })
}

/**
 * Create the relationships between the people defined in the 'relationship' object.
 * @param {string} relationshipType - Possible values: "child", "parent", or "spouse".
 * @param {string} pid - The pid of the person of focus (or just added, in the case of a new person).
 * @param {object} relationship - The object with the other pids for the relationship(s) to add.
 * @param {string} [relationship.parent1Id] - Pid of the first parent.
 * @param {string} [relationship.parent2Id] - Pid of the second parent.
 * @param {boolean} [relationship.spouseInPositionOne] - Whether the spouse is in position 1. (Could be the person just added, in the case of a new person).
 * @param {string} [relationship.spouseId] - ID of the spouse. (Could be the person just added, in the case of a new person).
 * @returns {Promise<object>} - A promise object that should resolve to the new relationship object that was added.
 */
function createRelationshipCall(relationshipType, pid, relationship, treeId, personCreatedInFlow) {
  const treeIdParam = treeId ? `?treeId=${treeId}&` : ''
  // relationshipType = child | parent | spouse
  const relationshipPath = relationshipType === 'spouse' ? '/relationships/spouses' : '/relationships/parents'

  const url = `/service/tree/tree-data/person/${pid}${relationshipPath}${treeIdParam}`

  const headers = { 'FS-USER-AGENT-CHAIN': `fs-add-person-service.createRelationship:${window.location.pathname}` }

  return axios({
    url,
    method: 'post',
    headers,
    data: relationship,
  }).then((data) => parseStatus({ res: data, pid, personCreatedInFlow }))
}

/**
 * Copy a private person from user's private space into a group.
 * @param {string} treeId - Id of the tree to copy private person into.
 * @param {array} pids - PIDs of the Private persons in the user's private space.
 * @param {string} person1Id - used for copying relationship correctly in tf
 * @param {string} person2Id - used for copying relationship correctly in tf
 * @param {string} childId - used for copying relationship correctly in tf
 * @returns {object} - And object with copied person's pid (`copyPersonId`)
 */
export function copyPersonFromUserPrivateSpace({ treeId, pids = [], person1Id, person2Id, childId }) {
  const idString = pids.map((pid) => `id=${pid}`).join('&')
  const url = `/service/tree/tree-data/user/CURRENT/tree/${treeId}/person/copy?copyType=ids&${idString}`

  const body = {}
  if (person1Id) {
    body.person1Id = person1Id
  }
  if (person2Id) {
    body.person2Id = person2Id
  }
  if (childId) {
    body.childId = childId
  }

  const headers = {
    'FS-USER-AGENT-CHAIN': `fs-add-person-service.copyPersonFromUserPrivateSpace:${window.location.pathname}`,
  }
  return axios({
    url,
    method: 'post',
    headers,
    timeout: 30000,
    data: JSON.stringify(body) === '{}' ? undefined : body,
  })
    .then((res) => {
      const { personCopyResults } = res?.data || { personCopyResults: {} }
      if (Object.values(personCopyResults).find(({ status }) => status === 'TOMBSTONED')) {
        throw new Error('TOMBSTONED')
      }
      return res
    })
    .catch((err) => {
      const { personCopyResults } = err?.response?.data || { personCopyResults: {} }
      const isAlreadyCopiedError = Object.values(personCopyResults).find(({ status }) => status === 'ALREADY_COPIED')
      if (isAlreadyCopiedError) {
        return err?.response
      }
      if (Object.values(personCopyResults).find(({ status }) => status === 'TOMBSTONED')) {
        throw new Error('TOMBSTONED')
      }
      throw err
    })
}

/**
 * Add the person defined in 'personObj' to the tree as a new person.
 * @param {object} personObj - The person object that needs to be added as a new person.
 * @param {boolean} readTf - Whether to read TreeFoundation
 * @returns {Promise<object>} - A promise object that should resolve to the new person object that was added.
 */
export function createNewPerson(personObj, readTf, treeId, recordInfo, recordData) {
  if (!personObj) return Promise.reject(new Error('Cannot create new Person, no personObj Provided'))

  const treeIdParam = treeId ? `&treeId=${treeId}` : ''
  const url = `/service/tree/tree-data/person?locale=${i18n.language}${readTf ? '&readTf=true' : ''}${treeIdParam}`

  return axios({
    url,
    method: 'post',
    headers: {
      'FS-USER-AGENT-CHAIN': `fs-add-person-service.createNewPersonCall:${window.location.pathname}`,
    },
    data: personObj,
  }).then((data) => parseStatus({ res: data, recordInfo, recordData }))
}

/**
 * Create a child-parent relationship with the child as the person of focus.
 * @param {string} pid - Pid of the child.
 * @param {object} relationship - Object with relationship info.
 * @param {string} [relationship.parent1Id] - Pid of the first parent.
 * @param {string} [relationship.parent2Id] - Pid of the second parent.
 * @returns {Promise<object>} - The call to the function to create a child to parent relationship.
 */
export function createChildRelationship(pid, relationship, treeId, personCreatedInFlow) {
  return createRelationshipCall('child', pid, relationship, treeId, personCreatedInFlow)
}

/**
 * Create a child-parent relationship with the parent as the person of focus.
 * @param {string} pid - Pid of the child.
 * @param {object} person - Object representing the parent.
 * @param {string} [person.id] - Pid of the parent.
 * @param {string} [person.gender] - Gender of the parent.
 * @param {boolean} [person.excludeUnknownChildren] - What are the 'unknown children'.
 * @returns {Promise<object>} - The call to the function to create a parent to child relationship.
 */
export function createParentRelationship(pid, person, treeId, personCreatedInFlow) {
  return createRelationshipCall('parent', pid, person, treeId, personCreatedInFlow)
}

/**
 * Create a spouse relationship with the spouse as the person of focus.
 * @param {string} pid - Pid of the spouse.
 * @param {object} relationship - The object with the other pids for the relationship(s) to add.
 * @param {boolean} [relationship.spouseInPositionOne] - Whether the spouse is in position 1. (Could be the person just added, in the case of a new person).
 * @param {string} [relationship.spouseId] - ID of the spouse. (Could be the person just added, in the case of a new person).
 * @returns {Promise<object>} - A promise object that should resolve to the new relationship object that was added.
 */
export function createSpouseRelationship(pid, relationship, treeId) {
  return createRelationshipCall('spouse', pid, relationship, treeId)
}
creationService.createSpouseRelationship = createSpouseRelationship
creationService.createParentRelationship = createParentRelationship
creationService.createChildRelationship = createChildRelationship

function getReplacePayload(relationshipObj) {
  const { spouseId, spouseInPositionOne, justification } = relationshipObj
  const parent1Id = spouseInPositionOne ? spouseId : relationshipObj.relatedSpouseOrParentId
  const parent2Id = spouseInPositionOne ? relationshipObj.relatedSpouseOrParentId : spouseId
  return { addingParent1: spouseInPositionOne, justification, parent1Id, parent2Id }
}
export function replaceSpouseCall(relationshipObj) {
  const url = `/service/tree/tree-data/relationship/couple/${relationshipObj.relationshipId}/family`
  const payload = getReplacePayload(relationshipObj)

  return axios({
    url,
    method: 'put',
    data: payload,
  }).then((res) => parseStatus({ res }))
}
creationService.replaceSpouse = replaceSpouseCall

export function replaceParentsCall(relationshipObj) {
  const url = `/service/tree/tree-data/relationship/parent-child/${relationshipObj.relationshipId}`
  const { parent1Id, parent2Id, justification, addingParent1 = false } = relationshipObj
  const payload = { addingParent1, justification, parent1Id, parent2Id }

  return axios({
    url,
    method: 'put',
    data: payload,
  }).then((res) => parseStatus({ res }))
}
creationService.replaceParents = replaceParentsCall

export function updateParentChildParent(_pid, relationship, treeId) {
  // type: parent1 | parent2
  const { justification = '', type } = relationship
  const url =
    relationship.relationshipId && type
      ? `/service/tree/tree-data/relationship/parent-child/${relationship.relationshipId}/${type}`
      : ''
  const payload = { justification, treeId, id: relationship.spouseId }

  return axios({
    url,
    method: 'put',
    data: payload,
  })
}

creationService.addParentToChild = updateParentChildParent
export default creationService

/**
 * Takes the form values and converts them into a tree-data person format.
 * @param {object} values - form values object.
 * @returns {object} person object in the tree-data format
 */
export function valuesToPersonObj(values) {
  const burialConclusion = !!values.burialDate &&
    !!values.burialPlace && {
      burialConclusion: {
        details: {
          date: formatStandardSuggestToTreeData(values.burialDate) || {},
          detailsType: 'EventDetails',
          place: formatStandardSuggestToTreeData(values.burialPlace) || {},
          type: 'BURIAL',
        },
        type: 'BURIAL',
        multiValued: false,
      },
    }
  return {
    id: 'PRIVATE',
    gender: values.sex.toUpperCase(),
    isLiving: values.status === 'living',
    birthConclusion: {
      details: {
        date: values.birthDate ? formatStandardSuggestToTreeData(values?.birthDate) : {},
        detailsType: 'EventDetails',
        place: values.birthPlace ? formatStandardSuggestToTreeData(values.birthPlace) : {},
        type: 'BIRTH',
      },
      type: 'BIRTH',
      multiValued: false,
    },
    deathConclusion: {
      details: {
        date: values.deathDate ? formatStandardSuggestToTreeData(values?.deathDate) : {},
        detailsType: 'EventDetails',
        place: values.deathPlace ? formatStandardSuggestToTreeData(values.deathPlace) : {},
        title: '',
        type: 'DEATH',
        deceasedFlag: values.status !== 'living',
      },
      type: 'DEATH',
      multiValued: false,
    },
    genderConclusion: {
      details: {
        detailsType: 'GenderDetails',
        gender: values.sex.toUpperCase(),
      },
      type: 'GENDER',
      multiValued: false,
    },
    nameConclusion: {
      details: {
        nameType: 'BIRTH',
        detailsType: 'NameDetails',
        nameForms: convertFormToTreeData(values),
        preferredName: true,
        style: values.isEurotypicNameOrder ? 'EUROTYPIC' : 'SINOTYPIC',
      },
      type: 'NAME',
      multiValued: false,
    },
    ...burialConclusion,
  }
}

/**
 * Convert a stage 2 result into a type of person object that we use for creating relationships.
 * @param {object} searchResult - a stage 2 search result
 * @returns {object} - the person object of the stage 2 result to use when we create the relationship
 */
export function stage2ResultToPersonObj(searchResult) {
  let personObj = {}
  if (searchResult && searchResult.type) {
    if (searchResult.type === 'COUPLE' && searchResult.spouse1 && searchResult.spouse2) {
      if (searchResult.personOfFocusIsSpouse1) {
        personObj = searchResult.spouse1
        personObj.spouse = searchResult.spouse2
      } else {
        personObj = searchResult.spouse2
        personObj.spouse = searchResult.spouse1
      }
    } else if (searchResult.type === 'PERSON' && searchResult.person) {
      personObj = searchResult.person
    }
  }
  return personObj
}

// munge full person object into results format - used by copy flow as well as add by id flow
export const createStage2 = (person) => {
  const parents = person.parents?.[0]
  if (!person?.spouses?.length) return [{ person: { ...person, parents }, spouses: undefined }]

  const stage2Couples = person.spouses.map((spouse) => {
    return {
      personOfFocusIsSpouse1: true,
      spouse1: { ...person, spouse },
      spouse2: spouse?.parent1?.id === person.id ? spouse.parent2 : spouse.parent1,
      type: 'COUPLE',
    }
  })

  return [
    {
      person: { ...person, parents },
      spouses: person.spouses.map((spouse) => {
        return spouse?.parent1?.id === person.id ? spouse.parent2 : spouse.parent1
      }),
      stage2Results: [
        ...stage2Couples,
        {
          personOfFocusIsSpouse1: true,
          person: { ...person, spouse: undefined },
          type: 'PERSON',
        },
      ],
    },
  ]
}
