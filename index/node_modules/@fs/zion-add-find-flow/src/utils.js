import { getNameRelatedData } from '@fs/zion-person-service'
import { operationTypes } from './services/AddFindFlowService'

export const computeDisplayedRelations = (
  operationType,
  relatedParent1,
  relatedParent2,
  relatedChildOrSpouse,
  spouseToReplace
) => {
  let displayRelatedParent1 = false
  let displayRelatedParent2 = false
  let displayRelatedChildOrSpouse = false
  let displaySpouseToReplace = false
  switch (operationType) {
    case 'replaceSpouse1':
    case 'replaceSpouse2':
      displaySpouseToReplace = Boolean(spouseToReplace?.id)
      break
    case 'replaceParent1':
      displayRelatedParent1 = Boolean(relatedParent1?.id)
      break
    case 'replaceParent2':
      displayRelatedParent2 = Boolean(relatedParent2?.id)
      break
    case 'addParent1':
    case 'addParent2':
    case 'addParents':
    case 'addSpouse':
    case 'addSpouse1':
    case 'addSpouse2':
    case 'addFirstAncestor':
    case 'addUnconnectedCustom':
      displayRelatedChildOrSpouse = Boolean(relatedChildOrSpouse?.id)
      break
    case 'addChild':
    case 'replaceParents':
      displayRelatedParent1 = Boolean(relatedParent1?.id)
      displayRelatedParent2 = Boolean(relatedParent2?.id)
      break
    default:
  }
  return { displayRelatedParent1, displayRelatedParent2, displayRelatedChildOrSpouse, displaySpouseToReplace }
}

export const computeHeadings = ({
  relatedParent1,
  relatedParent2,
  relatedChildOrSpouse,
  spouseToReplace,
  operationType,
  t,
  showNameInRomanScriptPreference,
}) => {
  if (!operationType || !t) {
    return {}
  }

  if (!operationTypes.includes(operationType)) {
    throw new Error(`Unsupported operationType: ${operationType}`)
  }

  const { displayRelatedParent1, displayRelatedParent2, displayRelatedChildOrSpouse, displaySpouseToReplace } =
    computeDisplayedRelations(operationType, relatedParent1, relatedParent2, relatedChildOrSpouse, spouseToReplace)

  // TW-464. Convert gender to uppercase for condition checking.
  // Flat endpoints (root ancestors & root descendants) returns uppercase.
  // Other endpoints (additional ancestors & additional descendants) return title case.
  const relatedParent1Gender = relatedParent1?.gender?.toUpperCase()
  const relatedParent2Gender = relatedParent2?.gender?.toUpperCase()
  const relatedChildOrSpouseGender = relatedChildOrSpouse?.gender?.toUpperCase()

  let relatedParent1Subtitle = null
  let relatedParent2Subtitle = null
  let relatedChildOrSpouseSubtitle = null
  let spouseToReplaceSubtitle = null

  // addChild, replaceParents
  if (displayRelatedParent1) {
    const { fullName: name } = getNameRelatedData(relatedParent1, showNameInRomanScriptPreference)
    if (operationType === 'replaceParent1' || operationType === 'replaceParent2') {
      // when we replace a single person, we leave off the label to avoid confusion
      relatedParent1Subtitle = name
    } else {
      relatedParent1Subtitle =
        relatedParent1Gender === 'MALE'
          ? t('add-find-flow.sub-heading.father', { name })
          : t('add-find-flow.sub-heading.mother', { name })
    }
  }
  if (displayRelatedParent2) {
    const { fullName: name } = getNameRelatedData(relatedParent2, showNameInRomanScriptPreference)
    if (operationType === 'replaceParent1' || operationType === 'replaceParent2') {
      // when we replace a single person, we leave off the label to avoid confusion
      relatedParent1Subtitle = name
    } else {
      relatedParent2Subtitle =
        relatedParent2Gender === 'MALE'
          ? t('add-find-flow.sub-heading.father', { name })
          : t('add-find-flow.sub-heading.mother', { name })
    }
  }
  // addSpouse
  if (operationType.includes('addSpouse') && displayRelatedChildOrSpouse) {
    const { fullName: name } = getNameRelatedData(relatedChildOrSpouse, showNameInRomanScriptPreference)
    relatedChildOrSpouseSubtitle =
      relatedChildOrSpouseGender === 'MALE'
        ? t('add-find-flow.sub-heading.spouse-male', { name })
        : t('add-find-flow.sub-heading.spouse-female', { name })
  }
  // addUnconnectedCustomButton
  if (operationType.includes('addUnconnectedCustom') && displayRelatedChildOrSpouse) {
    const { fullName: name } = getNameRelatedData(relatedChildOrSpouse, showNameInRomanScriptPreference)
    relatedChildOrSpouseSubtitle = t('add-find-flow.sub-heading.person-of-focus', { name })
  }
  // addFirstAncestorButton. For now this is the same as addUnconnectedCustomButton. But both buttons are used and may diverge in the future
  if (operationType.includes('addFirstAncestor') && displayRelatedChildOrSpouse) {
    const { fullName: name } = getNameRelatedData(relatedChildOrSpouse, showNameInRomanScriptPreference)
    relatedChildOrSpouseSubtitle = t('add-find-flow.sub-heading.person-of-focus', { name })
  }
  // addParent
  if (operationType.includes('addParent') && displayRelatedChildOrSpouse) {
    const { fullName: name } = getNameRelatedData(relatedChildOrSpouse, showNameInRomanScriptPreference)
    if (relatedChildOrSpouseGender === 'MALE') {
      relatedChildOrSpouseSubtitle = t('add-find-flow.sub-heading.child-male', { name })
    } else if (relatedChildOrSpouseGender === 'FEMALE') {
      relatedChildOrSpouseSubtitle = t('add-find-flow.sub-heading.child-female', { name })
    } else {
      relatedChildOrSpouseSubtitle = t('add-find-flow.sub-heading.child-unknown-sex', { name })
    }
  }
  // replaceSpouse
  if (displaySpouseToReplace) {
    // when we replace a single person, we leave off the label to avoid confusion
    const { fullName: name } = getNameRelatedData(spouseToReplace, showNameInRomanScriptPreference)
    spouseToReplaceSubtitle = name
  }

  return {
    relatedParent1Subtitle,
    relatedParent2Subtitle,
    relatedChildOrSpouseSubtitle,
    spouseToReplaceSubtitle,
  }
}

export const getGenderAutoSelect = ({
  operationType,
  relatedParent1,
  relatedParent2,
  relatedChildOrSpouse,
  position,
}) => {
  const relatedParent1Gender = relatedParent1?.gender?.toUpperCase()
  const relatedParent2Gender = relatedParent2?.gender?.toUpperCase()
  const relatedChildOrSpouseGender = relatedChildOrSpouse?.gender?.toUpperCase()

  switch (operationType) {
    case 'addParents': {
      if (!position) return ''
      return position === 1 ? 'male' : 'female'
    }
    case 'replaceParent1':
    case 'addParent1':
      // if we are adding a parent 1, we want to default to male unless there is already a parent2
      return relatedParent2Gender === 'MALE' ? 'female' : 'male'
    case 'replaceParent2':
    case 'addParent2':
      // if we are adding a parent 2, we want to default to female unless there is already a parent1
      return relatedParent1Gender === 'FEMALE' ? 'male' : 'female'
    case 'replaceSpouse1':
    case 'replaceSpouse2':
    case 'addSpouse':
    case 'addSpouse1':
    case 'addSpouse2':
      return relatedChildOrSpouseGender === 'FEMALE' ? 'male' : 'female'
    default:
      return ''
  }
}
