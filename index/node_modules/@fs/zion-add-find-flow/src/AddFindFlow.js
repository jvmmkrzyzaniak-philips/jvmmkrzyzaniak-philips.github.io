import React, { useState } from 'react'
import PropTypes from 'prop-types'
import { TransitioningDialogOverlay, Row, Button, InfoSheet, IconButton, Paragraph, H6, colors } from '@fs/zion-ui'
import { trackEvent } from '@fs/zion-analytics'
import { MemoryRouter, Route, RouteToParentRouter, useHistory } from '@fs/zion-router'
import { MemoriesPrivacyRouteView } from '@fs/zion-tree-groups'
import { RecordPreview, DismissMatch } from '@fs/zion-record-details'
import { useTranslation } from 'react-i18next'
import { ArrowCaret } from '@fs/zion-icon'
import { useEvent } from '@fs/zion-frontend-friends'
import { css } from '@linaria/core'
import { operationTypes } from './services/AddFindFlowService'
import AddFindFlowProvider, { useAddFindFlowContext } from './hooks/AddFindFlowContext'
import LoadingView from './views/LoadingView'
import SearchView from './views/SearchView'
import FindResultsView from './views/FindResultsView'
import Stage2ResultsView from './views/Stage2ResultsView'
import useTitle from './hooks/useTitle'
import { InitialValuesType } from './InitialValues'

const ADD_FIND_FLOW_RECORD_PATH = '/add-find-flow-record'
const ADD_FIND_FLOW_SEARCH_PATH = '/add-find-flow-search'
const MEMORY_PRIVACY_PATH = '/memories-privacy'
const ADD_FIND_FLOW_RESULTS_PATH = '/add-find-flow-results'
const ADD_FIND_FLOW_STAGE_TWO_PATH = '/add-find-flow-stage2'
export const ADD_FIND_FLOW_LOADING = '/add-find-flow-loading'

const infoHeadingCss = css`
  margin-inline-start: 10px;
  display: flex;
  align-items: center;
  column-gap: 10px;
`

const recordTextCss = css`
  position: absolute;
  display: grid;
  align-items: center;
  bottom: 0px;
  inset-inline-start: 0;
  background: white;
  width: 100%;
  background: ${colors.gray03};
  padding: 15px 10px;
`
const bottomTextBuffer = css`
  // This is a buffer to prevent the bottom of the infosheet from being cut off by the sticky record text.
  height: 120px;
`

const InfoSheetHeading = ({ title, previousFooter }) => {
  const { t } = useTranslation()
  const history = useHistory()
  const prevRoute = history.length > 1 && history.index !== 0
  const goBackHandler = useEvent(() => {
    history.goBack()
    previousFooter()
  })

  return (
    <span className={infoHeadingCss}>
      {prevRoute && (
        <IconButton
          aria-label={t('common-ui:back.action')}
          Icon={ArrowCaret}
          iconDirection="backward"
          onClick={goBackHandler}
        />
      )}
      <span>{title}</span>
    </span>
  )
}

const InfoSheetWrap = ({ children, resetFooterHistory, footer, ...props }) => {
  const history = useHistory()
  const reset = useEvent(() => {
    history.go(-history.index)
    resetFooterHistory()
  })
  const isRecordPath = history.location.pathname === ADD_FIND_FLOW_RECORD_PATH
  return (
    <InfoSheet footer={footer} {...props} onClose={reset}>
      {children}
      {isRecordPath && <div className={bottomTextBuffer} />}
    </InfoSheet>
  )
}

const MemoryRouterWrap = ({ children, infoSheetFooter, initialLocation, ...props }) => {
  return (
    <MemoryRouter initialEntries={[initialLocation]}>
      <InfoSheetWrap footer={infoSheetFooter} {...props}>
        {children}
      </InfoSheetWrap>
    </MemoryRouter>
  )
}

const useFooterHistory = (initialFooter) => {
  const [footerHistory, setFooterHistory] = useState([initialFooter])

  const updateInfoSheetFooter = useEvent((newFooter) => {
    setFooterHistory((prevHistory) => {
      const lastFooter = prevHistory[prevHistory.length - 1]
      // If the last footer is the same as the new footer, don't add it to the history.
      // There is probably a better way to do this.
      if (
        React.isValidElement(lastFooter) &&
        React.isValidElement(newFooter) &&
        lastFooter.props['data-testid'] === newFooter.props['data-testid']
      ) {
        return [...prevHistory.slice(0, -1), newFooter]
      }
      return [...prevHistory, newFooter]
    })
  })

  const previousFooter = useEvent(() => {
    setFooterHistory((prevHistory) => {
      if (prevHistory.length > 1) {
        return prevHistory.slice(0, -1)
      }
      return prevHistory
    })
  })

  const resetFooterHistory = useEvent(() => {
    setFooterHistory([initialFooter])
  })

  const currentFooter = footerHistory[footerHistory.length - 1]

  return { currentFooter, updateInfoSheetFooter, previousFooter, resetFooterHistory }
}

const AddFindFlowInner = (props) => {
  const { t } = useTranslation()
  const { overlay, close, heading, operationType, recordInfo, onRecordDismiss, inInfoSheet } = props

  const { relationshipInfo } = useAddFindFlowContext()
  const { relatedParent1, relatedParent2, relatedChildOrSpouse, spouseToReplace } = relationshipInfo
  const onDismiss = useEvent((evt) => {
    onRecordDismiss(evt)
    trackEvent({ event_name: 'add_find_with_record_dismissed' })
  })

  const {
    currentFooter: infoSheetFooter,
    updateInfoSheetFooter,
    previousFooter,
    resetFooterHistory,
  } = useFooterHistory(
    recordInfo ? (
      <Row data-testid="initial-footer" alignX="end">
        <DismissMatch
          emphasis="medium"
          onDismiss={onDismiss}
          treePersonId={relatedChildOrSpouse?.id}
          recordInfo={recordInfo}
        />
        <Button emphasis="high" data-testid="next-button" type="button" to={ADD_FIND_FLOW_SEARCH_PATH}>
          {t('common-ui:yes.action')}
        </Button>
      </Row>
    ) : null
  )

  const { title, subtitle } = useTitle({
    heading,
    operationType,
    relatedParent1,
    relatedParent2,
    relatedChildOrSpouse,
    spouseToReplace,
  })
  const Wrapper = inInfoSheet ? MemoryRouterWrap : TransitioningDialogOverlay
  const wrapperProps = inInfoSheet ? { size: 'md', resetFooterHistory, infoSheetFooter } : { size: 'xl' }

  return (
    <Wrapper
      close={close}
      data-testid="add-find-flow"
      closeOnClickAway={false}
      initialLocation={recordInfo ? ADD_FIND_FLOW_RECORD_PATH : ADD_FIND_FLOW_SEARCH_PATH}
      title={inInfoSheet ? <InfoSheetHeading title={title} previousFooter={previousFooter} /> : title}
      subtitle={subtitle}
      {...wrapperProps}
      {...overlay}
    >
      <Route footer={recordInfo ? infoSheetFooter : undefined} exact path={ADD_FIND_FLOW_RECORD_PATH}>
        <RecordPreview hideFooter ark={recordInfo?.recordURL} />
        <div className={recordTextCss}>
          <H6>{t('add-find-flow.find-record.add.suggestion')}</H6>
          <Paragraph size="sm">{t('add-find-flow.find-record.add.description')}</Paragraph>
        </div>
      </Route>
      <Route exact path={ADD_FIND_FLOW_SEARCH_PATH}>
        <SearchView
          {...props}
          hideTabs={props?.hideTabs || recordInfo}
          memoriesPrivacyPath={MEMORY_PRIVACY_PATH}
          addFindFlowResultsPath={ADD_FIND_FLOW_RESULTS_PATH}
          updateInfoSheetFooter={updateInfoSheetFooter}
        />
      </Route>
      <Route path={MEMORY_PRIVACY_PATH}>
        <MemoriesPrivacyRouteView
          altUpdateFooter={inInfoSheet ? updateInfoSheetFooter : undefined}
          addFindFlowResultsPath={ADD_FIND_FLOW_RESULTS_PATH}
        />
      </Route>
      <Route path={ADD_FIND_FLOW_RESULTS_PATH}>
        <FindResultsView
          updateInfoSheetFooter={updateInfoSheetFooter}
          addFindFlowStageTwoPath={ADD_FIND_FLOW_STAGE_TWO_PATH}
        />
      </Route>
      <Route path={ADD_FIND_FLOW_STAGE_TWO_PATH}>
        <Stage2ResultsView />
      </Route>
      <Route path={ADD_FIND_FLOW_LOADING}>
        <LoadingView updateInfoSheetFooter={updateInfoSheetFooter} />
      </Route>
      {!inInfoSheet && (
        <Route path="*">
          <RouteToParentRouter />
        </Route>
      )}
    </Wrapper>
  )
}
/**
 * JSX add/find flow.
 *
 * @param {object} props - The props passed into the element.
 * @param {object} [props.overlay] - useOverlay hook results
 * @returns {HTMLElement} - JSX.
 */
export default function AddFindFlow(props) {
  const {
    noGroupTabs,
    overlay,
    operationType = 'addUnconnected',
    onSuccess = () => {},
    onDismiss = () => {},
    inInfoSheet,
    recordInfo,
  } = props

  // we are replacing overlay's close function because we need to distinguish between two different types of closing - success vs dismiss.
  // this feature is used in first ancestor when going between the onboarding dialog and the add flow - if someone abandons the add flow,
  // we want to open back up the onboarding flow. Note: this type of an onSuccess vs onDismiss may need to be built in to zion-ui/overlay
  // at some point. We're doing this one off here, but if we have to do it again, we should propose the change in zion.
  const { close: overlayClose } = overlay
  const close = useEvent((nodeToFocus, runningAfterSuccess) => {
    overlayClose(nodeToFocus)
    !runningAfterSuccess && onDismiss()
  })

  return (
    <AddFindFlowProvider
      operationType={operationType}
      noGroupTabs={noGroupTabs}
      onSuccess={onSuccess}
      recordInfo={recordInfo}
      close={close}
      overlay={overlay}
      inInfoSheet={inInfoSheet}
      {...props}
    >
      <AddFindFlowInner close={close} overlay={overlay} {...props} />
    </AddFindFlowProvider>
  )
}

// Stryker disable all
AddFindFlow.propTypes = {
  /** The operation the AddFindFlow is to perform. */
  operationType: PropTypes.oneOf(operationTypes).isRequired,

  /** The ID of the selected tree. Undefined if personal pedigree. */
  /**
   * @deprecated treeId comes from the context as currentTreeId
   */
  treeId: PropTypes.string,

  /** Boolean determining whether or not we show group tabs. */
  noGroupTabs: PropTypes.bool,

  /** The text to display for the heading of the AddFindFlow when operationType=addUnconnectedCustom | addFirstAncestor | \/$replace*\/ */
  heading: PropTypes.string,

  /** Whether or not to hide the tabs */
  hideTabs: PropTypes.bool,

  /** If true, the status will be set to "deceased" and the user will not be able to change it. */
  deceasedOnly: PropTypes.bool,

  /** If true, the flow will not match against the tree. */
  noMatch: PropTypes.bool,

  /** If true, birth and death and relationships will be hidden. */
  hideAdditionalSearchFields: PropTypes.bool,

  /**
   * Function to update the aria text for the "Add Match" button when operationType=addUnconnectedCustom or operationType=addFirstAncestor.
   * Since this includes the matched person's name, we have to use a function to interpolate the value.
   * function signature: `({personName: String}): String`
   * Example: `({personName}) => t('my.string.key', {personName})`
   */
  getAriaAddPersonText: PropTypes.func,

  /** Function to run on successful add/replace. */
  onSuccess: PropTypes.func,

  /** Display using an InfoSheet, rather than a TransitioningDialogOverlay. */
  inInfoSheet: PropTypes.bool,

  /** Optionally preview a record before add-find-flow. Used in golden hints flow. Talk to UX if using anywhere else. */
  recordInfo: PropTypes.shape({
    recordURL: PropTypes.string,
    sex: PropTypes.oneOf(['U', 'F', 'M']),
    name: PropTypes.string,
  }),

  /** Function to run on exit of the add flow other than successful add/replace. */
  onDismiss: PropTypes.func,

  /** Get these props from useOverlay from ZionUI. */
  overlay: PropTypes.object.isRequired,

  /** This is used for replace operations. */
  existingRelationshipHasTwoParents: PropTypes.bool,

  /** A standard person object */
  spouseToReplace: PropTypes.shape({
    fullLifespan: PropTypes.string,
    gender: PropTypes.string,
    id: PropTypes.string,
    lifespan: PropTypes.string,
    name: PropTypes.string,
    nameConclusion: PropTypes.shape({
      details: PropTypes.shape({
        nameForms: PropTypes.array,
      }),
    }),
    portraitUrl: PropTypes.string,
  }),

  /** A standard person object (that a child will be added to OR a parent being replaced in a relationship OR the parent of a child getting replaced.) */
  relatedParent1: PropTypes.shape({
    fullLifespan: PropTypes.string,
    gender: PropTypes.string,
    id: PropTypes.string,
    lifespan: PropTypes.string,
    name: PropTypes.string,
    nameConclusion: PropTypes.shape({
      details: PropTypes.shape({
        nameForms: PropTypes.array,
      }),
    }),
    portraitUrl: PropTypes.string,
  }),

  /** A standard person object (that a child will be added to OR a parent being replaced in a relationship OR the parent of a child getting replaced.) */
  relatedParent2: PropTypes.shape({
    fullLifespan: PropTypes.string,
    gender: PropTypes.string,
    id: PropTypes.string,
    lifespan: PropTypes.string,
    name: PropTypes.string,
    nameConclusion: PropTypes.shape({
      details: PropTypes.shape({
        nameForms: PropTypes.array,
      }),
    }),
    portraitUrl: PropTypes.string,
  }),

  /** A standard person object (a child to add parents to OR a person to add a spouse to OR a child to replace parents for OR a child to be replaced OR a person whose spouse is getting replaced) */
  relatedChildOrSpouse: PropTypes.shape({
    fullLifespan: PropTypes.string,
    gender: PropTypes.string,
    id: PropTypes.string,
    lifespan: PropTypes.string,
    name: PropTypes.string,
    nameConclusion: PropTypes.shape({
      details: PropTypes.shape({
        nameForms: PropTypes.array,
      }),
    }),
    portraitUrl: PropTypes.string,
  }),

  /** Initial search form values */
  initialValues: PropTypes.shape(InitialValuesType),
}
