import Cache from '@fs/zion-cache'
import Queue from '@fs/zion-queue'
import { fetchData } from './utils'

/**
 * Cache service to take care of getting/setting caching and sending
 * cached version data to server.
 */

// cache-first - gets from cache and then from network if not in cache. returns a single promise.
// cache-and-network - gets from cache and network. returns two promises.

export default class CacheService {
  constructor({ cache, strategy = 'cache-first', queueConfig = {} }) {
    if (!cache) {
      throw new Error('`cache` must be defined. Either a Zion Cache instance or cache config object.')
    }

    this.cacheInstance = cache.pending ? cache : new Cache(cache)
    this.cacheQueue = new Queue(({ key }) => this.cacheInstance.getItem(key), queueConfig)
    this.fetchQueue = new Queue((opts) => fetchData(opts), queueConfig)
    this.strategy = strategy
  }

  /**
   * Public method to get data from cache and then server if version is different.
   * @param  {string} url - Url for endpoint, `/tree/v8/proxy` is prepended to this string.
   * @param  {string} key - The key used for the cache.
   * @param  {Object.Function} preCacheHook - Callback function to alter object before saving it to cache.
   * @param  {Object.Object} axiosConfig - Axios request config.
   * @param  {Object.string} queueId - a unique id to be used by the cache and fetch Queues.
   * @param  {Object.Boolean} ignoreCache - If true, the cache will be ignored and the data will be fetched again.
   * @param  {Object.Boolean} includeAxiosResponse - If true, the entire axios response will be resolved in serverPromise.
   * @return {Object.serverPromise} - Promise with data returned from axios call.
   * @return {Object.cachePromise} - Promise with data returned from @fs/zion-cache call.
   */
  get(url, key, { preCacheHook, axiosConfig, queueId, ignoreCache, includeAxiosResponse } = {}) {
    if (!url) throw new Error('No url passed in')
    if (!key) throw new Error('No cache key passed in')

    let serverPromise

    const cachePromise = new Promise((resolve) => {
      serverPromise = this.cacheQueue.add({ key, id: queueId || key }).then((data) => {
        let cachedVersion
        const response = includeAxiosResponse ? { data, isCache: true } : data
        resolve(response)

        if (data && !ignoreCache) {
          cachedVersion = data.version
          if (this.strategy === 'cache-first') {
            return Promise.resolve(response)
          }
        }
        return this.fetchQueue
          .add({
            id: queueId || url,
            url,
            cache: this.cacheInstance,
            key,
            cachedVersion,
            axiosConfig,
            preCacheHook,
            strategy: this.strategy,
            includeAxiosResponse,
          })
          .catch((err) => {
            if (err.message === 'LATEST_VERSION_CACHED') {
              return Promise.resolve(response)
            }
            throw err
          })
      })
    })

    if (this.strategy === 'cache-first') {
      return serverPromise
    }

    return [serverPromise, cachePromise]
  }
}
