import { useEffect, useReducer, useRef } from 'react'
import { useEvent } from '@fs/zion-frontend-friends'

const reducer = (state, action) => {
  switch (action.type) {
    case 'LOADING':
      return { ...state, loading: true, error: undefined }
    case 'SUCCESS': {
      let loading = false

      // If cache is empty (null), loading should still be true until data comes back from the server
      if (action.isFromCache) {
        loading = action.data === null
      }

      return { ...state, loading, data: action.data }
    }
    case 'ERROR':
      return { ...state, loading: false, error: action.error }
    default:
      throw new Error('No case to handle type ', action.type)
  }
}
const initialState = {
  data: undefined,
  loading: undefined,
  error: undefined,
}

export default function useCacheService(instance, url, key, options) {
  const urlRef = useRef()
  const isManual = options?.manual
  const [state, dispatch] = useReducer(reducer, initialState)
  const isCurrentRef = useRef(true)

  const updateStateFrom = useEvent((source, isFromCache) => {
    return source
      .then((data) => {
        isCurrentRef.current && dispatch({ type: 'SUCCESS', data, isFromCache })
        return data
      })
      .catch((err) => {
        isCurrentRef.current && dispatch({ type: 'ERROR', error: err })
      })
  })

  const refetch = useEvent(async (ignoreCache) => {
    dispatch({ type: 'LOADING' })

    const res = instance.get(url, key, { ...options, ignoreCache })

    if (Array.isArray(res)) {
      const [server, cache] = res
      if (!ignoreCache) {
        updateStateFrom(cache, true)
      }
      return updateStateFrom(server)
    }
    return updateStateFrom(res)
  })

  useEffect(() => {
    if (!isManual && urlRef.current !== url && url) {
      urlRef.current = url
      // we do want to use the cache on the initial page load
      refetch(false)
    }
  }, [isManual, refetch, url])

  useEffect(() => {
    isCurrentRef.current = true
    return () => {
      isCurrentRef.current = false
    }
  }, [])

  // if refetch is called externally we don't want to use the cache
  return [state, useEvent(() => refetch(true))]
}
