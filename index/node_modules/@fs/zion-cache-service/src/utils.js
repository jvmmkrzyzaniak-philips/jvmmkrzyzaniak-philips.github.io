import axios from '@fs/zion-axios'
import cloneDeep from 'lodash.clonedeep'

/**
 * Private method to fetch the data from the server.
 * @param  {string} url - Url for endpoint, `/tree/v8/proxy` is prepended to this string.
 * @param  {Object} cache - FSCache instance to read and write to.
 * @param  {string} key - The key used for the cache.
 * @param  {string} cachedVersion - Version of cached data.
 * @param  {Object} axiosConfig - Axios config object.
 * @param  {function} preCacheHook - Callback to munge data before caching.
 * @param  {Boolean} includeAxiosResponse - If true, return whole axios response
 * @return {Promise} - Promise with data returned from Axios call.
 */
export async function fetchData({
  url,
  cache,
  key,
  cachedVersion,
  axiosConfig = {},
  preCacheHook,
  strategy,
  includeAxiosResponse,
}) {
  const config = { ...axiosConfig }
  if (cachedVersion) {
    config.headers = axiosConfig.headers || {}
    config.headers['If-None-Match'] = cachedVersion
  }

  try {
    const res = await axios.get(url, config)
    const { headers, data, status } = res
    const version = headers.etag

    // Don't store non-json responses in the cache because
    // we need to rely on version for comparison later.
    // The exception being that 204 has no content but
    // can still be cached as such
    if (status !== 204 && typeof data !== 'object') {
      return res
    }

    let setData = data?.data || data || {}
    setData.version = version

    if (preCacheHook) {
      setData = await preCacheHook(setData)
    }
    cache.setItem(key, setData)

    const response = includeAxiosResponse ? { ...res, data: setData, version: setData.version } : setData
    return cloneDeep(response)
  } catch (err) {
    if (strategy === 'cache-and-network' && err.response && err.response.status === 304) {
      throw new Error('LATEST_VERSION_CACHED')
    }
    throw err
  }
}
