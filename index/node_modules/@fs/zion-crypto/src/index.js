/* eslint-disable no-console */

import 'webcrypto-shim/webcrypto-shim'
import { v4 as uuid } from 'uuid'
import { cacheKey } from '@fs/zion-config'
import zionDebug from '@fs/zion-debug'

const logWarn = zionDebug('zion:crypto:warn')
const logTime = zionDebug('zion:crypto:time')

// TODO: Work in https://github.com/fs-webdev/zion/pull/608 sometime
const vector = new Uint8Array(16)
const config = {
  name: 'AES-CBC',
  iv: vector,
}

let password = cacheKey

if (!password) {
  // TODO: re-evaluate after we get numbers from sentry
  console.warn('Cache key not set')
  password = 'fs'
}

let CRYPTO_KEY = null

/**
 * Create crypto key based on password.
 * @param  {string}  cryptoPassword      The password do create key.
 * @param  {Boolean} [ignoreCache=false] Ignore the memory cache.
 * @return {Promise}                     Crypto key.
 */
export async function getCryptoKey(cryptoPassword, ignoreCache = false) {
  if (CRYPTO_KEY && !ignoreCache) return CRYPTO_KEY

  const result = await window.crypto.subtle.digest({ name: 'SHA-256' }, stringToByteArray(cryptoPassword))
  CRYPTO_KEY = await window.crypto.subtle.importKey('raw', result, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt'])

  return CRYPTO_KEY
}

/**
 * Encrypts the data passed into it.
 * @param {any} data
 * @returns {Promise} Encrypted value in Uint8Array.
 */

export async function encrypt(data) {
  if (!data) {
    return null
  }

  const id = uuid()
  logTime.enabled && console.time(`encrypt${id}`)

  const key = await getCryptoKey(password)
  const result = await window.crypto.subtle.encrypt(config, key, stringToByteArray(data))
  const encryptedData = new Uint8Array(result)

  logTime.enabled && console.timeEnd(`encrypt${id}`)

  return encryptedData
}

/**
 * Decrypts the data passed into it.
 * @param {any} data
 * @returns {Promise}
 */
export async function decrypt(data) {
  if (!data) return null

  const id = uuid()
  logTime.enabled && console.time(`decrypt${id}`)

  const key = await getCryptoKey(password)
  let result
  try {
    result = await window.crypto.subtle.decrypt(config, key, data)
  } catch (e) {
    logWarn('cacheKey is invalid')
  }
  const decryptedData = new Uint8Array(result)
  let decryptedString = byteArrayToString(decryptedData)

  try {
    decryptedString = JSON.parse(decryptedString)
  } catch (e) {
    logWarn('decryption JSON.parse failed')
  }

  logTime.enabled && console.timeEnd(`decrypt${id}`)
  return decryptedString
}

function byteArrayToString(byteArray) {
  let result = ''

  if ('TextDecoder' in window) {
    const decoder = new window.TextDecoder()
    result = decoder.decode(byteArray)
  } else {
    result = Array.from(byteArray)
      .map((code) => String.fromCharCode(code))
      .join('')
  }

  result = b64DecodeUnicode(result)

  return result
}

function stringToByteArray(value) {
  let str = value
  if (typeof str !== 'string') {
    str = JSON.stringify(str)
  }

  str = b64EncodeUnicode(str)

  if ('TextEncoder' in window) {
    const encoder = new window.TextEncoder()
    return encoder.encode(str)
  }

  // Otherwise, fall back to 7-bit ASCII only
  const result = new Uint8Array(str.length)
  Array.from(str).forEach((char, i) => {
    result[i] = str.charCodeAt(i)
  })
  return result
}

//  The following functions (b64DecodeUnicode & b64EncodeUnicode) are from:
//  https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem
function b64DecodeUnicode(str) {
  // Going backwards: from bytestream, to percent-encoding, to original string.
  return decodeURIComponent(
    atob(str)
      .split('')
      .map((c) => `%${`00${c.charCodeAt(0).toString(16)}`.slice(-2)}`)
      .join('')
  )
}

function b64EncodeUnicode(str) {
  // first we use encodeURIComponent to get percent-encoded UTF-8,
  // then we convert the percent encodings into raw bytes which
  // can be fed into btoa.
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode(`0x${p1}`)))
}
