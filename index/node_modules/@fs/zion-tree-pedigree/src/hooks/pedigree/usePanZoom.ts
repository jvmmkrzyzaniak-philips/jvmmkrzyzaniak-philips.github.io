import { useEffect, useState, useRef, useLayoutEffect } from 'react'
import Cache from '@fs/zion-cache'
import type { ZoomPanValues, ZoomPanUtils, ZoomPanProps } from '@fs/zion-ui'
import { useContainerWidth, useZoomPan } from '@fs/zion-ui'
import { useHeaderControls } from '@fs/zion-root'
import { useZoomLevelContext } from '../../PedigreeZoomLevelProvider'

export const sessionCache = new Cache({ storeName: 'pedigreeTemporaryCache', type: 'local' })

const defaultZoomPanConfig: Partial<ZoomPanProps> = {
  minZoom: 0.1,
  maxZoom: 4,
  // Read: "(Ignoring negatives) the amount of space that is added to the..."
  panMarginX: 0,
  panMarginY: 0,
  stageTop: 0,
  stageRight: 0,
  stageBottom: 0,
  stageLeft: 0,
}

let shouldResetPan = true
let panCacheReady = false
let lastPanX: null | number = null
let lastPanY: null | number = null
let previousZoom = 0

const resetValues = (): void => {
  shouldResetPan = true
  panCacheReady = false
  lastPanX = null
  lastPanY = null
  previousZoom = 0
}

type setSavedPanArgs = {
  pofId: string
  zoomPan: ZoomPanUtils & ZoomPanValues
  initialCenteredPoints: number[]
  view: string
}

const setSavedPanPosition = async ({ pofId, zoomPan, view, initialCenteredPoints }: setSavedPanArgs): Promise<void> => {
  try {
    const lastPanPoint = await sessionCache.getItem('panPoint')
    const pofAndViewAreUnchanged = lastPanPoint?.pofId === pofId && lastPanPoint?.view === view
    if (shouldResetPan && lastPanPoint && pofAndViewAreUnchanged) {
      // If we can get rid of this timeout, lets do it. This is helping refresh and pan back work for sibling. It seems like a race condition.
      setTimeout(() => zoomPan.set(lastPanPoint), 500)
    } else {
      sessionCache.removeItem('panPoint')
    }
    if (!lastPanPoint || !pofAndViewAreUnchanged) {
      // We are using this as a way to set the initialPanX and initialPanY, so to speak.
      // Those zoompan props have been somewhat unreliable in our experience, and have resulted in different behavior depending on stage size, if not other variables as well.
      // We think this will give us the most uniform experience across pedigrees. If initialPanX is ever documented more thorougly we can revisit.
      zoomPan.set({ panX: initialCenteredPoints[0], panY: initialCenteredPoints[1] })
    }
    shouldResetPan = false
    panCacheReady = true
  } catch (e) {
    console.error('error getting panPoint from session cache', e)
  }
}
type usePanZoomProps = {
  stage: Record<string, number>
  initialCenteredPoints: number[]
  view: string
  initialZoom: number
  pedigreeReady: boolean
  pofId: string
  disableResetOnPidChange: boolean
}
export default function usePanZoom({
  stage,
  initialCenteredPoints = [0, 0],
  view,
  initialZoom,
  pedigreeReady,
  pofId,
  disableResetOnPidChange = false,
}: usePanZoomProps): ZoomPanProps | Record<string, never> {
  const [zoomPanRefs, zoomPan] = useZoomPan()
  const { setIsVisible } = useHeaderControls() || {}
  const [zoomPanConfig, setConfig] = useState(defaultZoomPanConfig)
  const { setZoomLevel } = useZoomLevelContext()
  const isMobile = useContainerWidth()({ md: false, default: true })
  const { viewerHeight, viewerWidth } = zoomPanRefs?.controllerRef?.current || {}
  const mounted = useRef(false)
  const [readyForPan, setReadyForPan] = useState(false)
  const isReady = Boolean(zoomPanRefs.viewerRef?.current?.textContent)
  const { panX, panY, reset } = zoomPan

  useEffect(() => {
    mounted.current = true
    return () => {
      mounted.current = false
      resetValues()
    }
  }, [])

  const updatedConfig: Partial<Omit<ZoomPanProps, 'initialZoom'>> & { initialZoom?: number } = {
    stageTop: stage.top,
    stageRight: stage.right,
    stageBottom: stage.bottom,
    stageLeft: stage.left,
    panMarginX: viewerWidth * 0.75,
    panMarginY: viewerHeight * 0.75,
    // even though initialPan values don't give us great results on initialization, we need it for the reset button.
    initialPanX: initialCenteredPoints[0],
    initialPanY: initialCenteredPoints[1],
  }

  if (!zoomPanConfig.initialZoom) {
    let zoomData
    sessionCache
      .getItem('zoomLevel')
      .then((data: number | null) => {
        zoomData = data
      })
      .catch((err: Error) => {
        console.error(err)
      })
      .finally(() => {
        setConfig(Object.assign(zoomPanConfig, { initialZoom: zoomData || initialZoom || (isMobile ? 0.5 : 0.8) }))
      })
  }

  const updatedConfigVals = Object.values({ ...defaultZoomPanConfig, ...updatedConfig })
  const configsAreEqual = Object.values(zoomPanConfig).every((val, idx) => val === updatedConfigVals[idx])

  if (!configsAreEqual) {
    setConfig(Object.assign(defaultZoomPanConfig, updatedConfig))
  }

  // Re-center the pedigree any time we change view mode or persons
  // useLayoutEffect to wait for DOM to settle, then setTimeout to give our pedigree a chance to animate to new positions prior to calling reset.
  useLayoutEffect(() => {
    return () => {
      // we disable this for sibling because there is no loading pedigree, and no saved expansions
      !disableResetOnPidChange && setTimeout(reset, 500)
    }
  }, [view, pofId, reset, disableResetOnPidChange])

  const currentZoom = zoomPanRefs?.controllerRef?.current?.currentValues?.zoom
  // without this useffect, we get occasional setState errors for trying to update other components during render.
  // So even though you are wanting to remove the useEffect because you saw a ted talk about it, please don't :)
  useEffect(() => {
    if (currentZoom && isReady && currentZoom !== previousZoom) {
      setZoomLevel(currentZoom)
      previousZoom = currentZoom
      sessionCache.setItem('zoomLevel', currentZoom)
    }
  }, [isReady, setZoomLevel, zoomPanRefs?.controllerRef, currentZoom])

  // ZoomPan timing is not always consistent between pedigrees, when we load expansions, etc... so we need to make sure and check one last thing here, otherwise our pan will not function like we need it to.
  // Once the clientHeight and stage.bottom line up, and everything else is good to go, we're reasonably sure this will work ;)
  useEffect(() => {
    if (zoomPanRefs.stageRef.current?.clientHeight === stage.bottom) {
      setReadyForPan(true)
    }
  }, [stage.bottom, zoomPanRefs.stageRef])

  if (pedigreeReady && shouldResetPan && isReady && mounted.current && readyForPan && !disableResetOnPidChange) {
    setSavedPanPosition({ pofId, view, zoomPan, initialCenteredPoints })
  }
  if (isReady && panCacheReady) {
    const xChanged = panX && panX !== lastPanX
    const yChanged = panY && panY !== lastPanY

    if (xChanged || yChanged) {
      lastPanX = panX
      lastPanY = panY
      if (isMobile) {
        setIsVisible(false)
      }

      shouldResetPan = false
      sessionCache.setItem('panPoint', { pofId, panX, panY, view })
    }
  }

  if (
    zoomPanConfig.initialZoom &&
    typeof zoomPanConfig.initialPanY !== 'undefined' &&
    typeof zoomPanConfig.initialPanX !== 'undefined'
  ) {
    return { ...zoomPanConfig, ...zoomPanRefs }
  }

  return {}
}
