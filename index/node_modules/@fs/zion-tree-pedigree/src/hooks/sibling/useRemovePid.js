import { useState } from 'react'
import { useEvent } from '@fs/zion-frontend-friends'
import { useOverlay } from '@fs/zion-ui'
import { selectKey as generateSelectKey } from './helpers'

const useRemovePid = ({ removePid, state }) => {
  const [removeData, setRemoveData] = useState()
  const removeOverlay = useOverlay()

  const removeHandler = useEvent(() => {
    removePid({ ...removeData })
    setRemoveData({})
    removeOverlay.close()
  })

  const checkRemove = useEvent((evt, selectKey) => {
    const [coupleDag, personToRemove] = selectKey.split('~')

    const selectKeys = new Set([selectKey])
    const newPaths = []
    // detect which pids on the path we need to remove
    state.selectedPidPaths.forEach((path) => {
      const pathIdx = path?.findIndex(([coupleId]) => coupleId === coupleDag)

      if (pathIdx !== -1) {
        const stillSelected = path.slice(0, pathIdx)
        // path from clicked node to the end of the selected path
        const others = path.slice(pathIdx)
        const clickedNodeKey = path[pathIdx][0]
        const otherPersonId = clickedNodeKey.replace(personToRemove, '').replace('_', '')
        let keepLine = false
        others.forEach(([coupleId, personId], idx) => {
          // If index is 0, we need to determine whether or not the rest of the line should be kept
          // To ensure relationships are valid, we need to check if the next node is a parent of the remaining selected person, or a child of the current node, if both people in the clicked couple were previously selected
          // If only 1 was selected, we just remove everything after the clicked node
          if (idx === 0 && !personId) {
            const keyToCheck = generateSelectKey(coupleId, otherPersonId)
            const remainingSelectedPerson = state.selectedPids[keyToCheck]
            // check if the current node has the next nodes ids in their parentsIds field
            const nextNodeCoupleId = others[1]?.[0]
            const nextNodeIsCurrentsParent = remainingSelectedPerson.parentsIds?.includes(nextNodeCoupleId)
            const [nextp1, nextp2] = nextNodeCoupleId?.split('_') || []
            const key1ChildNode = state.selectedPids[generateSelectKey(nextNodeCoupleId, nextp1)]
            const key2ChildNode = state.selectedPids[generateSelectKey(nextNodeCoupleId, nextp2)]
            // check if the next node is a child of the current node
            const nextNodeIsCurrentsChild =
              key1ChildNode?.parentsIds?.includes(coupleId) || key2ChildNode?.parentsIds?.includes(coupleId)
            if (nextNodeIsCurrentsParent || nextNodeIsCurrentsChild) {
              keepLine = true
            }
          }
          // if index is not 0, we should know by now whether or not the line should be kept
          // alternatively, if index is 0 and we have a personId, we know the remainder in the line should be removed
          if ((idx !== 0 && !keepLine) || (idx === 0 && personId)) {
            // generate selectKeys that need to be removed
            if (personId) {
              selectKeys.add(generateSelectKey(coupleId, personId))
            } else {
              const [id1, id2] = coupleId.split('_')
              selectKeys.add(generateSelectKey(coupleId, id1))
              selectKeys.add(generateSelectKey(coupleId, id2))
            }
          }
          // If we decided the line needed to be kept, add correct ids to stillSelected
          if (keepLine) {
            if (idx === 0) {
              stillSelected.push([coupleId, otherPersonId])
            } else {
              stillSelected.push([coupleId, personId].filter(Boolean))
            }
          }
        })
        stillSelected.length && newPaths.push(JSON.stringify(stillSelected))
      } else {
        newPaths.push(JSON.stringify(path))
      }
    })
    const parsed = [...newPaths].map((str) => JSON.parse(str))
    const altsToRemove = Object.values(state.selectedAltPids || {}).filter((person) => {
      return selectKeys?.has(person.treeLinkedSelectKey)
    })
    if (selectKeys.size + altsToRemove.length === 1) {
      // single node selected out of couple, no selections still exist past that point.
      removePid({ selectKeys: [...selectKeys], newPaths: parsed })
    } else {
      setRemoveData({ selectKeys: [...selectKeys], newPaths: parsed, altsToRemove })
      removeOverlay.handleClick(evt)
    }

    return { newPaths: parsed, selectKeys }
  })

  return {
    overlay: removeOverlay,
    selectKeys: removeData?.selectKeys,
    altsToRemove: removeData?.altsToRemove,
    removeHandler,
    checkRemove,
  }
}

export default useRemovePid
