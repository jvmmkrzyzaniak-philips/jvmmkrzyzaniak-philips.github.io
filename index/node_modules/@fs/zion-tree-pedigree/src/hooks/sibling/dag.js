import * as d3 from 'd3-dag'
import { v4 as uuid } from 'uuid'

const getNestedPropByPath = (path, data) => path.split('.').reduce((obj, nextProp) => obj?.[nextProp], data)

export function decross(layers, rankAccessor = 'data.node.data.rank') {
  layers.forEach((layer) => {
    // console.log('layer', layer)
    layer.sort((nodea, nodeb) => {
      // Sometimes we get 'findIndex' errors from d3-dag, and it turns out a 'link' type is getting into the layers here.
      // However, this is usually because we've screwed up the pedigree somewhere. Uncomment these to debug it.
      // if (nodea.data?.role === 'link') return -1
      // if (nodeb.data?.role === 'link') return -1
      const sortA = getNestedPropByPath(rankAccessor, nodea)?.toString().split('-')
      const sortB = getNestedPropByPath(rankAccessor, nodeb)?.toString().split('-')

      const idxToCompare = sortA.findIndex((num, i) => Number(num) !== Number(sortB[i]))
      return Number(sortA[idxToCompare]) - Number(sortB[idxToCompare])
    })
  })
}

const d3Stratify = d3.graphStratify()
const stratify = d3Stratify.id(({ dagId }) => dagId)

const layering = d3.layeringSimplex()
const coord = d3.coordQuad()

export const constants = {
  genHeight: 400,
  tileHeight: 270,
  coupleWidth: 372,
  coupleMargin: 12,
  padding: 140,
  nonDirectTileHeight: 230,
  nonDirectCoupleWidth: 316,
  nonDirectPadding: 70,
}

const nodeSize = ({ data }) => {
  let totalWidth
  if (data?.directLine) {
    totalWidth = constants.coupleWidth
    totalWidth += constants.padding
  } else {
    totalWidth = constants.nonDirectCoupleWidth
    totalWidth += constants.nonDirectPadding
  }
  const hasAltSpouses = [data.person1, data.person2].some((person) => person.hasMultipleFamiliesAsParent)
  const isCouple = (data.person1.name && data.person2.name) || Boolean(data.slotForExpand) || hasAltSpouses // slotForExpand means it's an add node
  const actualWidth = isCouple ? totalWidth : totalWidth / 1.7
  return [actualWidth, constants.genHeight]
}
const layout = d3.sugiyama().layering(layering).decross(decross).coord(coord).nodeSize(nodeSize)

export default function dagify(pedigree) {
  const dagIds = new Set()
  const pidsInTree = new Set()
  const duplicateMapping = {}
  const pedigreeWithLabelledDuplicates = pedigree.map((couple) => {
    const currentId = couple?.dagId
    if (dagIds.has(currentId)) {
      couple.dagId = uuid()
    } else {
      couple.dagId = currentId
    }
    // Most coupleIds are going to be around 17 chars long e.g. "ABCD-EFG_1234-567" if length is quite long (we'll go with 25 for now), we're dealing with a uuid from a duplicate node
    couple.isDuplicate = Boolean(couple.dagId.length > 25) && !couple.isGoldenHint
    if (couple.isDuplicate) {
      // Keep track of which node ids correspond to which uuids. This is crucial for looping pedigree support as well as the logic for collapse/expand
      duplicateMapping[couple.dagId] = couple.id
    }
    dagIds.add(currentId)
    couple.person1?.id && pidsInTree.add(couple.person1.id)
    couple.person2?.id && pidsInTree.add(couple.person2.id)
    return couple
  })

  const dag = stratify(pedigreeWithLabelledDuplicates)

  const { width, height } = layout(dag)
  const renderedNodes = [...(dag?.nodes() || [])]
  const renderedLinks = [...(dag?.links() || [])]

  return { pedigree: dag, renderedNodes, renderedLinks, height, width, pidsInTree, duplicateMapping }
}
