import { isValidPid } from '@fs/zion-pid'
import { getNameRelatedData } from '@fs/zion-person-service'
import { trackEvent } from '@fs/zion-analytics'
import type { MutGraphNode } from 'd3-dag'
import { v4 as uuid } from 'uuid'
import type { Gender, PersonId } from '@fs/zion-tree-types'
import dagify, { decross as sortByRank } from './dag'
import type {
  PedigreeNode,
  useSiblingReturn,
  rankNodesArg,
  PersistPedigreeArgs,
  SiblingState,
  PersonObj,
  AddFindProps,
} from './useSiblingPedigreeTypes'
import { pedigreeDebug } from '../../utils/shared'

export const coupleIdsAreEqual = ({ coupleId, compareId }): boolean => {
  // need this check for add parents
  const equalWithoutUnknown = coupleId?.replace('_UNKNOWN', '') === compareId?.replace('_UNKNOWN', '')
  return coupleId === compareId || coupleId?.split('_').reverse().join('_') === compareId || equalWithoutUnknown
}

export const coupleIdIncludesPersonId = ({ coupleId, personId }): boolean => {
  if (!personId || personId === 'UNKNOWN') return false
  return coupleId.includes(personId)
}

export const findChildNodes = ({ state, dagId }): PedigreeNode[] => {
  // Need to turn it into a dag structure first
  const { pedigree } = state?.pedigree ? dagify(state?.pedigree) : { pedigree: undefined }
  const roots = [...(pedigree.roots() || [])]

  // Nodes we want to keep but that might be in the descendants calls
  const childNodes: PedigreeNode[] = []

  let done = false
  roots.forEach((root) => {
    const descendants: MutGraphNode<PedigreeNode, PedigreeNode>[] = [...(root.descendants() || [])]
    descendants.forEach((node) => {
      if (done) return

      if (node?.data?.dagId === dagId) {
        done = true
        const children = Array.from(node?.children() || [])
        children.forEach((n) => {
          n?.data && childNodes.push(n.data)
        })
      }
    })
  })

  return childNodes
}

// This function takes the pedigree and converts it to a dag structure, after which it identifies which node we clicked on, and removes the appropriate branches from the tree
export const collapseAscendants = ({
  state,
  parentCoupleId,
  parentDagId,
  emptyNodeId,
  dagId,
  isExpandUp,
}: {
  state: SiblingState
  parentCoupleId: string
  parentDagId: string
  dagId: string
  emptyNodeId?: string
  isExpandUp?: boolean
}): PedigreeNode[] => {
  let newPedigree = state.pedigree.slice()
  // console.log('dagId', dagId)
  // Need to turn it into a dag structure first
  const { pedigree } = state?.pedigree ? dagify(state?.pedigree) : { pedigree: undefined }
  const roots = [...(pedigree.roots() || [])]

  // Nodes we want to keep but that might be in the descendants calls
  const keepAround = new Set()
  let clickedNode
  let depthForExpandUp // figure out what depth we are at.
  roots.forEach((root) => {
    const dagIdSet = new Set()
    let includeLine = false
    const depthObj = {} // Build a picture of which depths contain which id's relative to this branch.
    // go through each line and figure out which one we are removing nodes from.
    const descendants = [...(root.descendants() || [])]
    descendants.forEach((node) => {
      // Multiple root lines may go through this node, which is why we have to rely on parentDagId
      const dagOrId = parentDagId || parentCoupleId // cached calls on expand up will not have a parentDagId, so we need to look at the couple
      if ([dagOrId, emptyNodeId].some((id) => id === node?.data?.dagId)) {
        // found the parent. This descendant branch is the one we will be removing nodes from
        includeLine = true
      }
      // dagId is unique, build a set for this branch
      dagIdSet.add(node?.data?.dagId)
      // use y values to determine depth. Nodes at same level should have same y value.
      depthObj[node?.uy] ||= new Set()
      depthObj[node?.uy].add(node?.data?.dagId)
      // Find which node we clicked on, exclude descendants of that node as we need to keep those around.
      if (!clickedNode && node?.data.dagId === dagId) {
        clickedNode = node
        depthForExpandUp = node?.uy
        // console.log('clicked', node)
        const desc = [...(clickedNode.descendants() || [])]
        // These nodes are further down the line from where we clicked, so track these to make sure we don't get rid of them
        desc.forEach((n) => {
          keepAround.add(n?.data?.dagId)
        })
      }
    })

    // console.log(depthObj)
    // console.log('depth', depthForExpandUp, includeLine)
    // if this root line had our clicked dagId and its parents, we need to filter out all the other nodes from this root
    if (dagIdSet.has(dagId) && includeLine) {
      // console.log(dagIdSet)
      // if we are expanding up, we do not want to remove all ancestors from the branch, just the adjacent siblings (to avoid duplication)
      // ... unless we're adding parents to an empty node.
      const setToCheck = isExpandUp && !emptyNodeId ? depthObj[depthForExpandUp] : dagIdSet
      newPedigree = newPedigree.filter(
        // Keep it around if it's not in the current line (setToCheck), is the clicked node, or is further down the line than where we clicked (keepAround)
        // All others should be pruned (siblings, ancestors, etc)
        (n) => !setToCheck.has(n?.dagId) || n?.dagId === dagId || keepAround.has(n.dagId)
      )
      // Now that we have removed nodes, we need to ensure the parentIds array on the clickedNode is accurate, or else d3-dag will break
      clickedNode.data.parentIds = clickedNode.data.parentIds.filter((id) => isExpandUp || !setToCheck.has(id))
      // console.log(newPedigree)
    }
  })
  // console.log('new', newPedigree)
  return newPedigree
}

export const collapseChildren = ({ state, dagId }): PedigreeNode[] => {
  // Need to turn it into a dag structure first
  const { pedigree } = state?.pedigree ? dagify(state?.pedigree) : { pedigree: undefined }
  const nodesToRemove = new Set()
  const nodes = [...(pedigree.nodes() || [])]
  nodes.forEach((couple) => {
    const { data } = couple
    // remove all descendants of this node
    if (data?.dagId === dagId) {
      const descendants = [...(couple.descendants() || [])]
      descendants.forEach(({ data: nestedDescendant }) => {
        // do not include clicked node
        if (nestedDescendant?.dagId !== dagId) {
          nodesToRemove.add(nestedDescendant?.dagId)
        }
      })
    }
  })

  return state.pedigree.filter((node) => !nodesToRemove.has(node?.dagId))
}

export const normalizedCoupleId = ({ id1 = 'UNKNOWN', id2 = 'UNKNOWN', coupleId }): string => {
  if (coupleId) {
    if (coupleId.startsWith('_')) {
      return `UNKNOWN${coupleId}`
    }
    if (coupleId.endsWith('_')) {
      return `${coupleId}UNKNOWN`
    }
    // single POF nodes need UNKNOWN added, to not break functionality
    if (!coupleId.includes('_')) {
      return `${coupleId}_UNKNOWN`
    }
    return coupleId
  }
  if ([id1, id2].every((id) => id === 'UNKNOWN')) return ''
  return `${id1}_${id2}`
}

export const parentIdContainsValidPid = (parentId): boolean => {
  const [p1, p2] = parentId?.split('_') || []
  return isValidPid(p1) || isValidPid(p2)
}

export const pathToRoot = async ({ state, dagId, clickedId }): Promise<string[][]> => {
  const newPedigree = state.pedigree.slice()
  const parentData = {}
  const pedigreeObj = {}

  // Build object structures of pedigree for reference later.
  newPedigree.forEach((node) => {
    parentData[node?.dagId] = node.parentIds
    pedigreeObj[node?.dagId] = node
  })

  const { pedigree } = state?.pedigree ? dagify(state?.pedigree) : { pedigree: undefined }
  const roots = [...(pedigree.roots() || [])]

  let rootsEncountered = 0 // track/compare paths to how many root nodes we've seen.
  const calculatePaths = ({
    id,
    path = [],
    arr = [],
    resolve,
    fromClicked = false,
  }: {
    id: string
    path?: string[]
    arr?: string[][]
    resolve: (value: string[][]) => void
    fromClicked?: boolean
  }): void => {
    const parents = parentData[id] || []
    if (!parents.length) {
      arr.push([...path, id])
      rootsEncountered++
      // If we're travelling up from the clicked node, we only care about hitting the first root.
      if (roots.length === rootsEncountered || fromClicked) {
        resolve(arr)
      }
    }
    parents.forEach((parentId) => {
      const newPath = [...path, id]
      calculatePaths({ id: parentId, path: newPath, arr, resolve, fromClicked })
    })
  }

  const allPathsFromRoot: string[][] = await new Promise((resolve) => {
    calculatePaths({ id: state?.pofDagId, resolve })
  })

  const pathFromClickedToEdge = await new Promise((resolve) => {
    calculatePaths({ id: dagId, resolve, fromClicked: true })
  })
  let pathsRootIdx
  // Find point at which two paths intersect, save that pid. Helps when path goes up and then back down again.
  const connectingPid = pathFromClickedToEdge?.[0]?.find((id) =>
    allPathsFromRoot.some((nestedArr, idx) => {
      if (nestedArr.includes(id)) {
        pathsRootIdx = idx
        return true
      }
      return false
    })
  )

  const pathsArr = allPathsFromRoot[pathsRootIdx]

  // Convert couple path to single id path for selecting.
  const buildPath = (coupleDagId, idx, arr): string[] => {
    // figure out if next node on path is for parent1 or parent2
    const { person1, person2 } = pedigreeObj[coupleDagId] || {}
    const parents1 = person1?.parentsIds
    const parents2 = person2?.parentsIds
    const pathInfo = [coupleDagId]
    const wasClickedNode = dagId === coupleDagId

    const nextParents = arr[idx + 1]
    if (nextParents) {
      if (nextParents === parents1) {
        pathInfo.push(person1?.id)
      } else if (nextParents === parents2) {
        pathInfo.push(person2?.id)
      }
    }
    if (!nextParents && connectingPid) {
      if (connectingPid === parents1) {
        pathInfo.push(person1?.id)
      } else if (connectingPid === parents2) {
        pathInfo.push(person2?.id)
      }
    }
    if (wasClickedNode && pathInfo[1] && pathInfo[1] !== clickedId) {
      pathInfo.pop()
    }

    return pathInfo
  }

  const idxOfConnectorFromRoot = pathsArr.indexOf(connectingPid)
  const idxOfConnectorFromClicked = pathFromClickedToEdge?.[0].indexOf(connectingPid)

  // trim any generations that may be above us in the tree, but not necessary to draw path from root to clicked node
  const couplePathFromRoot = pathsArr.slice(0, idxOfConnectorFromRoot)
  const couplePathFromClicked = pathFromClickedToEdge?.[0].slice(0, idxOfConnectorFromClicked)

  const finalPathFromRoot = couplePathFromRoot.map(buildPath)
  const finalPathFromClicked = couplePathFromClicked.map(buildPath)

  // If not going back down another line, the tip of the path is where we clicked, and we know they will be related to the root, so specify a pid
  // Not specifying a pid will lead to both nodes being selected in the reducer
  const connectingPidEntry = finalPathFromClicked.length ? [connectingPid] : [connectingPid, clickedId]

  const fullPath = [...finalPathFromRoot, connectingPidEntry, ...finalPathFromClicked.reverse()]
  return Promise.resolve(fullPath)
}

export const selectTest = ({
  selectProps,
  person,
}: {
  selectProps: Record<string, unknown>[] | Record<string, unknown> | undefined
  person: Record<string, unknown> | undefined
}): boolean => {
  if (!selectProps) return true
  if (Array.isArray(selectProps)) {
    return selectProps.some((subset) => Object.entries(subset).every(([key, val]) => person?.[key] === val))
  }
  return Object.entries(selectProps).every(([key, val]) => person?.[key] === val)
}

export const genderForAddSlot = ({ id, slot }): string => {
  if (id === 'UNKNOWN' && slot === 1) {
    return 'MALE'
  }
  if (id === 'UNKNOWN' && slot === 2) {
    return 'FEMALE'
  }
  return ''
}

export const persistImportantNodeValues = ({
  oldNode,
  newNode,
  oldParentIds,
}: {
  oldNode: PedigreeNode
  newNode: PedigreeNode
  oldParentIds?: string
}): PedigreeNode => {
  // filter out the old parent ids in the case of replacing them during add spouse
  const parentIds = oldNode?.parentIds?.filter((parentId) => parentId !== oldParentIds) || []
  newNode.directLine = oldNode?.directLine
  if (newNode.person1) {
    newNode.person1.siblingsAreVisible = oldNode.person1?.siblingsAreVisible
    if (!newNode.person1.hasSiblings) {
      newNode.person1.hasSiblings = oldNode.person1?.hasSiblings
    }

    // In the case a new children coming in, spouses of the child will not have parentsIds set, so we need to copy over the old ones
    if (!oldParentIds || oldParentIds !== oldNode.person1.parentsIds) {
      newNode.person1.parentsIds = oldNode.person1.parentsIds
    }
  }
  if (newNode.person2) {
    newNode.person2.siblingsAreVisible = oldNode.person2?.siblingsAreVisible
    if (!newNode.person2.hasSiblings) {
      newNode.person2.hasSiblings = oldNode.person2?.hasSiblings
    }
    // In the case a new children coming in, spouses of the child will not have parentsIds set, so we need to copy over the old ones
    if (!oldParentIds || oldParentIds !== oldNode.person2.parentsIds) {
      newNode.person2.parentsIds = oldNode.person2.parentsIds
    }
  }
  if (oldNode.rank) {
    newNode.rank = oldNode.rank
  }
  if (oldNode.isPof) {
    newNode.isPof = oldNode.isPof
  }

  if (oldNode.parentIds?.length) {
    const allIds = new Set(newNode.parentIds?.concat?.(parentIds) || [])
    newNode.parentIds = [...Array.from(allIds)]
  }

  return newNode
}

export const switchParentId = ({ state, oldParentsCoupleId, newParentsCoupleId }): PedigreeNode[] => {
  return state.pedigree.map((couple) => {
    if (couple.person1.parentsIds === oldParentsCoupleId) {
      couple.person1.parentsIds = newParentsCoupleId
    }
    if (couple.person2.parentsIds === oldParentsCoupleId) {
      couple.person2.parentsIds = newParentsCoupleId
    }
    return couple
  })
}
export const markNotVisible = ({ stateCopy, dagId, personId }): void => {
  // When collapsing sibling lines, need to identify who we clicked on and set siblingsAreVisible flag so that arrow direction is correct.
  const clickedNode = stateCopy.pedigree.find((node) => node.dagId === dagId)
  if (!clickedNode) throw Error('Collapse Siblings could not identify clicked node')
  const person = clickedNode.person1.id === personId ? 'person1' : 'person2'
  clickedNode[person].siblingsAreVisible = false
}

export const selectKey = (dagId, personId): string => `${dagId}~${personId}`

// function to help us determine who in the generation is on an edge, so we can render lines appropriately
export const sortAndAddEdgeData = (nodes): void => {
  sortByRank([nodes], 'rank')
  nodes
    .filter((n) => n.visible !== false)
    .forEach((node, i, arr) => {
      node.isEdge = Boolean(i === 0 || i === arr.length - 1)
    })
}

export const rankNewNodes = ({
  secondGen,
  parentNode,
  childNodes,
  siblingIdx,
  rank,
  isPerson1,
  isExpandUp,
}: rankNodesArg): void => {
  const [tempRank, ...restOfDescRank] = rank.toString().split('-')
  let rankToUse = Number(tempRank)
  if (isExpandUp) {
    if (!isPerson1) {
      rankToUse = Number(rankToUse) + 1
    } else {
      rankToUse = Number(rankToUse)
    }
  }

  if (isExpandUp) {
    parentNode && (parentNode.rank = rankToUse * 2)
    const isSecondGen1ParentNodePerson1Parents = secondGen?.[0]?.dagId === parentNode?.person1?.parentsIds
    const secondGen1 = isSecondGen1ParentNodePerson1Parents ? secondGen?.[0] : secondGen?.[1]
    const secondGen2 = isSecondGen1ParentNodePerson1Parents ? secondGen?.[1] : secondGen?.[0]
    if (parentNode?.rank) {
      const secondGenP1Rank = Number(parentNode.rank) * 2
      const secondGenP2Rank = (Number(parentNode.rank) + 1) * 2
      secondGen1 && (secondGen1.rank = secondGenP1Rank.toString())
      secondGen2 && (secondGen2.rank = secondGenP2Rank.toString())
    }
    childNodes.forEach((node, idx) => {
      // rank determines display order for d3-dag
      // if we're looking at siblings of person 1, we need to decrease rank value, so we have to look at the overall length of the array and subtract current index to avoid inverting the order
      const toLeftOrRightCalc = isPerson1 ? -((childNodes.length - idx) * 0.01) : idx * 0.01 + 0.01
      node.rank = ((isPerson1 ? rankToUse : rankToUse - 1) + toLeftOrRightCalc).toString()
    })
  } else {
    const prevDescRankString = restOfDescRank.length ? `-${restOfDescRank.join('-')}` : ''
    childNodes.forEach((node, i) => {
      node.rank = (rankToUse / 2).toString().concat(siblingIdx ? `${prevDescRankString}-${i + 1}` : `-${i + 1}`)
    })
  }
}

export const copyOldNodeValuesToNew = ({ oldNode, newNode, emptyNodeId }): void => {
  const { person1, person2 } = newNode
  const parentIds = oldNode.parentIds || []
  newNode.directLine = oldNode.directLine
  if (person1 && oldNode.person1?.parentsIds !== emptyNodeId) {
    person1.parentsIds = oldNode.person1?.parentsIds
  }
  if (person2 && oldNode.person2?.parentsIds !== emptyNodeId) {
    person2.parentsIds = oldNode.person2?.parentsIds
  }

  if (oldNode.rank) {
    newNode.rank = oldNode.rank
  }
  if (oldNode.isPof) {
    newNode.isPof = oldNode.isPof
  }
  if (newNode.parentIds) {
    const allIds = new Set(newNode.parentIds?.concat?.(parentIds) || [])
    newNode.parentIds = [...Array.from(allIds)]
  } else {
    newNode.parentIds = parentIds
  }
  if (oldNode.person1?.parentHints && !newNode.person1?.parentHints) {
    // Sometimes the children data does not include parentHints, so we need to copy them over from the old node
    newNode.person1.parentHints = oldNode.person1.parentHints
  }
  if (oldNode.person2?.parentHints && !newNode.person2?.parentHints) {
    // Sometimes the children data does not include parentHints, so we need to copy them over from the old node
    newNode.person2.parentHints = oldNode.person2.parentHints
  }

  newNode.parentIds = newNode.parentIds?.filter((parentId) => parentId !== emptyNodeId)
  if (person1) {
    person1.hasSiblings = oldNode.person1.hasSiblings
    // keep correct siblingsAreVisible value, especially when expanding sibling line from spouse
    person1.siblingsAreVisible = oldNode.person1.siblingsAreVisible || person1?.siblingsAreVisible
  }
  if (person2) {
    person2.hasSiblings = oldNode.person2.hasSiblings
    // keep correct siblingsAreVisible value, especially when expanding sibling line from spouse
    person2.siblingsAreVisible = oldNode.person2.siblingsAreVisible || person2?.siblingsAreVisible
  }
}

// This function copies over important property values that we need from the clicked node or it's parent in the previous pedigree, to the same person in the new data.
// TODO: Look into whether we can use this function to replace persistImportantNodeValues as well. They do pretty much the same thing
export const persistPedigreePersonData = ({
  parentGen,
  secondGen,
  childrenGen,
  pedigree,
  emptyNodeId,
  clickedNodeDag,
  coupleId,
}: PersistPedigreeArgs): {
  updatedChildrenNodes: PedigreeNode[]
  updatedParentNode: PedigreeNode
  updatedSecondGenNodes: PedigreeNode[]
} => {
  const currentPedigreeObj = pedigree.reduce((obj, nextCouple) => {
    obj[nextCouple.dagId] = nextCouple
    return obj
  }, {})

  // when the server calls come back, and we are comparing with the already rendered/cached data, we need to know which nodes are expected to be duplicates
  // (cached data being updated via this call), versus those which would be actual duplicates and need new dagIds
  const clickedNode = currentPedigreeObj[clickedNodeDag]
  const clickedNodeCurrentParent1 = currentPedigreeObj[clickedNode?.parentIds?.[0]]
  const clickedNodeCurrentParent2 = currentPedigreeObj[clickedNode?.parentIds?.[1]]
  // for knowing which line we are working up towards if there are multiple parents attached to this node
  const clickedNodeCurrentParent = [clickedNodeCurrentParent1, clickedNodeCurrentParent2].find(
    (node) => node?.id === coupleId
  )
  const clickedNode2ndGen1 = currentPedigreeObj[clickedNodeCurrentParent?.parentIds?.[0]]
  const clickedNode2ndGen2 = currentPedigreeObj[clickedNodeCurrentParent?.parentIds?.[1]]
  const parentGenInPedigree =
    currentPedigreeObj[parentGen?.[0]?.dagId] ||
    currentPedigreeObj[parentGen?.[0]?.dagId.split('_').reverse().join('_')] // make sure we double check for the reversed couple order
  let parentGenIsDuplicate = false
  let secondGen1IsDuplicate = false
  let secondGen2IsDuplicate = false
  const secondGen1InPedigree =
    currentPedigreeObj[secondGen?.[0]?.dagId] ||
    currentPedigreeObj[secondGen?.[0]?.dagId.split('_').reverse().join('_')] // make sure we double check for the reversed couple order
  const secondGen2InPedigree =
    currentPedigreeObj[secondGen?.[1]?.dagId] ||
    currentPedigreeObj[secondGen?.[1]?.dagId.split('_').reverse().join('_')] // make sure we double check for the reversed couple order

  // If we have clickedNodeCurrentParentclick/clickedNode2ndGen1/clickedNode2ndGen2, the cache rendered and we're dealing with a server call
  // If those exist and we get duplicates, we want to use those dagIds (which should be a uuid) so we don't overwrite the existing dagId
  const parentDagIdIfDuplicate = clickedNodeCurrentParent?.dagId || uuid()

  const secondGen1DagIfDuplicate = clickedNode2ndGen1?.dagId || uuid()
  const secondGen2DagIfDuplicate = clickedNode2ndGen2?.dagId || uuid()

  if (parentGenInPedigree && !clickedNode.parentIds.includes(parentGenInPedigree?.dagId)) {
    // parent node already exists in the pedigree, but is not present in the parentIds of the node we clicked
    parentGen[0].isDuplicate = true
    parentGen[0].dagId = parentDagIdIfDuplicate
    parentGenIsDuplicate = true
  }
  if (
    secondGen1InPedigree &&
    !parentGenInPedigree?.parentIds.some((id) =>
      coupleIdsAreEqual({ coupleId: id, compareId: secondGen1InPedigree?.dagId })
    )
  ) {
    // secondGen1 node already exists in the pedigree, but is not present in the parentIds of the parentGen node
    secondGen[0].isDuplicate = true
    secondGen[0].dagId = secondGen1DagIfDuplicate
    secondGen1IsDuplicate = true
  }

  if (
    (secondGen2InPedigree &&
      !parentGenInPedigree?.parentIds.some((id) =>
        coupleIdsAreEqual({ coupleId: id, compareId: secondGen2InPedigree?.dagId })
      )) ||
    (Boolean(secondGen?.[0]?.dagId) && secondGen?.[0]?.dagId === secondGen?.[1]?.dagId) // account for possibility of both secondGen nodes being brand new, and identical, causing looping pedigree.
  ) {
    // secondGen2 node already exists in the pedigree, but is not present in the parentIds of the parentGen node
    secondGen[1].isDuplicate = true
    secondGen[1].dagId = secondGen2DagIfDuplicate
    secondGen2IsDuplicate = true
  }
  // update parentGen node's dagIds array to include the new dagIds if they were duplicates
  let updatedSecondGenNodes
  if (!parentGenIsDuplicate) {
    parentGen[0].parentIds = [
      secondGen1IsDuplicate ? secondGen1DagIfDuplicate : secondGen[0]?.dagId,
      secondGen2IsDuplicate ? secondGen2DagIfDuplicate : secondGen[1]?.dagId,
    ].filter(Boolean)
    updatedSecondGenNodes = secondGen || []
  } else {
    // if the parent generation is a duplicate, we don't want to include the second generation nodes in the new pedigree call
    updatedSecondGenNodes = []
    parentGen[0].parentIds = [] // also ensure we don't carry over parentIds
  }

  const updatedChildrenNodes = childrenGen.map((couple) => {
    const coupleInPedigree = currentPedigreeObj[couple.dagId]
    if (!coupleInPedigree) {
      // If parentGenInPedigree was found, we need to adjust the child's parentIds array
      if (parentGenIsDuplicate) {
        couple.parentIds = [parentDagIdIfDuplicate]
      }
      return couple
    }

    // NODE WAS ALREADY FOUND IN PEDIGREE AT THIS POINT, fix up data to be accurate
    if (parentGenInPedigree && parentGenIsDuplicate) {
      // child in new pedigree call, make sure we're updating their parentIds array
      couple.parentIds = couple.parentIds.filter((id) => id !== parentGen[0]?.id).concat(parentDagIdIfDuplicate)
    }
    if (coupleInPedigree.dagId !== clickedNodeDag) {
      // The node is in the pedigree, but it is not the node being expanded from
      // Ignore the node here and we will mark it as duplicate inside the dagify function
      return couple
    }

    if (coupleIdsAreEqual({ coupleId: couple?.id, compareId: coupleInPedigree.id })) {
      copyOldNodeValuesToNew({ oldNode: coupleInPedigree, newNode: couple, emptyNodeId })
    }
    return couple
  })
  if (parentGenInPedigree && !parentGenIsDuplicate) {
    const newNode = parentGen[0]
    copyOldNodeValuesToNew({ oldNode: parentGenInPedigree, newNode, emptyNodeId })
  }
  if (secondGen1InPedigree && !secondGen1IsDuplicate) {
    const newNode = secondGen[0]
    copyOldNodeValuesToNew({ oldNode: secondGen1InPedigree, newNode, emptyNodeId })
  }
  if (secondGen2InPedigree && !secondGen2IsDuplicate) {
    const newNode = secondGen[1]
    copyOldNodeValuesToNew({ oldNode: secondGen2InPedigree, newNode, emptyNodeId })
  }
  const updatedParentNode = parentGen[0]

  return { updatedChildrenNodes, updatedParentNode, updatedSecondGenNodes }
}

export const resetExpansionOrdering = (state: SiblingState): void => {
  const allExpansions = Object.values({ ...state.ascExpansions, ...state.descExpansions })
  allExpansions
    .sort((a, b) => (a?.order || 0) - (b?.order || 0))
    .forEach((expansion, idx) => {
      expansion.order = idx + 1
    })
}

export const calculateAddFindProps = ({
  type,
  person,
  otherPerson,
  coupleId,
  relatedChild,
  relatedChildSpouse,
  parent1,
  parent2,
  position1,
  pofId,
  couple,
  directLine,
  dagId,
  x,
  y,
  rank,
  siblingIdx,
  childNode,
  handleExpandUp,
  handleExpandDown,
  handleCollapseAscendants,
  addSpouse,
  getChildDagIdAndPerson,
}: {
  type: string
  person: PersonObj
  otherPerson: PersonObj
  coupleId: string
  relatedChild: PersonObj
  relatedChildSpouse: PersonObj
  parent1: PersonId
  parent2: PersonId
  position1: boolean
  pofId: PersonId
  couple: { recordUrl: string; id: string; dagId: string; slotForExpand?: number }
  directLine: boolean
  dagId: string
  x: number
  y: number
  rank: number
  siblingIdx: number
  childNode: PedigreeNode & { x: number; y: number }
  handleExpandUp: useSiblingReturn['handleExpandUp']
  handleExpandDown: useSiblingReturn['handleExpandDown']
  handleCollapseAscendants: useSiblingReturn['handleCollapseAscendants']
  addSpouse: useSiblingReturn['addSpouse']
  getChildDagIdAndPerson: useSiblingReturn['getChildDagIdAndPerson']
  parentIds: string[]
}): AddFindProps => {
  const { namePart1: firstName, namePart2: lastName } = getNameRelatedData(person)
  const isPof = [otherPerson?.id, person?.id].includes(pofId)

  const addFindFlowProps: AddFindProps = {
    operationType: type,
    recordInfo: couple?.recordUrl
      ? {
          recordURL: couple.recordUrl,
          name: person?.name || '',
          sex: (person?.gender?.toUpperCase() as Gender) || 'UNKNOWN',
        }
      : undefined,
    initialValues: couple?.recordUrl
      ? {
          nameTemplate: { en: { firstName, lastName } },
          status: 'deceased',
          sex: person.gender?.toLowerCase() || 'unknown',
          birthDate: person?.birth?.details?.date,
          birthPlace: person?.birth?.details?.place,
        }
      : {},
  }

  const onRecordDismiss = (): void => {
    handleCollapseAscendants({
      dagId: childNode?.dagId,
      parentCoupleId: couple?.id,
      parentDagId: couple?.dagId || '',
      x,
      y,
      personId: relatedChild?.id,
      dropHint: true,
    })
  }
  type AddFindSuccessObj = {
    coupleId?: string
    relationship?: {
      parents?: {
        parent1Id: string
        parent2Id: string
      }
    }
    person?: PersonObj & { spouse?: { id: string } }
  }

  const onSuccess = (data: AddFindSuccessObj): void => {
    trackEvent({ event_name: `Sibling Add Overlay: ${addFindFlowProps.operationType}` })
    switch (type) {
      case 'addChild':
        if (!directLine || isPof) {
          handleExpandDown({
            dagId,
            coupleId,
            x,
            y,
            rank,
            siblingIdx,
            showSiblings: false,
            isPerson1: false,
            parentDagId: '',
            emptyNodeId: '',
            correctChildSpouseId: '',
          })
        } else {
          const { childDagId, correctChildSpouseId, personId, childRank } = getChildDagIdAndPerson(coupleId)
          handleExpandUp({
            coupleId,
            personId,
            childDagId,
            correctChildSpouseId,
            showSiblings: true,
            x,
            y,
            rank: childRank,
            isPerson1: position1,
            parentDagId: '',
            correctChildCoupleId: '',
            emptyNodeId: '',
            childCoupleId: '',
          })
        }
        break
      case 'addSibling':
        handleExpandUp({
          coupleId: person?.parentsIds,
          childCoupleId: coupleId,
          childDagId: dagId,
          personId: person?.id,
          correctChildSpouseId: otherPerson?.id,
          x,
          y,
          rank,
          showSiblings: true,
          isPerson1: position1,
          parentDagId: '',
          correctChildCoupleId: '',
          emptyNodeId: '',
        })
        break
      case 'addSpouse':
      case 'addSpouse1':
      case 'addSpouse2': {
        const newCoupleId =
          data?.coupleId || `${data?.relationship?.parents?.parent1Id}_${data?.relationship?.parents?.parent2Id}`
        addSpouse({
          dagId,
          coupleId: newCoupleId,
          x,
          y,
        })
        break
      }
      case 'addParent':
      case 'addParents':
      case 'addParent1':
      case 'addParent2': {
        const newPersonId = data?.person?.id
        const newPersonSpouseId = data?.person?.spouse?.id
        let newCoupleId = `${newPersonId}_UNKNOWN`

        if (newPersonSpouseId) {
          newCoupleId = `${newPersonId}_${newPersonSpouseId}`
        } else if (data?.person?.gender?.toLowerCase() === 'female') {
          newCoupleId = `UNKNOWN_${newPersonId}`
        }

        handleExpandUp({
          coupleId: newCoupleId,
          childCoupleId: childNode?.id,
          childDagId: childNode?.dagId,
          personId: relatedChild?.id,
          correctChildSpouseId: relatedChildSpouse?.id,
          emptyNodeId: couple?.dagId,
          x: childNode?.x,
          y: childNode?.y,
          rank: childNode?.rank,
          isPerson1: couple?.slotForExpand === 1,
          showSiblings: false,
          parentDagId: '',
          correctChildCoupleId: '',
        })
        break
      }
      default:
        pedigreeDebug('no case found')
    }
  }

  switch (type) {
    case 'addChild': {
      addFindFlowProps.operationType = 'addChild'
      if (position1) {
        addFindFlowProps.relatedParent1 = isValidPid(person?.id) ? person : undefined
        addFindFlowProps.relatedParent2 = isValidPid(otherPerson?.id) ? otherPerson : undefined
      } else {
        addFindFlowProps.relatedParent1 = isValidPid(otherPerson?.id) ? otherPerson : undefined
        addFindFlowProps.relatedParent2 = isValidPid(person?.id) ? person : undefined
      }
      break
    }
    case 'addSibling': {
      addFindFlowProps.operationType = 'addChild'
      addFindFlowProps.relatedParent1 = { id: parent1 }
      addFindFlowProps.relatedParent2 = { id: parent2 }
      break
    }
    case 'addSpouse':
    case 'addSpouse1':
    case 'addSpouse2': {
      const isUnknownTile = person?.id === 'UNKNOWN'
      addFindFlowProps.relatedChildOrSpouse = isUnknownTile ? otherPerson : person
      if (position1) {
        addFindFlowProps.operationType = isUnknownTile ? 'addSpouse1' : 'addSpouse2'
      } else {
        addFindFlowProps.operationType = isUnknownTile ? 'addSpouse2' : 'addSpouse1'
      }
      break
    }
    case 'addParent': {
      addFindFlowProps.operationType = 'addParents'
      addFindFlowProps.relatedChildOrSpouse = relatedChild
      break
    }
    default: {
      console.error(`No operationType set for AddPeopleOverlay. Current: ${addFindFlowProps.operationType}`)
    }
  }
  return { ...addFindFlowProps, onRecordDismiss, onSuccess }
}
