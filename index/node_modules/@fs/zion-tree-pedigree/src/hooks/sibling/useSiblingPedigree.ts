import { useRef, useEffect, useCallback, useReducer } from 'react'
import cloneDeep from 'lodash.clonedeep'
import { useGroupsContext, clearLastViewedPid, switchTree } from '@fs/zion-tree-groups'
import { useEvent } from '@fs/zion-frontend-friends'
import type { MutGraphNode } from 'd3-dag'
import { useInfoSheet, useOverlay, useStatusOverlay } from '@fs/zion-ui'
import { useTranslation } from 'react-i18next'
import Cache from '@fs/zion-cache'
import { useFeatureFlag } from '@fs/zion-flags'
import dagify from './dag'
import { usePedigreeViewOptions } from '../../pedigree-view-options'
import {
  markNotVisible,
  collapseAscendants,
  collapseChildren,
  findChildNodes,
  parentIdContainsValidPid,
  pathToRoot,
  coupleIdsAreEqual,
  persistImportantNodeValues,
  switchParentId,
  selectKey,
  sortAndAddEdgeData,
  rankNewNodes,
  persistPedigreePersonData,
  resetExpansionOrdering,
} from './helpers'
import { pedigreeDebug } from '../../utils/shared'
import getPedigree, { emptyNode, hintNode, clearCache as clearAscendancyCache } from '../../service/sibling/ascendancy'
import type {
  Dagified,
  Err,
  FetchAndDispatchFamilyArgs,
  ExpansionCacheArgs,
  nodeOrIdsArgs,
  PedigreeNode,
  SelectModeStatePaths,
  SiblingAction,
  SiblingState,
  useSiblingReturn,
} from './useSiblingPedigreeTypes'

// exported for testing
export const expansionCache = new Cache({ storeName: 'portrait_expansions', type: 'local' })
export const expansionKey = 'expansionData'
const updateExpansionCache = (stateCopy: SiblingState): void => {
  expansionCache.setItem(expansionKey, {
    asc: stateCopy.ascExpansions,
    desc: stateCopy.descExpansions,
    pofId: stateCopy.pofId,
  })
}

const nodeOrIdsIncludesPersonAndSpouse = ({ node, nodeIds, personId, spouseId }: nodeOrIdsArgs): boolean => {
  const actuallyHasSpouse = spouseId && spouseId !== 'UNKNOWN'
  const whatToCheck = node?.id || nodeIds || []
  const includesPerson = whatToCheck.includes(personId)
  if (actuallyHasSpouse) {
    return includesPerson && whatToCheck.includes(spouseId)
  }
  return includesPerson
}

const reducer = (state: SiblingState, theAction: SiblingAction): SiblingState => {
  let stateCopy: SiblingState = cloneDeep(state)
  const action: SiblingAction = cloneDeep(theAction) // the cache service seems to reuse the same object, and we get weird behavior without this.
  // let newState: SiblingState = {pedigree: [], stateCopy}
  pedigreeDebug('action', action)
  switch (action.type) {
    case 'SET_POF':
      if (!action.initialState) throw Error('must include initial state')
      stateCopy = { ...action.initialState, pofId: action?.pofId || '' }
      break
    case 'ADD_EMPTY': {
      const nodeBeingAddedTo = stateCopy.pedigree.find(({ dagId }) => dagId === action?.dagId)
      const parentNode = action.parentHints?.length
        ? hintNode({ rank: action.rank, isPerson1: action.isPerson1, parentHints: action.parentHints })
        : emptyNode({ rank: action.rank, isPerson1: action.isPerson1 })
      if (!nodeBeingAddedTo) throw Error('No node found to add to')
      const isPerson1Parents = nodeBeingAddedTo?.person1.id === action.personId
      parentNode.childNode = nodeBeingAddedTo
      if (isPerson1Parents) {
        nodeBeingAddedTo.person1.parentsIds = parentNode.dagId
        parentNode.relatedChild = 'person1'
        parentNode.slotForExpand = 1
      } else {
        nodeBeingAddedTo.person2.parentsIds = parentNode.dagId
        parentNode.relatedChild = 'person2'
        parentNode.slotForExpand = 2
      }
      nodeBeingAddedTo?.parentIds.push(parentNode.dagId)
      stateCopy = { ...stateCopy, pedigree: stateCopy.pedigree.concat(parentNode) }
      break
    }
    case 'ADD_SPOUSE': {
      const nodeBeingAddedTo = stateCopy.pedigree.find(({ dagId }) => dagId === action?.dagId)
      if (!nodeBeingAddedTo || !action.parents || !action.children) throw Error('could not find node to add spouse to')
      const newNode = persistImportantNodeValues({
        oldNode: nodeBeingAddedTo,
        newNode: action.parents,
      })
      const childNodes: PedigreeNode[] = findChildNodes({ dagId: action?.dagId, state: stateCopy })
      const childDagIds = childNodes.map(({ dagId }) => dagId)
      action.children.forEach((child: PedigreeNode) => {
        if (childDagIds.includes(child?.dagId)) {
          const oldNode = childNodes.find(({ dagId }) => dagId === child?.dagId)
          oldNode && persistImportantNodeValues({ oldNode, newNode: child, oldParentIds: action.dagId })
        }
      })
      const newPedigree = stateCopy.pedigree.filter(({ dagId }) => ![action?.dagId, ...childDagIds].includes(dagId))
      stateCopy = { ...stateCopy, pedigree: newPedigree.concat(newNode, action.children) }
      break
    }
    case 'EXPAND_DOWN': {
      // Make sure we are appending cleanly
      if (!action.dagId || !action.children || !action.rank) {
        console.log(action)
        throw Error('Must include dagId, children, rank, and expandDownArgs')
      }

      // if expansion has already been collapsed (slow network, cached data came back and user collapsed before server returned) do not render server expansion
      if (!stateCopy.descExpansions[action.dagId]) break

      const resetPedigree = collapseChildren({ ...action, state: stateCopy })
      rankNewNodes({ childNodes: action.children, siblingIdx: action.siblingIdx, rank: action.rank })
      sortAndAddEdgeData(action.children)
      if (action.children.length > 1) {
        action.children.forEach((child) => {
          child.isSibling = true
        })
      }

      // Update the parents' hasChildren for case when adding a child to a person with no children
      // We can always infer this to be true since we're expanding down
      resetPedigree.forEach((couple) => {
        if (couple.id.includes(action.dagId) && action.children?.length) {
          couple.coupleHasChildren = true
          // parent node needs to not show loading spinner any more
          couple.loadingDesc = false
        }
      })

      const clicked = action.clickedNode || {}
      stateCopy = { ...stateCopy, pedigree: resetPedigree.concat(action.children), clickedNode: clicked }
      break
    }

    case 'EXPAND_UP': {
      if (!action?.pedigree?.parentGen) return stateCopy // cache empty or was cleared by user
      const { personId, coupleId, childDagId, parentDagId, emptyNodeId, isPerson1, rank, correctChildSpouseId } = action
      if (!personId || isPerson1 === undefined || !rank || !correctChildSpouseId || !childDagId || !coupleId) {
        throw Error(`One or more args for expand up were omitted: `)
      }
      // if expansion has already been collapsed (slow network, cached data came back and user collapsed before server returned) do not render server expansion
      if (!stateCopy.ascExpansions[`${childDagId}:${personId}`]) break

      const spouseId = correctChildSpouseId
      const { secondGen = [], parentGen, childrenGen = [] } = action.pedigree
      rankNewNodes({
        secondGen,
        parentNode: parentGen?.[0],
        childNodes: childrenGen,
        rank,
        isPerson1,
        isExpandUp: true,
      })

      // START - Figure out if the siblings from this expansion are visible
      const length = [...parentGen, ...childrenGen].length || 0
      const nonSecondGen = [...parentGen, ...childrenGen]
      secondGen.forEach((node) => {
        node.visible = true
        node.directLine = true
      })
      nonSecondGen.forEach((node) => {
        // Check and see if any new nodes are on the direct line
        const idsAreEqual = coupleIdsAreEqual({ coupleId: node?.id, compareId: coupleId })
        if (idsAreEqual || nodeOrIdsIncludesPersonAndSpouse({ personId, node, spouseId })) {
          node.directLine = true
          node.visible = true
          // SiblingsAreVisible is used to determine direction of sibling expander arrow.
          // If we determine that the node found is the one we clicked on, set property according to whether it was via parent or sibling button
          if (node.person1?.id?.includes(personId)) {
            length > 2 && (node.person1.siblingsAreVisible = action.showSiblings) // if length < 2 there are no siblings
          }
          if (node.person2?.id?.includes(personId)) {
            length > 2 && (node.person2.siblingsAreVisible = action.showSiblings) // if length < 2 there are no siblings
          }
        }
        // Depending on whether we expanded up or via the siblings arrow, determine whether a node should be visible.
        // If we're adding parents, the node may be a couple where the action.coupleId is a single person. Without includes we set the node to not visible.
        // There may be a better way to do this
        if (!idsAreEqual && !nodeOrIdsIncludesPersonAndSpouse({ node, personId, spouseId })) {
          node.visible = action.showSiblings
          node.isSibling = true
        }
      })
      // END - Figure out if the siblings from this expansion are visible

      // collapsing pedigree above connection point is how we do cache/server without duplicating nodes
      let resetPedigree: PedigreeNode[] = collapseAscendants({
        emptyNodeId,
        parentCoupleId: coupleId,
        parentDagId,
        dagId: childDagId,
        state: stateCopy,
        isExpandUp: true,
      })

      // update all the couples in current pedigree with new info from action.pedigree
      const { updatedChildrenNodes, updatedParentNode, updatedSecondGenNodes } = persistPedigreePersonData({
        pedigree: resetPedigree,
        secondGen,
        parentGen,
        childrenGen: childrenGen.filter((node) => node.visible), // If marked as not visible, it's a sibling node and we don't need those unless action.showSiblings was true
        emptyNodeId,
        clickedNodeDag: childDagId,
        coupleId,
      })

      sortAndAddEdgeData(updatedChildrenNodes)

      // Take the existing pedigree, remove the node we just clicked on, and its parent, as those have since been updated with new data, and we don't want duplicates
      // This is a delicate thing when it comes to looping pedigrees – be sure you know what you're doing if you mess with this.
      const clickedNodeParent = updatedParentNode // need the updated value rather than the one passed, in case we detected a duplicate with persistPedigreePersonData
      const secondGen1 = updatedSecondGenNodes[0]
      const secondGen2 = updatedSecondGenNodes[1]
      const idsToFilterOn = [
        action.clickedNode?.dagId,
        clickedNodeParent?.dagId,
        secondGen1?.dagId,
        secondGen2?.dagId,
      ].filter(Boolean)

      resetPedigree = resetPedigree.filter((node) => {
        return !idsToFilterOn.includes(node?.dagId)
      })

      const newPedigree = resetPedigree.concat(...updatedSecondGenNodes, clickedNodeParent, ...updatedChildrenNodes)

      stateCopy = {
        ...stateCopy,
        pedigree: newPedigree,
        clickedNode: action.clickedNode?.x ? action.clickedNode : stateCopy.clickedNode,
      }
      break
    }
    case 'EXPANSION_DATA': {
      const { dagId } = action
      const expansionNode = stateCopy.pedigree.find((node) => node.dagId === dagId)
      const allExpansions = Object.values({ ...stateCopy.ascExpansions, ...stateCopy.descExpansions })
      if ('expandUpArgs' in action) {
        const nextNumber = action.expandUpArgs?.order || allExpansions.length + 1
        const obj = { ...action.expandUpArgs, order: nextNumber }
        stateCopy.ascExpansions[`${dagId}:${action.expandUpArgs.personId}`] = obj

        if (expansionNode) {
          const keyToUse = action.expandUpArgs.showSiblings ? 'loadingSiblingsPid' : 'loadingAscPid'
          expansionNode[keyToUse] = action.expandUpArgs.personId // used for loading spinners on the tiles
        }
      }
      if ('expandDownArgs' in action) {
        const nextNumber = action.expandDownArgs?.order || allExpansions.length + 1
        const obj = { ...action.expandDownArgs, order: nextNumber }
        stateCopy.descExpansions[dagId] = obj

        expansionNode && (expansionNode.loadingDesc = true)
      }
      updateExpansionCache(stateCopy)
      break
    }
    case 'COLLAPSE_CHILDREN': {
      if (!action.dagId) throw Error('dagId needed for collapsing expansions')
      const pedigreeObj = {}

      const newPedigree = collapseChildren({ dagId: action.dagId, state: stateCopy })
      // Build object structures of pedigree for reference later.
      newPedigree.forEach((node) => {
        pedigreeObj[node?.dagId] = node
      })
      const descExpansionsToDelete = Object.keys(stateCopy.descExpansions).filter((dagId) => {
        return !pedigreeObj[dagId]
      })
      delete stateCopy.descExpansions[action.dagId]
      descExpansionsToDelete.forEach((dagId) => {
        delete stateCopy.descExpansions[dagId]
      })
      const clicked = action.clickedNode || {}

      stateCopy = { ...stateCopy, pedigree: newPedigree, clickedNode: clicked }
      resetExpansionOrdering(stateCopy)
      updateExpansionCache(stateCopy)
      break
    }
    case 'COLLAPSE_ASCENDANTS': {
      if (!action.dagId) throw Error('dagId needed for collapsing expansions')
      const pedigreeObj = {}

      const newPedigree = collapseAscendants({ ...action, state: stateCopy })
      newPedigree.forEach((node) => {
        pedigreeObj[node?.dagId] = node
      })
      const ascExpansionsToDelete = Object.keys(stateCopy.ascExpansions).filter((dagId) => {
        // ascExpansion keys are in the format of 'dagId:personId', since each node can have 2 expansions off of it, one for each parent
        const [key] = dagId.split(':')
        return !pedigreeObj[key]
      })
      const ascExpansionKey = `${action.dagId}:${action.personId}`
      delete stateCopy.ascExpansions[ascExpansionKey]
      ascExpansionsToDelete.forEach((key) => {
        delete stateCopy.ascExpansions[key]
      })
      const { person1: clickedP1, person2: clickedP2 } = pedigreeObj[action.dagId] || {
        person1: undefined,
        person2: undefined,
      }
      const clickedPerson = [clickedP1, clickedP2].find((person) => person?.id === action.personId)
      if (action.dropHint) {
        // Record hint dismissed, so remove it from the array
        clickedPerson.parentHints.shift()
      }

      if (clickedP1 && !pedigreeObj[clickedP1.parentsIds] && clickedP1.parentsIds?.length > 25) {
        clickedP1.parentsIds = undefined
      }
      if (clickedP2 && !pedigreeObj[clickedP2.parentsIds] && clickedP2.parentsIds?.length > 25) {
        clickedP2.parentsIds = undefined
      }

      markNotVisible({ stateCopy, personId: action.personId, dagId: action.dagId })

      stateCopy = { ...stateCopy, pedigree: newPedigree, clickedNode: action.clickedNode || {} }
      resetExpansionOrdering(stateCopy)
      updateExpansionCache(stateCopy)

      break
    }
    case 'COLLAPSE_SIBLINGS': {
      const spouseId = action.clickedNodeSpouseId
      const personId = action.personId || ''
      const parentDagId = action.parentDagId || ''
      const dagId = action.dagId
      // Need to turn it into a dag structure first
      const { pedigree }: Dagified = stateCopy?.pedigree ? dagify(stateCopy?.pedigree) : {}
      const nodesToRemove = new Set()
      const nodes: MutGraphNode<PedigreeNode, PedigreeNode>[] | undefined[] = [...Array.from(pedigree.nodes() || [])]
      markNotVisible({ stateCopy, personId, dagId: action.dagId })

      nodes.forEach((couple) => {
        const { data } = couple
        // find any couples with the same parent as the node we clicked, that are not the one we clicked.
        if (
          data?.parentIds?.includes(parentDagId) &&
          !nodeOrIdsIncludesPersonAndSpouse({ node: data, personId, spouseId })
        ) {
          const descendants = [...Array.from(couple.descendants() || [])]
          descendants.forEach(({ data: nestedDescendant }) => {
            // make sure we remove any descendants of those siblings
            nodesToRemove.add(nestedDescendant?.dagId)
          })
        }
      })

      const newPedigree = stateCopy.pedigree.filter((node) => !nodesToRemove.has(node?.dagId))

      const ascParentExpansionKey = `${parentDagId}:${personId}`
      if (stateCopy.ascExpansions[ascParentExpansionKey]) {
        stateCopy.ascExpansions[ascParentExpansionKey].showSiblings =
          !stateCopy.ascExpansions[ascParentExpansionKey].showSiblings
      }
      const ascDagExpansionKey = `${dagId}:${personId}`
      if (dagId && stateCopy.ascExpansions[ascDagExpansionKey]) {
        stateCopy.ascExpansions[ascDagExpansionKey].showSiblings = false
      }
      const clicked = action.clickedNode || {}

      stateCopy = { ...stateCopy, pedigree: newPedigree, clickedNode: clicked }
      break
    }
    case 'ERROR': {
      // clean up loading states
      const pedigree = stateCopy.pedigree.map((node) => {
        return {
          ...node,
          loadingDesc: false,
          loadingAscPid: '',
        }
      })
      stateCopy = { ...stateCopy, pedigree, errorCode: action.errorCode }
      break
    }
    case 'INIT': {
      if (!action.pedigree) return stateCopy

      stateCopy = {
        ...stateCopy,
        pedigree: action.pedigree || [],
        clickedNode: {},
        pofDagId: action.pedigree?.[0]?.dagId,
      }
      break
    }
    case 'CHANGE_ALTERNATE_PARENTS': {
      const newPedigree = switchParentId({
        state: stateCopy,
        oldParentsCoupleId: action.oldParentsCoupleId,
        newParentsCoupleId: action.newParentsCoupleId,
      })

      stateCopy = {
        ...stateCopy,
        pedigree: newPedigree,
        clickedNode: {},
      }
      break
    }
    case 'REFRESH_PEDIGREE': {
      const { dagId, pedigree, personId = '' } = action

      const isPof = personId === stateCopy.pofId
      const newPedigree = stateCopy.pedigree.map((oldNode) => {
        const newNode = pedigree?.find(
          (node) => node.dagId === oldNode.dagId || (oldNode.dagId.includes(personId) && node.dagId === dagId)
        )
        if (!newNode) return oldNode
        return persistImportantNodeValues({ oldNode, newNode })
      })

      stateCopy = {
        ...stateCopy,
        pedigree: newPedigree,
        pofDagId: isPof ? dagId : stateCopy.pofDagId,
        clickedNode: {},
      }
      break
    }
    case 'ADD_PID': {
      if (!action.connectingPath) throw Error('Need connecting path for ADD_PID')
      const connectingPath = action.connectingPath
      const pedigreeObj: Record<string, PedigreeNode> = {}
      const selected = stateCopy.selectedPids || {}

      const statePaths = [...(stateCopy.selectedPidPaths || [])]
      const newPaths: SelectModeStatePaths = []
      let alreadyAdded = false
      statePaths.forEach((path) => {
        const [shorter, longer] = path.length < connectingPath.length ? [path, connectingPath] : [connectingPath, path]
        const pathIsNested = shorter.every(([coupleDag], idx) => {
          const [cId] = longer[idx] || []
          if (!cId) return false
          if (cId === coupleDag) {
            return true
          }
          return false
        })
        if (pathIsNested) {
          const merged = longer.map((data, idx) => {
            const [coupleDag, pid] = data
            const [coupleDag2, pid2] = shorter[idx] || []
            if (coupleDag2 && pid !== pid2) {
              return [coupleDag]
            }
            return pid ? [coupleDag, pid] : [coupleDag]
          })
          newPaths.push(merged)
          alreadyAdded = true
        } else {
          newPaths.push(path)
        }
      })

      !alreadyAdded && newPaths.push(connectingPath)

      stateCopy.pedigree.forEach((node) => {
        pedigreeObj[node?.dagId] = node
      })
      connectingPath.forEach(([connectDagId, personId]) => {
        const node = pedigreeObj[connectDagId]
        const { person1, person2 } = node

        if (personId) {
          const rightPerson = person1?.id === personId ? person1 : person2
          const key = selectKey(connectDagId, personId)
          selected[key] = rightPerson
        } else {
          const key1 = selectKey(node.dagId, person1?.id)
          const key2 = selectKey(node.dagId, person2?.id)
          person1 && (selected[key1] = person1)
          person2 && (selected[key2] = person2)
        }
      })
      // update selected paths, as new selections can result in old paths having slightly incorrect data on whether just 1 or 2 of the pids is selected
      // if a path currently has a personId but we find another path where the personId is not included, we need to remove the personId from the path
      newPaths.forEach((arr) => {
        arr.forEach((segment, idx) => {
          const [cId, personId] = segment
          const [p1, p2] = cId.split('_')
          const key1 = selectKey(cId, p1)
          const key2 = selectKey(cId, p2)
          if (personId && selected[key1] && selected[key2]) {
            // both parents are selected, so we can remove the personId from the path
            arr[idx] = [cId]
          }
        })
      })
      stateCopy = { ...stateCopy, selectedPids: selected, selectedPidPaths: newPaths }
      break
    }
    case 'ADD_ALT_PID': {
      if (!action.personObj) throw Error('personObj required')
      const selectedAltPids = stateCopy.selectedAltPids || {}
      const parent = action.personObj.parent
      if (parent) {
        const isParentChecked = Boolean(selectedAltPids?.[parent.id])
        !isParentChecked && (selectedAltPids[parent.id] = parent)
        selectedAltPids[action.personObj.id] = { ...action.personObj, altParentSelectId: parent?.id }
      } else {
        selectedAltPids[action.personObj.id] = action.personObj
      }
      // remove UNKNOWN id from the list and from being passed to the call
      delete selectedAltPids.UNKNOWN
      stateCopy = { ...stateCopy, selectedAltPids }
      break
    }
    case 'REMOVE_ALT_PID': {
      if (!action.id) throw Error('id required')

      if (stateCopy.selectedAltPids) {
        delete stateCopy.selectedAltPids[action.id]
        const alsoRemove = Object.values(stateCopy.selectedAltPids).filter(
          (person) => person?.altParentSelectId === action.id
        )
        alsoRemove.forEach((person) => {
          delete stateCopy.selectedAltPids?.[person?.id]
        })
      }
      break
    }
    case 'REMOVE_PID': {
      if (!stateCopy.selectedPids) throw Error('No pids to remove from')

      action.selectKeys?.forEach((key) => {
        delete stateCopy.selectedPids?.[key]
      })

      // Also remove any previously selected alternate spouses and children associated with this pid
      if (action.altsToRemove) {
        action.altsToRemove.forEach((alt) => {
          delete stateCopy.selectedAltPids?.[alt.id]
        })
      }

      const selectedPidPaths = action.newPaths || stateCopy.selectedPidPaths
      stateCopy = { ...stateCopy, selectedPidPaths }
      break
    }
    case 'ADD_FIND_PROPS': {
      return { ...state, addFindProps: action.props }
    }
    default:
      throw new Error('Not a valid type')
  }
  try {
    // Similar to below – may put back later, but these were masking other legitimate errors and making debugging difficult.
    // stateCopy.pedigree = removeNonExistentParentIds(stateCopy)
    // stateCopy.pedigree = removeOrphanCouples(stateCopy)
    const { width, height, renderedNodes, renderedLinks, pidsInTree, duplicateMapping } = dagify(stateCopy.pedigree)
    const newState = { ...stateCopy, width, height, renderedNodes, renderedLinks, pidsInTree, duplicateMapping }
    pedigreeDebug('state result', newState)
    return newState
  } catch (err) {
    expansionCache.clear()
    pedigreeDebug('error in reducer', stateCopy)
    console.error(err)
    return {
      ...state,
      dagError: true,
    }
  }
}

const initialState: SiblingState = {
  pofId: '',
  pedigree: [],
  clickedNode: {},
  errorCode: undefined,
  ascExpansions: {},
  descExpansions: {},
  width: 0,
  height: 0,
  dagError: false,
  renderedNodes: [],
  pidsInTree: new Set(),
  duplicateMapping: {},
  addFindProps: undefined,
}

export default function useSiblingPedigree({
  pofId,
  selectHandler,
  selectMode,
  selectOnlyOne,
}: {
  pofId: string
  selectHandler: (string: string) => void
  selectMode: boolean
  selectOnlyOne: boolean
}): useSiblingReturn {
  const [state, dispatch] = useReducer(reducer, initialState)
  const showStatusOverlay = useStatusOverlay()
  const relationshipChangedOverlay = useOverlay()
  const { open: openRelationshipChangedOverlay } = relationshipChangedOverlay
  const { currentTreeId, selectTree, isResearcherGroup } = useGroupsContext()
  const goldenHintsFlagOn = useFeatureFlag('treeWeb_goldenHints')?.isOn
  const isMounted = useRef(true)
  const initialized = useRef(false)
  const refreshedAfterError = useRef(0)
  const { t } = useTranslation()

  useEffect(() => {
    isMounted.current = true
    return () => {
      isMounted.current = false
    }
  }, [])
  const {
    prefsState: { showTemple, prefs, loading: prefsLoading },
    setReloadCallback,
  } = usePedigreeViewOptions(true)

  useEffect(() => {
    initialized.current = false
    dispatch({ type: 'SET_POF', pofId, initialState })
  }, [pofId])

  // NOTE: addPid and addAltPid have short-circuits built into them when in selectOnlyOne mode, because it felt easier to just return with the selected person at this point, instead of getting lost in all of the complex state management for the various sub-components.

  const addPid: useSiblingReturn['addPid'] = useEvent(async ({ dagId, clickedId }): Promise<void> => {
    if (!selectOnlyOne || pofId === clickedId) {
      // The pofId check is to allow the focus person to still have their highlight
      const connectingPath = await pathToRoot({ state, dagId, clickedId })
      dispatch({ type: 'ADD_PID', connectingPath })
    } else {
      selectHandler(clickedId)
    }
  })

  const addAltPid: useSiblingReturn['addAltPid'] = useEvent((personObj) => {
    if (!selectOnlyOne) {
      const treeLinkedSelectKey = personObj.treeLinkedSelectKey
      if (treeLinkedSelectKey && !state.selectedPids?.[treeLinkedSelectKey]) {
        const [linkedDagId, linkedPid] = treeLinkedSelectKey.split('~')
        addPid({ dagId: linkedDagId, clickedId: linkedPid })
      }
      dispatch({ type: 'ADD_ALT_PID', personObj })
    } else {
      selectHandler(personObj.id)
    }
  })

  const removeAltPid: useSiblingReturn['removeAltPid'] = useEvent((id) => {
    dispatch({ type: 'REMOVE_ALT_PID', id })
  })

  const removePid: useSiblingReturn['removePid'] = useCallback(({ selectKeys, newPaths, altsToRemove }): void => {
    dispatch({ type: 'REMOVE_PID', selectKeys, newPaths, altsToRemove })
  }, [])

  // Need this outside of the handler so that our closure isn't stale by the time it's checking properties on state.
  const canAddExpansion = useEvent(
    (
      pedigree: { parentGen: PedigreeNode[]; childrenGen: PedigreeNode[] },
      childCoupleId: string,
      coupleId: string,
      correctChildCoupleId: string
    ): boolean => {
      // if we can't find the child in the new pedigree, it probably means the parent-child relationship doesn't exist anymore
      const childRelationshipNotFound = !pedigree.childrenGen?.find((couple) => couple?.id?.includes(childCoupleId))
      const parentRelationshipNotFound = !pedigree.parentGen?.find((couple) => couple?.id?.includes(coupleId))
      const [childId1, childId2] = correctChildCoupleId.split('_').filter(Boolean)
      const child1InTree = childId1 ? state.pidsInTree.has(childId1) : true
      const child2InTree = childId2 ? state.pidsInTree.has(childId2) : true
      const childCoupleToExpandFromIsInTree = child1InTree && child2InTree
      if (
        !pedigree.parentGen ||
        childRelationshipNotFound ||
        parentRelationshipNotFound ||
        !childCoupleToExpandFromIsInTree
      ) {
        expansionCache.clear()
        openRelationshipChangedOverlay()
        return false
      }
      return true
    }
  )

  const fetchAndDispatchFamily = useEvent((args: FetchAndDispatchFamilyArgs): void => {
    const {
      personId,
      coupleId,
      parentDagId,
      childCoupleId,
      childDagId,
      emptyNodeId,
      showSiblings,
      x,
      y,
      isPerson1,
      rank,
      correctChildSpouseId,
      correctChildCoupleId,
      turnObj,
      order,
    } = args
    const [server, cache] = getPedigree({
      coupleId,
      correctChildCoupleId,
      treeId: currentTreeId,
      showTemple,
      prefs,
      goldenHintsFlagOn,
    })
    const waiting = order && turnObj
    const handler = (pedigree: {
      parentGen: PedigreeNode[]
      childrenGen: PedigreeNode[]
      secondGen: PedigreeNode[]
    }): void => {
      if (!pedigree?.childrenGen) return // likely that the cache was empty
      if (!canAddExpansion(pedigree, childCoupleId, coupleId, correctChildCoupleId)) return // couldn't find relationships for expansion

      dispatch({
        type: 'EXPAND_UP',
        pedigree,
        personId,
        coupleId,
        parentDagId,
        childDagId,
        emptyNodeId, // only included when we're adding parents
        showSiblings,
        clickedNode: { x, y, dagId: childDagId },
        correctChildSpouseId,
        isPerson1,
        rank,
      })
    }
    dispatch({ type: 'EXPANSION_DATA', expandUpArgs: args, dagId: childDagId })
    !turnObj &&
      cache.then(handler).catch((err) => {
        dispatch({ type: 'ERROR', errorCode: '' })
        expansionCache.clear()
        console.error(err)
      })
    return server
      .then((data) => {
        let timeout
        const interval = setInterval(() => {
          if (order === turnObj?.turn || !waiting) {
            handler(data)
            if (turnObj) {
              turnObj.turn += 1
            }
            clearInterval(interval)
            clearTimeout(timeout)
          }
        }, 100)
        timeout = setTimeout(() => {
          // if calls take too long, stop polling
          clearInterval(interval)
          expansionCache.clear()
          dispatch({ type: 'ERROR', errorCode: '' }) // clean up remaining spinners
        }, 20000)
      })
      .catch((err) => {
        // This probably means a relationship was changed, like one parent was removed
        expansionCache.clear()
        dispatch({ type: 'ERROR', errorCode: '' })

        if (err?.response?.status === 400) {
          return openRelationshipChangedOverlay()
        }
        return console.error(err)
      })
  })
  const handleExpandDown: useSiblingReturn['handleExpandDown'] = useEvent((args): void => {
    const { dagId, coupleId, x, y, rank, siblingIdx, turnObj, order } = args
    const waiting = turnObj && order
    const [server, cache] = getPedigree({
      coupleId,
      treeId: currentTreeId,
      showTemple,
      prefs,
      goldenHintsFlagOn,
    })
    const handler = (pedigree: { childrenGen: PedigreeNode[] }): void => {
      if (!pedigree?.childrenGen) return // likely that the cache was empty
      dispatch({
        type: 'EXPAND_DOWN',
        children: pedigree.childrenGen,
        dagId,
        rank,
        siblingIdx,
        clickedNode: { x, y, dagId },
      })
    }
    dispatch({ type: 'EXPANSION_DATA', expandDownArgs: args, dagId })
    if (!turnObj) {
      cache.then(handler).catch((err) => {
        dispatch({ type: 'ERROR', errorCode: '' })
        expansionCache.clear()
        console.error(err)
      })
    }
    return server
      .then((data) => {
        let timeout
        const interval = setInterval(() => {
          if (order === turnObj?.turn || !waiting) {
            handler(data)
            if (turnObj) {
              turnObj.turn += 1
            }
            clearInterval(interval)
            clearTimeout(timeout)
          }
        }, 100)
        timeout = setTimeout(() => {
          // if calls take too long, stop polling
          clearInterval(interval)
          expansionCache.clear()
          dispatch({ type: 'ERROR', errorCode: '' }) // clean up remaining spinners
        }, 20000)
      })
      .catch((err) => {
        // This probably means a relationship was changed, like one parent was removed
        dispatch({ type: 'ERROR', errorCode: '' })
        expansionCache.clear()
        if (err?.response?.status === 400) {
          return openRelationshipChangedOverlay()
        }
        return console.error(err)
      })
  })
  const fetchAndDispatchPOF = useEvent((ignoreCache?: boolean) => {
    const handler = async (pedigree: PedigreeNode[]): Promise<void> => {
      if (pedigree) {
        const coupleOfFocus = pedigree?.find((couple) => couple?.id?.includes(pofId))
        const personOfFocus = coupleOfFocus?.person1.id === pofId ? coupleOfFocus?.person1 : coupleOfFocus?.person2

        switchTree({ focusPerson: personOfFocus, currentTreeId, selectTree, isResearcherGroup })
        dispatch({ type: 'INIT', pedigree })
        await expansionCache.getItem(expansionKey).then((expansions: ExpansionCacheArgs) => {
          const { desc, asc, pofId: expansionPofId } = expansions || {}
          if (expansionPofId === pofId) {
            // shared turnObj to ensure we expand up/down in the right order
            const turnObj = { turn: 1 }
            // we want a maximum of 10 total expansions allowed, so get rid of all expansions past that
            const ascExpansions = Object.values(asc).filter((exp) => exp.order < 10)
            const descExpansions = Object.values(desc).filter((exp) => exp.order < 10)

            descExpansions.forEach((exp) => handleExpandDown({ ...exp, turnObj }))
            ascExpansions.forEach((exp) => fetchAndDispatchFamily({ ...exp, turnObj }))
          } else {
            expansionCache.clear()
          }
        })
      }
    }
    const errorHandler = (err: Err): void => {
      if (err?.message) {
        // Most errors will have a code. If there is a network error, however, the response may be empty.
        dispatch({ type: 'ERROR', errorCode: err.response?.status || err.message })
        expansionCache.clear()
        clearLastViewedPid('pedigree')
      }
    }
    const [server /* cache */] = getPedigree({
      pofId,
      gens: 3,
      treeId: currentTreeId,
      prefs,
      showTemple,
      isInitialLoad: true,
      goldenHintsFlagOn,
    })
    if (!ignoreCache) {
      // cache.then(handler)
    }
    return server.then(handler).catch(errorHandler)
  })

  const { dagError } = state

  const handleRefreshPOF = useEvent(async (): Promise<void> => {
    await clearAscendancyCache()
    dispatch({ type: 'SET_POF', pofId, initialState })
    fetchAndDispatchPOF()
  })

  useEffect(() => {
    // A bit hacky, yes, but this allows users to keep going, while not masking errors when we're in dev mode.
    if (dagError && window?.location?.href.includes('familysearch')) {
      if (refreshedAfterError.current < 2) {
        showStatusOverlay({ message: t('tw.pedigree.error.refreshing'), type: 'warning', transient: true })
        handleRefreshPOF()
        // this prevents an infinite loop if there's really something wrong with the pedigree
        refreshedAfterError.current++
      } else {
        dispatch({ type: 'ERROR', errorCode: 500 })
      }
    }
  }, [dagError, fetchAndDispatchPOF, handleRefreshPOF, pofId, showStatusOverlay, t])

  useEffect(() => {
    if (!initialized.current && !prefsLoading) {
      fetchAndDispatchPOF()
      initialized.current = true
    }
  }, [fetchAndDispatchPOF, prefsLoading, pofId])

  useEffect(() => {
    // Select root node pof by default in select mode
    // Wait on pofDagId since that get set in INIT
    if (initialized.current && state.pofDagId && selectMode) {
      addPid({ dagId: state.pofDagId, clickedId: state.pofId })
    }
  }, [addPid, selectMode, state.pofDagId, state.pofId])

  const handleCollapseDesc: useSiblingReturn['handleCollapseDesc'] = useEvent(({ dagId, x, y }): void => {
    dispatch({ type: 'COLLAPSE_CHILDREN', dagId, clickedNode: { x, y, dagId } })
  })

  const handleCollapseSiblings: useSiblingReturn['handleCollapseSiblings'] = useCallback(
    ({ parentDagId, dagId, personId, x, y, clickedNodeSpouseId }): void => {
      dispatch({
        type: 'COLLAPSE_SIBLINGS',
        dagId,
        parentDagId,
        personId,
        clickedNodeSpouseId,
        clickedNode: { x, y, dagId },
      })
    },
    []
  )

  const handleCollapseAscendants: useSiblingReturn['handleCollapseAscendants'] = useCallback(
    ({ dagId, parentCoupleId, parentDagId, x, y, personId = '', dropHint }): void => {
      dispatch({
        type: 'COLLAPSE_ASCENDANTS',
        dagId,
        parentCoupleId,
        parentDagId,
        personId,
        clickedNode: { x, y, dagId },
        dropHint,
      })
    },
    []
  )

  const addSpouse: useSiblingReturn['addSpouse'] = useEvent(({ dagId, coupleId, x, y }): void => {
    // we don't need a cached call here since the data should be brand new
    const [server] = getPedigree({
      coupleId,
      treeId: currentTreeId,
      showTemple,
      prefs,
      goldenHintsFlagOn,
    })
    const handler = (pedigree: { parentGen: PedigreeNode[]; childrenGen: PedigreeNode[] }): void => {
      dispatch({
        type: 'ADD_SPOUSE',
        parents: pedigree.parentGen?.[0],
        children: pedigree.childrenGen,
        dagId,
        clickedNode: { x, y, dagId },
      })
    }

    server.then(handler).catch(console.error)
  })

  const getChildDagIdAndPerson: useSiblingReturn['getChildDagIdAndPerson'] = useEvent((dagId) => {
    const parentNode = state.renderedNodes.find((node) => node.data.dagId === dagId)
    if (!parentNode) throw Error('could not find parent node')
    const childCouple = Array.from(parentNode.children()).find((node) => node.data.directLine)
    if (!childCouple) throw Error('could not find childCouple node')
    const { person1, person2 } = childCouple.data
    const childId = [person1, person2].find((person) => person.parentsIds === dagId)?.id
    const childSpouseId = [person1?.id, person2?.id].find((id) => id !== childId)
    if (!childSpouseId || !childId) throw Error('could not find child or spouseIds')
    return {
      childDagId: childCouple.data.dagId,
      personId: childId,
      correctChildSpouseId: childSpouseId,
      childRank: childCouple.data.rank,
    }
  })

  const handleRefreshPedigree = useEvent(async () => {
    await fetchAndDispatchPOF(true)
    const turnObj = { turn: 1 }
    Object.values(state.ascExpansions).forEach((exp) => fetchAndDispatchFamily({ ...exp, turnObj }))
    Object.values(state.descExpansions).forEach((exp) => handleExpandDown({ ...exp, turnObj }))
  })
  const handleExpandUp: useSiblingReturn['handleExpandUp'] = useEvent(
    ({
      coupleId, // couple id of parent
      parentDagId, // dag id of parent
      childCoupleId,
      childDagId,
      personId,
      emptyNodeId,
      x,
      y,
      rank,
      isPerson1,
      correctChildSpouseId,
      showSiblings = false,
      parentHints,
    }): void => {
      if (!coupleId || !parentIdContainsValidPid(coupleId)) {
        dispatch({ type: 'ADD_EMPTY', rank, dagId: childDagId, personId, isPerson1, parentHints })
        return
      }

      // const [p1, p2] = coupleId?.split('_') || []
      // const [parent1Id] = [p1, p2].filter((id) => id !== 'UNKNOWN')
      fetchAndDispatchFamily({
        coupleId,
        parentDagId,
        childCoupleId,
        correctChildCoupleId: childCoupleId,
        childDagId,
        personId,
        emptyNodeId,
        showSiblings,
        x,
        y,
        isPerson1,
        rank,
        correctChildSpouseId,
      })
    }
  )

  const handleRefreshFamily: useSiblingReturn['handleRefreshFamily'] = useEvent(
    ({ coupleId, personId, dagId }): void => {
      const [server] = getPedigree({
        coupleId,
        treeId: currentTreeId,
        showTemple,
        prefs,
        refresh: true,
        goldenHintsFlagOn,
      })
      const handler = (pedigree: {
        parentGen: PedigreeNode[]
        childrenGen: PedigreeNode[]
        secondGen: PedigreeNode[]
      }): void => {
        if (!pedigree.parentGen?.length) return
        dispatch({
          type: 'REFRESH_PEDIGREE',
          pedigree: [...pedigree.parentGen, ...pedigree.childrenGen, ...pedigree.secondGen],
          personId,
          dagId,
        })
      }
      return server.then(handler).catch((err) => {
        dispatch({ type: 'ERROR', errorCode: '' })
        expansionCache.clear()
        console.error(err)
      })
    }
  )

  const handleAlternateParentsChange: useSiblingReturn['handleAlternateParentsChange'] = useEvent(
    ({ oldParentsCoupleId, newParentsCoupleId, coupleId, personId, dagId, correctChildSpouseId, rank, isPerson1 }) => {
      dispatch({
        type: 'COLLAPSE_ASCENDANTS',
        dagId,
        parentCoupleId: oldParentsCoupleId,
        parentDagId: oldParentsCoupleId,
        personId,
      })
      dispatch({ type: 'CHANGE_ALTERNATE_PARENTS', oldParentsCoupleId, newParentsCoupleId })
      handleExpandUp({
        coupleId: newParentsCoupleId,
        parentDagId: newParentsCoupleId,
        childCoupleId: coupleId,
        childDagId: dagId,
        personId,
        correctChildSpouseId,
        rank,
        isPerson1,
        emptyNodeId: '',
        showSiblings: false,
        x: 0,
        y: 0,
        correctChildCoupleId: '',
      })
    }
  )
  const addFindFlowOverlay = useInfoSheet()
  const resetAddFindProps = useEvent(() => dispatch({ type: 'ADD_FIND_PROPS', props: undefined }))
  const handleAddFindClick: useSiblingReturn['handleAddFindClick'] = useEvent((addFindProps) => {
    const props = {
      noMatch: isResearcherGroup,
      treeId: currentTreeId,
      ...addFindProps,
      onSuccess: (data) => {
        addFindProps.onSuccess?.(data)
        resetAddFindProps()
      },
      onRecordDismiss: () => {
        addFindFlowOverlay.close()
        addFindProps.onRecordDismiss?.()
      },
      onDismiss: resetAddFindProps,
    }
    dispatch({ type: 'ADD_FIND_PROPS', props })

    addFindFlowOverlay.open()
  })

  useEffect(() => {
    isMounted.current &&
      setReloadCallback(() => {
        handleRefreshPedigree()
      })
  }, [setReloadCallback, handleRefreshPedigree])

  const { dagId, x, y } = state?.clickedNode || {}
  if (dagId && x && !Number.isNaN(x) && state.renderedNodes && state.renderedLinks) {
    // Shift everything from the perspective of the clicked node
    const nodes = state.renderedNodes
    const links = state.renderedLinks
    const clickedNode = state?.renderedNodes?.find((node) => node.data.dagId === state.clickedNode.dagId)
    // If we don't clean up the state.clickedNode when that node no longer exists, we'll see weird shifts in the pedigree.
    // Ideally we'll just always do that correctly. However, if we don't, and we don't gate the logic below, the nodes get updated infinitely and the app crashes.
    if (clickedNode) {
      let xDiff = 0
      let yDiff = 0
      xDiff = x - (clickedNode?.x || 0)
      yDiff = y - (clickedNode?.y || 0)

      nodes.forEach((node) => {
        node.x += xDiff
        node.y += yDiff
      })
      links.forEach(({ points }) => {
        if (points.length) {
          points[0][0] += xDiff
          points[1][0] += xDiff
          points[0][1] += yDiff
          points[1][1] += yDiff
        }
      })
    }
  }

  return {
    state,
    height: state.height,
    width: state.width,
    handleExpandDown,
    handleExpandUp,
    handleCollapseDesc,
    handleCollapseAscendants,
    handleCollapseSiblings,
    handleRefreshPedigree,
    handleRefreshFamily,
    getChildDagIdAndPerson,
    addSpouse,
    addPid,
    addAltPid,
    removeAltPid,
    removePid,
    relationshipChangedOverlay,
    handleRefreshPOF,
    handleAlternateParentsChange,
    handleAddFindClick,
    addFindFlowOverlay,
  }
}
