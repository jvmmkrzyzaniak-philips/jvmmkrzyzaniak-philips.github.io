import zionDebug from '@fs/zion-debug'
import { path } from 'd3-path'

export const formatCoupleId = (coupleId) => {
  if (coupleId.includes('UNKNOWN_')) {
    return coupleId.split('_').reverse().join('_')
  }
  return coupleId
}

export const pedigreeDebug = zionDebug('tree:pedigrees')

// Function to connect nodes in sibling/landscape/portrait views
// NO TOUCHY!!!!!!!!!
// Seriously though, don't mess with this unless you REALLY know what you're doing, cause it will affect alllll those pedigrees, and a bunch of edge cases
export const connectNodes = ({
  portraitMode,
  node,
  parentNode,
  midPointPXAdjust = 0,
  radius = 0,
  skipSecondaryArc = false,
}) => {
  const singlePath = path()
  let realRadius = radius
  // Starting position
  const origin = { x: node.x, y: node.y }
  singlePath.moveTo(origin.x, origin.y)

  if (portraitMode) {
    const midPointY = (node.y + parentNode.y) / 2 + midPointPXAdjust

    // Figure out steps
    const step1 = { x: node.x, y: midPointY }
    const step2 = { x: parentNode.x, y: midPointY }
    const final = { x: parentNode.x, y: parentNode.y }
    const xDiff = node.x - final.x

    // if the radius would cause an overlap in lines, adjust it accordingly
    if (Math.abs(xDiff) < radius * 2) {
      realRadius = Math.floor(Math.abs(xDiff / 2))
    }
    if (origin.x === final.x) {
      singlePath.lineTo(final.x, final.y)
      return singlePath
    }
    // Draw line just short to just short of first point.
    // Figure out whether we need to curve up or down
    const curve = step2.x > step1.x ? realRadius : -realRadius
    singlePath.lineTo(step1.x, step1.y + realRadius)
    singlePath.arcTo(step1.x, step1.y, step1.x + curve, step1.y, realRadius)

    // add or subtract the radius
    singlePath.lineTo(step2.x + (!skipSecondaryArc ? -curve : 0), step2.y)
    singlePath.arcTo(step2.x, step2.y, step2.x, step2.y - realRadius, realRadius)

    singlePath.lineTo(final.x, final.y)
  } else {
    const midPointX = (node.x + parentNode.x) / 2 + midPointPXAdjust

    // Figure out steps
    const step1 = { x: midPointX, y: node.y }
    const step2 = { x: midPointX, y: parentNode.y }
    const final = { x: parentNode.x, y: parentNode.y }

    if (origin.y === final.y) {
      singlePath.lineTo(final.x, final.y)
      return singlePath
    }
    // Draw line just short to just short of first point.
    // Figure out whether we need to curve up or down
    const curve = step2.y > step1.y ? radius : -radius
    singlePath.lineTo(step1.x - radius, step1.y)
    singlePath.arcTo(step1.x, step1.y, step1.x, step1.y + curve, radius)

    // add or subtract the radius
    singlePath.lineTo(step2.x, step2.y + (!skipSecondaryArc ? -curve : 0))
    singlePath.arcTo(step2.x, step2.y, step2.x + radius, step2.y, radius)

    singlePath.lineTo(final.x, final.y)
  }

  return singlePath
}
