import CacheService from '@fs/zion-cache-service'
import { v4 as uuid } from 'uuid'
import { normalizedCoupleId, coupleIdsAreEqual } from '../../hooks/sibling/helpers'

const ascendancyCacheService = new CacheService({
  cache: { storeName: 'ascendancyyy', encrypted: true },
  strategy: 'cache-and-network',
})

export const GOLDEN_HINT_ID = 'Golden'
export const clearCache = () => {
  return ascendancyCacheService.cacheInstance.clear()
}

export const emptyNode = ({ rank, isPerson1 }) => {
  const unique = uuid()
  const obj = {
    person1: {
      id: 'UNKNOWN',
    },
    person2: {
      id: 'UNKNOWN',
    },
    id: unique,
    dagId: unique,
    directLine: true,
    parentIds: [],
    rank: isPerson1 ? rank * 2 : rank * 2 + 1,
    isDuplicate: false,
  }
  return obj
}

const makeGoldenId = ({ person1, person2 }) => {
  if (!person1?.name || !person2?.name) return 'goldencouple_UNKNOWN' // We need UNKNOWN to be present for when we only have hinting on one side, so that line drawing will be accurate.
  return 'goldencouple'
}

export const hintNode = ({ rank, isPerson1, parentHints }) => {
  const unique = uuid()
  const hintToUse = parentHints[0]
  const { parent1: person1 = { id: 'UNKNOWN' }, parent2: person2 = { id: 'UNKNOWN' } } = hintToUse
  const obj = {
    ...hintToUse,
    person1,
    person2,
    id: makeGoldenId({ person1, person2 }),
    dagId: unique,
    directLine: true,
    parentIds: [],
    rank: isPerson1 ? rank * 2 : rank * 2 + 1,
    isDuplicate: false,
    isGoldenHint: true,
  }
  delete obj.parent1
  delete obj.parent2
  return obj
}

const getRank = ({ isChildren, coupleI, genI }) => {
  // Calculate initial rank from root couple.
  // Children need to be in the "2.X-X" range to ensure cousins render on the correct side of the pedigree. (Assuming the ranking logic isn't messed with)
  // Any changes here affect quite a few things, so be careful.
  const rank = isChildren
    ? `2.0${(coupleI || 0).toString().padStart(3, '0')}-${coupleI + 1}`
    : 2 ** (genI + 2) + coupleI * 2

  return rank
}

const setParentIds = (parentsIds, pofId) => {
  if (!parentsIds) return undefined
  const p1 = parentsIds?.parent1Id || 'UNKNOWN'
  const p2 = parentsIds?.parent2Id || 'UNKNOWN'
  const switchEm = pofId === p2

  return switchEm ? `${p2}_${p1}` : `${p1}_${p2}`
}

const createDAGCouple = ({
  parent1 = {},
  parent2 = {},
  coupleIdFromChildPerspective,
  lastGen,
  coupleI,
  genI,
  hasChildren,
  pofId,
  rootDag,
  isChildren,
  isSibling,
  parent1ParentIds,
  parent2ParentIds,
  parent1ParentHints,
  parent2ParentHints,
  isEdge,
  isGoldenHint,
  goldenId,
  person1GoldenParentDag,
  person2GoldenParentDag,
  recordUrl,
  // both of these are only used when looking at child nodes
  correctChildCoupleId,
  correctParentId,
  //
  isInitialLoad,
  coupleId,
  ancestors,
}) => {
  let realCoupleId = coupleIdFromChildPerspective || parent1?.id || parent2?.id

  // This section only comes into play during non-initial loads, when looking at the children of a couple.
  // We need to make sure the couple is in the correct order, as the back end doesn't guarantee this.
  if (correctChildCoupleId) {
    const normalizedId = normalizedCoupleId({ coupleId })
    realCoupleId =
      correctChildCoupleId?.split('_').reverse().join('_') === normalizedId ? correctChildCoupleId : coupleId
  }
  // We cannot rely on the data call to provide parent1ParentIds/parent2ParentIds in the correct order, so we need to do a check for the children to ensure we're not causing bugs elsewhere, like in select mode.
  // See comments on https://fhjira.churchofjesuschrist.org/browse/TF-3524 for details
  parent1.parentsIds = isChildren && parent1.descendant ? rootDag : setParentIds(parent1ParentIds)
  parent2.parentsIds = isChildren && parent2.descendant ? rootDag : setParentIds(parent2ParentIds)

  // Adjust parentsIds for golden hints
  if (person1GoldenParentDag) {
    parent1.parentsIds = person1GoldenParentDag
    parent1.parentHints = parent1ParentHints
  }
  if (person2GoldenParentDag) {
    parent2.parentsIds = person2GoldenParentDag
    parent2.parentHints = parent2ParentHints
  }

  let parentIds
  const pofIsPerson1 = parent1.id === pofId
  if (coupleI === 0 && genI === 0 && !isChildren) {
    parentIds = pofIsPerson1 ? [setParentIds(parent1ParentIds)] : [setParentIds(parent2ParentIds)]
  } else if (isChildren) {
    const actualParentId = coupleIdsAreEqual({ coupleId: rootDag, compareId: correctParentId })
      ? correctParentId
      : rootDag
    parentIds = [actualParentId]
  } else {
    parentIds = lastGen ? [] : [setParentIds(parent1ParentIds), setParentIds(parent2ParentIds)]
  }

  if (person1GoldenParentDag || person2GoldenParentDag) {
    parentIds.push(...[person1GoldenParentDag, person2GoldenParentDag].filter(Boolean))
  }

  if (!parent1?.id && !isGoldenHint) {
    parent1 = { id: 'UNKNOWN' }
  }
  if (!parent2?.id && !isGoldenHint) {
    parent2 = { id: 'UNKNOWN' }
  }
  const id = normalizedCoupleId({ coupleId: realCoupleId })
  const switchPositions = !isGoldenHint && !id?.startsWith(parent1?.id)
  if (isGoldenHint) {
    parent1.id = parent1.name ? GOLDEN_HINT_ID : 'UNKNOWN' // Just need to make sure the id isn't empty – we hide the pid in the person component
    parent2.id = parent2.name ? GOLDEN_HINT_ID : 'UNKNOWN'
  }

  const dagCouple = {
    person1: switchPositions ? parent2 : parent1,
    person2: switchPositions ? parent1 : parent2,
    coupleHasChildren: hasChildren,
    id: isGoldenHint ? makeGoldenId({ person1: parent1, person2: parent2 }) : id,
    isPof: !isChildren && coupleI === 0 && genI === 0,
    isSibling,
    dagId: isGoldenHint ? goldenId : id,
    directLine: Boolean(!isChildren),
    parentIds: parentIds.filter(Boolean),
    isEdge,
    siblingIdx: Number.isInteger(coupleI) ? coupleI + 1 : undefined,
  }

  if (ancestors) {
    // modify ancestor nodes to include dagId – needed for record dismissal
    const currentAncestor = ancestors?.[genI]?.[coupleI]
    currentAncestor.dagId = dagCouple.dagId
  }

  if (isGoldenHint) {
    dagCouple.isGoldenHint = true
    dagCouple.recordUrl = recordUrl
  }
  // Only set rank on initial page load
  // Rank setting happens in the useSiblingPedigree hook for other calls
  if (isInitialLoad) {
    dagCouple.rank = getRank({ isChildren, coupleI, genI })
  }

  return dagCouple
}

const createDAG = ({ data, gens, pofId, correctParentId, correctChildCoupleId, isInitialLoad, showRecordHints }) => {
  const { children, ancestors } = data
  const tempAncestors = ancestors.slice(0, gens + 1)
  tempAncestors.forEach((gen, tempGenI) => {
    gen.forEach((couple, tempCoupleI) => {
      const parentGenSlot = tempGenI + 1
      const parentGenCoupleSlotParent1 = gen === 0 ? 0 : tempCoupleI * 2
      const parentGenCoupleSlotParent2 = parentGenCoupleSlotParent1 + 1
      const existingNodeAtP1Slot = tempAncestors[parentGenSlot]?.[parentGenCoupleSlotParent1]
      const existingNodeAtP2Slot = tempAncestors[parentGenSlot]?.[parentGenCoupleSlotParent2]
      // Make sure we don't have exisintg nodes at the parent slots before adding hints
      if (couple.parent1ParentHints && existingNodeAtP1Slot && !existingNodeAtP1Slot.id && showRecordHints) {
        // add a couple to the right slot in the ancestors array
        const hintedCouple = couple.parent1ParentHints[0] // grab the first hint in the array
        hintedCouple.isGoldenHint = true
        // If we want to make this look nicer in the future we could hash it or something
        const coupleGoldenId = `${couple.id}-${hintedCouple.parent1?.name}.${hintedCouple.parent2?.name}`
        hintedCouple.goldenId = coupleGoldenId
        tempAncestors[parentGenSlot][parentGenCoupleSlotParent1] = hintedCouple
        couple.person1GoldenParentDag = hintedCouple.goldenId
      }
      // Make sure we don't have exisintg nodes at the parent slots before adding hints
      if (couple.parent2ParentHints && existingNodeAtP2Slot && !existingNodeAtP2Slot.id && showRecordHints) {
        // add a couple to the right slot in the ancestors array
        const hintedCouple = couple.parent2ParentHints[0] // grab the first hint in the array
        hintedCouple.isGoldenHint = true
        // If we want to make this look nicer in the future we could hash it or something
        const coupleGoldenId = `${couple.id}-${hintedCouple.parent1?.name}.${hintedCouple.parent2?.name}`
        hintedCouple.goldenId = coupleGoldenId
        tempAncestors[parentGenSlot][parentGenCoupleSlotParent2] = hintedCouple
        couple.person2GoldenParentDag = hintedCouple.goldenId
      }
    })
  })
  const ancestorNodes = tempAncestors.map((gen, genI) => {
    return gen.map((couple, coupleI) => {
      if (!couple.coupleId && !couple.isGoldenHint) return false
      return createDAGCouple({
        ...couple,
        lastGen: gens === genI,
        coupleI,
        genI,
        pofId,
        isInitialLoad,
        ancestors,
      })
    })
  })
  // duplicate detection – we need to update both the dagId and the parentIds of the child if we have duplicate nodes.
  // we don't worry about childNodes duplicates here, as those get handled gracefully in the dag file without extra work.
  const ancestorDags = new Set()
  ancestorNodes.forEach((gen, idx) => {
    gen.forEach((couple, coupleIdx) => {
      if (!couple) return
      const { dagId } = couple
      if (ancestorDags.has(dagId)) {
        const newId = uuid()
        couple.dagId = newId
        const childInPreviousGen = ancestorNodes[idx - 1]?.[Math.floor(coupleIdx / 2)]
        const matchingIdIdx = childInPreviousGen?.parentIds.findIndex((id) => {
          return id === dagId
        })
        if (matchingIdIdx > -1) {
          childInPreviousGen.parentIds[matchingIdIdx] = newId
        }
      }
      ancestorDags.add(dagId)
      // Also set up childNodes for any goldenhint nodes
      // We do this here, rather than in createDagCouple, because we want the childNodes to be grabbed from the ancestorNodes, not the default ancestors
      if (couple.isGoldenHint) {
        const childNode = ancestorNodes?.[idx - 1]?.[Math.floor(coupleIdx / 2)]
        const relatedChild = coupleIdx % 2 ? 'person2' : 'person1'
        couple.childNode = childNode
        couple.relatedChild = relatedChild
      }
    })
  })
  const childNodes =
    children?.slice().map((couple, coupleI) => {
      return createDAGCouple({
        ...couple,
        pofId,
        rootDag: ancestorNodes[0][0].dagId,
        genI: 0,
        coupleI,
        isChildren: true,
        isSibling: children.length > 1,
        isEdge: coupleI === 0 || coupleI === children.length - 1,
        correctChildCoupleId,
        correctParentId,
        isInitialLoad,
      })
    }) || []

  // Now that calculations on ranks/duplicates are done, filter out any empty nodes
  // We need to do this after the duplicate check, otherwise we may not find matches accurately
  const ancestorNodesFiltered = ancestorNodes.map((gen) => {
    return gen.filter(Boolean) // Some nodes in gen may be falsy if initial pedigree was not completely filled out. Passing Boolean here will filter those out.
  })
  return { ancestorNodes: ancestorNodesFiltered, childNodes }
}

export default function getPedigree({
  pofId, // used during initial load
  coupleId, // used during all other calls
  correctChildCoupleId, // in the child array, we will get a couple object that includes the current couple in the pedigree. This helps us ensure the couple is in the correct order.
  gens = 2,
  treeId,
  showTemple = false,
  prefs,
  isInitialLoad, // whether or not this is the initial load
  refresh,
  goldenHintsFlagOn,
}) {
  const correctChildCoupleIdQuery = correctChildCoupleId ? `&childCoupleId=${correctChildCoupleId}` : ''
  const params = new URLSearchParams({
    includeTempleRollupStatus: showTemple,
    numGenerations: gens + 1,
    includePhotos: prefs.showPortraits,
    includeFullHasSiblings: true,
    includeRecordHints: prefs.showRecordHints,
    treeId: treeId || 'PRIVATE',
    includeSpouseAncestry: !isInitialLoad,
    goldenHintsEx: true,
  })

  const [person1, person2] = coupleId?.split('_') || []
  const coupleIdSorted = coupleId?.startsWith('UNKNOWN') ? `${person2}_${person1}` : coupleId
  const idToUseForDataCall = pofId || coupleIdSorted
  const url = `/service/tree/tree-data/r9/portrait-pedigree/${idToUseForDataCall}?${params.toString()}${correctChildCoupleIdQuery}`

  const [serverPromise, cachePromise] = ascendancyCacheService.get(url, idToUseForDataCall + gens + 1 + treeId)

  const handler = (data) => {
    if (!data?.ancestors) return undefined
    if (!data.ancestors[1]) data.ancestors[1] = [{}, {}] // In the case of a single gen pedigree, tree-data does not fill out the remaining gens with empty nodes. We need this for golden-hints
    const { ancestorNodes, childNodes } = createDAG({
      data,
      gens,
      pofId,
      correctChildCoupleId,
      correctParentId: coupleId,
      isInitialLoad,
      showRecordHints: prefs.showRecordHints && goldenHintsFlagOn,
    })
    if (!isInitialLoad) {
      // if we are refreshing (like with temple indicators), we don't want to include the parentCoupleId
      // otherwise, we will get dag errors due to parent nodes not existing
      const refreshParentGen = ancestorNodes?.[0]?.map((node) => {
        return {
          ...node,
          parentIds: [],
        }
      })
      // Additionally, we know that in all cases outside of isInitialLoad, the secondGen should not have parentIds
      const secondGen = ancestorNodes?.[1]?.map((node) => {
        return {
          ...node,
          parentIds: [],
        }
      })
      return {
        childrenGen: childNodes,
        parentGen: refresh ? refreshParentGen : ancestorNodes[0],
        secondGen: secondGen || [],
      }
    }
    return [...ancestorNodes.slice(0, gens + 1), ...childNodes].flat()
  }

  return [serverPromise.then(handler), cachePromise.then(handler)]
}
