import React, { memo } from 'react'
import { css, cx } from '@linaria/core'
import { Person, usePersonSheet } from '@fs/zion-person'
import { ArrowCaret, NoticeLoading } from '@fs/zion-icon'
import { boolAttr } from '@fs/zion-frontend-friends'
import { Affordance } from '@fs/zion-ui/quarks-authorized-use-only'
import { Button, IconButton, colors, Separator, Checkbox, Tag } from '@fs/zion-ui'
import { isValidPid } from '@fs/zion-pid'
import { trackEvent } from '@fs/zion-analytics'
import { useTranslation } from 'react-i18next'
import { isTranslationAvailable } from '@fs/zion-locale'
import { constants } from '../../hooks/sibling/dag'
import AddPeopleOverlay from './AddPeopleOverlay'
import {
  parentIdContainsValidPid,
  selectTest,
  coupleIdsAreEqual,
  genderForAddSlot,
  selectKey,
} from '../../hooks/sibling/helpers'
import AlternateSpouses from '../shared/AlternateSpouses'
import { usePedigreeViewOptions } from '../../pedigree-view-options'
import AlternateParents from '../shared/AlternateParents'
import Indicators from '../shared/Indicators'
import PrivatePersonTag from '../PrivatePersonTag'
import { GOLDEN_HINT_ID } from '../../service/sibling/ascendancy'

const hoverBgColorLight = colors.gray03
const hoverBgColorDark = colors.gray10

export const buttonCss = css`
  // I know, we don't usually like to use z-index. We're trying to strike a balance between node sizes/positioning with d3-dag though, and this is simpler than tweaking that again.
  z-index: 1;
`

const altParentsButtonCss = css`
  position: absolute;
  top: -24px;
  background: ${colors.gray00};
  border: none;
  height: 24px;
  inset-inline-start: 10px;
  inset-inline-end: 10px;
  width: ${constants.coupleWidth / 2 - 20}px;
  border-start-end-radius: 8px;
  border-start-start-radius: 8px;
  display: flex;
  flex-flow: row;
  align-items: center;
  justify-content: center;
  [non-direct-line] & {
    width: ${constants.nonDirectCoupleWidth / 2 - 20}px;
  }
  &:focus,
  &:hover {
    background: ${hoverBgColorLight};
  }
  &[dark-mode] {
    background: ${colors.gray05};
  }
  &[dark-mode]:focus,
  &[dark-mode]:hover {
    background: ${hoverBgColorDark};
  }
`

const tileOuterWrapperCss = css`
  position: relative;
  &[slot='1'][is-couple] {
    margin-inline-end: ${constants.coupleMargin}px;
  }
`

const tileWrapperCss = css`
  display: flex;
  flex-flow: column;
  align-items: center;
  border-radius: 8px;
  height: ${constants.tileHeight}px;
  width: ${constants.coupleWidth / 2}px;
  background: ${colors.gray00};
  [data-theme='night'] & {
    background: ${colors.gray05};
  }
  [data-theme='night'] &:hover,
  [data-theme='night'] &:focus {
    background: ${hoverBgColorDark} !important;
  }
  [non-direct-line] & {
    height: ${constants.nonDirectTileHeight}px;
    width: ${constants.nonDirectCoupleWidth / 2}px;
  }
  &[is-selected] {
    box-shadow: 0 0 0 4px ${colors.green30};
  }
  &:not([is-not-selectable]):hover,
  &:not([is-not-selectable]):focus {
    background: ${hoverBgColorLight};
  }
  &:not([golden-hint])::before {
    // TW-5572 - The flex-shrink is to account for the 4px before gender band taking up some of the space for the couple height
    flex-shrink: 0;
    border-radius: 8px 8px 0 0;
    content: '';
    height: 4px;
    width: 100%;
    background: ${colors.gray30};
  }
  &[sex='FEMALE']::before {
    background: ${colors.red50};
  }

  &[sex='MALE']::before {
    background: ${colors.blue30};
  }
  &[highlight] {
    border: 3px solid gray;
    &[sex='MALE'] {
      border-color: ${colors.blue30};
    }
    &[sex='FEMALE'] {
      border-color: ${colors.red50};
    }
  }
  &[golden-hint] {
    background: none;
    border: 4px dashed ${colors.green70};
  }
`
export const affordanceCss = css`
  position: absolute;
  top: 0;
  inset-inline-end: 0;
  bottom: 0;
  inset-inline-start: 0;
  height: 100%;
  width: 100% !important; // HACK: Firefox needs this width
  background: transparent;
  --affordance-margin: 0 !important; // HACK: Affordance doesn't allow for 0 margin.
  &:not(:disabled):hover {
    background: transparent !important;
  }
`
const altSpousesCss = css`
  position: absolute;
  top: 8px;
  inset-inline-start: 18px;
`
const expandRightSiblingsCss = css`
  position: absolute;
  inset-inline-end: -28px;
  top: ${constants.tileHeight / 2 - 16}px;
`
const expandLeftSiblingsCss = css`
  position: absolute;
  inset-inline-start: -28px;
  top: ${constants.tileHeight / 2 - 16}px;
`

export const expandButtonCss = css`
  // Overriding buttons color to comply with designs (similar to what we're doing in FA)
  // Is zion going to support this eventually?
  background: none;
  svg {
    stroke: ${colors.blue60};
    stroke-width: 1px;
  }
  &[expand-up] svg {
    height: 32px;
    width: 32px;
  }
  [expand-sibling] svg {
    height: 24px;
    width: 24px;
  }
  button {
    &:hover,
    &:focus {
      background: ${hoverBgColorLight} !important;
    }
  }

  [data-theme='night'] & button {
    &:hover,
    &:focus {
      background: ${hoverBgColorDark} !important;
    }
  }
  [aria-disabled='true'] {
    svg {
      stroke: none;
    }
    &:hover,
    &:focus {
      background: none !important;
    }
  }
`

export const tileCss = css`
  padding: 20px;
  width: 100%;
  height: 100%;
  display: flex;
  flex-flow: column;
  align-items: center;
  &[is-not-selectable] {
    background: ${colors.gray03};
    opacity: 0.3;
  }
`
const potentialTagCss = css`
  position: absolute;
  width: 75%;
  display: flex;
  justify-content: center;
  background: ${colors.green10};
  border-radius: 4px;
  top: -20px;
  height: 30px;
  span {
    background: ${colors.green10};
  }
`

const expandUpCss = css`
  position: absolute;
  width: 100%;
  display: grid;
  justify-content: center;
  top: -45px;
  &[parent-node-expanded] {
    top: -75px;
  }
  &[has-alt-parents] {
    top: -87px;
  }
`

function Tile({
  addPid,
  addSpouse,
  checkRemove,
  isSelectable,
  couple,
  handleCollapseAscendants,
  handleCollapseSiblings,
  handleExpandDown,
  handleExpandUp,
  handleChangeSpouse: handleRealChangeSpouse,
  handleAlternateParentsChange,
  handleRefreshFamily,
  getChildDagIdAndPerson,
  otherPerson,
  person,
  pofId,
  readOnlyMode,
  selectedPids,
  selectMode,
  selectOnlyOne,
  selectProps,
  slot,
  x,
  y,
  loading,
  highlight,
  duplicateMapping,
  loadingExpandUp,
  loadingSiblings,
  isGoldenHint,
  handleAddFindClick,
}) {
  const { t } = useTranslation()
  const position1 = slot === 1
  const personIsUnknown = person?.id === 'UNKNOWN'
  const { parentIds, dagId, rank, siblingIdx, isDuplicate, childNode, directLine, slotForExpand: isAddCouple } = couple
  const otherPersonIsPof = otherPerson?.id === pofId
  const showExpandUp = directLine && (!selectMode || Boolean(person.parentsIds)) && !personIsUnknown && !isGoldenHint
  const expandedParentNodeId = parentIds?.find((id) =>
    [id, duplicateMapping[id]].filter(Boolean).includes(person?.parentsIds)
  )
  const personCollapse = parentIds?.some((id) => {
    const compareId = person?.parentsIds
    if (!compareId) return false
    return coupleIdsAreEqual({ coupleId: id, compareId }) || duplicateMapping[id] === compareId
  })
  const personSheetContext = usePersonSheet()
  const horizontalDirection = {
    out: position1 ? 'backward' : 'forward',
    in: position1 ? 'forward' : 'backward',
  }
  const { prefs } = usePedigreeViewOptions()
  const handleChangeSpouse = (newSpouseId) => {
    handleRefreshFamily({
      coupleId: slot === 2 ? `${otherPerson?.id}_${newSpouseId}` : `${newSpouseId}_${otherPerson?.id}`,
      personId: otherPerson?.id,
      dagId: slot === 2 ? `${otherPerson?.id}_${newSpouseId}` : `${newSpouseId}_${otherPerson?.id}`,
    })
    handleRealChangeSpouse(newSpouseId)
  }
  const handleIndicatorSuccess = () => {
    handleRefreshFamily({
      coupleId: couple?.id,
      personId: person?.id,
      dagId,
    })
  }
  const selectModePersonProps = (personData) => {
    if (!selectMode) return {}
    const k = selectKey(dagId, personData?.id)
    const isSelected = selectedPids?.[k]
    const handler = isSelected ? (evt) => checkRemove(evt, k) : () => addPid({ dagId, clickedId: personData?.id })
    const onClick = selectTest({ selectProps, person: personData }) && handler
    return {
      hideLifespan: Boolean(onClick) && person.living,
      doNotLinkToPersonPage: true,
      hidePid: !selectOnlyOne,
      onClick,
    }
  }

  const handleExpandUpButton = (collapse) => {
    if (collapse) {
      trackEvent({ link_name: 'pedigree: portrait beta: toggle ancestors: close' })
      handleCollapseAscendants({
        dagId: couple?.dagId,
        parentCoupleId: person?.parentsIds,
        parentDagId: expandedParentNodeId,
        x,
        y,
        personId: person?.id,
      })
    } else {
      trackEvent({ link_name: 'pedigree: portrait beta: toggle ancestors: open' })
      handleExpandUp({
        coupleId: person?.parentsIds,
        parentDagId: expandedParentNodeId,
        childCoupleId: couple?.id,
        childDagId: couple?.dagId,
        personId: person?.id,
        correctChildSpouseId: otherPerson?.id,
        x,
        y,
        rank,
        isPerson1: position1,
        parentHints: person?.parentHints,
      })
    }
  }
  const addStuffProps = {
    otherPerson,
    rank,
    siblingIdx,
    dagId,
    handleExpandUp,
    handleExpandDown,
    addSpouse,
    x,
    y,
    position1,
    couple,
    childNode,
    isGoldenHint,
  }
  const personSelected = selectMode && selectedPids?.[selectKey(dagId, person?.id)]
  const showAffordance = (isSelectable || !selectMode) && !loading && !isGoldenHint
  const {
    prefs: { showAltRelationships, colorScheme },
  } = usePedigreeViewOptions()

  const showExpandSibling = directLine && parentIdContainsValidPid(person?.parentsIds) && person?.hasSiblings

  const handleOpenPersonSheet = (evt) => {
    personSheetContext.setPerson({
      personId: person?.id,
      personObj: person,
    })

    !personSheetContext.personSheet.isOpen && personSheetContext.personSheet.open(evt)
  }
  const showAltSpouses = otherPerson?.hasMultipleFamiliesAsParent && showAltRelationships && !selectMode

  const personToShow = isGoldenHint || (person?.id && person?.id !== 'UNKNOWN')
  const personNotShown = personIsUnknown && readOnlyMode
  const expandUpTranslationKey = personCollapse ? 'tw.pedigree.collapse-parents.1' : 'tw.pedigree.expand-parents.1'
  const showAltParents = showAltRelationships && person?.hasMultipleFamiliesAsChild && !selectMode

  let affordanceAriaLabel = t(
    personSelected ? 'tw.pedigree.remove-person-from-copy.label' : 'tw.pedigree.add-person-copy.label'
  )
  if (selectOnlyOne) {
    affordanceAriaLabel = t('tw.pedigree.sibling-select-person.label', { name: person.name })
  }

  // If this person does not exist, but the spouse does, hide this Tile unless we need to show alt spouses
  if (!loading && personIsUnknown && isValidPid(otherPerson?.id) && !showAltSpouses) return null
  // If this person is unknown and the spouse is a golden hint, hide this Tile
  if (personIsUnknown && otherPerson?.id === GOLDEN_HINT_ID) return null

  const [parent1Id, parent2Id] = person?.parentsIds?.split('_') || []

  const duplicateTooltip =
    isDuplicate && isTranslationAvailable('tw.pedigree.expand-duplicate-info.label')
      ? t('tw.pedigree.expand-duplicate-info.label')
      : ''
  return (
    <div
      className={tileOuterWrapperCss}
      slot={slot}
      is-couple={boolAttr(
        otherPerson.name || isAddCouple || (person.hasMultipleFamiliesAsParent && showAltRelationships)
      )} // if this person has multiple families as parent, then add spouse tile will show, and we need margin
    >
      {showAltParents && (
        <AlternateParents
          childWithMultipleFamilies={person?.id}
          child={person}
          person1Id={parent1Id}
          person2Id={parent2Id}
          onChange={(newParentsCoupleId) => {
            handleAlternateParentsChange({
              oldParentsCoupleId: person?.parentsIds,
              newParentsCoupleId,
              personId: person?.id,
              coupleId: couple?.id,
              dagId: couple?.dagId,
              correctChildSpouseId: otherPerson?.id,
              rank,
              isPerson1: position1,
            })
          }}
          showForm={Boolean(directLine)}
          portraitMode
          className={altParentsButtonCss}
          dark-mode={boolAttr(colorScheme === 'nightfall')}
          darkMode={colorScheme === 'nightfall'}
        />
      )}
      <div
        className={tileWrapperCss}
        highlight={boolAttr(highlight && !selectMode)}
        golden-hint={boolAttr(isGoldenHint)}
        sex={personNotShown ? undefined : genderForAddSlot({ id: person?.id, slot }) || person?.gender}
        is-selected={boolAttr(personSelected)}
        is-not-selectable={boolAttr(!showAffordance || personNotShown)}
        role="button"
      >
        {(loading || personToShow) && (
          <>
            {showAffordance && (
              <Affordance
                className={affordanceCss}
                onClick={handleOpenPersonSheet}
                {...selectModePersonProps(person)}
                aria-label={affordanceAriaLabel}
                aria-hidden={false}
              />
            )}
            <div className={tileCss} is-not-selectable={boolAttr(selectMode && !isSelectable)}>
              <Person
                componentSize={couple.directLine ? 'lg' : 'md'}
                openPersonSheet={!selectMode && !isGoldenHint}
                personObj={person}
                usePortraitUrl={prefs?.showPortraits}
                orientation="portrait"
                loading={loading}
                hideLifespan={person.living}
                hidePid={isGoldenHint}
                doNotLinkToPersonPage={isGoldenHint}
                {...selectModePersonProps(person)}
              />
              {!isGoldenHint && !selectMode && (
                <>
                  <PrivatePersonTag person={person} />
                  <div>
                    <Separator size="nano" />
                    <Indicators
                      showAll
                      limit={2}
                      includeTemple
                      person={person}
                      coupleId={couple.id}
                      onSuccess={handleIndicatorSuccess}
                    />
                  </div>
                </>
              )}
              {selectMode && !selectOnlyOne && (
                <Checkbox
                  data-testid={`Select-${person.name}`}
                  aria-label={t('tw.pedigree.sibling-select-person.label', { name: person.name })}
                  checked={personSelected || !isSelectable}
                  disabled={!isSelectable}
                  onChange={isSelectable ? selectModePersonProps(person).onClick : null}
                  background={personSelected ? colors.green30 : colors.gray05}
                />
              )}
              {selectMode && selectOnlyOne && pofId !== person?.id && (
                <Button
                  disabled={!isSelectable}
                  emphasis="medium"
                  onClick={isSelectable ? selectModePersonProps(person).onClick : null}
                >
                  {t('tw.pedigree.sibling-select.action')}
                </Button>
              )}
            </div>
          </>
        )}
        {!readOnlyMode && !selectMode && (
          <AddPeopleOverlay
            getChildDagIdAndPerson={getChildDagIdAndPerson}
            pofId={pofId}
            directLine={directLine}
            person={person}
            operationTypeIfFromTile={isGoldenHint || otherPerson.id === 'UNKNOWN' ? 'addParent' : 'addSpouse'}
            handleCollapseAscendants={handleCollapseAscendants}
            handleAddFindClick={handleAddFindClick}
            personIsUnknown={personIsUnknown}
            isGoldenHint={isGoldenHint}
            {...addStuffProps}
          />
        )}
        {showAltSpouses && (
          <div className={altSpousesCss}>
            <AlternateSpouses
              otherPerson={otherPerson}
              onChange={handleChangeSpouse}
              editable={otherPersonIsPof || (!couple.directLine && otherPerson?.isDescendant)}
            />
          </div>
        )}
        {isGoldenHint && (
          <div className={potentialTagCss}>
            <Tag text="Potential" color="green" />
          </div>
        )}
      </div>

      {showExpandUp && (
        <div
          className={expandUpCss}
          has-alt-parents={boolAttr(showAltParents)}
          parent-node-expanded={boolAttr(expandedParentNodeId)}
        >
          <div expand-up="" className={expandButtonCss}>
            <IconButton
              aria-label={t(expandUpTranslationKey, { parent1: person?.name })}
              disabled={isDuplicate}
              title={duplicateTooltip}
              emphasis="low"
              Icon={loadingExpandUp ? NoticeLoading : ArrowCaret}
              iconDirection={personCollapse ? 'down' : 'up'}
              onClick={() => {
                handleExpandUpButton(personCollapse)
              }}
              data-testid="expand-up"
            />
          </div>
        </div>
      )}

      {showExpandSibling && (
        <div className={cx(position1 ? expandLeftSiblingsCss : expandRightSiblingsCss, expandButtonCss, buttonCss)}>
          <IconButton
            aria-label={t(
              person?.siblingsAreVisible ? 'tw.pedigree.collapse-siblings.label' : 'tw.pedigree.expand-siblings.label',
              { name: person?.name }
            )}
            data-testid="expand-sibling"
            expand-sibling=""
            emphasis="low"
            Icon={loadingSiblings ? NoticeLoading : ArrowCaret}
            size="sm"
            title={duplicateTooltip}
            disabled={isDuplicate}
            iconDirection={person?.siblingsAreVisible ? horizontalDirection.in : horizontalDirection.out}
            onClick={() => {
              if (person?.siblingsAreVisible) {
                handleCollapseSiblings({
                  dagId,
                  parentDagId: parentIds?.find((id) => [id, duplicateMapping[id]].includes(person?.parentsIds)),
                  personId: person?.id,
                  clickedNodeSpouseId: otherPerson?.id,
                  x,
                  y,
                })
                trackEvent({ link_name: 'pedigree: portrait beta: toggle siblings: close' })
              } else {
                handleExpandUp({
                  coupleId: person?.parentsIds,
                  dagId: parentIds?.find((id) => id.includes(person?.parentsIds)),
                  childCoupleId: couple?.id,
                  childDagId: couple?.dagId,
                  personId: person?.id,
                  correctChildSpouseId: otherPerson?.id,
                  x,
                  y,
                  rank,
                  isPerson1: position1,
                  parentDagId: parentIds.find((id) => id.includes(person?.parentsIds)),
                  showSiblings: true,
                })
                trackEvent({ link_name: 'pedigree: portrait beta: toggle siblings: open' })
              }
            }}
          />
        </div>
      )}
    </div>
  )
}

export default memo(Tile)
