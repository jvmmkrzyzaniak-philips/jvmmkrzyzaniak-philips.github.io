import React from 'react'
import { css } from '@linaria/core'
import { colors } from '@fs/zion-ui'
import { path } from 'd3-path'
import { boolAttr } from '@fs/zion-frontend-friends'
import { constants } from '../../hooks/sibling/dag'
import { coupleIdsAreEqual } from '../../hooks/sibling/helpers'
import { connectNodes } from '../../utils/shared'

const lineRadius = 8

const pathCss = css`
  stroke: ${colors.gray40};
  stroke-width: 1px;
  fill: none;
  stroke-linejoin: round;
  &[direct] {
    stroke-dasharray: none;
    stroke-width: 3px;
  }
  [data-theme='night'] & {
    stroke: ${colors.gray60};
  }
  &[is-golden] {
    stroke: ${colors.green70};
    stroke-dasharray: 7;
    stroke-width: 4px;
  }
`
const svgCss = css`
  position: absolute;
  overflow: visible;
`
export default function Lines({ links, pofId, duplicateMapping }) {
  const generationsObj = {}
  links?.forEach((link) => {
    generationsObj[link.target?.uy] ||= new Set()
    generationsObj[link.target?.uy].add(link.source?.ux)
  })
  return (
    <svg className={svgCss}>
      {links?.map((data, idx) => {
        const generation = Array.from(generationsObj[data.target.uy])
        generation.sort((a, b) => a - b)
        const genIdx = generation.findIndex((genX) => data.source.ux === genX)

        const { points } = data || {}

        if (!points.length) return null
        const parentPointsOriginal = data?.points[0]
        const childPointsOriginal = data?.points[1]
        const parentIsDirect = Boolean(data?.source?.data?.directLine)
        const parentIsGolden = Boolean(data?.source?.data?.isGoldenHint)
        const childIsDirect = Boolean(data?.target?.data?.directLine)
        const childIsSibling = Boolean(data?.target?.data?.isSibling)
        const childIsEdgeNode = data?.target?.data?.isEdge
        const bothNodesExpanded = data?.target?.data?.parentIds?.length === 2
        const parentIds = data?.source?.data?.dagId
        const widthType = parentIsDirect ? 'coupleWidth' : 'nonDirectCoupleWidth'
        const heightType = parentIsDirect ? 'tileHeight' : 'nonDirectTileHeight'

        const realParentX = parentPointsOriginal[0] + constants[widthType] / 2 + constants.coupleMargin / 2 // center it between nodes
        const realParentY = parentPointsOriginal[1] + constants[heightType]

        const isSingleNode = data?.target?.data?.id.includes('UNKNOWN')
        const isSingleParent = data?.source?.data?.id.includes('UNKNOWN')
        const child1ParentIds = data.target?.data?.person1?.parentsIds
        const child2ParentIds = data.target?.data?.person2?.parentsIds

        const parentIsDuplicate = data?.source?.data?.isDuplicate
        let isPerson1Parents = coupleIdsAreEqual({
          coupleId: parentIsDuplicate ? duplicateMapping[parentIds] : parentIds,
          compareId: child1ParentIds,
        })
        // Super edge case â€“ incest, where both sets of parents are the same couple. We need to check and see which parent couple rank is further left.
        // If it's this one, mark as person1's parents. Otherwise, person2's parents.
        if (isPerson1Parents && bothNodesExpanded && duplicateMapping[parentIds] === child2ParentIds) {
          isPerson1Parents = false
        }
        const childPerson = data?.target?.data?.[isPerson1Parents ? 'person1' : 'person2']
        const parentPoints = { x: realParentX, y: realParentY }

        // which direction to shift the line originating from the child node, depending on whose parents we are drawing line from.
        let realChildX = childPointsOriginal[0]

        const amountToShift = childIsDirect ? constants.coupleWidth / 4 : constants.nonDirectCoupleWidth / 4
        if (isPerson1Parents || isSingleNode) {
          // parents are for person 1
          realChildX += amountToShift * (isSingleNode ? 2 : 1)
        } else {
          // parents are for person 2, shift further, account for margin
          realChildX += amountToShift * 3 + constants.coupleMargin
        }

        // If on direct line and both parent lines head to the left or right, they overlap. Account for that and adjust height .
        let shiftUp = false
        if (childIsDirect && bothNodesExpanded && parentPoints.x > realChildX && isPerson1Parents) {
          shiftUp = true
        }
        if (childIsDirect && bothNodesExpanded && parentPoints.x < realChildX && !isPerson1Parents) {
          shiftUp = true
        }
        const isDirect = parentIsDirect && childIsDirect
        const coupleConnectorAdjustment = 20
        // Calculate where the middle generation is, so we can offset the midpoint for descendancy lines, to better avoid overlap.
        const middleIdx = Math.floor(generation.length / 2) - (generation.length % 2 ? 0 : 1)

        // The midpoint needs to adjust to account for possible overlap. Tricky logic here, use caution.
        // % operator should limit the number of pixels we adust by, so that in the case of excessive expansions, the lines don't run into the next generation.
        const midPointPXAdjust =
          (shiftUp ? 15 : 25) - (!childIsDirect && !parentIsDirect ? Math.abs((middleIdx - genIdx) % 8) * 10 : 0)
        let li = connectNodes({
          node: { x: realChildX, y: childPointsOriginal[1] },
          parentNode: { x: parentPoints.x, y: parentPoints.y + (isSingleParent ? 0 : coupleConnectorAdjustment) },
          radius: childIsEdgeNode || childIsDirect ? lineRadius : 0,
          midPointPXAdjust,
          // We want to skip the secondary arc here if the node has siblings
          skipSecondaryArc: childPerson?.siblingsAreVisible || childIsSibling,
          portraitMode: true,
        })
        // if there is a mismatch in parent vs child direct status, we don't want extra lines drawn with potentially different styling.
        if (!isSingleParent && (parentIsDirect === childIsDirect || parentIds.includes(pofId))) {
          const distance =
            (parentIsDirect ? constants.coupleWidth / 4 : constants.nonDirectCoupleWidth / 4) +
            constants.coupleMargin / 2
          const startX = parentPoints.x - distance
          const y2 = parentPoints.y + coupleConnectorAdjustment
          const x2 = startX + distance * 2
          const connector = path()
          connector.moveTo(startX, parentPoints.y)
          // Draw couple connector
          connector.lineTo(startX, y2 - lineRadius)
          connector.arcTo(startX, y2, startX + lineRadius, y2, lineRadius)
          connector.lineTo(x2 - lineRadius, y2)
          connector.arcTo(x2, y2, x2, y2 - lineRadius, lineRadius)
          connector.lineTo(x2, parentPoints.y)
          li += connector
        }

        const k = idx
        return (
          <React.Fragment key={k}>
            <path className={pathCss} is-golden={boolAttr(parentIsGolden)} direct={boolAttr(isDirect)} d={li} />
          </React.Fragment>
        )
      })}
    </svg>
  )
}
