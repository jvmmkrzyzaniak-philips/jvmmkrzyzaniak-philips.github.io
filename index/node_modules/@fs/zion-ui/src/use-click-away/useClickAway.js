import React, { useEffect, useRef } from 'react'
import PropTypes from 'prop-types'
import { ClickAwayContext } from './ClickAwayProvider'
import useEventStack from '../use-event-stack'

export default function useClickAway({ enabled, handler, originatorRef, focusBackRef, contentRef, inline }) {
  const handlerRef = useRef()

  useEffect(() => {
    const outsideClickHandler = (event) => {
      const { target } = event

      if (
        // If the patron is clicking on something inside of the content, we don't want to close
        contentRef?.current?.contains(target) ||
        // If the patron begins a click outside of the content but finishes the click inside the content,
        // we don't want it to close. If they do that, the target will end up being the closest common ancestor
        // between the beginning of the click and the end of the click.
        // If the element is inline, then this will always be true, which we don't want
        (!inline && target.contains(contentRef?.current)) ||
        // Within the shadow root we want to keep the click-away handler from firing when clicking on contentRef.
        // Previous checks don't work for this because when clicking in the shadow DOM the target
        // is always the shadow root - not what is actually clicked.
        // (e.g. hf-inj-react > header > lang picker - a dialog launched from within shadow DOM)
        (contentRef?.current && event?.composedPath()?.includes(contentRef.current))
      ) {
        return
      }

      let focusNode = focusBackRef?.current

      if (originatorRef?.current?.contains(target)) {
        // If the user clicks the originator used to enable click-away
        focusNode = originatorRef.current
        // Prevent the originator from trying to re-enable click-away immediately after
        event.stopPropagation()
      } else if (target.tabIndex >= 0) {
        // If the user clicks something outside the content that is focusable
        focusNode = target
      }

      handler(focusNode, target)
    }
    handlerRef.current = outsideClickHandler
  }, [focusBackRef, handler, originatorRef, contentRef, inline])

  useEventStack({
    Context: ClickAwayContext,
    enabled,
    handlerRef,
  })
}

// This is just a dummy component so that we can use propTypes to make things easier to document
export const HookConfigOptions = (props) => <div {...props} />

const DomElement = typeof Element === 'undefined' ? () => {} : Element

HookConfigOptions.propTypes = {
  /** If true, then auto-focus will fire whenever `isOpen` is changed to true. */
  enabled: PropTypes.bool.isRequired,

  /** Ran each time click-away is triggered. */
  handler: PropTypes.func.isRequired,

  /** Ref to the element that triggered enabling the click-away (i.e. the button that opened the overlay). */
  originatorRef: PropTypes.oneOfType([
    // Either a function
    PropTypes.func,
    // Or the instance of a DOM native element
    PropTypes.shape({ current: PropTypes.instanceOf(DomElement) }),
  ]),

  /** Ref to the element that will receive focus after click-away fires. */
  focusBackRef: PropTypes.oneOfType([
    // Either a function
    PropTypes.func,
    // Or the instance of a DOM native element
    PropTypes.shape({ current: PropTypes.instanceOf(DomElement) }),
  ]),

  /** Ref to the container that should not trigger click-away when clicked on. */
  contentRef: PropTypes.oneOfType([
    // Either a function
    PropTypes.func,
    // Or the instance of a DOM native element
    PropTypes.shape({ current: PropTypes.instanceOf(DomElement) }),
  ]),
}
