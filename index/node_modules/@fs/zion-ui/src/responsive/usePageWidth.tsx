import React, { useMemo, createContext, useContext } from 'react'
import type { CSSProperties, HTMLAttributes } from 'react'
import type { AtWidthFunction } from './useContainerWidth'
import useContainerWidth, { defaultAtWidthFunction } from './useContainerWidth'
import type { GuttersType } from './gutters'
import gutters from './gutters'

type SpacerValues = Record<keyof GuttersType, number>

const defaultSpacers: SpacerValues = Object.entries(gutters).reduce((spacers, [gutter, options]) => {
  spacers[gutter] = options.default
  return spacers
}, {} as SpacerValues)

export const PageWidthContext = createContext<{
  pageWidth: AtWidthFunction
  spacers: SpacerValues
}>({
  pageWidth: defaultAtWidthFunction,
  spacers: defaultSpacers,
})

export function PageWidthProvider({ children, ...props }: HTMLAttributes<HTMLDivElement>): JSX.Element {
  const pageWidth = useContainerWidth()

  const [gutterStyles, contextValue] = useMemo(() => {
    const styles: CSSProperties = {}
    const spacers = {} as SpacerValues
    Object.entries(gutters).forEach(([gutter, options]) => {
      const spacer = (pageWidth(options) ?? 0) * 2
      styles[`--spacer-${gutter}`] = `${spacer}px`
      spacers[gutter] = spacer
    })
    return [styles, { pageWidth, spacers }]
  }, [pageWidth])

  return (
    <PageWidthContext.Provider value={contextValue}>
      <div {...props} style={gutterStyles}>
        {children}
      </div>
    </PageWidthContext.Provider>
  )
}

/**
 * This allows any application to benefit from dynamic page width functionality.
 * @returns {Function} pageWidth
 */
export default function usePageWidth(): AtWidthFunction {
  return useContext(PageWidthContext).pageWidth
}
