import type { ElementType } from 'react'
import React, { createContext, useContext, Children, cloneElement, isValidElement } from 'react'
import type { InferProps } from 'prop-types'
import PropTypes from 'prop-types'
import { css, cx } from '@linaria/core'
import { boolAttr, sanitizeProps } from '@fs/zion-frontend-friends'
import type { PolymorphicComponentProps } from '../polymorphic-prop-types'
import GridContext from './GridContext'
import ResponsiveCellProvider from './ResponsiveCellProvider'
import { useWidth } from '../responsive'
import LabelSpacer from '../input-label/LabelSpacer'
import { colors } from '../theme'

export const GutterContext = createContext(0)

export const gridlikeCss = css`
  /* When two grid-like items are siblings, a standard gap between them will be set */
  & + & {
    padding-top: calc(var(--gutters-y) * 2);
  }
`

const gridCss = css`
  display: flex; /* It's a LIE!!! Using display:Grid with gutters that get larger than columns causes issues. */
  flex-wrap: wrap;
  gap: calc(var(--gutters-y) * 2) calc(var(--gutters-x) * 2);

  --grid-align: stretch;
  --grid-justify: var(--grid-justify-parent, start);
  --grid-width: var(--cell-width);

  &[align-y='top'] {
    --grid-justify-parent: start;
  }

  &[align-y='middle'] {
    --grid-justify-parent: center;
  }

  &[align-y='bottom'] {
    --grid-justify-parent: end;
  }

  &[grow-y] {
    flex-grow: 1;
  }
`

const cellCss = css`
  --grid-width-and-margins: calc(var(--grid-width) + var(--gutters-x) * 2);
  --cell-width: calc(var(--grid-width-and-margins) * var(--cell-columns) / var(--grid-columns) - var(--gutters-x) * 2);
  position: relative;

  /*
   * Please NOTE:
   *
   * The Line below looks a lot like the --cell-width variable above. Unfortunately we can't just use it
   * here, because it will fail in DialogOverlay. Normally, we have a <GridStart> nested directly inside
   * of a <ResponsiveProvider>. But we can't do that in DialogOverlay without introducing strobing problems.
   */
  width: calc((100% + var(--gutters-x) * 2) * var(--cell-columns) / var(--grid-columns) - var(--gutters-x) * 2);
  /* width: var(--cell-width); */ /* maybe someday. If we can have the organization start using the aspect-ratio rule */

  /* In the case the component that this gets wrapped around doesn't return anything (e.g. it returns null),
   * we need this element to not take up any space or columns. We don't allow free-loaders.
   */
  &:empty {
    display: none;
  }

  &[border-end]:before,
  &[border-bottom]:after {
    content: '';
    position: absolute;
    background: ${colors.transparent.gray10};
  }

  &[border-end]:before {
    width: 1px;
    height: 100%;
    top: 0;
    inset-inline-end: calc(var(--gutters-x) * -1);
  }

  &[border-end='full']:before {
    top: calc(var(--gutters-y) * -1);
    height: calc(100% + var(--gutters-y) * 2);
  }

  &[border-bottom]:after {
    width: 100%;
    height: 1px;
    bottom: calc(var(--gutters-y) * -1);
    inset-inline-start: 0;
  }

  &[border-bottom='full']:after {
    width: calc(100% + var(--gutters-x) * 2);
    inset-inline-start: calc(var(--gutters-x) * -1);
  }
`

// Also used in FlowGrid cell alignment
export const cellAlignmentCss = css`
  /** The next two lines are needed to vertically align content,
  * as well as match their neighbor's height if someone passes 
  * in flex-grow/shrink */
  display: flex;
  flex-direction: column;
  align-self: var(--grid-align);
  justify-content: var(--grid-justify);

  &[align-y='top'] {
    --grid-justify: start;
  }

  &[align-y='middle'] {
    --grid-justify: center;
  }

  &[align-y='bottom'] {
    --grid-justify: end;
  }

  /* This is needed for noGrowY to function properly
  * noGrowY requires an explicit alignment for the container to size correctly
  */
  &[no-grow-y] {
    --grid-align: var(--grid-justify);
  }
`

const propTypes = {
  /** Vertical alignment of children */
  alignItemsY: PropTypes.oneOf(['top', 'middle', 'bottom'] as const),

  /**
   * Alias for `alignItemsY`, except for when Grid is a child of another Grid.
   * In that case, use alignY to align the container Grid within its parent Grid
   * and use alignItemsY to align the children of the container Grid.
   */
  alignY: PropTypes.oneOf(['top', 'middle', 'bottom'] as const),

  /** The horizontal and vertical space between each of the cells in the grid */
  gutters: PropTypes.oneOf(['none', 'pico', 'nano', 'xxs', 'xs', 'sm', 'md', 'lg', 'xl', 'xxl'] as const),

  /**
   * The horizontal vertical space between each of the cells in the grid.
   * Use if you'd like the horizontal gutters different than the vertical gutters.
   */
  guttersX: PropTypes.oneOf(['none', 'pico', 'nano', 'xxs', 'xs', 'sm', 'md', 'lg', 'xl', 'xxl'] as const),

  /**
   * The vertical vertical space between each of the cells in the grid.
   * Use if you'd like the horizontal gutters different than the vertical gutters.
   */
  guttersY: PropTypes.oneOf(['none', 'pico', 'nano', 'xxs', 'xs', 'sm', 'md', 'lg', 'xl', 'xxl'] as const),

  /**
   * Whether this Grid should try to fill vertical space.
   *
   * **NOTE:** You must place this Grid _directly_ inside a flex container (Like LayoutBand,
   * a main page, or DialogOverlay), this property will not work!
   */
  growY: PropTypes.bool,
}

type GridProps<C extends ElementType> = PolymorphicComponentProps<C, InferProps<typeof propTypes>>

/**
 * ### _Provides powerful control over the layout of a given set of content._
 * `Grid` allows you to control the size of each internal element individually. For a simple grid with elements all the same size,
 * use `FlowGrid` for simplicity.
 * This grid system is based up on Material Design's [Responsive Layout Grid](https://material.io/design/layout/responsive-layout-grid.html),
 * with some subtle differences:
 *
 * ### There are no margins, only gutters
 *
 * The reason for this is so that the page-layout (some parent element) Can control the margins.
 * This allows for more control in lining up the grid edges with other content.
 *
 * **DO NOT USE A GRID BY ITSELF**: Margins are a very important part of a page layout. Top-level Grids should
 * always be wrapped in a LayoutBand.
 *
 * ### The grid system is always based upon twelve columns.
 *
 * Material Design dictates that smaller devices should be based upon a 4-column system, medium
 * devices on an 8-column system, and larger devices on a 12-column system. This gets confusing
 * when thinking about how your content will be laid out. It also makes things messy if you
 * want to do a 3-column layout on a medium or a small device.
 *
 * Keeping the system as always-12-column is more flexible. **But please don't go overboard.** Try
 * to adhere to the recommendation that smaller devices should use fewer columns. On smaller devices,
 * cells should be set to consume more columns so less content is presented side-by-side.
 *
 * Starting with the most simple of divisions, the following demonstrates how a `Grid` is divided into `Cell`s (represented by `Cards` in this example), each of
which can claim a number of columns for their particular content. These `Cell`s are not responsive (they don't alter
their column count based on the container size) so they stay relatively locked in their place as the screen is resized. 
 *
 * ## Examples
 */
const Grid = <C extends ElementType>({
  children,
  as,
  gutters = 'sm',
  guttersY = gutters,
  guttersX = gutters,
  alignY,
  alignItemsY = alignY,
  growY,
  ...props
}: GridProps<C>): JSX.Element => {
  const gridColumns = useContext(GridContext)
  const width = useWidth()
  const TagName = as || 'div'
  return (
    <TagName
      align-y={alignItemsY}
      grow-y={boolAttr(growY)}
      {...sanitizeProps(props)}
      className={cx(gridCss, gridlikeCss)}
      style={{
        '--grid-columns': gridColumns,
        '--gutters-x': `calc(var(--spacer-${guttersX}) / 2)`, // used by destiny's children to determine their padding
        '--gutters-y': `calc(var(--spacer-${guttersY}) / 2)`, // used by destiny's children to determine their padding
      }}
    >
      {Children.map(children, (child) => {
        // Donâ€™t wrap children that React ignores:
        // https://reactjs.org/docs/jsx-in-depth.html#booleans-null-and-undefined-are-ignored
        if (typeof child === 'boolean' || child == null) return child

        const key = child?.key
        const {
          columns = 12,
          alignY: alignSelfY,
          noGrowY,
          noShrinkX, // eslint-disable-line @typescript-eslint/no-unused-vars -- ignored
          growX, // eslint-disable-line @typescript-eslint/no-unused-vars -- ignored
          order,
          borderEnd,
          borderBottom,
          ...rest
        } = child?.props ?? {}
        if (columns === 'hide') return null
        const clonedChild = isValidElement(child) ? cloneElement({ ...child, props: rest }) : child

        // Make sure a whole number is being passed, and it's within the available columns
        const actualColumns = Math.round(Math.max(1, Math.min(columns, gridColumns)))

        const cellWidth = (actualColumns / 12) * width
        const spacer = alignSelfY === 'nextToInput' ? <LabelSpacer /> : null
        return (
          <ResponsiveCellProvider width={cellWidth}>
            <GridContext.Provider value={actualColumns}>
              <div
                key={key}
                className={cx(cellCss, cellAlignmentCss)}
                border-end={borderEnd === 'full' ? 'full' : boolAttr(borderEnd)}
                border-bottom={borderBottom === 'full' ? 'full' : boolAttr(borderBottom)}
                align-y={alignSelfY}
                no-grow-y={boolAttr(noGrowY)}
                style={{ '--cell-columns': actualColumns, order }}
              >
                {spacer}
                {clonedChild}
              </div>
            </GridContext.Provider>
          </ResponsiveCellProvider>
        )
      })}
    </TagName>
  )
}

Grid.propTypes = propTypes

export default Grid

const GridChildPropTypes = {
  /** Number of columns to occupy. Use the word "hide" to hide.
   * NOTE: In sub-grid situations, The maximum allowed number of
   * columns is defined by the parent Cell component. If you go
   * above the columns defined by the parent, this cell will behave
   * as if you specified the same number of columns as its parent cell.
   */
  columns: PropTypes.oneOf(['hide', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] as const),

  /** Whether to **not** stretch the content vertically to match neighboring cells */
  noGrowY: PropTypes.bool,

  /** Vertical alignment */
  alignY: PropTypes.oneOf(['top', 'middle', 'bottom'] as const),

  /**
   * Set a specific order placement inside of the Grid
   *
   * If you set this value to something positive, it will be placed after all other items
   * that don't have an order property. If you set it to something <= 0, it will be placed
   * before all other items that don't have an order property.
   */
  order: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Whether to show a border on the right side of the cell
   *
   * Use the word "full" to show a longer border, similar to the way
   * a divider works with the `fullWidth` property.
   */
  borderEnd: PropTypes.oneOf([false, true, 'full'] as const),

  /**
   * Whether to show a border on the bottom of the cell
   *
   * Use the word "full" to show a longer border, similar to the way
   * a divider works with the `fullWidth` property.
   */
  borderBottom: PropTypes.oneOf([false, true, 'full'] as const),
}

export const GridCell = ({ order }: InferProps<typeof GridChildPropTypes>): JSX.Element => (
  <div data-something={order} />
)
