import type { FC, UIEvent, ReactNode } from 'react'
import React, { useState, useContext, createContext, useCallback, useMemo, useRef, useEffect } from 'react'
import { css } from '@linaria/core'
import { boolAttr } from '@fs/zion-frontend-friends'

export const pageLayoutCss = css`
  display: flex;
  flex-grow: 1;
  /* This prevents unwanted scrollbars during infosheet sliding animations  */
  width: 100%;
  max-width: 100vw;

  @media print {
    overflow: unset !important;
  }
`

const appContentCss = css`
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  // prevent width from overflowing by removing the default minWidth:fit-content
  min-width: 0;
  min-height: 0;

  &[data-scrollable] {
    overflow-y: auto;
  }

  @media print {
    overflow: unset !important;
  }
`

const spacerCss = css`
  position: relative;
  display: flex;
  flex-grow: 0;
`

export const InfoSheetContext = createContext(null)

export const sideSheetSizes = {
  null: 0,
  sm: 300,
  md: 360,
  lg: 440,
}

type UpdateInfoSheetArgs = {
  isBottomSheet: boolean
  size: 'sm' | 'md' | 'lg'
  close: (nodeToFocus?: HTMLElement | UIEvent) => void
  bottomSheetHeight: number
}

type InfoSheetProviderValues = {
  updateInfoSheet: (args: UpdateInfoSheetArgs) => void
  closingCurrentInfoSheet: (close: () => void, togglingPosition?: boolean) => void
  registerNonClosableSheet: (open: () => void) => void
  sheetPortalDiv: Element
  inFullPageOverlay?: boolean
}

export const useInfoSheetContext = (): InfoSheetProviderValues => useContext(InfoSheetContext)

export const InfoSheetProvider: FC<Pick<InfoSheetProviderValues, 'inFullPageOverlay'> & { children: ReactNode }> = ({
  children,
  inFullPageOverlay,
}) => {
  const [isBottomSheet, setIsBottomSheet] = useState(false)
  const [bottomSheetHeight, setBottomSheetHeight] = useState(300)
  const [sheetSize, setSheetSize] = useState(null)
  const currentClose = useRef<() => void>()
  const nonClosableRef = useRef<() => void>()
  const appContentRef = useRef<HTMLDivElement>()
  const [currentScroll, setCurrentScroll] = useState<number | null>(null)

  // This is a "Callback Ref": https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node
  // Since parent-refs are not defined on initial render of children-components, we need a way to re-render the portal once the element _is_ available
  const [sheetPortalDiv, setSheetPortalDiv] = useState<Element>((): Element | undefined =>
    document ? document.createElement('div') : undefined
  )
  const sheetPortalRef = useCallback(setSheetPortalDiv, [setSheetPortalDiv])

  const registerNonClosableSheet = useCallback((open) => {
    nonClosableRef.current = open
    open?.()
  }, [])

  const updateInfoSheet = useCallback(
    ({ isBottomSheet: thisOneIsBottomSheet, size, close, bottomSheetHeight: thisOneBottomSheetHeight }) => {
      if (!currentClose.current && close) {
        // if opening from a closed position, we set the currentScroll to the document's current scroll position
        const scroll = document.scrollingElement?.scrollTop
        scroll && setCurrentScroll(scroll)
      }

      if (close !== currentClose.current) {
        currentClose.current?.()
        currentClose.current = close
      }
      setIsBottomSheet(thisOneIsBottomSheet)
      setSheetSize(size)
      setBottomSheetHeight(thisOneBottomSheetHeight)
    },
    []
  )

  const closingCurrentInfoSheet = useCallback((close, togglingPosition = false) => {
    if (close === currentClose.current) {
      if (nonClosableRef.current && !togglingPosition) {
        nonClosableRef.current()
      } else if (!togglingPosition) {
        // we update the currentScroll when closing so the document will know where to scroll to
        const scroll = appContentRef.current?.scrollTop
        scroll && setCurrentScroll(scroll)

        // tell the provider that the infosheet is closed
        currentClose.current = null

        // remove the spacer
        setSheetSize(null)
      }
    }
  }, [])

  // The size of the spacer that pushes content
  const spacerSize = sideSheetSizes[sheetSize]
  const width = !isBottomSheet ? spacerSize : '100%'
  const height = isBottomSheet ? bottomSheetHeight : '100%'

  const infoSheetRiffRaff = useMemo(
    (): InfoSheetProviderValues => ({
      updateInfoSheet,
      closingCurrentInfoSheet,
      registerNonClosableSheet,
      sheetPortalDiv,
    }),
    [updateInfoSheet, closingCurrentInfoSheet, registerNonClosableSheet, sheetPortalDiv]
  )

  // This keeps the page scrolled to the same height when switching between document.scrollingElement and the app-content-scroller
  // FullPageOverlay does not need this behavior because its scrollable content is already inside the InfoSheetProvider, unlike when we want to scroll the document
  useEffect(() => {
    if (!inFullPageOverlay && typeof currentScroll === 'number') {
      if (currentClose.current) appContentRef.current.scrollTo({ top: currentScroll })
      else document.scrollingElement.scrollTo({ top: currentScroll })
      setCurrentScroll(null)
    }
  }, [currentScroll, inFullPageOverlay])

  return (
    <InfoSheetContext.Provider value={infoSheetRiffRaff}>
      <div
        className={pageLayoutCss}
        style={{
          flexDirection: !isBottomSheet ? 'row' : 'column',
          // the height should be the same as the viewport minus role indicator
          // when infosheet is open so that we don't have double scrollbars
          height: currentClose.current && !inFullPageOverlay ? 'var(--page-content-height)' : 'auto',
          // the minHeight should always be the viewport minus role indicator except in
          // FullPageOverlay, because FullPageOverlay handles the height of its own contents
          minHeight: !inFullPageOverlay ? 'var(--page-content-height)' : undefined,
          // We should only prevent overflow when an infosheet is open or if the provider is inside a FullPageOverlay
          // because they both have heights that they need to adhere to.
          // We should not hide overflow when there is no height, or else sticky elements will refuse to work (ZIONUI-1351)
          overflow: currentClose.current || inFullPageOverlay ? 'hidden' : undefined,
        }}
      >
        <div
          id="app-content-scroller"
          ref={appContentRef}
          className={appContentCss}
          // when the height is limited to the viewport, we need this to be scrolly
          // FullPageOverlay has its own scrolly element, so it doesn't need this
          data-scrollable={boolAttr(currentClose.current && !inFullPageOverlay)}
        >
          {children}
        </div>

        <div
          ref={sheetPortalRef}
          className={spacerCss}
          style={{
            /* The spacer does not display if there isn't a sheet to display. This is to prevent some css bugs. */
            display: currentClose.current ? 'block' : 'none',
            width,
            height,
            flexShrink: isBottomSheet ? 1 : 0,
          }}
        />
      </div>
    </InfoSheetContext.Provider>
  )
}

// SIZE:
//  - Needed for the spacer, so it can know how much to push content
// PLACEMENT:
//  - Needed for the spacer, so it knows which way to push content
//  - Needed for the flex layout, so it knows which way to set flex direction
// ISOPEN:
//  - Needed for the spacer, so it can determine if it should be expanded or not
// ID:
//  - Unique identifier so we can confirm which sheet is the current sheet
