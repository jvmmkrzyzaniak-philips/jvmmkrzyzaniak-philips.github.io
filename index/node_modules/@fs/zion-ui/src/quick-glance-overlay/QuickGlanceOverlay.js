import React, { forwardRef, useRef } from 'react'
import { css } from '@linaria/core'
import PropTypes from 'prop-types'
import {
  deprecatedPropType,
  focusableSelectors,
  sanitizeProps,
  useForwardRef,
  useRandomId,
} from '@fs/zion-frontend-friends'
import { ResponsiveProvider, usePageWidth } from '../responsive'
import { colors, Theme } from '../theme'
import Overlay, { useOnClose } from '../overlay'
import OpenCloseAnimation from '../open-close-animation'
import Popper from '../popper'
import Portal, { PopperPortalContext } from '../portal'
import useEscHandler from '../use-esc-handler'
import useClickAway from '../use-click-away'
import useFocusManager from '../use-focus-manager'
import useAutoFocus from '../use-auto-focus'
import { DialogOverlay } from '../dialog-overlay'
import MarginBox from '../margin-box'

import { LayoutBandContext } from '../layout-band/LayoutBand'
import QuickGlanceHeader from './QuickGlanceHeader'

const quickGlanceOverlayCss = css`
  min-width: 120px;
  background: ${colors.gray00};
  z-index: 2;
`

const animationStyles = {
  openStyles: { opacity: 1, config: { tension: 300 } },
  closeStyles: { opacity: 0, config: { tension: 300 } },
}

function getNextElement(element) {
  const focusableElements = Array.from(document.querySelectorAll(focusableSelectors))
  const elementIndex = focusableElements.indexOf(element)
  return focusableElements[elementIndex + 1]
}

/**
 * This is for use with other things besides QuickGlanceOverlay;
 * namely: Autosuggest, FilteredSelect, and ComboMenu
 */
export const QuickGlanceOverlayBase = ({
  // Props provided by consumer
  children,
  nonClosable = false,
  onClose,
  escapeToClose = true, // needs to be manually handled inside Autosuggest

  // Popper Props (provided by consumer)
  placement,
  updateOnChildrenChange = true,
  overlayRef,
  z = 8,
  portalRef,

  /** [HIDDEN]: For internal Zion-UI use only */
  centerPlacement,

  // From useOverlay()
  close,
  focusBackRef,
  handleTransitioned,
  isOpen,
  targetRef,
  transitioning,

  /** [SCRUBBED]: Don't pass on to children */
  handleClick,
  open,

  ...props
}) => {
  const ariaProps = { 'aria-modal': 'false' }

  // onClose handler
  useOnClose({
    isOpen,
    transitioning,
    onClose,
  })

  // Close the dialog when clicking off the dialog
  useClickAway({
    enabled: isOpen && !transitioning && !nonClosable,
    originatorRef: targetRef,
    contentRef: overlayRef,
    focusBackRef,
    handler: close,
  })

  // Close on escape key
  useEscHandler({
    handler: close,
    enabled: escapeToClose && isOpen && !nonClosable,
  })

  return !isOpen && !transitioning ? null : (
    <Portal context={PopperPortalContext} ref={portalRef}>
      <Popper
        isOpen={isOpen}
        transitioning={transitioning}
        placement={placement}
        centerPlacement={centerPlacement}
        targetRef={targetRef}
        updateOnChildrenChange={updateOnChildrenChange}
        elevatedZIndex
      >
        <OpenCloseAnimation
          onOpenFinished={handleTransitioned}
          onCloseFinished={handleTransitioned}
          isOpen={isOpen}
          {...animationStyles}
        >
          <Overlay {...ariaProps} ref={overlayRef} z={z} {...sanitizeProps(props)}>
            {children}
          </Overlay>
        </OpenCloseAnimation>
      </Popper>
    </Portal>
  )
}

/** This is used to isolate away some logic that shouldn't be used when in full-screen mode,
 * because DialogOverlay is doing the work instead.
 */
const QuickGlanceOverlayWrapper = forwardRef(
  (
    {
      // Props provided by consumer
      children,
      ariaLabel: oldAriaLabel,
      'aria-label': ariaLabel,
      focusRef,
      maxWidth = '456px',
      nonClosable = false,
      title,

      /** [HIDDEN]: For internal Zion-UI use only */
      overlayRef: externalOverlayRef,

      // From useOverlay()
      close,
      isOpen,
      targetRef,

      ...props
    },
    ref
  ) => {
    const overlayRef = useForwardRef(externalOverlayRef)
    const portalRef = useRef()

    // When focus escapes the overlay, the overlay closes and we determine where the focus ends up
    useFocusManager({
      enabled: isOpen && !nonClosable,
      containerRef: portalRef,
      originatorRef: targetRef,
      handler: (_, tabCycling) => {
        // IF focus escaped through focusing another element, prevent `overlay.close()` from stealing focus away from the element that was focused
        if (!tabCycling) close(null, true)
        // Focus the next thing in the dom after the targetRef
        else if (tabCycling === 'forward') close(getNextElement(targetRef.current))
        // Just focus back to the targetRef
        else close(targetRef.current)
      },
    })

    useAutoFocus({
      isOpen,
      enabled: !nonClosable,
      focusRef,
      containerRef: overlayRef,
    })

    ariaLabel = ariaLabel || oldAriaLabel
    const randomId = useRandomId()
    const ariaProps = { 'aria-modal': 'false' }
    let labelledById
    let describedById

    if (ariaLabel) {
      ariaProps['aria-label'] = ariaLabel
    } else {
      labelledById = `${randomId}-quick-glance-label`
      describedById = `${randomId}-quick-glance-description`
      ariaProps['aria-labelledby'] = labelledById
      ariaProps['aria-describedby'] = describedById
    }

    return (
      <QuickGlanceOverlayBase
        {...props}
        {...ariaProps}
        nonClosable={nonClosable}
        isOpen={isOpen}
        close={close}
        overlayRef={overlayRef}
        targetRef={targetRef}
        portalRef={portalRef}
      >
        {/* Make it so LayoutBands within this component don't use ResponsiveProvider */}
        <LayoutBandContext.Provider value>
          <Theme className={quickGlanceOverlayCss} style={{ maxWidth }} ref={ref}>
            <MarginBox marginX="xs" marginY="xs">
              <ResponsiveProvider>
                <QuickGlanceHeader id={labelledById} title={title} />
                <div id={describedById}>{children}</div>
              </ResponsiveProvider>
            </MarginBox>
          </Theme>
        </LayoutBandContext.Provider>
      </QuickGlanceOverlayBase>
    )
  }
)

const QuickGlanceOverlay = forwardRef(
  (
    {
      children,
      footer,
      fullscreen,

      // Not Fullscreen Props
      nonClosable = false,
      maxWidth = '456px',
      placement,
      updateOnChildrenChange = true,
      centerPlacement,

      ...props
    },
    ref
  ) => {
    const isSmallSize = usePageWidth()({ default: true, sm: false })
    const isFullscreen = isSmallSize && !nonClosable && fullscreen

    const nonFullscreenProps = {
      nonClosable,
      maxWidth,
      placement,
      updateOnChildrenChange,
      centerPlacement,
    }

    return !isFullscreen ? (
      <QuickGlanceOverlayWrapper {...props} {...nonFullscreenProps} ref={ref}>
        {children}
        {footer}
      </QuickGlanceOverlayWrapper>
    ) : (
      <DialogOverlay {...props} footer={footer} ref={ref}>
        {children}
      </DialogOverlay>
    )
  }
)

export default QuickGlanceOverlay

const DomElement = typeof Element === 'undefined' ? () => {} : Element

QuickGlanceOverlay.propTypes = {
  /** The label for the overlay which is read to a screen reader. It defaults to the what's in the QuickGlanceHeader. */
  'aria-label': PropTypes.string,
  ariaLabel: deprecatedPropType(
    'DialogOverlay: `ariaLabel` prop has been deprecated. Please use `aria-label` instead.'
  ),

  /** [HIDDEN]: If true, popper will center the placement. Used for tooltips. */
  // centerPlacement: PropTypes.bool,

  /** Content to go inside the overlay. */
  children: PropTypes.node,

  /** Title of the overlay. Can be jsx. */
  title: PropTypes.node,

  /** Footer of the overlay. Should be used if fullscreen mode needs a footer. Can be jsx. */
  footer: PropTypes.node,

  /** If you want the overlay to focus on something specific, pass a ref to it here. Must be something focusable like an `a`, `button`, `input`, `select`, etc... (See focusable-selectors.js for whole list) */
  focusRef: PropTypes.shape({ current: PropTypes.instanceOf(DomElement) }),

  /** If TRUE internal closing methods (useClickAway and ESC key), focusLock, and fullscreen will be disabled. Must supply a DOM node to `useOverlay.open` to position the overlay. */
  nonClosable: PropTypes.bool,

  /** If TRUE the overlay will go fullscreen on mobile. Does not work if the overlay is nonClosable */
  fullscreen: PropTypes.bool,

  /** Which side of the target to place the overlay. Use an array of placement values to use as backup when the first placement value would render the overlay offscreen. */
  placement: PropTypes.oneOfType([
    PropTypes.oneOf(['top', 'end', 'bottom', 'start', 'top-start', 'top-end', 'bottom-start', 'bottom-end']),
    PropTypes.arrayOf(
      PropTypes.oneOf(['top', 'end', 'bottom', 'start', 'top-start', 'top-end', 'bottom-start', 'bottom-end'])
    ),
  ]),

  /** Sets the max width the quick glance overlay can be */
  maxWidth: PropTypes.string,

  /** If true, the overlay will update its position whenever there is an update to its children. Disable if there are performance issues. */
  updateOnChildrenChange: PropTypes.bool,

  /** Handler fired whenever the dialog is closed. Fires no matter how the dialog is closed. */
  onClose: PropTypes.func,

  /** REQUIRED: Dialog Overlay needs all the props provided from the useOverlay hook in order to work. */
  '{...useOverlay()}': PropTypes.object,
}
