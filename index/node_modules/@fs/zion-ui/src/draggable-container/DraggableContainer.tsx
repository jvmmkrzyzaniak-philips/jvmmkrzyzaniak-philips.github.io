import type { CSSProperties, ElementType, MutableRefObject, ReactNode, SetStateAction, RefObject } from 'react'
import React, {
  createContext,
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from 'react'
import { useSpring, animated } from '@react-spring/web'
import { useEvent, useSyncedRef } from '@fs/zion-frontend-friends'
import type { Bounds, DraggableContextType, Rect, PartialRect, RectSpringValues } from './types'

export const DraggableContext = createContext<DraggableContextType | null>(null)
export type DispatchPosition = (value: SetStateAction<PartialRect>, options?: { animate?: boolean }) => void

const emptyRect: PartialRect = { x: 0, y: 0 }

/** Measure whether two numbers are basically the same */
const closeEnough = (a: number | undefined, b: number | undefined): boolean =>
  a == null || b == null ? a === b : Math.abs(a - b) <= 0.25

/** Measure whether two rectangles are basically the same */
const approximatelyEqual = (a: PartialRect, b: PartialRect): boolean =>
  closeEnough(a.x, b.x) && closeEnough(a.y, b.y) && closeEnough(a.width, b.width) && closeEnough(a.height, b.height)

const SHOULD_ANIMATE = Symbol('SHOULD_ANIMATE')

/**
 * react-spring has an issue where, if you initialize it with one set of props, then
 * add new props to the mix later, it kinda falls apart. This can happen because the `width`
 * and `height` values of DraggableContainer are sometimes left out. This ensures they will
 * actually exist at initialization
 */
const makeFullRect = ({ width, height, ...rest }: PartialRect): Rect => ({
  width: width || 0,
  height: height || 0,
  ...rest,
})

const mergeRects = ({ x, y, width, height }: Rect, future: PartialRect): Rect => ({
  x: future.x ?? x,
  y: future.y ?? y,
  width: future.width ?? width,
  height: future.height ?? height,
})

/**
 * Sometimes the ZoomPan values are calculated with missing information. Examples:
 *  - Before the viewer has been initialized with the size of the canvas
 *  - If the viewer's height is temporarily set to zero (causing division by zeros)
 *  - If the viewer is set to `display: none;`, like when a Suspense is currently loading.
 *
 *  This function prevents the Spring animation system from getting stuck in an unrecoverable
 *  state where the zoomPan values contain NaNs, thus causing future values (often derived
 *  from previous values) to be NaNs.
 */
const hasNaNs = ({ x = 0, y = 0, width = 0, height = 0 }: PartialRect): boolean =>
  [x, y, width, height].some(Number.isNaN)

/**
 * Used to programmatically change the position/size of a DraggableContainer,
 * or to monitor what is happening to it via user interaction.
 */
export const useDraggableContainer = (initialRect: PartialRect = emptyRect): [PartialRect, DispatchPosition] => {
  const [position, updatePosition] = useState<PartialRect>(initialRect)
  const shouldAnimateRef = useRef(false)
  const setPosition = useCallback<DispatchPosition>((rect, { animate = false } = {}) => {
    shouldAnimateRef.current = animate
    updatePosition((prevRect) => {
      let newRect = rect as PartialRect
      if (typeof rect === 'function') newRect = rect(prevRect)

      // in the case that newRect is missing values needed in the
      // approximatelyEqual function, we merge the two references
      const mergedRect = {
        ...prevRect,
        ...newRect,
      }
      if (approximatelyEqual(prevRect, mergedRect)) {
        return prevRect
      }
      if (animate) mergedRect[SHOULD_ANIMATE] = true
      return mergedRect
    })
  }, [])
  return [position, setPosition]
}

/**
 * Hook to allow you to define the boundary of a draggable container
 * based on some other div (like its parent)
 */
export const useDraggableBoundingRef = (
  boundingRef: RefObject<HTMLElement>,
  minWidth: number,
  minHeight: number,
  padding = 0
): ((draggableRect: Rect) => Bounds) =>
  useCallback(
    (draggableRect: Rect): Bounds => {
      const boundingRect: Rect = boundingRef.current?.getBoundingClientRect() || makeFullRect(emptyRect)
      const boundary = {
        x: boundingRect.x - draggableRect.x + padding,
        y: boundingRect.y - draggableRect.y + padding,
        width: boundingRect.width - padding * 2,
        height: boundingRect.height - padding * 2,
      }
      return { boundary, minWidth, minHeight }
    },
    [boundingRef, minWidth, minHeight, padding]
  )

/** Hook to allow you to define the boundary of a draggable container based on the window */
export const useDraggableWindowBounds = (
  minWidth: number,
  minHeight: number,
  padding: number
): ((draggableRect: Rect) => Bounds) =>
  useCallback(
    (draggableRect: Rect): Bounds => {
      const { innerWidth, innerHeight } = window
      const boundary = {
        x: -draggableRect.x + padding,
        y: -draggableRect.y + padding,
        width: innerWidth - padding * 2,
        height: innerHeight - padding * 2,
      }
      return { boundary, minWidth, minHeight }
    },
    [minWidth, minHeight, padding]
  )

// https://www.youtube.com/watch?v=5sEZmMeH96Q
const YUUGE = Number.MAX_VALUE / 2 // Because Later the math breaks on Infinity - Infinity = NaN.
const fantasia = {
  x: -YUUGE,
  y: -YUUGE,
  width: YUUGE * 2,
  height: YUUGE * 2,
}

/** Hook to allow you to define minimum dimensions, but unlimited maximum dimensions based on the window */
export const useDraggableUnbounded = (minWidth = 0, minHeight = 0): ((rect: Rect) => Bounds) =>
  useCallback((): Bounds => ({ boundary: fantasia, minWidth, minHeight }), [minWidth, minHeight])

/**
 * Helper function to quickly get style values
 * @param style the react-spring style rect
 * @returns numerical values of the style rect
 */
export const getCurrentValues = ({ x, y, width, height }: RectSpringValues): Rect => ({
  x: x?.get(),
  y: y?.get(),
  width: width?.get(),
  height: height?.get(),
})

type DraggableProps = {
  /**
   * The current position (and width/height) of the thing to be dragged
   * NOTE: **You must use useDraggableContainer to get this if you need it!!**
   */
  position: PartialRect & { [SHOULD_ANIMATE]?: boolean }

  /**
   * The tag name
   */
  as?: ElementType

  /**
   * The ability to programmatically set the current position (and width/height)
   * of the thing to be dragged.
   * NOTE: **You must use useDraggableContainer to get this if you need it!!**
   */
  setPosition: DispatchPosition

  /** The boundary available to be dragged within */
  getBounds?: (rect: Rect) => Bounds

  /* If you need to know when a drag is starting (like to shut off zoomPan's listeners) */
  onDragStart?: () => void

  /* If you need to know when a drag is ending (like to turn back on zoomPan's listeners) */
  onDragEnd?: () => void

  /* DO NOT USE unless you need this for very specific and prescribed reasons */
  onAnimationChange?: (change: Rect) => void

  /** Disables all sizing and positioning of the component, allowing it to exist as a normal div */
  disabled?: boolean

  /** The children of the component */
  children: ReactNode

  /** Custom css given to the DraggableContainer. */
  className?: string

  /**
   * Css styles
   * @ignore
   */
  style?: CSSProperties
}

type UncontrolledDraggableProps = Omit<DraggableProps, 'position' | 'setPosition'>

const foreverTimes = (): Bounds => ({
  boundary: fantasia,
  minWidth: 0,
  minHeight: 0,
})

const noOp = (): void => undefined

const dummyRect: Rect = { x: 0, y: 0, width: 0, height: 0 }

const ControlledDraggableContainer = forwardRef<HTMLElement, DraggableProps>(
  (
    {
      as = 'div',
      position,
      setPosition,
      disabled = false,
      style: userStyles = {},
      getBounds = foreverTimes,
      onDragStart = noOp,
      onDragEnd = noOp,
      onAnimationChange = noOp,
      children,
      ...props
    },
    ref
  ) => {
    const isDraggingRef = useRef(false)
    const updatePosition = useEvent(setPosition)
    const handleGetBounds = useEvent(getBounds)
    const handleDragStart = useEvent(onDragStart)
    const handleDragEnd = useEvent(onDragEnd)
    const handleUpdate = useEvent((change: Rect) => onAnimationChange(change))

    const isMountedRef = useRef(false)
    useEffect(() => {
      isMountedRef.current = true
      return () => {
        isMountedRef.current = false
      }
    }, [])

    const [style, api] = useSpring<Rect>(() => ({
      ...dummyRect,
      onRest: (restingValue) => {
        if (!isMountedRef.current) return
        handleDragEnd()
        isDraggingRef.current = false
        updatePosition(restingValue.value as PartialRect)
      },
      onChange: (change) => handleUpdate(change.value as Rect),
    }))
    const styleRef = useSyncedRef(style)

    useEffect(() => {
      const { [SHOULD_ANIMATE]: shouldAnimate, ...rect } = position
      api[shouldAnimate ? 'start' : 'set'](makeFullRect(rect))
    }, [position, api])

    // Using this to remove width/height styles when they aren't wanting
    // to be tracked by the spring. That way non-resizable stuff doesn't
    // get messed with.
    const [trackingWidth, setTrackingWidth] = useState(!!position.width)
    const [trackingHeight, setTrackingHeight] = useState(!!position.height)
    useEffect(() => {
      if (position.width) setTrackingWidth(true)
      if (position.height) setTrackingHeight(true)
    }, [position.width, position.height])

    const effectiveStyle = useMemo(() => {
      if (trackingHeight && trackingWidth) return style
      const { width, height, x, y } = style
      if (trackingWidth) return { x, y, width }
      if (trackingHeight) return { x, y, height }
      return { x, y }
    }, [style, trackingHeight, trackingWidth])

    const draggableRef = useRef() as MutableRefObject<HTMLDivElement>
    useImperativeHandle(ref, () => draggableRef.current)

    const value: DraggableContextType = useMemo(
      () => ({
        dragStart: () => {
          handleDragStart()
          isDraggingRef.current = true
          const { x, y } = styleRef.current
          const { offsetWidth, offsetHeight } = draggableRef.current
          return { x: x.get(), y: y.get(), width: offsetWidth, height: offsetHeight }
        },
        dragUpdate: (rect) => {
          if (rect.width) setTrackingWidth(true)
          if (rect.height) setTrackingHeight(true)
          api.set(rect)
        },
        dragEnd: (change) => {
          const current = getCurrentValues(styleRef.current)
          const future = mergeRects(current, change)
          if (!approximatelyEqual(future, current)) {
            api.start(future)
          } else {
            handleDragEnd()
            isDraggingRef.current = false
            updatePosition(mergeRects(current, future))
          }
        },
        getBounds: () => {
          const { x, y, width, height } = draggableRef.current.getBoundingClientRect()
          const currentX = styleRef.current.x.get()
          const currentY = styleRef.current.y.get()
          return handleGetBounds({ x: x - currentX, y: y - currentY, width, height })
        },
        handleOverflow: (transform, shouldAnimate) => {
          if (isDraggingRef.current) return
          const { clientWidth, clientHeight } = draggableRef.current
          const { x, y, width, height } = draggableRef.current.getBoundingClientRect()
          const currentX = styleRef.current.x.get()
          const currentY = styleRef.current.y.get()
          const current = { x: currentX, y: currentY, width: clientWidth, height: clientHeight }
          const bounds = handleGetBounds({ x: x - currentX, y: y - currentY, width, height })
          const delta: PartialRect = transform(current, bounds)

          if (hasNaNs(delta)) return

          if (delta.width !== clientWidth) setTrackingWidth(true)
          else delete delta.width
          if (delta.height !== clientHeight) setTrackingHeight(true)
          else delete delta.height

          if (shouldAnimate) api.start(delta)
          else {
            api.set(delta)
            updatePosition(delta)
          }
        },
      }),
      [api, styleRef, handleDragStart, handleDragEnd, updatePosition, handleGetBounds] // these dependencies are all stable and shouldn't trigger updates
    )

    const TagName = animated(as)

    return (
      <TagName
        {...props}
        ref={draggableRef}
        style={{ ...userStyles, ...(!disabled ? effectiveStyle : {}), position: 'absolute' }}
      >
        <DraggableContext.Provider value={value}>{children}</DraggableContext.Provider>
      </TagName>
    )
  }
)

const UncontrolledDraggableContainer = forwardRef<HTMLElement, UncontrolledDraggableProps>((props, ref) => {
  const [position, setPosition] = useDraggableContainer()
  return <ControlledDraggableContainer {...props} ref={ref} position={position} setPosition={setPosition} />
})

function isControlledProps(props: DraggableProps | UncontrolledDraggableProps): props is DraggableProps {
  return (props as DraggableProps).position !== undefined
}

export const DraggableContainer = forwardRef<HTMLElement, DraggableProps | UncontrolledDraggableProps>((props, ref) => {
  if (isControlledProps(props)) return <ControlledDraggableContainer ref={ref} {...props} />
  return <UncontrolledDraggableContainer {...props} ref={ref} />
})

// eslint-disable-next-line @typescript-eslint/no-unused-vars -- Functions below are just to show props in storybook
export const UseDraggableContainerProps = (_props: PartialRect): JSX.Element => <div />
