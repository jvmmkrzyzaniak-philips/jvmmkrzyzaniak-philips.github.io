import type { Dispatch, ReactNode, RefObject, SetStateAction } from 'react'
import React, { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react'
import { useEvent, useSyncedRef } from '@fs/zion-frontend-friends'
import { css } from '@linaria/core'
import type { MinMax, GestureType, ActionType, DraggingState, UiPoint, PointHandler } from './types'
import { draggingReducer, deltaTransformer, useNonRenderingReducer, zeroPoint } from './reducer'

/**
 * Allows us to take a generic input and get a uiPoint out of it. Useful for various types of events (mouse/touch/etc)
 */
type PointEmitter<E> = (e: E) => UiPoint

const currentlyDraggingCss = css`
  user-select: none; // (https://icseng.atlassian.net/browse/FDXQ12024-27)
`

const initialState: DraggingState = { start: zeroPoint, current: null, gesture: null }

/**
 * Combines multiple touches into a single normalized point.
 * Just compares the first two points (if more than one are present),
 * finds the midpoint, and calculates the distance/rotation between the two
 */
const combineTouches: PointEmitter<TouchEvent> = ({ touches }) => {
  const [p1, p2] = Array.from(touches)
  if (!p2) return { x: p1.clientX, y: p1.clientY, distance: 1, rotation: 0 }
  const x = (p1.clientX + p2.clientX) / 2
  const y = (p1.clientY + p2.clientY) / 2
  const distX = p1.clientX - p2.clientX
  const distY = p1.clientY - p2.clientY
  const distance = Math.sqrt(distX ** 2 + distY ** 2)
  const rotation = Math.atan2(distY, distX)
  return { x, y, distance, rotation }
}

/**
 * Gets a mouse point and converts it into a UI point, so that it can be compatible with
 * the points created by combineTouches
 */
const getMousePoint: PointEmitter<MouseEvent> = ({ clientX: x, clientY: y }) => ({ x, y, distance: 1, rotation: 0 })

/**
 * Pointless stub, to be used for `mouseup` and `touchend` events. The point data for these
 * isn't actually needed, and often the `touchend` event is missing point data anyway.
 */
const dummyPoint: UiPoint = { x: 0, y: 0, distance: 1, rotation: 0 }
const pointless: PointEmitter<unknown> = () => dummyPoint

type UseDraggableType = {
  /**
   * The DOM Node that will be dragged in some way, usually a resize handle or a move handle
   */
  draggableRef: RefObject<HTMLElement>

  /**
   * Function to run on mousedown and touchstart event listeners.
   * @param point the x and y values returned by the event listeners
   * @return boolean to stop propogation and prevent defaults if true
   */
  onDragStart?: PointHandler

  /**
   * Function to run on mousemove and touchmove event listeners.
   * @param point the x and y values returned by the event listeners
   * @return boolean to stop propogation if true
   */
  onDragMove?: PointHandler

  /**
   * Function to run on mouseup and touchend event listeners.
   * @param point the x and y values returned by the event listeners
   * @return boolean to stop propogation if true
   */
  onDragEnd?: PointHandler

  /**
   * Function to run on mousedown and touchstart event listeners.
   * @param point the x and y values returned by the event listeners
   * @return the min and max x and y values provided by the handles
   */
  getBounds?: (point: UiPoint) => MinMax

  /**
   * Whether this needs to be turned off under certain circumstances
   * @default false
   */
  disabled?: boolean

  /** Whether to disallow for a rubber banding effect as feedback to the user */
  noStretchy?: boolean

  /**
   * What cursor should be showing when dragging is happening.
   *
   * Why not just put this on css? That's a good question. The problem with dragging
   * and having rubber-banding (when you get to the limits of what's draggable and it
   * starts to feel stretchy) happen is that your mouse cursor will leave the drag handle
   * at times. This causes the cursor to change to whatever is underneath it. We want
   * to keep that cursor consistent while the drag is in progress.
   *
   * Note: You will probably also need to keep a mouse cursor css rule on the draggable thing,
   * so that the cursor is consistent when just hovering and not dragging.
   */
  cursor?: string

  /**
   * If desired, certain drag events can be ignored, based on the event.
   * By default, dragging on focusable items is prevented (like buttons).
   */
  filterEvents?: (event?: Event) => boolean
}

const missingDispatchThingy = (): void => {
  throw new Error('Providers component is missing. useDraggable or DraggableContainer will not work without it.')
}

export const DraggingCursorContext = createContext<Dispatch<SetStateAction<string>>>(missingDispatchThingy)

export const DraggingCursorProvider = ({ children }: { children: ReactNode }): JSX.Element => {
  const [cursor, setCursor] = useState('')

  return (
    <DraggingCursorContext.Provider value={setCursor}>
      <div className={cursor && currentlyDraggingCss} style={{ cursor }}>
        {children}
      </div>
    </DraggingCursorContext.Provider>
  )
}

// Just a memory-stable noOp function to use as a placeHolder
const noOp = (): void => undefined

// Just a memory-stable noOp function to use as a placeHolder
const alwaysYes = (): boolean => true

const noRightClick = (e: MouseEvent): boolean => !e.button

export default function useDraggable({
  draggableRef,
  onDragStart,
  onDragMove,
  onDragEnd,
  getBounds,
  noStretchy = false,
  cursor = '',
  disabled = false,
  filterEvents = alwaysYes,
}: UseDraggableType): void {
  const handleDragStart = useEvent(onDragStart)
  const handleDragMove = useEvent(onDragMove)
  const handleDragEnd = useEvent(onDragEnd)
  const handleGetBounds = useEvent(getBounds)
  const cachedBoundsRef = useRef<MinMax>() // The bounds should only need to be calculated once every mouseDown
  const setCursor = useContext(DraggingCursorContext)
  const cursorRef = useSyncedRef(cursor)

  // What to do when the dragging state changes after each dispatch
  const handleUpdate = useCallback(
    (newState: DraggingState) => {
      const { current, start, gesture } = newState

      // This is the starting state, and should not fire any events.
      // Once the first gesture happens, start will always exist
      if (!start) return

      // This simulates a point down
      if (gesture && !current) {
        handleDragStart(start)
        setCursor(cursorRef.current)
        cachedBoundsRef.current = handleGetBounds(start)
        return
      }

      if (cachedBoundsRef.current) {
        // Calculate the distance between the start point and the current point
        const delta = deltaTransformer(newState, cachedBoundsRef.current, noStretchy)
        if (gesture) {
          handleDragMove(delta)
        } else {
          setCursor('')
          handleDragEnd(delta)
        }
      }
    },
    [cursorRef, handleDragEnd, handleDragMove, handleDragStart, handleGetBounds, setCursor, noStretchy]
  )

  const [, dispatch] = useNonRenderingReducer(draggingReducer, initialState, handleUpdate)

  const shouldMouseDown = useEvent((event) => filterEvents(event) && noRightClick(event))
  const shouldTouchStart = useEvent(filterEvents)

  const [alwaysListening, sometimesListening] = useMemo(() => {
    // Dispatches UiPoint objects into the reducer for events triggered by mouse/touch/etc
    const dispatchPoints =
      <T extends Event>(
        type: ActionType,
        gesture: GestureType,
        getPoint: PointEmitter<T>,
        onDispatch: () => void = noOp,
        shouldDispatch: (event: T) => boolean = alwaysYes
      ): EventListener =>
      (event: Event) => {
        if (!shouldDispatch(event as T)) return
        dispatch({ type, gesture, point: getPoint(event as T) })
        onDispatch()
      }

    /**
     * This is an array of listeners that are only listening while a user is dragging.
     * They need to turn themselves off when a user is not dragging (like after a mouse-up)
     * The reason is that they have to listen on the window object, and that can be bad
     * if the listeners are on all the time.
     */
    let sometimes: [keyof HTMLElementEventMap, EventListener][] = []

    // Function to call to start the sometimesListening to happen
    const startListening = (): void => sometimes.forEach(([name, callback]) => window.addEventListener(name, callback))

    // Function to call to stop the sometimesListening
    const stopListening = (): void =>
      sometimes.forEach(([name, callback]) => window.removeEventListener(name, callback))

    const touchStart = dispatchPoints('DOWN', 'TOUCH', combineTouches, startListening, shouldTouchStart)
    const touchMove = dispatchPoints('MOVE', 'TOUCH', combineTouches)
    const touchEnd = dispatchPoints('UP', 'TOUCH', pointless, stopListening)

    const mouseDown = dispatchPoints('DOWN', 'MOUSE', getMousePoint, startListening, shouldMouseDown)
    const mouseMove = dispatchPoints('MOVE', 'MOUSE', getMousePoint)
    const mouseUp = dispatchPoints('UP', 'MOUSE', pointless, stopListening)

    const always: [keyof HTMLElementEventMap, EventListener][] = [
      ['mousedown', mouseDown],
      ['touchstart', touchStart],
    ]

    sometimes = [
      ['mousemove', mouseMove],
      ['mouseup', mouseUp],
      ['touchmove', touchMove],
      ['touchend', touchEnd],
      ['touchcancel', touchEnd],
    ]

    return [always, sometimes]
  }, [dispatch, shouldMouseDown, shouldTouchStart])

  useEffect(() => {
    const dragHandle = draggableRef.current
    if (disabled) {
      alwaysListening.forEach(([name, callback]) => dragHandle?.removeEventListener?.(name, callback))
    } else {
      alwaysListening.forEach(([name, callback]) => dragHandle?.addEventListener?.(name, callback, { capture: true }))
    }
  }, [disabled, alwaysListening, sometimesListening, draggableRef])

  // For when the component unmounts
  useEffect(() => {
    const dragHandle = draggableRef.current
    return () => {
      alwaysListening.forEach(([name, callback]) => dragHandle?.removeEventListener?.(name, callback))
      sometimesListening.forEach(([name, callback]) => window.removeEventListener?.(name, callback))
    }
  }, [alwaysListening, sometimesListening, draggableRef])
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars -- This is just to show props in storybook
export const UseDraggableProps = (_props: UseDraggableType): JSX.Element => <div />
