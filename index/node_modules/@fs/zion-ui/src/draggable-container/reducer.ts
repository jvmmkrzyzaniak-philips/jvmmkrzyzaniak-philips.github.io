import { useRef, useCallback } from 'react'
import { useEvent } from '@fs/zion-frontend-friends'
import type { DraggingState, DraggingAction, UiPoint, MinMax } from './types'
import { minMax, makeStretchyMinMax, stretchyRotation, insideOutStretchyPants, limitRotation } from './limiters'

const stretchyMinMax = makeStretchyMinMax({
  minStrength: 0.05,
  maxStrength: 0.05,
})

const stretchyScale = makeStretchyMinMax({
  minClamper: insideOutStretchyPants,
  minStrength: 0.05,
  maxStrength: 0.05,
})

type NeverNullRef<T> = {
  current: T
}

export const draggingReducer = (state: DraggingState, action: DraggingAction): DraggingState => {
  const { type, gesture, point } = action
  const { gesture: currentGesture } = state
  switch (type) {
    case 'DOWN':
      if (currentGesture && currentGesture !== gesture) return state
      return {
        ...state,
        start: point,
        current: null,
        gesture,
      }

    case 'MOVE':
      if (currentGesture !== gesture) return state
      return { ...state, current: point }

    case 'UP':
      if (currentGesture !== gesture) return state
      return { ...state, gesture: null }

    default:
      return state
  }
}

export const zeroPoint: UiPoint = { x: 0, y: 0, distance: 1, rotation: 0 }

export const deltaTransformer = (state: DraggingState, { min, max }: MinMax, noStretchy = false): UiPoint => {
  const { start, current, gesture } = state
  if (!current) return zeroPoint

  // Calculate the base delta
  const unlimited = {
    x: current.x - start.x,
    y: current.y - start.y,
    distance: current.distance / start.distance,
    rotation: current.rotation - start.rotation,
  }

  // If we're in the middle of a gesture, we return a stretched version of the delta
  if (gesture && !noStretchy) {
    return {
      x: stretchyMinMax(unlimited.x, min.x, max.x),
      y: stretchyMinMax(unlimited.y, min.y, max.y),
      distance: stretchyScale(unlimited.distance, min.distance, max.distance),
      rotation: stretchyRotation(unlimited.rotation),
    }
  }

  // But if we're at the end of a gesture (mouse-up, etc.), we return a fully-limited version
  return {
    x: minMax(unlimited.x, min.x, max.x),
    y: minMax(unlimited.y, min.y, max.y),
    distance: minMax(unlimited.distance, min.distance, max.distance),
    rotation: limitRotation(unlimited.rotation),
  }
}

/**
 * This is similar to React.useReducer, except it doesn't trigger a re-render
 * with every state update. This is good for rendering performance when you're
 * using non-rendering tools like react-spring's `animated` component.
 *
 * @param reducer the reducer function to use
 * @param initialState the initial state
 * @param onUpdate what you'd like to happen when the state changes
 */
export const useNonRenderingReducer = <S, A>(
  reducer: (state: S, action: A) => S,
  initialState: S,
  onUpdate: (state: S) => void
): [NeverNullRef<S>, (action: A) => void] => {
  const handleUpdate = useEvent(onUpdate)
  const stateRef = useRef(initialState)
  const dispatch = useCallback(
    (action: A): void => {
      const prevState = stateRef.current
      const newState = reducer(prevState, action)
      handleUpdate(newState)
      stateRef.current = newState
    },
    [reducer, handleUpdate]
  )
  return [stateRef, dispatch]
}
