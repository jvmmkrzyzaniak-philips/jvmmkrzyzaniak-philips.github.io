import type { ForwardRefExoticComponent, HTMLAttributes } from 'react'
import React, { forwardRef, useCallback, useContext, useRef } from 'react'
import { css, cx } from '@linaria/core'
import { useEvent, useForwardRef } from '@fs/zion-frontend-friends'
import useDraggable from './useDraggable'
import { DraggableContext } from './DraggableContainer'
import type { Bounds, MinMax, Rect, PartialRect, UiPoint } from './types'
import { textDirection } from '../rtl-support'

// eslint-disable-next-line @fs/zion/logical-over-directional -- This is necessary because of the way it's being used
const handleCss = css`
  --handle-size: 15px;
  position: absolute;
  left: 0;
  top: 0;
  user-select: none;
  width: var(--handle-size);
  height: var(--handle-size);
  margin-left: calc(-0.5 * var(--handle-size));
  margin-top: calc(-0.5 * var(--handle-size));

  @media (pointer: coarse) {
    --handle-size: 24px;
  }
`

const xCss = css`
  height: 100% !important;
  margin-top: 0 !important;
`

// eslint-disable-next-line @fs/zion/logical-over-directional -- This is necessary because of the way it's being used
const yCss = css`
  width: 100% !important;
  margin-left: 0 !important;
`

// eslint-disable-next-line @fs/zion/logical-over-directional -- This is necessary because of the way it's being used
const rightCss = css`
  left: 100% !important;
`

const bottomCss = css`
  top: 100% !important;
`

type HandleProps = HTMLAttributes<HTMLDivElement> & {
  disabled?: boolean
}

type BaseDragHandleProps = HandleProps & {
  cursor: string
  noStretchy?: boolean
  getBounds(boundingDimensions: Bounds, currentRect: Rect): MinMax
  onDragMove(delta: UiPoint, currentRect: PartialRect): PartialRect
}

type BorderHandleProps = HandleProps & {
  topLeft?: Record<string, unknown>
  top?: Record<string, unknown>
  topRight?: Record<string, unknown>
  left?: Record<string, unknown>
  right?: Record<string, unknown>
  bottomLeft?: Record<string, unknown>
  bottom?: Record<string, unknown>
  bottomRight?: Record<string, unknown>
}

// This is declared outside of the component that uses it, so that it will keep referential integrity.
// It's a default value of something, so that this code doesn't complain when a rect isn't provided.
const emptyRect: Rect = { x: 0, y: 0, width: 0, height: 0 }

export const BaseDragHandle = forwardRef<HTMLDivElement, BaseDragHandleProps>(
  ({ getBounds: getDragHandleBounds, onDragMove, disabled, cursor, style, noStretchy, ...props }, ref) => {
    const draggableRef = useForwardRef(ref)
    const startRef = useRef(emptyRect)

    const handleGetBounds = useEvent(getDragHandleBounds)
    const handleDragMove = useEvent(onDragMove)

    const { dragStart, dragUpdate, dragEnd, getBounds } = useContext(DraggableContext)

    const onDragStartHandler = useCallback(() => {
      startRef.current = dragStart()
    }, [dragStart])

    const onDragMoveHandler = useCallback(
      (delta: UiPoint) => {
        const startRect = startRef.current
        const change = handleDragMove(delta, startRect)
        dragUpdate(change)
      },
      [dragUpdate, handleDragMove]
    )

    const onDragEndHandler = useCallback(
      (delta: UiPoint) => {
        const change = handleDragMove(delta, startRef.current)
        dragEnd(change)
      },
      [handleDragMove, dragEnd]
    )

    const getBoundsHandler = useCallback(
      () => handleGetBounds(getBounds(), startRef.current),
      [getBounds, handleGetBounds]
    )

    useDraggable({
      draggableRef,
      getBounds: getBoundsHandler,
      onDragStart: onDragStartHandler,
      onDragMove: onDragMoveHandler,
      onDragEnd: onDragEndHandler,
      cursor,
      disabled,
      noStretchy,
    })

    return (
      <div ref={draggableRef} data-drag-handle style={{ ...style, cursor: disabled ? undefined : cursor }} {...props} />
    )
  }
)

export const MoveHandle = forwardRef<HTMLDivElement, HandleProps>((props, ref) => (
  <BaseDragHandle
    {...props}
    ref={ref}
    getBounds={(b, { x, y, width, height }) => ({
      min: { x: b.boundary.x - x, y: b.boundary.y - y },
      max: { x: b.boundary.x + b.boundary.width - x - width, y: b.boundary.y + b.boundary.height - y - height },
    })}
    onDragMove={(delta, { x, y }) => ({ x: x + delta.x, y: y + delta.y })}
    cursor="move"
  />
))

type LimitValue = (x: number, width: number, leftBound: number, rightBound: number, minWidth: number) => number
type UpdateValue = (x: number, width: number, delta: number) => number | undefined

const noMin = (): number => -Infinity
const noMax = (): number => Infinity
const noChange = (): undefined => undefined

type MakeHandle = {
  minX?: LimitValue
  minY?: LimitValue
  maxX?: LimitValue
  maxY?: LimitValue
  setX?: UpdateValue
  setY?: UpdateValue
  setWidth?: UpdateValue
  setHeight?: UpdateValue
}

const makeResizeHandle = (
  {
    minX = noMin,
    minY = noMin,
    maxX = noMax,
    maxY = noMax,
    setX = noChange,
    setY = noChange,
    setWidth = noChange,
    setHeight = noChange,
  }: MakeHandle,
  cursor: string,
  classNames: string[] = []
): ForwardRefExoticComponent<HandleProps> =>
  forwardRef<HTMLDivElement, HandleProps>(({ className, ...props }, ref) => (
    <BaseDragHandle
      {...props}
      ref={ref}
      getBounds={({ boundary, minHeight, minWidth }, { x, y, width, height }) => ({
        min: {
          x: minX(x, width, boundary.x, boundary.width, minWidth),
          y: minY(y, height, boundary.y, boundary.height, minHeight),
        },
        max: {
          x: maxX(x, width, boundary.x, boundary.width, minWidth),
          y: maxY(y, height, boundary.y, boundary.height, minHeight),
        },
      })}
      onDragMove={(delta, { x, y, width, height }) => ({
        x: setX(x, width, delta.x),
        y: setY(y, height, delta.y),
        width: setWidth(x, width, delta.x),
        height: setHeight(y, height, delta.y),
      })}
      className={cx(handleCss, ...classNames, className)}
      cursor={cursor}
    />
  ))

const setTopHandleY: UpdateValue = (y, _, deltaY) => y + deltaY
// The text direction needs to be ascertained at render time, not when this file is imported and the config objects are created.
const setHorizontalHandleXIfDirectionIs: (targetTextDirection: 'ltr' | 'rtl') => UpdateValue =
  (targetTextDirection) => (x, _, deltaX) => (textDirection() === targetTextDirection ? x + deltaX : undefined)
const setLeftHandleWidth: UpdateValue = (_, width, deltaX) => width - deltaX
const setRightHandleWidth: UpdateValue = (_, width, deltaX) => width + deltaX

const limitLeftMin: LimitValue = (x, _, leftBound) => leftBound - x
const limitLeftMax: LimitValue = (_, width, _1, _2, minWidth) => width - minWidth

const limitRightMin: LimitValue = (_, width, _1, _2, minWidth) => minWidth - width
const limitRightMax: LimitValue = (x, width, leftBound, rightBound) => leftBound + rightBound - x - width

const topConfig = {
  minY: limitLeftMin,
  maxY: limitLeftMax,
  setY: setTopHandleY,
  setHeight: setLeftHandleWidth,
}

const bottomConfig = {
  minY: limitRightMin,
  maxY: limitRightMax,
  setHeight: setRightHandleWidth,
}

const leftConfig = {
  minX: limitLeftMin,
  maxX: limitLeftMax,
  setX: setHorizontalHandleXIfDirectionIs('ltr'),
  setWidth: setLeftHandleWidth,
}

const rightConfig = {
  minX: limitRightMin,
  maxX: limitRightMax,
  setX: setHorizontalHandleXIfDirectionIs('rtl'),
  setWidth: setRightHandleWidth,
}

export const TopResizeHandle = makeResizeHandle(topConfig, 'ns-resize', [yCss])
export const BottomResizeHandle = makeResizeHandle(bottomConfig, 'ns-resize', [yCss, bottomCss])
export const LeftResizeHandle = makeResizeHandle(leftConfig, 'ew-resize', [xCss])
export const RightResizeHandle = makeResizeHandle(rightConfig, 'ew-resize', [xCss, rightCss])

export const TopLeftResizeHandle = makeResizeHandle({ ...topConfig, ...leftConfig }, 'nwse-resize')
export const TopRightResizeHandle = makeResizeHandle({ ...topConfig, ...rightConfig }, 'nesw-resize', [rightCss])
export const BottomLeftResizeHandle = makeResizeHandle({ ...bottomConfig, ...leftConfig }, 'nesw-resize', [bottomCss])
export const BottomRightResizeHandle = makeResizeHandle({ ...bottomConfig, ...rightConfig }, 'nwse-resize', [
  bottomCss,
  rightCss,
])

export const BorderResizeHandles = ({
  topLeft,
  top,
  topRight,
  left,
  right,
  bottomLeft,
  bottom,
  bottomRight,
}: BorderHandleProps): JSX.Element => (
  <>
    <TopResizeHandle {...top} />
    <BottomResizeHandle {...bottom} />
    <LeftResizeHandle {...left} />
    <RightResizeHandle {...right} />
    <TopLeftResizeHandle {...topLeft} />
    <TopRightResizeHandle {...topRight} />
    <BottomLeftResizeHandle {...bottomLeft} />
    <BottomRightResizeHandle {...bottomRight} />
  </>
)
