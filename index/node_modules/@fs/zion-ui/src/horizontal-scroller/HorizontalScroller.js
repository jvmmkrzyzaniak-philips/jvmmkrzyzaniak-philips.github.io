import React, { useState, useEffect, useRef, forwardRef, useCallback, useContext } from 'react'
import PropTypes from 'prop-types'
import { css, cx } from '@linaria/core'
import { useSpring } from '@react-spring/web'
import { useTranslation } from 'react-i18next'

import { ArrowCaret } from '@fs/zion-icon'
import { ObserverRootContext, boolAttr, useEvent, useForwardRef, useResizeObserver } from '@fs/zion-frontend-friends'

import { IconButton } from '../buttons/icon-button'
import { textDirection } from '../rtl-support'
import { colors } from '../theme'
import { WhiteThemeContext } from '../theme/white-theme'

const containerCss = css`
  position: relative;
  isolation: isolate; // Create a new stacking context
  [data-in-layout-band]& {
    margin: 0 calc(var(--bleedable-sides) * -1);
  }
  /* NOTE: This is a little bit of a hack because of the fact that Card uses Bleedable and not MarginBox. If Card switches over to using MarginBox, this will break. */
  /* TODO: Make this work for all containers (Card, LayoutBand and DialogOverlay) */
  --grid-width: var(--cell-width);
`

const scrollerNavCss = css`
  overflow-x: auto;
  overflow-y: hidden;
  position: relative;
  // allow drag to continue scrolling after user lets go for mobile.
  -webkit-overflow-scrolling: touch;

  -ms-overflow-style: none;
  scrollbar-width: none;
  &::-webkit-scrollbar {
    display: none;
  }
`

const scrollerContentCss = css`
  z-index: 0;
  align-items: center;
  display: flex;
  width: fit-content;
  min-width: 100%;
  position: relative;
  transition: transform 0.2s ease-in-out;

  [data-in-layout-band] & {
    padding: var(--_padding-y, 0) var(--bleedable-sides);
  }
`

const fadingZoneCss = css`
  display: flex;
  align-items: center;
  background: transparent;
  border: 0;
  padding: 0;
  animation: fade-in 0.3s;
  bottom: 0;
  height: 100%;
  margin: 0;
  position: absolute;
  width: 60px;
  cursor: pointer;
  z-index: 1;
  pointer-events: none;
  -webkit-tap-highlight-color: transparent;

  // Just want the button to be clickable not the fade zone
  & button {
    pointer-events: all;
    flex-shrink: 0;
  }

  background: linear-gradient(
    var(--gradient-angle),
    hsla(0, 0%, var(--gradient-color-base), 0) 0%,
    hsla(0, 0%, var(--gradient-color-base), 0.013) 6.075%,
    hsla(0, 0%, var(--gradient-color-base), 0.049) 11.625%,
    hsla(0, 0%, var(--gradient-color-base), 0.104) 16.875%,
    hsla(0, 0%, var(--gradient-color-base), 0.175) 21.75%,
    hsla(0, 0%, var(--gradient-color-base), 0.259) 26.475%,
    hsla(0, 0%, var(--gradient-color-base), 0.352) 30.9%,
    hsla(0, 0%, var(--gradient-color-base), 0.45) 35.325%,
    hsla(0, 0%, var(--gradient-color-base), 0.55) 39.675%,
    hsla(0, 0%, var(--gradient-color-base), 0.648) 44.1%,
    hsla(0, 0%, var(--gradient-color-base), 0.741) 48.525%,
    hsla(0, 0%, var(--gradient-color-base), 0.825) 53.25%,
    hsla(0, 0%, var(--gradient-color-base), 0.896) 58.125%,
    hsla(0, 0%, var(--gradient-color-base), 0.951) 63.375%,
    hsla(0, 0%, var(--gradient-color-base), 0.987) 68.925%,
    hsl(0, 0%, var(--gradient-color-base)) 75%
  );

  &[data-direction='backward'] {
    --gradient-angle: -90deg;
    [dir='rtl'] & {
      --gradient-angle: 90deg;
    }
    inset-inline-start: -1px;
    padding-inline-start: 20px;

    &[data-is-white] {
      background-image: linear-gradient(var(--gradient-angle), ${colors.transparent.gray00} 0%, ${colors.gray02} 35%);
    }
  }

  &[data-direction='forward'] {
    --gradient-angle: 90deg;
    [dir='rtl'] & {
      --gradient-angle: -90deg;
    }
    inset-inline-end: 0;
    justify-content: flex-end;
    padding-inline-end: 20px;

    &[data-is-white] {
      background-image: linear-gradient(var(--gradient-angle), ${colors.transparent.gray00} 0%, ${colors.gray02} 35%);
    }
  }

  &[data-hide-fade] {
    background: none;
  }

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
`

const findClosestIndex = (x, items, isRtl) =>
  items.findIndex((item, index) => {
    const indexOffset = isRtl ? -1 : 1
    const left = items[index - indexOffset]?.getBoundingClientRect().right || item.getBoundingClientRect().left
    const right = items[index + indexOffset]?.getBoundingClientRect().left || item.getBoundingClientRect().right
    return left <= x && right >= x
  })

const getScrollerItems = (itemSelector, horizontalScroller) =>
  Array.from(horizontalScroller.querySelectorAll(itemSelector))

export const smartLeftScroller =
  (itemSelector, margin = 32) =>
  (currentScrollPos, horizontalScroller) => {
    const isRtl = textDirection() === 'rtl'
    const scrollerDimensions = horizontalScroller.getBoundingClientRect()
    const items = getScrollerItems(itemSelector, horizontalScroller)

    // Find the index of the item that is closest to the left edge of the scroller
    let closestIndex = findClosestIndex(scrollerDimensions.x, items, isRtl)
    const leftmostIndex = isRtl ? items.length - 1 : 0
    if (closestIndex === -1) {
      closestIndex = leftmostIndex
    }

    let closestItem = items[closestIndex]

    const targetItemAmountInView =
      closestItem.getBoundingClientRect().width - (scrollerDimensions.x - closestItem.getBoundingClientRect().x)

    const newScrollPos = currentScrollPos - scrollerDimensions.width + targetItemAmountInView + margin

    const scrollDifference = currentScrollPos - newScrollPos

    // We need to make sure that the amount of scrolling isn't a tiny amount, because it causes an uninspiring experience.
    if (closestIndex === leftmostIndex || currentScrollPos <= 0 || scrollDifference > scrollerDimensions.width / 2) {
      return newScrollPos
    }

    // When the scroll amount is tiny, we will instead just scroll to the left by one single tab
    closestItem = items[closestIndex - (isRtl ? -1 : 1)]
    return currentScrollPos - scrollerDimensions.width + targetItemAmountInView + margin
  }

export const smartRightScroller =
  (itemSelector, margin = 32) =>
  (currentScrollPos, horizontalScroller) => {
    const isRtl = textDirection() === 'rtl'
    const scrollerDimensions = horizontalScroller.getBoundingClientRect()
    const items = getScrollerItems(itemSelector, horizontalScroller)

    // Find the index of the item that is closest to the right edge of the scroller
    let closestIndex = findClosestIndex(scrollerDimensions.right, items, isRtl)
    const rightmostIndex = isRtl ? 0 : items.length - 1
    if (closestIndex === -1) {
      closestIndex = rightmostIndex
    }

    let closestItem = items[closestIndex]
    // Do some math to find the new position
    const newScrollPos = closestItem.getBoundingClientRect().x - scrollerDimensions.x - margin + currentScrollPos

    const scrollDifference = newScrollPos - currentScrollPos

    // We need to make sure that the amount of scrolling isn't a tiny amount, because it causes an uninspiring experience.
    if (closestIndex === rightmostIndex || scrollDifference > scrollerDimensions.width / 2) {
      return newScrollPos
    }

    // When the scroll amount is tiny, we will instead scroll one extra item - but only if the screen is wider than 380px (the smallest breakpoint), otherwise we will skip beyond what is needed.
    if (scrollerDimensions.width > 380) {
      closestItem = items[closestIndex + (isRtl ? -1 : 1)]
    }
    return closestItem.getBoundingClientRect().x - scrollerDimensions.x - margin + currentScrollPos
  }

const defaultScrollRightFn = (currentScroll, horizontalScroller) => currentScroll - 100 + horizontalScroller.clientWidth
const defaultScrollLeftFn = (currentScroll, horizontalScroller) => currentScroll + 100 - horizontalScroller.clientWidth

const ControlledHorizontalScroller = forwardRef(ControlledHorizontalScrollerComponent)
function ControlledHorizontalScrollerComponent(
  {
    buttonColor,
    buttonEmphasis = 'low',
    buttonSize = 'sm',
    children,
    className,
    gradientClassName,
    hideFades,
    hideIcons,
    inLayoutBand,
    marginY,
    scrollLeftFn = defaultScrollLeftFn,
    scrollPosition: restingScrollPosition,
    scrollRightFn = defaultScrollRightFn,
    setScrollPosition: setRestingScrollPosition,
    ...props
  },
  ref
) {
  const isRtl = textDirection() === 'rtl'
  const [t] = useTranslation()
  const [scrolledToStart, setScrolledToStart] = useState(false)
  const [scrolledToEnd, setScrolledToEnd] = useState(false)
  const isWhite = useContext(WhiteThemeContext)

  const contentRef = useRef(null)
  const containerRef = useForwardRef(ref)
  const scrollPositionRef = useRef(restingScrollPosition)
  const [, api] = useSpring(() => ({
    x: restingScrollPosition,
    onChange: (_, ctrl) => {
      containerRef.current.scrollLeft = ctrl.get().x
    },
  }))
  const timeoutId = useRef()

  // Handle the scroll for going left OR right
  const handleScroll = useEvent(() => {
    // Target the parent container
    const scrollerEl = containerRef.current

    // Inital value is 0 for the left scroller
    scrollPositionRef.current = scrollerEl.scrollLeft

    // Set previous position to the left scroller amount, initally is 0
    const previousScrollPosition = scrollPositionRef.current

    // scrollLeft is negative in RTL, but we only need the scalar distance for this calculation
    const scrollDistance = Math.abs(scrollerEl.scrollLeft)
    // Show/hide scroll buttons if not scrolled to start/end (with 2px buffer)
    setScrolledToStart(scrollDistance <= 2)
    setScrolledToEnd(scrollDistance >= scrollerEl.scrollWidth - scrollerEl.clientWidth - 2)

    // Reset Timeout
    clearTimeout(timeoutId.current)

    // Code related to resizing
    timeoutId.current = setTimeout(() => {
      if (scrollPositionRef.current === previousScrollPosition) {
        // When we manually scroll ReactSpring needs to be updated
        api.start({
          x: previousScrollPosition,
          immediate: true,
        })
        setRestingScrollPosition(previousScrollPosition)
      }
    }, 100)
  })

  // Handles resized of screen with the scroll?
  useResizeObserver(containerRef, handleScroll)
  useEffect(handleScroll, [children, handleScroll])

  useEffect(() => {
    // Get scroller element
    const scrollerEl = containerRef.current
    // Adding a buffer to the maxScrollPosition because sometimes the maxScroll is off by a little
    const maxScrollPosition = scrollerEl.scrollWidth - scrollerEl.clientWidth + 8
    // We take the max width we could scroll to and then take the restingScrollPosition as the calculated position.
    const calculatedPosition = Math.min(restingScrollPosition, maxScrollPosition)

    clearTimeout(timeoutId.current)
    api.start({
      x: calculatedPosition,
    })
  }, [restingScrollPosition, api, containerRef])

  const handleArrow = useCallback(
    (scrollAmountFn) => {
      const horizontalScroller = containerRef.current
      const currentScrollPos = horizontalScroller.scrollLeft

      const newScrollPos = scrollAmountFn(currentScrollPos, horizontalScroller)
      setRestingScrollPosition(newScrollPos)
    },
    [setRestingScrollPosition, containerRef]
  )

  const handleLeftArrow = useCallback(() => handleArrow(scrollLeftFn), [handleArrow, scrollLeftFn])
  const handleRightArrow = useCallback(() => handleArrow(scrollRightFn), [handleArrow, scrollRightFn])
  return (
    <div {...props} className={cx(className, containerCss)} data-in-layout-band={boolAttr(inLayoutBand)}>
      {!scrolledToStart && (
        <div
          className={cx(fadingZoneCss, gradientClassName)}
          data-direction="backward"
          data-is-white={boolAttr(isWhite)}
          data-hide-fade={boolAttr(hideFades)}
        >
          {!hideIcons && (
            <IconButton
              debounce={0}
              Icon={ArrowCaret}
              iconDirection="backward"
              onClick={isRtl ? handleRightArrow : handleLeftArrow}
              title={isRtl ? t('scroll.right', 'Scroll right') : t('scroll.left', 'Scroll left')}
              emphasis={buttonEmphasis}
              size={buttonSize}
              color={buttonColor}
            />
          )}
        </div>
      )}

      {/* CONTENT */}
      <div className={scrollerNavCss} ref={containerRef} onScroll={handleScroll}>
        <div
          className={scrollerContentCss}
          ref={contentRef}
          style={marginY ? { '--_padding-y': `var(--spacer-${marginY})` } : undefined}
        >
          <ObserverRootContext.Provider value={containerRef}>{children}</ObserverRootContext.Provider>
        </div>
      </div>

      {!scrolledToEnd && (
        <div
          className={cx(fadingZoneCss, gradientClassName)}
          data-direction="forward"
          data-is-white={boolAttr(isWhite)}
          data-hide-fade={boolAttr(hideFades)}
        >
          {!hideIcons && (
            <IconButton
              debounce={0}
              Icon={ArrowCaret}
              iconDirection="forward"
              onClick={isRtl ? handleLeftArrow : handleRightArrow}
              title={isRtl ? t('scroll.left', 'Scroll left') : t('scroll.right', 'Scroll right')}
              emphasis={buttonEmphasis}
              size={buttonSize}
              color={buttonColor}
            />
          )}
        </div>
      )}
    </div>
  )
}

const UncontrolledHorizontalScroller = forwardRef(UncontrolledHorizontalScrollerComponent)
function UncontrolledHorizontalScrollerComponent(props, ref) {
  const [scrollPosition, setScrollPosition] = useState(0)
  return (
    <ControlledHorizontalScroller
      ref={ref}
      scrollPosition={scrollPosition}
      setScrollPosition={setScrollPosition}
      {...props}
    />
  )
}

const HorizontalScroller = forwardRef(HorizontalScrollerComponent)
function HorizontalScrollerComponent({ scrollPosition, setScrollPosition, ...props }, ref) {
  if (setScrollPosition) {
    return (
      <ControlledHorizontalScroller
        ref={ref}
        scrollPosition={scrollPosition}
        setScrollPosition={setScrollPosition}
        {...props}
      />
    )
  }
  return <UncontrolledHorizontalScroller ref={ref} {...props} />
}

export default HorizontalScroller

HorizontalScroller.propTypes = {
  /** JSX of elements that need to scroll */
  children: PropTypes.node.isRequired,

  /** Determines if navigation arrows are displayed */
  hideIcons: PropTypes.bool,

  /** Determines if fade zones are shown */
  hideFades: PropTypes.bool,

  /** Resting scroll position. Must be ≤0 in RTL mode. */
  scrollPosition: PropTypes.number,

  /**
   * Vertical margin around content.
   *
   * Useful if the scrollbars are too close, or if card shadows are being cut off
   */
  marginY: PropTypes.oneOf(['nano', 'xxs', 'xs', 'sm', 'md', 'lg']),

  /**
   * Whether this component is going to be used in a LayoutBand
   *
   * This is useful because it will allow the placement of the buttons to go outside
   * of the space, if available, but will try to line up the content with the LayoutBand's
   * content-well.
   */
  inLayoutBand: PropTypes.bool,

  /** Color of the left/right buttons */
  buttonColor: PropTypes.oneOf(['blue', 'green', 'yellow', 'red', 'purple', 'gray']),

  /** Emphasis of the left/right buttons */
  buttonEmphasis: PropTypes.oneOf(['low', 'high', 'lightHigh']),

  /** Emphasis of the left/right buttons */
  buttonSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg']),

  /** Optional scroll function you can pass in to customize how you scroll to the left. */
  scrollLeftFn: PropTypes.func,

  /** Optional scroll function you can pass in to customize how you scroll to the right. */
  scrollRightFn: PropTypes.func,
}
