import { focusableSelectors, useEvent } from '@fs/zion-frontend-friends'
import React, { useState, useRef, useCallback, useReducer, useEffect, useMemo } from 'react'
import type { UIEvent, RefObject } from 'react'

type OverlayState = {
  /** Whether the overlay is open. */
  isOpen: boolean

  /** Whether the overlay is currently transitioning. True when transitioning in _or_ out. */
  transitioning: boolean

  /** Whether to automatically focus on something in the overlay when it's opened */
  autoFocus?: boolean
}

type OverlayAction = {
  type: 'OPEN' | 'CLOSE' | 'TRANSITIONED'
  autoFocus?: boolean
}

type OpenFunction = (props?: { target?: HTMLElement; autoFocus?: boolean }) => void
type CloseFunction = (nodeToFocus?: HTMLElement | UIEvent, disableFocusBack?: boolean) => void
type HandleClickFunction = (event: UIEvent) => void

export type UseOverlayOptions = {
  /** Used to set the initial open value */
  initiallyOpen?: boolean

  /** Receives focus after the overlay is closed.
   *
   *  **NOTE:** If you don't specify a focusBackRef, useOverlay will try to focus back on the element that was clicked to open the overlay.
   */
  focusBackRef?: RefObject<HTMLElement>

  /** Function to call when the overlay finishes closing */
  afterClose?: () => void
}

export type UseOverlayReturnOptions = OverlayState & {
  /** Function to open the overlay. Please consider attaching `handleClick` on open-affordances instead. */
  open: OpenFunction

  /** Function to close the overlay. */
  close: CloseFunction

  /** Click handler that opens or closes the overlay. */
  handleClick: HandleClickFunction

  /** The ref to focus on when the Overlay is opened */
  targetRef: RefObject<HTMLElement>

  /** The ref to focus on when the Overlay is closed */
  focusBackRef: RefObject<HTMLElement>

  /** Handle transition completion for animations */
  handleTransitioned: () => void
}

function reducer(state: OverlayState, action: OverlayAction): OverlayState {
  const { type, autoFocus = true } = action
  switch (type) {
    case 'OPEN':
      if (state.isOpen) return state

      return {
        autoFocus,
        isOpen: true,
        transitioning: true,
      }
    case 'CLOSE':
      if (!state.isOpen) return state

      return {
        ...state,
        isOpen: false,
        transitioning: true,
      }
    case 'TRANSITIONED':
      return {
        ...state,
        transitioning: false,
      }

    default:
      return state
  }
}

export default ({ initiallyOpen = false, focusBackRef }: UseOverlayOptions = {}): UseOverlayReturnOptions => {
  // targetRef is using setState(createRef) because we need to trigger rerenders
  // when targetRef changes, so that popper can update its location when the targetRef changes
  const [targetRef, setTargetRef] = useState<RefObject<HTMLElement>>({ current: null })

  const isMounted = useRef(true)
  const [state, unsafeDispatch] = useReducer(reducer, {
    isOpen: initiallyOpen,
    transitioning: false,
  })

  const { isOpen } = state
  const isOpenRef = useRef(isOpen)
  const dispatch = useCallback((action) => {
    if (isMounted.current) unsafeDispatch(action)
  }, [])

  useEffect(() => {
    isOpenRef.current = isOpen
  }, [isOpen])

  useEffect(() => {
    isMounted.current = true
    return () => {
      isMounted.current = false
    }
  }, [])

  const handleTransitioned = useCallback(() => {
    dispatch({ type: 'TRANSITIONED' })
  }, [dispatch])

  // This is for keeping track of that which was focusable in the target when the overlay was opened
  const internalFocusBackRef = useRef<HTMLElement>()

  const open = useEvent<OpenFunction>(({ target, autoFocus } = {}) => {
    if (isMounted.current && target) {
      setTargetRef({ current: target })
      internalFocusBackRef.current = target.closest(focusableSelectors) || target
    }
    dispatch({ type: 'OPEN', autoFocus })
  })

  /**
   * When the user closes the overlay, we need to focus back on the element that opened the overlay
   * (the internalFocusBackRef), an element of the consumer's choice (focusBackRef), or a target
   * element passed in (nodeToFocus) If close is used as an event handler (e.g. on a button), then
   * nodeToFocus is an event. We don't want to explicitly handle events, but that is still a valid
   * use case (e.g. <Button onClick={overlay.close}/>)
   */
  const close: CloseFunction = useEvent<CloseFunction>((nodeToFocus, disableFocusBack) => {
    dispatch({ type: 'CLOSE' })

    // Sometimes we don't want the close function to focus anything. This is the case in QuickGlanceOverlay when a user clicks a focusable element that is not inside the overlay. In such cases, focus should remain on the element the user clicked and not stolen away by this function.
    if (disableFocusBack) return

    let focusBackElement = focusBackRef?.current || internalFocusBackRef.current
    // Protect against the possibility of an event being passed instead of a node, because a consumer attached `overlay.close` to the onClick of something.
    if (nodeToFocus instanceof HTMLElement) focusBackElement = nodeToFocus

    if (focusBackElement?.focus) {
      requestAnimationFrame(() => isMounted.current && focusBackElement.focus({ preventScroll: true }))
    }
  })

  const handleClick = useEvent<HandleClickFunction>((event) => {
    if (!isOpenRef.current) {
      open({ target: event?.currentTarget as HTMLElement })
    } else {
      close()
    }
  })

  const result: UseOverlayReturnOptions = useMemo(
    () => ({
      ...state,
      open,
      close,
      handleClick,
      targetRef,
      focusBackRef,
      handleTransitioned,
    }),
    [state, targetRef, focusBackRef, open, close, handleClick, handleTransitioned]
  )

  return result
}

// This is just a dummy component so that we can use propTypes to make things easier to document
export const HookReturnProps = ({ isOpen }: UseOverlayReturnOptions): JSX.Element => <div data-is-open={isOpen} />

export const HookProps = ({ initiallyOpen }: UseOverlayOptions): JSX.Element => <div data-is-open={initiallyOpen} />
