import type {
  ElementType,
  HTMLAttributes,
  SetStateAction,
  Dispatch,
  RefAttributes,
  ForwardRefExoticComponent,
} from 'react'
import React, { forwardRef, useMemo, useState, useContext, createContext, useEffect } from 'react'
import type { InferProps } from 'prop-types'
import PropTypes from 'prop-types'

import { cx } from '@linaria/core'
import { boolAttr, sanitizeProps } from '@fs/zion-frontend-friends'
import type { ExtendableProps, PolymorphicComponentPropsWithRef, PolymorphicRef } from '../polymorphic-prop-types'

import type { ContentSlot } from './HeadingContext'
import HeadingContext from './HeadingContext'
import {
  textAcss,
  textBcss,
  textCcss,
  textDcss,
  textEcss,
  textFcss,
  textGcss,
  textHcss,
  textBaseCss,
  displayBaseCss,
  headingBaseCss,
  subheadingBaseCss,
  overlineBaseCss,
  boldCss,
} from './typographyStyles'

export type HeadingLevel = 'H1' | 'H2' | 'H3' | 'H4' | 'H5' | 'H6'

type HeadingBase = {
  baseCss: string
  primaryCss: string
  alternativeCss: string
  subheadingCss: string
  overlineCss: string
}

type HeadingOptions<T extends HeadingLevel> = { TagName: Lowercase<T> } & HeadingBase

type GenericBlockOptions = { TagName: 'div' } & HeadingBase

type HeadingsType = {
  [T in HeadingLevel]: T extends HeadingLevel ? HeadingOptions<T> : GenericBlockOptions
}

const DeconstructedContext = createContext<Dispatch<SetStateAction<Lowercase<HeadingLevel> | null>> | undefined>(
  undefined
)

const headingStyles: HeadingsType = {
  H1: {
    TagName: 'h1',
    baseCss: textBaseCss,
    primaryCss: cx(textHcss, displayBaseCss),
    alternativeCss: cx(textGcss, headingBaseCss, boldCss),
    subheadingCss: cx(textDcss, textBaseCss, subheadingBaseCss),
    overlineCss: cx(textCcss, textBaseCss, overlineBaseCss),
  },
  H2: {
    TagName: 'h2',
    baseCss: textBaseCss,
    primaryCss: cx(textGcss, displayBaseCss),
    alternativeCss: cx(textFcss, headingBaseCss, boldCss),
    subheadingCss: cx(textDcss, textBaseCss, subheadingBaseCss),
    overlineCss: cx(textCcss, textBaseCss, overlineBaseCss),
  },
  H3: {
    TagName: 'h3',
    baseCss: textBaseCss,
    primaryCss: cx(textFcss, displayBaseCss),
    alternativeCss: cx(textEcss, headingBaseCss, boldCss),
    subheadingCss: cx(textCcss, textBaseCss, subheadingBaseCss),
    overlineCss: cx(textBcss, textBaseCss, overlineBaseCss),
  },
  H4: {
    TagName: 'h4',
    baseCss: cx(textBaseCss, headingBaseCss, textDcss),
    primaryCss: boldCss,
    alternativeCss: '',
    subheadingCss: cx(textBcss, textBaseCss, subheadingBaseCss),
    overlineCss: cx(textBcss, textBaseCss, overlineBaseCss),
  },
  H5: {
    TagName: 'h5',
    baseCss: cx(textBaseCss, headingBaseCss, textCcss),
    primaryCss: boldCss,
    alternativeCss: '',
    subheadingCss: cx(textBcss, textBaseCss, subheadingBaseCss),
    overlineCss: cx(textAcss, textBaseCss, overlineBaseCss),
  },
  H6: {
    TagName: 'h6',
    baseCss: cx(textBaseCss, headingBaseCss, textBcss),
    primaryCss: boldCss,
    alternativeCss: '',
    subheadingCss: cx(textAcss, textBaseCss, subheadingBaseCss),
    overlineCss: cx(textAcss, textBaseCss, overlineBaseCss),
  },
}

const propTypes = {
  /**
   * **This is for text, _not_ complex components.**
   * If you find yourself wanting to put complex components
   * inside of a Heading, then you may need to
   * review our Layout components for better results.
   *
   * ### Special Children
   * - **Overline**: Always placed ahead of all other children.
   *   Use to add a precursory text to the main heading.
   *   Rendered as a `<small>` inside of the `<h*>` tag. Screen
   *   readers and SEO will read this as part of the main heading.
   * - **Subheading**: Creates a supplementary paragraph to the
   *   main heading. Rendered as a `<p>` after the `<h*>` of the
   *   heading to work well with screen readers and SEO. Visually
   *   emphasized over regular Paragraphs to guide the reader's
   *   attention.
   */
  children: PropTypes.node,

  /**
   * This represents the font size of the heading text. This allows
   * for flexibility in controlling the visual ballance, while keeping
   * a semantic hierarchy of headings on the page.
   */
  size: PropTypes.oneOf(['H1', 'H2', 'H3', 'H4', 'H5', 'H6'] as const),

  /**
   * Center the text (horizontally). To center vertically, use a
   * layout component.
   */
  centered: PropTypes.bool,

  /**
   * Balance out the way text lines will wrap.
   *
   * Normally, browsers try to put as many words as possible on a line of text. Often look visually awkward,
   * because the last line of a heading could end up having just word on it. This property will balance each
   * line of text so that each line has roughly the same length.
   */
  balanced: PropTypes.bool,

  /**
   * Add this property when you need to use the supplementary form of this heading
   */
  supplementary: PropTypes.bool,
}

type Props = InferProps<typeof propTypes>

type GenericHeadingProps<C extends ElementType> = PolymorphicComponentPropsWithRef<C, Props>

type GenericHeadingComponent = {
  <C extends ElementType = 'div'>(props: GenericHeadingProps<C>): JSX.Element
  displayName?: string
  propTypes?: Record<string, unknown>
}

type DeconstructedHeadingProps = {
  children?: React.ReactNode | React.ReactNode[] | null
} & JSX.IntrinsicAttributes

// This allows us to deconstruct the heading into its semantic value and its visual value.
// This is useful for when we need to use the semantic value for SEO and screen readers,
// but we need to use the visual value to be rendered elsewhere in the document.
export function DeconstructedHeading({ children, ...props }: DeconstructedHeadingProps): JSX.Element {
  const [TagName, setHeadingLevel] = useState<Lowercase<HeadingLevel> | 'div'>('div')
  return (
    <DeconstructedContext.Provider value={setHeadingLevel}>
      <TagName {...props}>{children}</TagName>
    </DeconstructedContext.Provider>
  )
}

export const GenericHeading: GenericHeadingComponent = forwardRef(
  <C extends ElementType = 'div'>(
    { as, balanced, children, centered, size, supplementary, ...props }: GenericHeadingProps<C>,
    ref: PolymorphicRef<C>
  ) => {
    if (!as) throw new Error('Missing required property: as')
    if (!size) throw new Error('Missing required property: size')

    const setExternalHeadingLevel = useContext(DeconstructedContext)

    useEffect(() => {
      if (setExternalHeadingLevel) {
        setExternalHeadingLevel(as as Lowercase<HeadingLevel>)
      }
    }, [setExternalHeadingLevel, as])

    const TagName = setExternalHeadingLevel ? 'div' : (as as ElementType)

    const [overline, setOverlineContent] = useState<ContentSlot<HTMLSpanElement>>()
    const [subheading, setSubheadingContent] = useState<ContentSlot<HTMLParagraphElement>>()

    const context = useMemo(
      () => ({
        setOverlineContent,
        setSubheadingContent,
      }),
      []
    )

    const styles = headingStyles[size]
    if (!styles)
      throw new Error(
        `Invalid size supplied to GenericHeading: "${size}"${
          headingStyles[size.toUpperCase()]
            ? `, you probably mean to use "${size.toUpperCase()}"`
            : '. Options are H1, H2, H3, H4, H5, H6'
        }`
      )
    const { baseCss, primaryCss, alternativeCss, overlineCss, subheadingCss } = styles
    const headingCss = cx(baseCss, supplementary ? alternativeCss : primaryCss)

    const dataCentered = boolAttr(centered)

    // When using an h1-h6, the subheading should live as a sibling to the heading component,
    // But when using this component to lay out typography in non-heading components, it is
    // much better to keep all the text elements as siblings
    //
    // Who let the dogs out? H1-H6
    // Who has lap dogs? RecordBlock, ListItem, and PersonBlock
    let theDogsOut = false
    if (typeof TagName === 'string' && /^h[1-6]$/.test(TagName)) {
      theDogsOut = true
    }

    const Overline = (overline?.as || (theDogsOut ? 'small' : 'span')) as 'small'
    const overlineContent = overline?.children && (
      <Overline
        {...sanitizeProps(overline.props)}
        ref={overline.ref}
        className={overlineCss}
        data-secondary={boolAttr(overline.secondary)}
        data-balanced={boolAttr(balanced)}
      >
        {overline.children}
      </Overline>
    )

    const Subheading = (subheading?.as || (theDogsOut ? 'p' : 'span')) as 'p'
    const subheadingContent = subheading?.children && (
      <Subheading
        {...sanitizeProps(subheading.props)}
        ref={subheading.ref}
        data-secondary={boolAttr(subheading.secondary)}
        data-centered={dataCentered}
        className={subheadingCss}
        data-balanced={boolAttr(balanced)}
      >
        {subheading.children}
      </Subheading>
    )

    return (
      <HeadingContext.Provider value={context}>
        <TagName
          {...sanitizeProps(props)}
          ref={ref}
          data-balanced={boolAttr(balanced)}
          className={headingCss}
          data-centered={dataCentered}
        >
          {overlineContent}
          {children}
          {!theDogsOut && subheadingContent}
        </TagName>
        {theDogsOut && subheadingContent}
      </HeadingContext.Provider>
    )
  }
)

type HeadingProps = ExtendableProps<HTMLAttributes<HTMLHeadingElement>, Props>
type HeadingComponent = ForwardRefExoticComponent<HeadingProps & RefAttributes<HTMLHeadingElement>>

const makeHeading = (as: HeadingLevel): HeadingComponent => {
  const { TagName } = headingStyles[as]
  const Heading = forwardRef<HTMLHeadingElement, Props>(({ children, size = as, ...props }, ref) => (
    <GenericHeading size={size} {...props} as={TagName} ref={ref}>
      {children}
    </GenericHeading>
  ))
  Heading.displayName = as
  Heading.propTypes = propTypes
  return Heading
}

/** 
 * ### _Display headings of various semantic values and sizes, with optional subheading or overline text._

Headings consist of six heading levels, similar to HTML. The semantic value and visual size of these headings can be adjusted if they are different.

Each Heading has a specific recommended type pairing from our FS Type. It is highly recommended that you do not alter the typographic pairings and combinations. _If you find that you are in need of alternate Header pairing/combo, please consult with a member of the Zion Design Team._ 

Subheading and Overline are used to pair text along side each heading. 
- `Overline` introduction text that displays above the heading
- `Subheading` supportive text that displays under the heading.
*/
export const H1 = makeHeading('H1')
export const H2 = makeHeading('H2')
export const H3 = makeHeading('H3')
export const H4 = makeHeading('H4')
export const H5 = makeHeading('H5')
export const H6 = makeHeading('H6')
