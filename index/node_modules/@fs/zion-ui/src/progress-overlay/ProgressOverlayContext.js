import React, { useCallback, useContext, lazy, Suspense, useReducer, createContext, useMemo } from 'react'
import PropTypes from 'prop-types'
import { useRandomId } from '@fs/zion-frontend-friends'
import { PortalContext } from '../portal'
import ProgressOverlayStatus from './ProgressOverlayStatus'

const ProgressOverlay = lazy(() => import('./ProgressOverlay'))

export const ProgressOverlayContext = createContext()

const { IN_PROGRESS, SUCCESSFUL, FAILED } = ProgressOverlayStatus
const isValidStatus = (status) => [IN_PROGRESS, SUCCESSFUL, FAILED].includes(status)
const initialGroupState = { onDismiss: undefined, progressItems: [] }

function reducer(state, action) {
  let { progressItemGroups } = state
  const { groupId } = action
  const progressItemGroup = progressItemGroups[groupId] || initialGroupState

  switch (action.type) {
    // Sets the onDismiss function for the progressItemGroup
    case 'SET_ON_DISMISS': {
      return {
        ...state,
        progressItemGroups: { ...progressItemGroups, [groupId]: { ...progressItemGroup, onDismiss: action.onDismiss } },
      }
    }
    // Adds new progress items
    case 'ADD': {
      /** Don't add if the item is already in the progress list. */
      if (progressItemGroup.progressItems.find((progressItem) => progressItem.id === action.progressItem.id)) {
        return state
      }

      let { progressItem } = action
      if (!isValidStatus(action.progressItem.status)) {
        progressItem = { ...progressItem, status: IN_PROGRESS }
      }
      return {
        ...state,
        progressItemGroups: {
          ...progressItemGroups,
          [groupId]: { ...progressItemGroup, progressItems: [progressItem, ...progressItemGroup.progressItems] },
        },
      }
    }
    // Update the progress item
    case 'UPDATE': {
      /** Ignore the update if the item isn't in the progress list. */
      const index = progressItemGroup.progressItems.findIndex(
        (progressItem) => progressItem.id === action.progressItem.id
      )

      if (index === -1) {
        return state
      }

      const progressItems = [...progressItemGroup.progressItems]
      progressItems[index] = { ...progressItems[index], ...action.progressItem }
      return {
        ...state,
        progressItemGroups: { ...progressItemGroups, [groupId]: { ...progressItemGroup, progressItems } },
      }
    }
    // Remove the progress items from the list
    case 'REMOVE': {
      const progressItems = progressItemGroup.progressItems.filter((progressItem) => {
        const index = action.progressItemIds.findIndex((itemId) => progressItem.id === itemId)
        return !(index > -1)
      })
      return {
        ...state,
        progressItemGroups: { ...progressItemGroups, [groupId]: { ...progressItemGroup, progressItems } },
      }
    }
    // Remove all progress items from all groups
    case 'REMOVE_ALL': {
      progressItemGroups = { ...progressItemGroups }
      Object.keys(progressItemGroups).forEach((id) => {
        progressItemGroups[id] = { ...progressItemGroups[id], progressItems: [] }
      })
      return { ...state, progressItemGroups }
    }
    // Set the progress overlay header message
    case 'SET_HEADER_MESSAGE': {
      const headerMessage = action.headerMessage?.trim()
      return { ...state, headerMessage }
    }
    // Set bottom position so that other components can position themselves to not cover progress overlay
    case 'BOTTOM': {
      const { screenBottom } = action
      if (Math.abs(state.screenBottom) === screenBottom) {
        return state
      }
      return { ...state, screenBottom }
    }
    default: {
      throw new Error(`Unhandled action type: ${action.type}`)
    }
  }
}

export function ProgressOverlayProvider({ children, portalDiv }) {
  const [state, dispatch] = useReducer(reducer, {
    progressItemGroups: {},
    headerMessage: '',
    screenBottom: 0,
  })

  const { progressItemGroups, headerMessage, screenBottom } = state
  const flattenedProgressItems = Object.values(progressItemGroups).flatMap(
    (progressItemGroup) => progressItemGroup.progressItems || []
  )

  const removeAllItems = useCallback(() => dispatch({ type: 'REMOVE_ALL' }), [dispatch])

  const removeItem = useCallback(
    (groupId, ...progressItemIds) => dispatch({ type: 'REMOVE', groupId, progressItemIds }),
    [dispatch]
  )

  const setScreenBottom = useCallback(
    (newScreenBottom) => dispatch({ type: 'BOTTOM', screenBottom: newScreenBottom }),
    [dispatch]
  )

  const value = useMemo(() => ({ dispatch, screenBottom }), [screenBottom])

  return (
    <ProgressOverlayContext.Provider value={value}>
      {children}
      <PortalContext.Provider value={portalDiv}>
        <Suspense fallback="">
          {flattenedProgressItems.length > 0 && (
            <ProgressOverlay
              headerMessage={headerMessage}
              progressItemGroups={progressItemGroups}
              flattenedProgressItems={flattenedProgressItems}
              removeItem={removeItem}
              removeAllItems={removeAllItems}
              setScreenBottom={setScreenBottom}
            />
          )}
        </Suspense>
      </PortalContext.Provider>
    </ProgressOverlayContext.Provider>
  )
}

function useProgressOverlay() {
  const groupId = useRandomId()
  const { dispatch } = useContext(ProgressOverlayContext)

  if (dispatch === undefined) {
    throw new Error(
      `It looks like you're trying to use a Zion component without wrapping it in a "Providers" component, which is needed in order for useProgressOverlay to work properly.`
    )
  }

  const createProgressItem = useMemo(() => {
    let count = 1
    return (progressItem, onCancel = () => true) => {
      if (progressItem === undefined) {
        throw new Error(`Missing param 'progressItem'.`)
      }

      const id = count++

      dispatch({ type: 'ADD', groupId, progressItem: { ...progressItem, id, onCancel } })

      const update = (updates) => dispatch({ type: 'UPDATE', groupId, progressItem: { ...updates, id } })

      return update
    }
  }, [dispatch, groupId])

  const setHeaderMessage = useCallback(
    (headerMessage) => dispatch({ type: 'SET_HEADER_MESSAGE', headerMessage }),
    [dispatch]
  )

  const setOnDismiss = useCallback(
    (onDismiss) => dispatch({ type: 'SET_ON_DISMISS', groupId, onDismiss }),
    [dispatch, groupId]
  )

  return { createProgressItem, setHeaderMessage, setOnDismiss }
}

export default useProgressOverlay

export const ProgressItemType = ({ message, status = 'in-progress', percent }) => (
  <div message={message} status={status} percent={percent} />
)
ProgressItemType.propTypes = {
  /** The message to display for the progress item. The Progress Overlay can display up to two lines of text
   *  for each progress item. Ellipsis will be used if the message is longer than that. Hovering the mouse
   *  over the message will display the full text. */
  message: PropTypes.string.isRequired,

  /** The status of the progress item. For your convenience, these values are also exported from `ProgressOverlayStatus`
   *  as `IN_PROGRESS`, `SUCCESS`, and `FAILED`. */
  status: PropTypes.oneOf(['in-progress', 'successful', 'failed']),

  /** The percentage completed. If provided, this value is will be displayed in the progress item. */
  percent: PropTypes.number,
}

export const CreateProgressItemType = (props) => <div {...props} />
CreateProgressItemType.propTypes = {
  /** The progress item to be created. */
  progressItem: PropTypes.shape({
    message: PropTypes.string,
    status: PropTypes.oneOf(['in-progress', 'successful', 'failed']),
    percent: PropTypes.number,
  }).isRequired,
  /** The function to be called when the user clicks the cancel button for the progress item.
   *  A progress item can only be cancelled when its status is `in-progress`.
   */
  onCancel: PropTypes.func,
}

export const UpdateProgressItemType = (props) => <div {...props} />
UpdateProgressItemType.propTypes = {
  /** An object containing one or more of the progress item properties to be updated. */
  progressItem: PropTypes.shape({
    message: PropTypes.string,
    status: PropTypes.oneOf(['in-progress', 'successful', 'failed']),
    percent: PropTypes.number,
  }).isRequired,
}

export const HeaderMessageType = (props) => <div {...props} />
HeaderMessageType.propTypes = {
  /** The message to be displayed in the Progress Overlay header. The header can display up to two lines of text.
   *  Ellipsis will be used if the message is longer than that. Hovering the mouse over the message will
   *  display the full text. */
  message: PropTypes.string.isRequired,
}

export const OnDismissType = (props) => <div {...props} />
OnDismissType.propTypes = {
  /** The function to be called when the Progress Overlay is dismissed. */
  onDismiss: PropTypes.func.isRequired,
}
