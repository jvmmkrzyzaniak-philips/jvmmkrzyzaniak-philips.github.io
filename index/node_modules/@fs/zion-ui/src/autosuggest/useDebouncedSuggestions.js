import { useEffect, useState, useMemo } from 'react'
import { useEvent } from '@fs/zion-frontend-friends'
import debounce from 'lodash.debounce'

/**
 * `useDebouncedSuggestions` is a hook that provides an efficient way to fetch and manage a list of suggestions for
 * Autosuggest components.
 *
 * @param {Function} fetchSuggestions - A function that fetches suggestions based on the user's input text. This
 * function should return a Promise that resolves to an array of suggestions.
 *
 * @param {number} maxWait - The maximum amount of time (in milliseconds) to wait between
 * sending API requests to fetch suggestions.
 *
 * @param {string} initialInputValue - The initial value of the input text. This is useful for scenarios where you want
 * to have a pre-filled value in your input field.
 *
 * @param {Array} initialSuggestions - An array of initial suggestions to be used in conjunction with
 * `initialInputValue`. These suggestions will be shown until the user starts typing in the input field.
 *
 * @param {boolean} fetchWhenInputIsEmpty - Determines whether to fetch suggestions or return an empty array
 * when the input text is empty. If true, `fetchSuggestions` will be called even when the input is empty.
 *
 * @param {boolean} leading - Send a request at the beginning of a burst of requests. Either leading, trailing, or both must be set to true.
 *
 * @param {boolean} trailing - Send a request at the end of a burst of requests. Either leading, trailing, or both must be set to true.
 *
 * @param {number} wait - The minimum amount of time (in milliseconds) to wait before sending another request.
 *
 * @returns {Object} An object containing the following properties:
 *  - `inputText`: The current value of the input text.
 *
 *  - `setInputText`: A function that updates the value of the input text. It accepts either a string or a function
 *  that receives the previous state and returns the new state.
 *
 * - `suggestions`: An array of the current suggestions.
 */

export default function useDebouncedSuggestions(
  fetchSuggestions,
  maxWait = 1000,
  initialInputValue = '',
  initialSuggestions,
  fetchWhenInputIsEmpty = false,
  leading = true,
  trailing = true,
  wait = 300
) {
  // If both leading and trailing are false, no requests will be sent
  if (!leading && !trailing) throw new Error('Either leading, trailing, or both must be set to true')

  const [inputText, setInputText] = useState(initialInputValue)
  const [suggestions, setSuggestions] = useState(initialSuggestions || [])

  // If leading and trailing are true, send a request at the beginning and end of a burst of requests.
  // Send additional requests only if the maxWait time is reached (default 1000ms).
  // Inspired by https://css-tricks.com/the-difference-between-throttling-and-debouncing/
  const doFetch = useEvent(fetchSuggestions)
  const debouncedFetch = useMemo(
    () =>
      debounce(
        async (input, setResults) => {
          // The results / error handling has to be done inside the debounce
          // otherwise we will get outdated results from time to time
          try {
            // using await here instead of promises because await allows for either sync/async function calls
            const results = await doFetch(input)
            if (results) {
              setResults(results)
            }
          } catch (err) {
            console.error(err)
            setResults([])
          }
        },
        wait,
        { leading, maxWait, trailing }
      ),
    [maxWait, doFetch, leading, trailing, wait]
  )

  const trimmedInput = (inputText?.trim && inputText?.trim()) || ''
  const inputIsDirty = initialInputValue
    ? // If the input matches the initial state, the input can still be dirty, because
      // the user might have restored the input value to its original state. In that
      // case we still want to fetch suggestions. We can know if we are in this state if
      // the suggestions do NOT match the initialSuggestions, because they would only
      // match up until the user started changing the input value.
      initialInputValue !== trimmedInput || initialSuggestions !== suggestions
    : trimmedInput.length > 0
  const suggestionsAreEmpty = suggestions.length === 0
  const shouldFetchBecauseEmpty = trimmedInput.length === 0 ? fetchWhenInputIsEmpty : suggestionsAreEmpty
  const shouldFetch = inputIsDirty || shouldFetchBecauseEmpty

  useEffect(() => {
    let canceled = false

    if (shouldFetch) {
      debouncedFetch(trimmedInput, (results) => !canceled && setSuggestions(results))
    } else if (trimmedInput.length === 0) {
      setSuggestions([])
    }

    return () => {
      canceled = true
    }
  }, [shouldFetch, trimmedInput, debouncedFetch])

  return {
    inputText,
    setInputText,
    suggestions,
  }
}
