import React, { forwardRef, useContext, useEffect, useMemo, useRef, useState } from 'react'
import { sanitizeProps, useResizeObserver, useForwardRef, useEvent } from '@fs/zion-frontend-friends'
import { css } from '@linaria/core'
import TextField from '../text-field'
import AutosuggestOverlay from './AutosuggestOverlay'
import { useOverlay } from '../overlay'
import AutosuggestList from './AutosuggestList'
import { DownshiftContext } from './Autosuggest'

const rootCss = css`
  flex-grow: 1;
  position: relative;
`

/**
 * The autosuggest overlay and autosuggest menu need to be in sync with each other, or the user experience will be broken.
 * This hook ensures that the overlay and autosuggest menu are in sync with each other.
 *
 * @param overlay - overlay object returned from useOverlay
 * @param menuIsOpen - boolean indicating if the autosuggest menu is open
 * @param inputContainerRef - ref to the input container
 * @param setOverlayIsOpen - event handler ran when the overlay is opened or closed
 */
const useSyncOverlayState = ({ overlay, menuIsOpen, inputContainerRef, setOverlayIsOpen }) => {
  const { closeMenu } = useContext(DownshiftContext)
  const { isOpen: overlayIsOpen, open, close, handleTransitioned } = overlay
  const prevMenuIsOpenRef = useRef(menuIsOpen)
  const prevOverlayIsOpenRef = useRef(overlayIsOpen)

  useEffect(() => {
    const menuIsOpening = menuIsOpen && !prevMenuIsOpenRef.current
    const menuIsClosing = !menuIsOpen && prevMenuIsOpenRef.current
    const overlayIsClosing = !overlayIsOpen && prevOverlayIsOpenRef.current

    if (menuIsOpening && !overlayIsOpen) {
      // open the overlay if the autosugget menu is opening
      open({ target: inputContainerRef.current })
      setOverlayIsOpen(true)
    } else if (menuIsClosing && overlayIsOpen) {
      // close the overlay if the autosuggest menu is closing
      close()
      handleTransitioned()
      setOverlayIsOpen(false)
    } else if (overlayIsClosing && menuIsOpen) {
      // close the autosuggest menu if the overlay is closing
      closeMenu()
    }
    // The case where the overlay is opening and the menu is closed does not need to be handled here because the overlay only opens when the menu opens.

    prevMenuIsOpenRef.current = menuIsOpen
    prevOverlayIsOpenRef.current = overlayIsOpen
  }, [
    menuIsOpen,
    overlayIsOpen,
    prevMenuIsOpenRef,
    prevOverlayIsOpenRef,
    inputContainerRef,
    open,
    close,
    closeMenu,
    setOverlayIsOpen,
    handleTransitioned,
  ])
}

// For Downshift input props we need to pass some to the wrapping div and some to the input
const InputWrapper = forwardRef(({ children, clearOnClickAway, overlayIsOpen, inputRef, disabled }, ref) => {
  const { getInputProps, inputValue, selectedItem, displaySuggestions, selectHighlightedItem, toggleMenu, closeMenu } =
    useContext(DownshiftContext)
  const { id, value, onBlur, onChange, ...inputWrapperProps } = useMemo(() => {
    const labelledby = overlayIsOpen
      ? {} // use the default from downshift
      : { 'aria-labelledby': undefined } // hide the labelledby until the overlay is open (AA11YQ124-13)
    return getInputProps({
      onKeyDown: (event) => {
        if (event.keyCode === 9) {
          /* tab key */
          if (!clearOnClickAway && inputValue && !selectedItem) {
            // on tab press with an input and no selection: select item and close menu
            selectHighlightedItem()
            if (overlayIsOpen) {
              inputRef.current?.focus()
            }
          }
          closeMenu()
        }
        if (event.keyCode === 27) {
          /* escape key */
          handleSelectingItemOnInputBlurOrEscape({
            event,
            displaySuggestions,
            selectHighlightedItem,
          })
          closeMenu()
        }

        // prevent space ' ' from being entered at the beginning of input
        if (event.key === ' ' && !inputValue?.length) event.preventDefault()
      },
      onClick: () => {
        if (disabled) {
          return
        }
        if (displaySuggestions?.length) toggleMenu()
      },
      'aria-autocomplete': null, // This is to override the aria-autocomplete getInputProps() provides. We already use aria-autocomplete in the input
      ...labelledby,
    })
  }, [
    clearOnClickAway,
    closeMenu,
    disabled,
    displaySuggestions,
    getInputProps,
    inputRef,
    inputValue,
    overlayIsOpen,
    selectedItem,
    selectHighlightedItem,
    toggleMenu,
  ])

  return (
    <div {...inputWrapperProps} ref={ref}>
      {children({ id, value, onBlur, onChange })}
    </div>
  )
})

function handleSelectingItemOnInputBlurOrEscape({ event, displaySuggestions, selectHighlightedItem }) {
  // By default downshift will clear the selected item and input text on blur or escape.
  // Autosuggest design allows for the currently highlighted item to be selected instead.

  // auto-select the highlighted item (the handleInput prop and entered text is managed by the reducerOverride).
  if (displaySuggestions.length > 0) {
    selectHighlightedItem()
    event.nativeEvent.preventDownshiftDefault = true
  }
}

const noOp = () => undefined

// This just wraps the suggestions in an overlay, unless that's not what is wanted.
const AutoSuggestListWrapper = ({ noOverlay, children, ...props }) =>
  noOverlay ? children : <AutosuggestOverlay {...props}>{children}</AutosuggestOverlay>

const InputComponent = ({
  callersOnBlur,
  chromeAutoCompleteOff,
  clearOnClickAway,
  handleOnClear,
  Icon,
  inputRef,
  selectedItem,
  wrapperRef,
  id,
  ...props
}) => {
  const { getInputProps, clearSelection, inputValue } = useContext(DownshiftContext)
  const inputProps = useMemo(
    () =>
      getInputProps({
        autoComplete: chromeAutoCompleteOff,
        onBlur: (event) => {
          callersOnBlur(event)
          // Use relatedTarget to determine if we are really blurring outside the Autosuggest component
          // Avoid overriding downshift behavior when clicking within the Autosuggest option list.
          if (
            (!event.relatedTarget || !wrapperRef.current.contains(event.relatedTarget)) &&
            clearOnClickAway &&
            !inputValue &&
            selectedItem
          ) {
            clearSelection()
          }
        },
      }),
    [
      callersOnBlur,
      chromeAutoCompleteOff,
      clearOnClickAway,
      clearSelection,
      getInputProps,
      inputValue,
      selectedItem,
      wrapperRef,
    ]
  )

  return (
    <TextField
      {...props}
      {...inputProps}
      id={id}
      onClear={handleOnClear}
      Icon={Icon || (selectedItem && selectedItem.Icon)}
      aria-labelledby={undefined} // This is to override the aria-labelledby getInputProps() provides. We already use a "for" and "id" strat.
      ref={inputRef}
    />
  )
}

const AutoSuggestCore = ({
  /** Input Props */
  callersOnBlur,
  chromeAutoCompleteOff = 'off',
  clearable,
  clearOnClickAway,
  disabled,
  errorMessage,
  helpMessage,
  Icon,
  id,
  inputProps: consumerInputProps,
  inputRef: consumerInputRef,
  label,
  largerLabel = false,
  allowLabelWrapping = false,
  maxLength = 512,
  name,
  placeholder,
  validMessage,
  warningValidate,

  /** Overlay Props */
  noOverlay,
  overlayRef,

  /** List Props */
  highlightMatchingText,
  ignoreDiacritics = true,
  itemProps,
  listMaxHeight,
  menuProps,
  virtualize = false,

  isOpen: menuIsOpen,
  onClear = () => {},
  rootRef,
  setOverlayIsOpen = noOp,
  ...extraProps
}) => {
  const { clearSelection, closeMenu, displaySuggestions } = useContext(DownshiftContext)
  const inputRef = useForwardRef(consumerInputRef)
  const inputContainerRef = useRef()
  const wrapperRef = useForwardRef(rootRef)

  const [overlayWidth, setOverlayWidth] = useState(0)
  useResizeObserver(inputContainerRef, (entry) => setOverlayWidth(entry.target.offsetWidth))

  const overlay = useOverlay({ focusBackRef: inputRef })
  const { isOpen: overlayIsOpen } = overlay
  const handleOnClear = useEvent(() => {
    clearSelection()
    onClear()
  })

  useSyncOverlayState({ overlay, menuIsOpen, inputContainerRef, closeMenu, setOverlayIsOpen })

  useEffect(() => {
    if (!displaySuggestions?.length) closeMenu()
  }, [closeMenu, displaySuggestions?.length])

  return (
    <div className={`autosuggest-wrapper ${rootCss}`} ref={wrapperRef}>
      <InputWrapper
        clearOnClickAway={clearOnClickAway}
        overlayIsOpen={overlayIsOpen}
        inputRef={inputRef}
        disabled={disabled}
      >
        {(props) => (
          <InputComponent
            {...sanitizeProps(consumerInputProps)}
            {...sanitizeProps(extraProps)}
            {...props}
            callersOnBlur={callersOnBlur}
            chromeAutoCompleteOff={chromeAutoCompleteOff}
            clearable={clearable}
            clearOnClickAway={clearOnClickAway}
            disabled={disabled}
            errorMessage={errorMessage}
            handleOnClear={handleOnClear}
            helpMessage={helpMessage}
            Icon={Icon}
            id={id}
            inputContainerRef={inputContainerRef}
            inputRef={inputRef}
            label={label}
            largerLabel={largerLabel}
            allowLabelWrapping={allowLabelWrapping}
            maxLength={maxLength}
            name={name}
            placeholder={placeholder}
            validMessage={validMessage}
            warningValidate={warningValidate}
            wrapperRef={wrapperRef}
          />
        )}
      </InputWrapper>
      {displaySuggestions?.length > 0 && (
        <AutoSuggestListWrapper
          inputRef={inputRef}
          noOverlay={noOverlay}
          onCloseFinished={closeMenu}
          overlay={overlay}
          overlayRef={overlayRef}
        >
          <AutosuggestList
            highlightMatchingText={highlightMatchingText}
            ignoreDiacritics={ignoreDiacritics}
            itemProps={itemProps}
            listMaxHeight={listMaxHeight}
            menuProps={menuProps}
            style={{ width: overlayWidth }}
            virtualize={virtualize}
          />
        </AutoSuggestListWrapper>
      )}
    </div>
  )
}

export default AutoSuggestCore
