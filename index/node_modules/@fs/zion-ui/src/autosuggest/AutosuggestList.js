import React, { Fragment, forwardRef, useEffect, useRef, useCallback, useMemo, useContext, createContext } from 'react'
import { sanitizeProps } from '@fs/zion-frontend-friends'
import { css } from '@linaria/core'
import { VariableSizeList } from 'react-window'
import debounce from 'lodash.debounce'
import { List, ListItemCore, ListSubSection } from '../list'
import { colors } from '../theme'
import { textDirection } from '../rtl-support'
import { DownshiftContext } from './Autosuggest'

const groupedMenuCss = css`
  max-width: 600px;
  min-width: 80px;
`
const listWrapperCss = css`
  padding: 0 10px;
`

const matchingTextCss = css`
  color: ${colors.gray100};
  font-weight: bold;
`

export function removeDiacritics(str) {
  // normalize() converts a string into unicode, from which we can replace a range of diacritic characters
  // https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
  return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '')
}

function HighlightMatchingText({ children, textToHighlight, ignoreDiacritics }) {
  const inputText = ignoreDiacritics ? removeDiacritics(textToHighlight) : textToHighlight
  const regexStr = inputText.trim().replace(/\W+/g, '\\W+') // remove all unsafe chars
  const regex = new RegExp(regexStr, 'i')
  const testingStr = ignoreDiacritics ? removeDiacritics(children) : children
  const matchingText = testingStr.match(regex)

  if (matchingText?.[0]) {
    const indexOfMatch = testingStr.indexOf(matchingText[0])
    const charsToHighlight = children.substr(indexOfMatch, matchingText[0].length)
    const displayTermParts = children.split(charsToHighlight)

    return displayTermParts.map((textChunk, i) => {
      if (i === 0) {
        return textChunk
      }
      return (
        <Fragment key={textChunk + String(i)}>
          <span className={matchingTextCss}>{charsToHighlight}</span>
          {textChunk}
        </Fragment>
      )
    })
  }
  return children
}

function PrimaryText({ suggestion, highlightMatchingText, ignoreDiacritics, inputValue }) {
  if (suggestion.type === 'LAST_RESORT') {
    const color = suggestion.color || colors.blue50
    return <span style={{ color }}>{suggestion.primaryText}</span>
  }
  if (highlightMatchingText) {
    return (
      <HighlightMatchingText textToHighlight={inputValue} ignoreDiacritics={ignoreDiacritics}>
        {suggestion.primaryText}
      </HighlightMatchingText>
    )
  }
  return suggestion.primaryText
}

function SecondaryText({ suggestion, highlightMatchingText, inputValue }) {
  return highlightMatchingText ? (
    <>
      <div>
        <HighlightMatchingText textToHighlight={inputValue}>{suggestion.secondaryText || ''}</HighlightMatchingText>
      </div>
      {suggestion.tertiaryText && (
        <div>
          <HighlightMatchingText textToHighlight={inputValue}>{suggestion.tertiaryText || ''}</HighlightMatchingText>
        </div>
      )}
    </>
  ) : (
    <>
      {suggestion.secondaryText || ''}
      {suggestion.tertiaryText || ''}
    </>
  )
}

// When we aren't using sub-sections, drop these props on the floor and go with a fragment. Otherwise, yay SubSections!
const ListWrapper = forwardRef(({ heading, children, ...props }, ref) => {
  if (heading)
    return (
      <div className={listWrapperCss} ref={ref}>
        <ListSubSection {...props} heading={heading}>
          {children}
        </ListSubSection>
      </div>
    )
  return <>{children}</>
})

// TODO: explore this area to find scrolling bug
// Lazy loading?
function scrollItemIntoView(ref) {
  // Scroll to the newly highlighted item
  // we need to wait until the overlay positions itself before scrolling or else we will scroll to the top of the page
  const scrollRequest = requestAnimationFrame(() =>
    ref.current?.querySelector?.('[itemselected]')?.scrollIntoView?.({
      alignToTop: false,
      block: 'nearest',
    })
  )
  return () => cancelAnimationFrame(scrollRequest)
}

const maxWait = 50
const config = { leading: true, maxWait, trailing: true }
const debouncedScrollToItem = debounce(scrollItemIntoView, maxWait, config)

const LIST_ITEM_SIZE = {
  primaryText: 56,
  primaryAndSecondaryText: 80,
  primarySecondaryAndTertiary: 92,
}

const AutoSuggestListContext = createContext(null)

const AutosuggestListItem = ({ index }) => {
  const { itemProps, highlightMatchingText, ignoreDiacritics } = useContext(AutoSuggestListContext)
  const { displaySuggestions, getItemProps, highlightedIndex, inputValue } = useContext(DownshiftContext)
  const suggestion = displaySuggestions[index]
  return (
    <ListItemCore
      {...getItemProps({
        ...sanitizeProps(itemProps),
        item: suggestion,
        index,
      })}
      primaryText={
        // The span is added to prevent the highlighted text from wrapping.
        <span>
          <PrimaryText
            highlightMatchingText={highlightMatchingText}
            inputValue={inputValue}
            suggestion={suggestion}
            ignoreDiacritics={ignoreDiacritics}
          />
        </span>
      }
      secondaryText={
        <SecondaryText highlightMatchingText={highlightMatchingText} inputValue={inputValue} suggestion={suggestion} />
      }
      overline={suggestion.overline}
      startElement={suggestion.startElement}
      endElement={suggestion.endElement}
      data-testid={`suggestion-${index}`}
      selected={highlightedIndex === index}
      disabled={suggestion.disabled}
      interactable
      key={suggestion.key || suggestion.id}
      tabIndex={-1}
    />
  )
}

const VirtualizedRow = ({ index, style }) => (
  <div style={{ ...style, width: '100%' }}>
    <AutosuggestListItem index={index} />
  </div>
)

const getItemSize = (item) => {
  if (item) {
    if (item.primaryText && item.secondaryText && item.tertiaryText) {
      return LIST_ITEM_SIZE.primarySecondaryAndTertiary
    }

    if (item.primaryText && item.secondaryText) {
      return LIST_ITEM_SIZE.primaryAndSecondaryText
    }
    if (item.primaryText) {
      return LIST_ITEM_SIZE.primaryText
    }
  }
  return 0
}

function AutosuggestVirtualizedList({ menuprops, listMaxHeight = 300 }) {
  const { highlightedIndex, displaySuggestions } = useContext(DownshiftContext)
  const variableListRef = useRef(null)

  const getItemSizeFromIndex = useCallback(
    (index) => {
      return getItemSize(displaySuggestions[index])
    },
    [displaySuggestions]
  )

  const listHeight = useMemo(
    () =>
      (displaySuggestions || []).reduce((accum, currentValue) => {
        return Math.min(accum + getItemSize(currentValue), listMaxHeight)
      }, 0),
    [displaySuggestions, listMaxHeight]
  )

  useEffect(() => {
    variableListRef.current.scrollToItem(highlightedIndex)
  }, [highlightedIndex])

  return (
    <List {...menuprops} as="div" height={`${listHeight}`}>
      <VariableSizeList
        direction={textDirection()} // react-window doesn't detect the html dir attribute and overrides it with ltr
        estimatedItemSize={LIST_ITEM_SIZE.primaryAndSecondaryText}
        height={listHeight}
        itemCount={displaySuggestions.length}
        itemSize={getItemSizeFromIndex}
        ref={variableListRef}
        width="100%"
      >
        {VirtualizedRow}
      </VariableSizeList>
    </List>
  )
}

export function groupSuggestionsForGroupList(suggestions) {
  const tempGroupedDisplaySuggestions = suggestions.reduce((acc, suggestion) => {
    const { group = null } = suggestion
    if (acc.has(group)) acc.get(group).push(suggestion)
    else acc.set(group, [suggestion])
    return acc
  }, new Map())

  // sort null last (that is, put stuff not-in-groups at the bottom)
  return new Map(
    [...tempGroupedDisplaySuggestions].sort(([a], [b]) => {
      if (a === null) return 1
      if (b === null) return -1
      return 0
    })
  )
}

function AutosuggestGroupedList({ menuprops, listMaxHeight = 260 }) {
  const listRef = useRef(null)
  const { highlightedIndex, displaySuggestions } = useContext(DownshiftContext)

  const groupedDisplaySuggestions = groupSuggestionsForGroupList(displaySuggestions)

  // Scrolls when the index that is being highlighted changes
  useEffect(() => {
    return debouncedScrollToItem(listRef)
  }, [highlightedIndex])

  // glitter global index across all groups to match downshift highlightedIndex
  let currentGlobalIndex = 0
  groupedDisplaySuggestions.forEach((value) => {
    value.forEach((curSuggestion) => {
      curSuggestion.globalIndex = currentGlobalIndex
      currentGlobalIndex++
    })
  })

  return (
    /* We have to override the a11y props here because Safari does not honor the role=listbox features when mixed with a ul-li DOM structure */
    <List {...menuprops} as="div" maxHeight={`${listMaxHeight}px`} ref={listRef}>
      {[...groupedDisplaySuggestions].map(([group, groupSuggestions], groupIndex) => {
        const namespaceIndex = groupIndex + 1
        return (
          <ListWrapper heading={group} key={`group-${namespaceIndex}`}>
            {groupSuggestions.map((suggestion) => {
              const index = suggestion.globalIndex
              return <AutosuggestListItem index={index} key={index} />
            })}
          </ListWrapper>
        )
      })}
    </List>
  )
}

export default function AutosuggestList({
  highlightMatchingText,
  ignoreDiacritics,
  itemProps,
  listMaxHeight,
  menuProps,
  virtualize,
  ...props
}) {
  const { getMenuProps } = useContext(DownshiftContext)
  const menuprops = getMenuProps(menuProps, { suppressRefError: true })

  const VirtualizedOrGroupedList = virtualize ? AutosuggestVirtualizedList : AutosuggestGroupedList

  const value = useMemo(
    () => ({
      highlightMatchingText,
      ignoreDiacritics,
      itemProps,
    }),
    [highlightMatchingText, ignoreDiacritics, itemProps]
  )

  return (
    <div {...props} className={groupedMenuCss}>
      <AutoSuggestListContext.Provider value={value}>
        <VirtualizedOrGroupedList menuprops={menuprops} listMaxHeight={listMaxHeight} />
      </AutoSuggestListContext.Provider>
    </div>
  )
}
