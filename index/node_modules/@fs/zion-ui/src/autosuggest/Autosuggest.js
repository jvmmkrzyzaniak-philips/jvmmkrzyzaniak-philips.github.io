import React, { createContext, forwardRef, useCallback, useMemo } from 'react'
import Downshift from 'downshift'
import PropTypes from 'prop-types'
import { oneOfComponentType, sanitizeProps, useEvent } from '@fs/zion-frontend-friends'
import { ListItem } from '../list/index'
import AutosuggestCore from './AutosuggestCore'
import { groupSuggestionsForGroupList, removeDiacritics } from './AutosuggestList'

export const DownshiftContext = createContext(null)

function createInputSuggestion(input) {
  return {
    key: 'INPUT_TEXT_OPTION',
    primaryText: input.trim(),
    type: 'INPUT_TEXT_OPTION',
  }
}

function shouldKeepInputValue(changes) {
  // Autosuggest design is to keep the current input value when LAST_RESORT is selected.
  return isLastResortSuggestion(changes.selectedItem)
}

function includesInputText(suggestionText, inputText, ignoreDiacritics) {
  if (suggestionText) {
    const normalizedSuggestionText = (
      ignoreDiacritics ? removeDiacritics(suggestionText) : suggestionText
    ).toLowerCase()
    const normalizedInputText = (ignoreDiacritics ? removeDiacritics(inputText) : inputText).toLowerCase().trim()
    return normalizedSuggestionText.includes(normalizedInputText)
  }
  return false
}

/**
 * This method is inspired by downshift
 * see https://github.com/downshift-js/downshift/blob/master/src/utils.js#L374C10-L374C29
 */
function getNonDisabledSuggestionIndex({ startIndex, backwards = false, suggestions, circular = false }) {
  const count = suggestions.length

  if (backwards) {
    for (let index = startIndex; index >= 0; index--) {
      if (!suggestions[index].disabled) {
        return index
      }
    }
  } else {
    for (let index = startIndex; index < count; index++) {
      if (!suggestions[index].disabled) {
        return index
      }
    }
  }

  if (circular) {
    return getNonDisabledSuggestionIndex({ startIndex: backwards ? count - 1 : 0, backwards, suggestions })
  }

  return -1
}

function getDisplaySuggestions({
  virtualize = false,
  suggestions = [],
  noFilter = false,
  inputValue,
  ignoreDiacritics = true,
  sortFunction = null,
  lastResort,
  showLastResortOnFocus,
  handleInput = false,
}) {
  let displaySuggestions = virtualize
    ? [...suggestions]
    : Array.from(groupSuggestionsForGroupList(suggestions).values()).flat()
  if (!noFilter && inputValue) {
    displaySuggestions = displaySuggestions.filter(
      (suggestion) =>
        includesInputText(suggestion.primaryText, inputValue, ignoreDiacritics) ||
        includesInputText(suggestion.secondaryText, inputValue, ignoreDiacritics) ||
        includesInputText(suggestion.tertiaryText, inputValue, ignoreDiacritics)
    )
  }
  // User-provided sort function for suggestions
  if (sortFunction && typeof sortFunction === 'function') {
    displaySuggestions.sort(sortFunction.bind(null, inputValue))
  }
  if (lastResort && (inputValue || showLastResortOnFocus)) {
    displaySuggestions.push({ ...lastResort, key: 'LAST_RESORT', type: 'LAST_RESORT' })
  }
  if (
    handleInput &&
    inputValue &&
    !displaySuggestions.find((s) => s.primaryText.toLowerCase() === inputValue.toLowerCase().trim())
  ) {
    displaySuggestions.unshift(createInputSuggestion(inputValue))
  }
  return displaySuggestions
}

function isLastResortSuggestion(suggestion) {
  return suggestion?.type === 'LAST_RESORT' && suggestion?.onClick
}

function getSuggestionMatchingInputValue(getSuggestions, state) {
  const suggestions = getSuggestions(state.inputValue)
  const normalizedInputValue = (state.inputValue || '').toLowerCase()
  return suggestions.find((suggestion) => suggestion.primaryText.toLowerCase() === normalizedInputValue)
}

const EventType = Downshift.stateChangeTypes

function stateReducerOverride({ state, changes, getSuggestions, clearOnClickAway, handleInput }) {
  switch (changes.type) {
    case EventType.touchEnd:
      return state // without this, touchEnd will cause the menu to close before the clickItem event can fire on mobile

    case EventType.keyDownEnter:
    case EventType.clickItem:
      if (changes.selectedItem?.disabled) {
        return state
      }
      if (changes.selectedItem?.type === 'LAST_RESORT' && changes.selectedItem?.onClick) {
        changes.selectedItem.onClick()
        return state
      }
      return changes

    case EventType.keyDownArrowUp:
    case EventType.keyDownArrowDown:
    case EventType.keyDownHome:
    case EventType.keyDownEnd: {
      const currentSuggestions = getSuggestions(state.inputValue)
      if (currentSuggestions[changes.highlightedIndex]?.disabled) {
        return {
          ...changes,
          highlightedIndex: getNonDisabledSuggestionIndex({
            startIndex: changes?.highlightedIndex,
            backwards: changes.type === EventType.keyDownArrowUp || changes.type === EventType.keyDownEnd,
            suggestions: currentSuggestions,
            circular: changes.type === EventType.keyDownArrowUp || changes.type === EventType.keyDownArrowDown,
          }),
        }
      }
      return changes
    }
    case EventType.blurInput:
      if (!clearOnClickAway) {
        const suggestionMatchingInputValue = getSuggestionMatchingInputValue(getSuggestions, state)

        if (isLastResortSuggestion(suggestionMatchingInputValue)) {
          return state
        }

        changes.inputValue = state.inputValue

        if (suggestionMatchingInputValue) {
          // avoid updating changes if it already matches the currently selectedItem
          if (
            suggestionMatchingInputValue.primaryText.toLowerCase() !== state.selectedItem?.primaryText?.toLowerCase()
          ) {
            changes.selectedItem = suggestionMatchingInputValue
          }
        } else if (handleInput && state.inputValue) {
          changes.selectedItem = createInputSuggestion(state.inputValue)
        }
      }
      if (shouldKeepInputValue(changes)) {
        return { ...changes, inputValue: state.inputValue }
      }
      return changes
    case EventType.mouseUp:
      return state
    default:
      if (shouldKeepInputValue(changes)) {
        return { ...changes, inputValue: state.inputValue }
      }
      return changes
  }
}

const DownshiftInner = ({
  downshiftProps,
  getSuggestions,
  lastResort,
  noFilter,
  showLastResortOnFocus,
  sortFunction,
  ...props
}) => {
  const { isOpen, inputValue } = downshiftProps
  const displaySuggestions = useMemo(() => getSuggestions(inputValue), [inputValue, getSuggestions])
  const value = useMemo(() => ({ ...downshiftProps, displaySuggestions }), [displaySuggestions, downshiftProps])
  return (
    <DownshiftContext.Provider value={value}>
      <AutosuggestCore {...props} isOpen={isOpen && displaySuggestions?.length} />
    </DownshiftContext.Provider>
  )
}

// we may need an initial open prop
const Autosuggest = forwardRef(function Autosuggest(
  {
    clearOnClickAway = false,
    handleInput = false,
    initialSelectedItem = '',
    inputText,
    keepUserInputTextAlways = false,
    lastResort,
    noFilter = false,
    onBlur: callersOnBlur = () => {},
    onInputTextChange = () => {},
    onSuggestionSelected = () => {},
    selectedItem, // selectedItem must not be defaulted to null, or strange results like getting called multiple times on selection will occur.
    showLastResortOnFocus = false,
    sortFunction = null,
    suggestions,
    virtualize,
    ignoreDiacritics,
    ...props
  },
  ref
) {
  const getSuggestions = useCallback(
    (inputValue) => {
      return getDisplaySuggestions({
        inputValue,
        handleInput,
        noFilter,
        lastResort,
        showLastResortOnFocus,
        sortFunction,
        virtualize,
        ignoreDiacritics,
        suggestions,
      })
    },
    [handleInput, ignoreDiacritics, lastResort, noFilter, showLastResortOnFocus, sortFunction, suggestions, virtualize]
  )

  return (
    <Downshift
      onChange={onSuggestionSelected}
      selectedItem={selectedItem}
      itemToString={(suggestion) => {
        if (keepUserInputTextAlways) return inputText
        return suggestion ? suggestion.primaryText : ''
      }}
      inputValue={inputText}
      onInputValueChange={useEvent((inputValue, stateToSet) => {
        if (
          (stateToSet.type !== EventType.keyDownEnter && stateToSet.type !== EventType.clickItem) ||
          stateToSet?.selectedItem?.type !== 'LAST_RESORT' ||
          !stateToSet?.selectedItem?.onClick
        ) {
          onInputTextChange(inputValue)
        }
      })}
      defaultHighlightedIndex={0}
      initialSelectedItem={initialSelectedItem}
      initialInputValue={initialSelectedItem?.primaryText}
      stateReducer={(state, changes) =>
        stateReducerOverride({ state, changes, getSuggestions, clearOnClickAway, handleInput })
      }
    >
      {({ getRootProps, ...downshiftProps }) => (
        <DownshiftInner
          {...sanitizeProps(props)}
          {...getRootProps({ refKey: 'rootRef' })}
          callersOnBlur={callersOnBlur}
          clearOnClickAway={clearOnClickAway}
          downshiftProps={downshiftProps}
          getSuggestions={getSuggestions}
          inputRef={ref}
          lastResort={lastResort}
          noFilter={noFilter}
          showLastResortOnFocus={showLastResortOnFocus}
          sortFunction={sortFunction}
          virtualize={virtualize}
          ignoreDiacritics={ignoreDiacritics}
        />
      )}
    </Downshift>
  )
})

export default Autosuggest
export const meta = {
  name: 'Autosuggest',
  isZionFormComponent: true,
}

Autosuggest.meta = meta

Autosuggest.propTypes = {
  /** An array of objects used to generate the dropdown suggestions */
  suggestions: PropTypes.arrayOf(
    PropTypes.shape({
      key: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
      primaryText: PropTypes.string.isRequired,
      secondaryText: PropTypes.string,
      overline: PropTypes.string,
      disabled: PropTypes.bool,
      startElement: oneOfComponentType([
        ListItem.Icon,
        ListItem.Avatar,
        ListItem.MultiAvatar,
        ListItem.Image,
        ListItem.Filler,
        ListItem.FillerMedia,
      ]),
      endElement: oneOfComponentType([ListItem.Icon, ListItem.IconButton, ListItem.MetaText]),
    })
  ),

  /** When a suggestion is selected this function is called with the selected suggestion object.
   *  A suggestion can be selected by mouse, finger tap, or arrowing down and pressing the 'Enter' key. */
  onSuggestionSelected: PropTypes.func,

  /** Used to set the value of the input text field programmatically. Allows the input to be controlled from the state of the parent */
  inputText: PropTypes.string,

  /** Called each time the input text changes. Apps can use this to make appropriate API calls to update suggestions. */
  onInputTextChange: PropTypes.func,

  /** Set the selected item. This is the entire object not just the input text.
   * WARNING: Downshift uses 'undefined' to know whether it should maintain internal state.
   * If the caller sets selectedItem to null or to a value other than 'undefined' then Downshift will
   * not maintain it's own state and unexpected results may occur (e.g. multiple calls to onSuggestedSelected).
   * Downshift warnings will display in the console when usages start off 'undefined' later change
   * to something other than 'undefined'. */
  selectedItem: PropTypes.oneOfType([
    PropTypes.shape({
      key: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
      primaryText: PropTypes.string.isRequired,
      secondaryText: PropTypes.string,
      startElement: oneOfComponentType([ListItem.Icon, ListItem.Avatar, ListItem.Image]),
      endElement: oneOfComponentType([ListItem.Icon, ListItem.IconButton, ListItem.MetaText]),
    }),
    PropTypes.oneOf(['undefined']), // Downshift uses 'undefined' because sadness (see comment above)
  ]),

  /** Initialize Autosuggest with the given selected item (helpful for testing components that use downshift) */
  initialSelectedItem: PropTypes.oneOfType([
    PropTypes.shape({
      primaryText: PropTypes.string.isRequired,
      secondaryText: PropTypes.string,
      startElement: oneOfComponentType([ListItem.Icon, ListItem.Avatar, ListItem.Image]),
      endElement: oneOfComponentType([ListItem.Icon, ListItem.IconButton, ListItem.MetaText]),
    }),
    PropTypes.oneOf(['undefined']), // Downshift uses 'undefined' because sadness (see comment above selectedItem)
  ]),

  /** Whether to avoid filtering suggestions based on input text (default false). */
  noFilter: PropTypes.bool,

  /** Show matching text in the suggestions by highlighting the input text within the suggestions  */
  highlightMatchingText: PropTypes.bool,

  /** Whether to ignore diacritic characters in comparisons and highlighting (default true). */
  ignoreDiacritics: PropTypes.bool,

  /** Add a last resort suggestion to the end of the suggestion list to help direct users where to go next when there are no suitable suggestions.
   * The primaryText field value will be displayed in the suggestion.
   * The selected suggestion will have a type field set to 'LAST_RESORT'. */
  lastResort: PropTypes.shape({
    primaryText: PropTypes.string.isRequired,
    startElement: oneOfComponentType([ListItem.Icon]),
    onClick: PropTypes.func,
  }),
  disabled: PropTypes.bool,

  /** The text for the label for the input. */
  label: PropTypes.string,

  /** Increases label size when set to true */
  largerLabel: PropTypes.bool,

  /** Allows label to wrap when set to true */
  allowLabelWrapping: PropTypes.bool,

  /** Determines how Chrome's native autocomplete is suppressed, depending on whether the field is address-related or not. */
  chromeAutoCompleteOff: PropTypes.string,

  /** Allows the field to be cleared. Adds a "clear" button. */
  clearable: PropTypes.bool,

  /** Handler run when the field is cleared. Will set clearable to true if provided and clearable is not provided. */
  onClear: PropTypes.func,

  /** runs when the user blurs away from TextField (see TextField docs for more). */
  onBlur: PropTypes.func,

  /** a placeholder for the underlying TextField (see TextField docs for more). */
  placeholder: PropTypes.string,

  /** Adds an input text field at the beginning of suggestions when the input text doesn't match any of the official suggestions.
   * The primaryText field value will be displayed in the suggestion.
   * When the user tabs out or blurs away suggestion will always be selected. */
  handleInput: PropTypes.bool,

  /** Add custom props to the input. */
  inputProps: PropTypes.object,

  /** Add custom props to the item. */
  itemProps: PropTypes.object,

  /** Add custom props to the menu. */
  menuProps: PropTypes.object,

  /** Clear the text field when blurred */
  clearOnClickAway: PropTypes.bool,

  /** If lastResort is provided, setting this to true makes it show up when the input is focused */
  showLastResortOnFocus: PropTypes.bool,

  /** Set to true if you want the user's text to always remain in the input, even when an item is selected. */
  keepUserInputTextAlways: PropTypes.bool,

  /** Optional compare function for sorting suggestions. Expects parameters (inputValue, suggestionA, suggestionB).
   *  suggestionA and suggestionB are used as in the default javascript sort algorithm. Expects to return -1, 0 or 1 */
  sortFunction: PropTypes.func,

  /** Provides access the overlay's DOM node */
  overlayRef: PropTypes.oneOfType([PropTypes.shape({ current: PropTypes.node }), PropTypes.func]),

  /** A function that will tell you when the AutosuggestOverlay is open */
  setOverlayIsOpen: PropTypes.func,

  /** Set to true if you want the suggestions to display directly below the input field, instead of in a drop down overlay. */
  noOverlay: PropTypes.bool,

  /** The maximum height of the suggestion list. */
  listMaxHeight: PropTypes.number,
}
