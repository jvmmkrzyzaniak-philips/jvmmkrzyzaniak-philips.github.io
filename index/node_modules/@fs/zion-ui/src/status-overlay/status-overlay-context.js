import React, { Suspense, lazy, useCallback, useContext, useReducer, useRef, useEffect, createContext } from 'react'
import { PortalContext } from '../portal'

const StatusOverlay = lazy(() => import('./StatusOverlay'))

export const StatusOverlayContext = createContext([])

function reducer(state, action) {
  let { messages } = state
  switch (action.type) {
    // Add a new status overlay to the queue
    case 'ADD': {
      if (!action.overlay.message) {
        throw new Error('No message provided for StatusOverlay')
      }
      let { currentMessageState } = state

      // If the first item in the existing queue is transient, time to remove the message
      if (messages[0]?.transient) {
        // animate away niceley if it's in process of showing/leaving
        if (currentMessageState !== 'hidden') {
          currentMessageState = 'leaving'
        } else {
          // otherwise, just delete it
          messages = messages.slice(1)
        }
      }

      // If the length of the queue is bigger than 1 and the last message is transient, delete it
      if (messages.length > 1 && messages[messages.length - 1].transient) {
        messages = messages.slice(0, -1)
      }

      return {
        ...state,
        currentMessageState,
        messages: [...messages, action.overlay],
      }
    }

    // Mark a message as entering
    case 'ENTER': {
      return {
        ...state,
        currentMessageState: 'entering',
      }
    }

    // Mark a message as entered
    case 'LEAVE': {
      return {
        ...state,
        currentMessageState: 'leaving',
      }
    }

    // Remove the status overlay from the queue
    case 'REMOVE': {
      return {
        ...state,
        currentMessageState: 'hidden',
        messages: messages.slice(1),
      }
    }

    default: {
      throw new Error(`Unhandled action type: ${action.type}`)
    }
  }
}

const noOp = () => {}

export function StatusOverlayProvider({ children, portalDiv }) {
  const [state, internalDispatch] = useReducer(reducer, { messages: [], currentMessageState: 'hidden' })
  const dispatchRef = useRef(internalDispatch)

  useEffect(() => {
    // this is to just make sure we don't update state on an unmounted component
    return () => {
      dispatchRef.current = noOp
    }
  }, [])

  const { messages, currentMessageState } = state
  const [currentMessage] = messages

  const enter = useCallback(() => dispatchRef.current({ type: 'ENTER' }), [])
  const leave = useCallback(() => dispatchRef.current({ type: 'LEAVE' }), [])
  const remove = useCallback(() => dispatchRef.current({ type: 'REMOVE' }), [])

  return (
    <StatusOverlayContext.Provider value={dispatchRef}>
      {children}
      <PortalContext.Provider value={portalDiv}>
        <Suspense fallback="">
          {currentMessage && (
            <StatusOverlay
              {...currentMessage}
              messageState={currentMessageState}
              leave={leave}
              enter={enter}
              remove={remove}
            />
          )}
        </Suspense>
      </PortalContext.Provider>
    </StatusOverlayContext.Provider>
  )
}

export function useStatusOverlay() {
  const dispatchRef = useContext(StatusOverlayContext)

  const addStatusOverlay = useCallback(
    (message) => {
      dispatchRef.current({
        type: 'ADD',
        overlay: typeof message === 'string' ? { message } : message,
      })
    },
    [dispatchRef]
  )

  if (!dispatchRef.current) {
    throw new Error('useStatusOverlay must be used within a StatusOverlayContext.')
  }
  // Return the add function to consumers
  return addStatusOverlay
}
