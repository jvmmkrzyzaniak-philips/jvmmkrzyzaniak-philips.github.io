import React from 'react'
import * as RadixSlider from '@radix-ui/react-slider'
import PropTypes from 'prop-types'
import { css, cx } from '@linaria/core'
import { boolAttr } from '@fs/zion-frontend-friends'
import { colors } from '../theme'
import { elevationBaseCss, e2, h4 } from '../elevation'
import { textDirection } from '../rtl-support'
import { useMediaContext } from './MediaProvider'

/**
 * We did an investigation on using the html input range instead of an outside library and decided against it because of two problems.
 * 1. It was difficult to test in jest because UserEvent and FireEvent don't trigger onInput or onChange for the input range. It isn't yet supported see issue (https://github.com/testing-library/user-event/issues/871)
 * 2. When the range and step did not divide evenly (for example a range of 5 and a step of 2), the input range would not get to the end of the track. See the documentation (https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range#step)
 * Using radix-ui's slider component doesn't have these issues, is still accessible, and supports rtl.
 */

const clickableRegionCss = css`
  position: absolute;
  top: -8px;
  height: calc(100% + 16px);
  width: 100%;
  cursor: pointer;
`
const sliderCss = css`
  position: relative;
  display: flex;
  align-items: center;
  user-select: none;
  touch-action: none;
  width: 100%;
  padding: 8px 0;
`
const trackCss = css`
  position: relative;
  flex-grow: 1;
  width: 100%;
  height: 2px;
  cursor: pointer;
  border-radius: 1px;
  background: linear-gradient(
    to var(--slider-orientation),
    ${colors.gray20} 0%,
    ${colors.gray20} var(--slider-buffer-percent, 0%),
    ${colors.gray10} 0%,
    ${colors.gray10} var(--slider-value-percent, 100%)
  );
`

const rangeCss = css`
  position: absolute;
  background: ${colors.blue80};
  height: 2px;

  &[no-show-progress] {
    background: ${colors.gray10};
  }
`
const thumbCss = css`
  display: block;
  width: 16px;
  height: 16px;
  background: ${colors.blue80};
  border-radius: 50%;
  cursor: pointer;

  transition:
    background 0.3s,
    transform 0.15s;

  &:hover,
  &:active,
  &:focus {
    background: ${colors.blue60};
    transform: scale(1.15);
  }

  &:focus-visible {
    outline: 3px solid ${colors.transparent.blue20};
    outline-offset: 2px;
  }
`

const Slider = ({ value, max, min, bufferPercent = 0, noShowProgress = false, ...props }) => {
  const isMedia = useMediaContext()
  const direction = isMedia ? 'ltr' : textDirection()

  return (
    <RadixSlider.Root
      value={[value]}
      max={max}
      min={min}
      step={props?.step || 1}
      orientation="horizontal"
      className={sliderCss}
      onValueChange={(newVal) => {
        props.onChange(newVal[0])
      }}
      dir={direction}
    >
      {/** This div makes the clickable region larger without adding height to the entire slider */}
      <div className={clickableRegionCss} />
      <RadixSlider.Track
        className={trackCss}
        style={{
          '--slider-orientation': direction === 'ltr' ? 'right' : 'left', // linear-gradient needs this because it doesn't use css properties like end or start.
          '--slider-value-percent': `${(value / max) * 100}%`,
          '--slider-buffer-percent': `${bufferPercent}`,
        }}
      >
        <RadixSlider.Range className={rangeCss} no-show-progress={boolAttr(noShowProgress)} />
      </RadixSlider.Track>
      <RadixSlider.Thumb className={cx(thumbCss, elevationBaseCss, e2, h4)} />
    </RadixSlider.Root>
  )
}

export default Slider

Slider.propTypes = {
  /** Sets the value of the slider. */
  value: PropTypes.number,

  /** Sets the min value of the slider. */
  min: PropTypes.number,

  /** Sets the max value of the slider. */
  max: PropTypes.number,

  /** How far the slider is adjusted using the arrow keys. */
  step: PropTypes.number,

  /** Called with the updated value when the slider is changed */
  onChange: PropTypes.func,

  /** Sets the buffer percent of the slider track. */
  bufferPercent: PropTypes.string,

  /** Hides the background color of the track up to the handle of the slider. */
  noShowProgress: PropTypes.bool,
}
