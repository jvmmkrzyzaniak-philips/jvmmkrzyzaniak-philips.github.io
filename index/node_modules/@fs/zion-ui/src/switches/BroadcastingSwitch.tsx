import type { Context, Dispatch, ReactElement, ReactNode, Reducer, ReducerAction } from 'react'
import React, {
  Children,
  cloneElement,
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useReducer,
  useRef,
  isValidElement,
} from 'react'

import { Switch, matchPath, useLocation } from '@fs/zion-router'
import { shallowEqual } from '@fs/zion-frontend-friends'

import type TransitionSwitch from './TransitionSwitch'

import type { RouteType } from './types'

type PropsType = Record<string, unknown>

type RouteState<T extends PropsType> = {
  /** The default properties supplied by properties of the BroadcastingSwitch */
  defaults: Partial<T>

  /** The base properties supplied by properties of <Route> */
  base: Partial<T>

  /** Any extra properties supplied by calling the update() function from useSwitchStateUpdate */
  updates: Partial<T>
}

type RouteAction<T extends PropsType> = Partial<RouteState<T>> | ((prevState: RouteState<T>) => Partial<RouteState<T>>)
type RouteReducer<T extends PropsType> = Reducer<RouteState<T>, RouteAction<T>>

export type BroadcastStateContextType<T extends PropsType> = RouteState<T>
export type BroadcastUpdateContextType<T extends PropsType> = Dispatch<ReducerAction<RouteReducer<T>>>

/** Needed for the next item */
type UpdateType<T> = (routeBase: T | undefined, updated: T | undefined) => T

/** This type is similar to the type of the setState function returned from useReducer,
 * allowing a value or a function to be passed to it.
 */
export type UpdateHookType<T> = {
  /** When you just pass a value */
  (value: T): void

  /** When you pass an update function */
  (value: UpdateType<T>): void
}

const RouteIndexContext = createContext<number>(-1)
const CurrentRouteIndexContext = createContext<number>(-1)

const EMPTY_OBJ = {}
export const initialState = { defaults: {}, base: {}, updates: {} }

const baseReducer = <T extends PropsType>(state: RouteState<T>, action: Partial<RouteState<T>>): RouteState<T> => {
  let actualUpdates: RouteState<T> | null = null
  Object.entries(action).forEach(([key, update]) => {
    const orig = state[key]
    if (!shallowEqual(update, orig)) {
      actualUpdates = actualUpdates || { ...state }
      // This is fine because we only access existing keys of the `action` object
      actualUpdates[key] = update!
    }
  })
  // This whole bit is to avoid creating a new object each time we update state, so we don't rerender unecessarily
  return actualUpdates || state
}

const reducer = <T extends PropsType>(state: RouteState<T>, action: RouteAction<T>): RouteState<T> => {
  if (typeof action === 'function') return baseReducer(state, action(state))
  return baseReducer(state, action)
}

export const useIsCurrentRoute = (): boolean => {
  const currentRouteIndex = useContext(CurrentRouteIndexContext)
  const routeIndex = useContext(RouteIndexContext)
  return currentRouteIndex === routeIndex
}

export const useSwitchStateUpdate = <T extends PropsType, K extends keyof T>(
  context: Context<BroadcastUpdateContextType<T>>,
  key: K
): UpdateHookType<T[K]> => {
  const dispatch = useContext(context)
  const isCurrentRoute = useIsCurrentRoute()
  const shouldUpdateRef = useRef(true)

  // We set a ref here to make it more stable so it doesn't cause so many unnecessary rerenders
  useEffect(() => {
    shouldUpdateRef.current = isCurrentRoute
  }, [isCurrentRoute])

  const update: UpdateHookType<T[K]> = useCallback(
    (value: T[K] | UpdateType<T[K]>) => {
      // DO NOT UPDATE if we're on a different route now (this happens when routes are animated in and out)
      if (!shouldUpdateRef.current) return
      dispatch((broadcastState) => {
        let actualValue = value
        if (typeof value === 'function') {
          actualValue = (value as UpdateType<T[K]>)(
            broadcastState.base[key] || broadcastState.defaults[key],
            broadcastState.updates[key]
          )
        }
        const { updates } = broadcastState
        return { updates: { ...updates, [key]: actualValue } }
      })
    },
    [dispatch, key]
  )

  return update
}

type ProviderProps<T extends PropsType> = {
  SwitchStateContext: Context<BroadcastStateContextType<T>>
  SwitchDispatchContext: Context<BroadcastUpdateContextType<T>>
  children: ReactNode
}

export const BroadcastSwitchProvider = <T extends PropsType>({
  SwitchStateContext,
  SwitchDispatchContext,
  children,
}: ProviderProps<T>): JSX.Element => {
  const [state, dispatch] = useReducer<Reducer<RouteState<T>, RouteAction<T>>>(reducer, initialState)
  return (
    <SwitchDispatchContext.Provider value={dispatch}>
      <SwitchStateContext.Provider value={state}>{children}</SwitchStateContext.Provider>
    </SwitchDispatchContext.Provider>
  )
}

/** Props taken from react-router v5: https://v5.reactrouter.com/web/api/Route */
export type BroadcastingRouteProps<T> = T & RouteType
export type BroadcastingSwitchProps<T extends PropsType> = {
  /* The state context object to use */
  updateContext: Context<BroadcastUpdateContextType<T>>

  /* Either a Switch or a TransitionSwitch */
  as?: Switch | typeof TransitionSwitch

  /* Optional component that wraps each route */
  WrapperComponent?: Switch | typeof TransitionSwitch

  /* The default values when Routes don't provide them */
  defaultValues: T

  /* Must be Routes, but with added props for broadcasting */
  children: ReactElement<BroadcastingRouteProps<T>> | ReactElement<BroadcastingRouteProps<T>>[]
}

export const BroadcastingSwitch = <T extends PropsType>({
  updateContext,
  as: SwitchComponent = Switch,
  children,
  WrapperComponent = 'div',
  defaultValues,
}: BroadcastingSwitchProps<T>): JSX.Element => {
  const dispatch = useContext(updateContext)

  // If default values change, then update the state to the new default values
  useEffect(() => dispatch({ defaults: defaultValues }), [defaultValues, dispatch])

  const location = useLocation()
  const routes = useMemo(
    () =>
      Children.map(children, (child, index) => {
        // Child can be a ReactNode, but we will only return something if it is a valid element
        if (isValidElement(child)) {
          // Pull out all Route original props
          const { path, exact, strict, sensitive, children: routeChildren, Component, render, ...rest } = child.props
          const originalRouteProps = { path, exact, strict, sensitive, children: routeChildren, Component, render }
          const routeProps = { path, exact, strict }
          // Pull out all unique props used for this broadcasting switch shenanigan
          const broadcastProps: T = rest as unknown as T // Typescript is whining, but this should be correct
          return {
            broadcastProps,
            routeProps,
            child: cloneElement({
              ...child,
              key: String(index),
              props: {
                ...originalRouteProps,
                children: (
                  <RouteIndexContext.Provider value={index}>
                    <WrapperComponent>{child.props.children}</WrapperComponent>
                  </RouteIndexContext.Provider>
                ),
              },
            }),
          }
        }
        return null
      }),
    [children, WrapperComponent]
  )

  const matchedRouteIndex = routes.findIndex((route) => matchPath(location.pathname, route.routeProps))

  const base = useMemo(() => routes[matchedRouteIndex]?.broadcastProps || EMPTY_OBJ, [matchedRouteIndex, routes])

  // Update the updates state whenever the updates change (separate from base updates ON PURPOSE - you need to ask Matt Larson on a good day to understand any of this. On a bad day, you'll just get word salad.)
  useEffect(() => dispatch({ updates: EMPTY_OBJ }), [matchedRouteIndex, dispatch])

  // Update the base state whenever the base changes
  useEffect(() => dispatch({ base }), [base, dispatch])

  return (
    <CurrentRouteIndexContext.Provider value={matchedRouteIndex}>
      <SwitchComponent>{routes.map((route) => route.child)}</SwitchComponent>
    </CurrentRouteIndexContext.Provider>
  )
}
