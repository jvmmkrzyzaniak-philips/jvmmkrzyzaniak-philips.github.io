import type { Dispatch, ReactElement, SetStateAction } from 'react'
import React, { Children, createContext, useContext, useEffect, useMemo, useRef, useState } from 'react'
import { useLocation, useHistory, Switch, matchPath } from '@fs/zion-router'
import { useSpringRef, useSpring, useTransition, useChain, animated } from '@react-spring/web'
import { css, cx } from '@linaria/core'
import { boolAttr, useEvent, useResizeObserver } from '@fs/zion-frontend-friends'
import type { InferProps } from 'prop-types'
import PropTypes from 'prop-types'
import debounce from 'lodash.debounce'
import { colors } from '../theme'
import type { SwitchType, RouteType, Location } from './types'
import { textDirection } from '../rtl-support'

type TransitionSwitchContextProps = {
  /** Used to alert consumers of TransitionSwitch whether or not routes are currently transitioning  */
  setTransitioning: Dispatch<SetStateAction<boolean>>
}
export const TransitionSwitchContext = createContext<TransitionSwitchContextProps>({
  setTransitioning: () => undefined,
})

const heightContainer = css`
  position: relative;
  display: flex;
  flex-direction: column;
  flex-grow: 1;
`

const switchCss = css`
  background: ${colors.gray00};
  width: 100%;

  &[data-transitioning] {
    position: absolute;
    top: 0;
    inset-inline-start: 0;

    // Adding height: 100% and hiding overflow allows the exiting snapshot to be the same height as the entering snapshot,
    // allowing the scrollbar to be the correct size much earlier than usual. Otherwise, the scrollbar wouldn't update until the
    // exiting div unmounted, often causing scrollbars to appear and disappear weirdly during transitions.
    height: 100%;
    overflow: hidden;
  }
`

type SwitchSnapshotProps = {
  path: string
  location: Location
}

const unknownLocation: Location = {
  key: '',
  pathname: '',
}

const unknownSnapshot: SwitchSnapshotProps = {
  path: '',
  location: unknownLocation,
}

type SwitchSnapshotWrapperProps = SwitchType & {
  setHeight: Dispatch<SetStateAction<number>>
}
const SwitchSnapshotWrapper = ({
  location,
  children,
  setHeight,
}: SwitchSnapshotWrapperProps): ReactElement<RouteType> => {
  const actualLocation = useLocation()
  const heightObserverRef = useRef<HTMLDivElement>()

  const isCurrentRoute = useMemo(
    () => location.pathname === actualLocation.pathname,
    [actualLocation.pathname, location.pathname]
  )

  // We need to debounce the resize handler so children that take a render or two to calculate their height (e.g. MoreLess) will return the most updated and correct height values
  // Otherwise, the overlay will do a weird animation due to this being called multiple times with different heights
  const resize = useMemo(() => debounce(() => setHeight(heightObserverRef.current?.offsetHeight)), [setHeight])
  useEffect(() => () => resize.cancel(), [resize])

  useEffect(() => {
    if (isCurrentRoute) resize()
  }, [isCurrentRoute, resize])

  useResizeObserver(heightObserverRef, () => {
    if (isCurrentRoute) resize()
  })

  return (
    <div ref={heightObserverRef} className={heightContainer}>
      {/* Each Route gets wrapped in its own Switch so it doesn't change the children when the route changes and we're trying to transition in or out */}
      <Switch location={location}>{children}</Switch>
    </div>
  )
}

type TransitionSwitchProps = {
  /* must be routes, but with added props for broadcasting */
  children: ReactElement<RouteType> | ReactElement<RouteType>[]
}

export default function TransitionSwitch({ children }: TransitionSwitchProps): JSX.Element | null {
  const ref = useRef(null)
  const location = useLocation()
  const history = useHistory()
  // Used to prevent transition initially
  const [isInitialized, setIsInitialized] = useState(false)
  // Used to transition between routes
  const [currentSnapshot, setCurrentSnapshot] = useState<SwitchSnapshotProps>()
  // Used to add height animation to snapshots when transitioning
  const [isTransitioning, setIsTransitioning] = useState(false)
  // Used to prevent unwanted updates to currentSnapshot and isTransitioning
  const prevPathRef = useRef()
  // Used to determine if the routes are currently transitioning
  const queuedTransitionsRef = useRef(0)
  // Alerts consumers of TransitionSwitch when the routes are transitioning
  const { setTransitioning } = useContext(TransitionSwitchContext)

  const handleTransitioned = useEvent((bool: boolean) => {
    if (!isInitialized || !ref.current) return

    // if we have multiple transitions happening at the same time, i.e. when a user is rapidly switching routes,
    // then we need a method to prevent isTransitioning from becoming false until every transition is finished.
    if (bool) queuedTransitionsRef.current++
    // we shouldn't let the value fall below 0
    else if (queuedTransitionsRef.current) queuedTransitionsRef.current--

    const shouldTransition = !!queuedTransitionsRef.current

    setTransitioning(shouldTransition)
    setIsTransitioning(shouldTransition)
  })

  useEffect(() => {
    // Must be delayed an event loop, otherwise it doesn't prevent initial animation
    const timeout = setTimeout(() => setIsInitialized(true), 0)
    return () => clearTimeout(timeout)
  }, [])

  // Initiate transition between routes.
  // Transition ONLY when a different route is activated, and not on every change of location
  useEffect(() => {
    const { pathname: path } = location
    if (path === prevPathRef.current) return // path didn't change, do nothing

    const chillens = Children.toArray(children) as ReactElement<RouteType>[]
    const currentRoute = chillens.find((child) => matchPath(path, child.props))
    if (!currentRoute) return // route doesn't exist, do nothing

    prevPathRef.current = path

    setCurrentSnapshot({ path, location })
    handleTransitioned(true)
  }, [location, children, handleTransitioned])

  /** ANIMATION LOGIC BELOW */

  const reverse = textDirection() === 'ltr' ? history.action === 'POP' : history.action !== 'POP'

  const heightSpringRef = useSpringRef()
  const routeSpringRef = useSpringRef()

  const [height, setHeight] = useState<number | undefined>(undefined)
  const heightStyles = useSpring({
    // We can update the height immediately when not transitioning between routes because we do not manually control the height of the TransitionSwitch
    // unless we are transitioning between routes (see commment in the component return statement below for details), though we should still keep the value
    // synced with the actual container height.
    immediate: !isInitialized || !isTransitioning,
    height,
    ref: heightSpringRef,
    config: {
      tension: 300,
      clamp: true,
    },
  })

  const routeTransitions = useTransition(currentSnapshot, {
    immediate: !isInitialized,
    ref: routeSpringRef,
    key: (snapshot: SwitchSnapshotProps) => snapshot.path,
    onRest: (_1, _2, item) => {
      // The onRest normally runs twice (once each for the entering and exiting items, both ending simultaneously)
      // We only want it to run once to signify the end of the transition, so we only allow it to run on one of the instances
      if (item.path === currentSnapshot.path) handleTransitioned(false)
    },
    config: {
      tension: 220,
    },
    // CSS on initial mount
    from: {
      x: reverse ? '-100%' : '100%',
      zIndex: 0,
      opacity: 1,
    },
    // What it transitions to right after mounting
    enter: {
      x: '0%',
      zIndex: 1,
      opacity: 1,
    },
    // What it transitions to when unmounting
    leave: {
      x: reverse ? '100%' : '-100%',
      zIndex: 0,
      opacity: 0,
    },
  })

  useChain(
    // run height animation before route-change animation
    [heightSpringRef, routeSpringRef],
    [
      // timings of how much delay happens before the 2nd animation starts
      0, // first spring (height change) triggers immediately
      0.1, // How much delay happens before the 2nd spring starts
    ]
  )

  return (
    // animate height
    // NOTE: the height NEEDS be controlled by the browser when not transitioning between routes or else images in the content will often cause a looping
    // resize (strobe) effect (image causes scrollbar, scrollbar shrinks image, because image is smaller scrollbar disappears, image grows to fill space,
    // image causes scrollbar, etc.). Browsers usually detect this situation and handle it themselves somehow, but controlling the height manually
    // and adding animations seems to block the browser's ability to do so.
    <animated.div ref={ref} style={isTransitioning ? heightStyles : {}} className={heightContainer}>
      {/* animate route changes */}
      {routeTransitions((props, { location: snapshotLocation } = unknownSnapshot) => (
        <animated.div
          style={props}
          className={cx(switchCss, heightContainer)}
          data-transitioning={boolAttr(isTransitioning)}
        >
          <SwitchSnapshotWrapper location={snapshotLocation} setHeight={setHeight}>
            {children}
          </SwitchSnapshotWrapper>
        </animated.div>
      ))}
    </animated.div>
  )
}

const propTypes = {
  /* must be routes, but with added props for broadcasting */
  children: PropTypes.node,
}

type Props = InferProps<typeof propTypes> & TransitionSwitchProps

export const TransitionSwitchProps = ({ children, ...props }: Props): JSX.Element => <div {...props}>{children}</div>

TransitionSwitchProps.propTypes = propTypes
