import type { CSSProperties, ReactElement } from 'react'
import React, { useCallback, useEffect, useRef, useState } from 'react'
import { css } from '@linaria/core'
import { boolAttr, sanitizeProps, useObserver } from '@fs/zion-frontend-friends'
import type { InferProps } from 'prop-types'
import PropTypes from 'prop-types'
import BaseSkeleton from '../skeleton/BaseSkeleton'

const imageCss = css`
  display: block;
  object-fit: cover;
  height: auto;
  width: 100%;
  animation: fadeIn 0.6s;

  @keyframes fadeIn {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }

  &[no-crop] {
    object-fit: contain;
  }

  [dir='rtl'] &[flip-rtl] {
    transform: scaleX(-1);
  }
`

const propTypes = {
  /** Source of the image */
  src: PropTypes.string.isRequired,

  /** Label for the image */
  alt: PropTypes.string.isRequired,

  /** Fallback element to render should the provided `src` fail to load. */
  failureFallback: PropTypes.node,

  /** Specifies the height of the image.
   * @default "auto"
   */
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * Sets the minimum height of the image
   * @default {0}
   */
  minHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets the maximum height of the image */
  maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Specifies the width of the image.
   * If a horizontal layout is needed, you can set a fixed `height`
   * and set the `width` to "auto", and the image will keep its original proportions
   * @default "100%"
   */
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * Sets the minimum width of the image
   * @default {0}
   */
  minWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** sets the maximum width of the image */
  maxWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /**
   * When the sides of the image needs to be cropped, how should the image be aligned?
   * @default "center"
   */
  positionX: PropTypes.oneOf(['left', 'center', 'right'] as const), // THIS NEEDS TO STAY left/right, no RTL support is needed here

  /**
   * When the top and bottom of the image needs to be cropped, how should the image be aligned?
   * @default "middle"
   */
  positionY: PropTypes.oneOf(['top', 'middle', 'bottom'] as const),

  /**
   * Whether the image should not be cropped (contained instead of covered)
   * @default false
   */
  noCrop: PropTypes.bool,

  /** Additional CSS properties for the image */
  style: PropTypes.object,

  /** Use children to render a <picture> element instead of an <img> element */
  children: PropTypes.node,

  /** Whether to allow the image to flip in RTL
   * @default false
   */
  flipRtl: PropTypes.bool,
}

type ImageProps = InferProps<typeof propTypes> & {
  /** Additional CSS properties for the image */
  style?: CSSProperties

  /** Use children to render a <picture> element instead of an <img> element */
  children?: ReactElement<'source'> | ReactElement<'source'>[]
}

export default function FancyImage({
  src,
  alt,
  failureFallback,
  height,
  minHeight,
  maxHeight,
  width,
  minWidth,
  maxWidth,
  positionX = 'center',
  positionY = 'middle',
  noCrop,
  flipRtl,
  style,
  children,
  ...props
}: ImageProps): JSX.Element {
  const [imageLoaded, setImageLoaded] = useState(false)
  const [imageFailed, setImageFailed] = useState(false)
  const [hasBecomeVisible, setHasBecomeVisible] = useState(false)
  const adjustedPositionY = positionY === 'middle' ? 'center' : positionY
  const imageRef = useRef<HTMLImageElement>(null)
  const skeletonRef = useRef<HTMLDivElement>(null)
  const ref = imageLoaded ? imageRef : skeletonRef

  const intersectCallback = useCallback(({ isIntersecting }: IntersectionObserverEntry) => {
    setHasBecomeVisible((prev) => prev || isIntersecting)
  }, [])

  // If the src prop changes on us, we need to make this non-loaded
  useEffect(() => {
    setImageLoaded(false)
  }, [src])

  useEffect(() => {
    if (!hasBecomeVisible) return
    const imageData = new Image()
    imageData.onload = () => {
      setImageLoaded(true)
    }
    imageData.onerror = () => {
      setImageFailed(true)
      setImageLoaded(true)
    }
    imageData.src = src
  }, [hasBecomeVisible, src])

  useObserver(ref, intersectCallback)

  if (imageFailed && failureFallback) {
    return <>{failureFallback}</>
  }

  if (!imageLoaded) {
    return (
      <BaseSkeleton
        style={{ height, minHeight, maxHeight }}
        role="img"
        aria-label={alt}
        aria-hidden="false"
        ref={skeletonRef}
      />
    )
  }

  const imgOutput = (
    <img
      {...sanitizeProps(props)}
      ref={imageRef}
      alt={alt}
      no-crop={boolAttr(noCrop)}
      flip-rtl={boolAttr(flipRtl)}
      src={src}
      style={{
        height,
        maxHeight,
        minHeight,
        width,
        minWidth,
        maxWidth,
        objectPosition: `${adjustedPositionY} ${positionX}`,
        flexGrow: height ? 0 : 1,
        flexShrink: height ? 0 : 1,
        ...style,
      }}
      className={imageCss}
    />
  )

  if (children)
    return (
      <picture>
        {children}
        {imgOutput}
      </picture>
    )
  return imgOutput
}

FancyImage.propTypes = propTypes
