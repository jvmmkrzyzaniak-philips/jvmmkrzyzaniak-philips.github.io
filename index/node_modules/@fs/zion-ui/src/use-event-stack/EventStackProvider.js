import React, { useRef, useCallback, useEffect } from 'react'
import PropTypes from 'prop-types'

const hasDocument = typeof document !== 'undefined'

const EventStackProvider = ({ Context, eventType, children }) => {
  const state = useRef({ stack: [], cancelled: false })

  const checkTheStackForTopAndRunIt = useCallback((e) => {
    const { cancelled, stack } = state.current
    if (cancelled) {
      state.current.cancelled = false
    } else {
      // The top of the stack should be the only handler that is called...
      // UNLESS: In the case of `useKeyboardShortcuts`, we want to allow
      // Each member of the stack to receive the shortcuts they registered to,
      // As long as it wasn't handled earlier in the stack. This `some` function will stop at the first item in the stack unless the handler it calls returns something truthy
      stack.some((handler) => {
        return !handler.current?.(e)
      })
    }
  }, [])

  // START and STOP listening based on if handlers are in the state
  useEffect(() => {
    hasDocument && document.body.addEventListener(eventType, checkTheStackForTopAndRunIt, { capture: true })
    return () => {
      hasDocument && document.body.removeEventListener(eventType, checkTheStackForTopAndRunIt)
    }
  }, [checkTheStackForTopAndRunIt, eventType])

  return <Context.Provider value={state}>{children}</Context.Provider>
}

export default EventStackProvider

EventStackProvider.propTypes = {
  /** The Context specific to the event you wish to stack. See ClickAwayProvider or EscHandlerProvider for examples. */
  Context: PropTypes.object.isRequired,

  /** The event name this provider should attach listeners for. i.e. "click". */
  eventType: PropTypes.string.isRequired,
}
