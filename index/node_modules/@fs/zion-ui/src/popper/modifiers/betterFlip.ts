/* eslint-disable no-underscore-dangle */
/* the underscore is part of the popperjs conventions which is copy+pasted and utilized here as well */
import getOppositePlacement from '@popperjs/core/lib/utils/getOppositePlacement'
import getBasePlacement from '@popperjs/core/lib/utils/getBasePlacement'
import getOppositeVariationPlacement from '@popperjs/core/lib/utils/getOppositeVariationPlacement'
import { bottom, top, start, right, left, auto } from '@popperjs/core/lib/enums'
import getVariation from '@popperjs/core/lib/utils/getVariation'
import { detectOverflow } from '@popperjs/core'
import type { ModifierArguments, Placement, BasePlacement, Modifier, Rect, SideObject } from '@popperjs/core'
import type { Options } from '@popperjs/core/lib/modifiers/flip'

const placementToRect = {
  top: 'height',
  bottom: 'height',
  left: 'width',
  right: 'width',
}

function getOverflowPercentage(placement: Placement, overflow: SideObject, popperRect: Rect): number {
  return overflow[placement] / popperRect[placementToRect[placement]]
}

// NOTE: Much of this code is heavily copy+pasted from the flip modifier. https://github.com/popperjs/popper-core/blob/master/src/modifiers/flip.js

// BEGIN DUPLICATED CODE
function getExpandedFallbackPlacements(placement: Placement): Placement[] {
  if ((getBasePlacement(placement) as BasePlacement | 'auto') === auto) {
    return []
  }

  const oppositePlacement = getOppositePlacement(placement)

  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)]
}

function betterFlip({ state, options, name }: ModifierArguments<Options>): void {
  if (state.modifiersData[name]._skip) return

  const {
    mainAxis: checkMainAxis = true,
    altAxis: checkAltAxis = true,
    fallbackPlacements: specifiedFallbackPlacements,
    padding,
    boundary,
    rootBoundary,
    altBoundary,
    flipVariations = true,
  } = options

  const preferredPlacement = state.options.placement
  const isBasePlacement = getBasePlacement(preferredPlacement) === preferredPlacement

  const fallbackPlacements =
    specifiedFallbackPlacements ||
    (isBasePlacement || !flipVariations
      ? [getOppositePlacement(preferredPlacement)]
      : getExpandedFallbackPlacements(preferredPlacement))

  const placements = [preferredPlacement, ...fallbackPlacements]

  const referenceRect = state.rects.reference
  const popperRect = state.rects.popper

  const overflowMap = new Map<Placement, number>()
  let makeFallbackChecks = true
  let bestFittingPlacement = placements[0]

  // For each placement in order of priority, either determine if the popper will fit inside the boundaries with that placement or store the highest overflow percentage
  // eslint-disable-next-line @typescript-eslint/prefer-for-of -- TODO write reason for disabling
  for (let i = 0; i < placements.length; i++) {
    const placement = placements[i]
    const basePlacement = getBasePlacement(placement)
    const isStartVariation = getVariation(placement) === start
    const isVertical = ([top, bottom] as Placement[]).indexOf(basePlacement) >= 0
    const len = isVertical ? 'width' : 'height'

    const overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding,
    })

    let mainVariationSide: BasePlacement = isStartVariation ? bottom : top
    if (isVertical) mainVariationSide = isStartVariation ? right : left

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide) as BasePlacement
    }

    const altVariationSide = getOppositePlacement(mainVariationSide) as BasePlacement

    const overflowValues: number[] = []
    if (checkMainAxis) overflowValues.push(overflow[basePlacement])
    if (checkAltAxis) overflowValues.push(overflow[mainVariationSide], overflow[altVariationSide])

    // Does it fit? If so, we're done here.
    if (overflowValues.every((overflowValue) => overflowValue <= 0)) {
      bestFittingPlacement = placement
      makeFallbackChecks = false
      break
    }

    // calculate the highest overflow percentage
    let maxOverflow = 0
    if (checkMainAxis) maxOverflow = Math.max(maxOverflow, getOverflowPercentage(basePlacement, overflow, popperRect))
    if (checkAltAxis)
      maxOverflow = Math.max(
        maxOverflow,
        getOverflowPercentage(mainVariationSide, overflow, popperRect),
        getOverflowPercentage(altVariationSide, overflow, popperRect)
      )

    // store the highest overflow percentage to be used to determine the next-best fitting placement if there is no fitting placement
    overflowMap.set(placement, maxOverflow)
  }

  // Find the next-best fitting placement. The placement with the lowest overflow percentage wins.
  if (makeFallbackChecks) {
    let bestPlacement: Placement | undefined
    let minOverflow: number

    overflowMap.forEach((value, key) => {
      if (!bestPlacement || minOverflow > value) {
        bestPlacement = key
        minOverflow = value
      }
    })

    bestFittingPlacement = bestPlacement || bestFittingPlacement
  }

  if (state.placement !== bestFittingPlacement) {
    state.modifiersData[name]._skip = true
    state.placement = bestFittingPlacement
    state.reset = true
  }
}

const betterFlipModifier: Modifier<'betterFlip', Options> = {
  name: 'betterFlip',
  enabled: true,
  phase: 'main',
  fn: betterFlip,
  requiresIfExists: ['offset'],
  data: { _skip: false },
}

export default betterFlipModifier
