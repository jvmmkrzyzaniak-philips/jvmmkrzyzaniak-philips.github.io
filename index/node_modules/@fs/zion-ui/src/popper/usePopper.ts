import type { RefObject, MutableRefObject } from 'react'
import { useCallback, useContext, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react'
import type { Modifier, Obj } from '@popperjs/core/lib/popper-lite'
import { createPopper } from '@popperjs/core/lib/popper-lite'
import type {
  Instance,
  Placement as PopperPlacement,
  BasePlacement as PopperBasePlacement,
  Variation as PopperVariation,
} from '@popperjs/core'
import { useResizeObserver, useEvent } from '@fs/zion-frontend-friends'

import { PopperModifiersContext, PopperContext } from './PopperContext'
import { textDirection } from '../rtl-support'

type BasePlacement = PopperBasePlacement | 'start' | 'end'

type TopPlacement = 'top' | 'top-start' | 'top-end'
type EndPlacement = 'end' | 'end-start' | 'end-end'
type BottomPlacement = 'bottom' | 'bottom-start' | 'bottom-end'
type StartPlacement = 'start' | 'start-start' | 'start-end'
export type Placement = TopPlacement | EndPlacement | BottomPlacement | StartPlacement

type UsePopperConfigsArgs = {
  placement: Placement | Placement[]
  centerPlacement: boolean
  setMaxHeight?: (h: number) => void
  distance: number
}

type PopperOptions = {
  placement: PopperPlacement
  modifiers: Modifier<string, Obj>[]
}

// exported for testing purposes only please use getPopperPlacementValue from usePopper instead
export function computePlacementComponents(value: Placement): [PopperBasePlacement, PopperVariation] {
  let [base, variation = 'start'] = value.split('-') as [BasePlacement, PopperVariation]

  const isLTR = textDirection() === 'ltr'
  const start = isLTR ? 'left' : 'right'
  const end = isLTR ? 'right' : 'left'
  const variationStart = isLTR ? 'start' : 'end'
  const variationEnd = isLTR ? 'end' : 'start'

  switch (base) {
    case 'start':
    case 'left':
      base = start
      break

    case 'end':
    case 'right':
      base = end
      break

    case 'top':
    case 'bottom':
      variation = variation === 'end' ? variationEnd : variationStart
      break
    default:
      break
  }

  return [base, variation]
}

const defaultBackupPlacement: Placement[] = ['bottom', 'top', 'start']

function usePopperConfigs({
  placement: placementValue,
  centerPlacement,
  setMaxHeight,
  distance,
}: UsePopperConfigsArgs): PopperOptions {
  const providedModifiers = useContext(PopperModifiersContext)

  const getPopperPlacementValue = useEvent((value: Placement): PopperPlacement => {
    const [base, variant] = computePlacementComponents(value)
    if (centerPlacement) return base
    return `${base}-${variant}`
  })

  const [placement, ...placementBackup] = useMemo(() => {
    let placementArray = Array.isArray(placementValue) ? placementValue : [placementValue]
    if (placementArray.length === 1) {
      placementArray = [placementArray[0], ...defaultBackupPlacement]
    }
    return placementArray
  }, [placementValue])

  // Arrays passed down as a prop trigger dependency updates if they are not memoized in the component declaring the array.
  // We don't want those updates to happen here because it causes unnecessary updates to the Popper instance and breaks tests.
  // To circumvent this issue, we use this state variable that updates only when the values in the array actually change.
  const [stablePlacementBackup, setStablePlacementBackup] = useState(placementBackup)
  useEffect(() => {
    setStablePlacementBackup((prev) =>
      prev.length !== placementBackup.length || prev.some((currentP, i) => currentP !== placementBackup[i])
        ? placementBackup
        : prev
    )
  }, [placementBackup])

  const popperOptions: PopperOptions = useMemo(() => {
    const actualPlacement = getPopperPlacementValue(placement)
    const fallbackPlacements = stablePlacementBackup.map(getPopperPlacementValue)
    return {
      placement: actualPlacement,
      modifiers: providedModifiers({ placement: actualPlacement, fallbackPlacements, setMaxHeight, distance }),
    }
  }, [placement, stablePlacementBackup, distance, setMaxHeight, getPopperPlacementValue, providedModifiers])

  return popperOptions
}

type UsePopperArgs = {
  isOpen: boolean
  transitioning: boolean
  targetRef: MutableRefObject<HTMLElement | null>
  placement: Placement | Placement[]
  centerPlacement: boolean
  updateOnChildrenChange: boolean
  setMaxHeight?: (h: number) => void
  distance: number
  instanceRef?: MutableRefObject<Instance | null>
}

function usePopper({
  isOpen,
  transitioning,
  targetRef,
  placement,
  centerPlacement,
  updateOnChildrenChange,
  setMaxHeight,
  distance,
  instanceRef: externalInstanceRef,
}: UsePopperArgs): RefObject<HTMLDivElement> {
  const popperRef = useRef<HTMLDivElement>(null)
  const instanceRef = useRef<Instance | null>(null)
  const setActivePoppers = useContext(PopperContext)
  const popperOptions = usePopperConfigs({
    placement,
    centerPlacement,
    setMaxHeight,
    distance,
  })

  const destroyPopper = useCallback(() => {
    setActivePoppers((prev) => prev.filter((node) => node !== instanceRef))
    if (externalInstanceRef) externalInstanceRef.current = null
    instanceRef.current?.destroy()
    instanceRef.current = null
  }, [externalInstanceRef, setActivePoppers])

  // destroy instance on unmount
  useEffect(() => destroyPopper, [destroyPopper])

  // destroy instance if not open or transitioning (for components using display: 'none')
  useEffect(() => {
    if (!isOpen && !transitioning) destroyPopper()
  }, [isOpen, transitioning, destroyPopper])

  // destroy instance on targetRef change
  // this effect runs every time the popper is first being created, so
  // useLayoutEffect lets this effect run before the createPopper useLayoutEffect below
  // to prevent popper from being created, destroyed, and created again
  useLayoutEffect(() => {
    destroyPopper()
  }, [targetRef, destroyPopper])

  // create instance if noCurrentInstance, shouldShow, and popperRequirementsExist
  // useLayoutEffect prevents the popper from flickering at top of the screen
  useLayoutEffect(() => {
    const noCurrentInstance = !instanceRef.current
    const shouldShow = isOpen || transitioning

    if (noCurrentInstance && shouldShow && !!popperRef.current && !!targetRef.current) {
      const instance = createPopper(targetRef.current, popperRef.current, popperOptions)
      instanceRef.current = instance
      if (externalInstanceRef) externalInstanceRef.current = instance
      setActivePoppers((prev) => prev.concat(instanceRef))
    }
  }, [isOpen, transitioning, targetRef, popperOptions, setActivePoppers, externalInstanceRef])

  // update instance on resize
  useResizeObserver(popperRef, () => {
    if (updateOnChildrenChange) {
      instanceRef.current?.update()
      setActivePoppers((prev) => [...prev])
    }
  })

  // update instance options when they change
  useEffect(() => {
    instanceRef.current?.setOptions((options) => ({
      ...options,
      ...popperOptions,
    }))
  }, [popperOptions])

  return popperRef
}

export default usePopper
