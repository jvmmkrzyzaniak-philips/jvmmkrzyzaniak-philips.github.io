import React, { Children, cloneElement, createElement, createRef, useEffect, useRef, useState, useContext } from 'react'
import { Tabs as ReachTabs, TabList, TabPanel, TabPanels } from '@reach/tabs'
import PropTypes from 'prop-types'
import { css, cx } from '@linaria/core'
import { trackEvent } from '@fs/zion-analytics'
import { boolAttr, sanitizeProps } from '@fs/zion-frontend-friends'
import { useLocation } from '@fs/zion-router'
import Tab from './Tab'
import { Bleed } from '../bleed'
import { colors } from '../theme'
import themeSubsets from '../theme/themeSubsets'
import Elevation from '../elevation/Elevation'
import HorizontalScroller, { smartLeftScroller, smartRightScroller } from '../horizontal-scroller'
import { TabsListPortal } from './TabsPortalProvider'
import { sizeWidths } from '../layout-band/LayoutBand'
import { WhiteThemeContext } from '../theme/white-theme'

const tabListCss = css`
  color: ${colors.transparent.gray70};
  align-items: flex-end;
  display: flex;
  float: left;
  position: relative;
  transition: transform 0.2s ease-in-out;
  white-space: nowrap;

  &[centered] {
    margin: 0 auto;
  }

  &[fullwidth] {
    display: grid;
    grid-template-columns: repeat(var(--tab-count), minmax(max-content, 1fr));
    min-width: 100%;
  }
`

const tabListContainerCss = css`
  flex: 1 1;
  width: 0; /* Not sure why this works, but it allows the left and right sides to take priority and shrink the tab width. flex: 1 1 0 should work, but doesn't. */
  max-width: 100%;
`

const wrapperCss = css`
  & *[data-reach-tab-panel]:focus {
    outline: none;
  }
`

const tabsRow = css`
  display: flex;
`

const rightOfTabsCss = css`
  flex-shrink: 0;
  margin-inline-start: 16px;
`

const leftOfTabsCss = css`
  flex-shrink: 0;
  margin-inline-end: 16px;
`

function moveTabIntoView(tabRefs, currentIndex, parentRef, setScroll) {
  const currentTab = tabRefs[currentIndex].current
  const previousTab = tabRefs[currentIndex - 1]?.current
  const nextTab = tabRefs[currentIndex + 1]?.current
  const { x: itemNodeX } = currentTab?.getBoundingClientRect() || {}
  const { x: parentX } = parentRef?.getBoundingClientRect() || {}

  const tabX = itemNodeX - parentX
  const currentScrollPos = parentRef.scrollLeft
  let newScrollPos = currentScrollPos
  // Going left
  if (tabX < 32 && previousTab) {
    newScrollPos = currentScrollPos - (previousTab.clientWidth / 2 - tabX) - 32
  } else if (tabX < 0) {
    newScrollPos = currentScrollPos + tabX
  } else if (tabX + currentTab.clientWidth > parentRef.clientWidth) {
    const nextTabWidth = nextTab?.clientWidth || 0
    const fullView = tabX + currentTab.clientWidth - parentRef.clientWidth
    newScrollPos = currentScrollPos + fullView + nextTabWidth / 2 + 32
  }
  if (currentScrollPos !== newScrollPos) {
    setScroll(newScrollPos)
  }
}
function Tabs({ children, ...props }) {
  if (!children) children = [] // Default prop value doesn't fix null error
  const tabChildren = Children.toArray(children).filter((child) => child?.type === Tab)

  const pathMap = tabChildren.reduce((paths, tab, i) => {
    if (tab?.props?.to) {
      if (!paths) {
        paths = {}
      }
      paths[tab.props.to] = i
    }
    return paths
  }, null)

  return pathMap ? (
    <RouterTabs pathMap={pathMap} {...props}>
      {tabChildren}
    </RouterTabs>
  ) : (
    <RenderTabs {...props}>{tabChildren}</RenderTabs>
  )
}

function RenderTabs({
  fullWidth,
  centered,
  children,
  color = 'blue',
  linkName,
  maxWidth,
  index,
  onChange,
  defaultIndex = 0,
  elevated,
  css: customCss, // Pulled out to prevent using this prop for custom styling (renamed since we already have a css definition)
  style: customStyle, // Pulled out to prevent using this prop for custom styling
  /** [HIDDEN]: For internal Zion-UI use only */
  LeftSide,
  RightSide,
  location,
  pathMap,

  ...props
}) {
  // only using defaultIndex if location is not set.
  let pathNumber
  if (location && pathMap) {
    pathNumber = pathMap[location.pathname] >= 0 ? pathMap[location.pathname] : -1
  } else {
    pathNumber = defaultIndex
  }
  const [selectedIndex, setSelectedIndex] = useState(pathNumber)
  const [scrollPosition, setScrollPosition] = useState(0)
  const scrollerRef = useRef()
  const isWhite = useContext(WhiteThemeContext)

  const tabRefs = []

  // Add a ref to each Tab and keep an array of tabRefs - Used to scroll the selected item into view
  const tabs = Children.map(children, (tab, i) => {
    const tabRef = createRef()
    tabRefs.push(tabRef)
    const newProps = { ...tab.props, ref: tabRef }

    // use 'aria-current' attribute if selected tab is a link
    if (tab.props.to) {
      newProps['aria-selected'] = undefined
      if (i === selectedIndex) {
        newProps['aria-current'] = 'page'
      }
    }
    // If the tab doesn't have a linkName but tabs does, a link (with "to") will only track if we push the linkName onto props
    if (newProps.to && linkName && !newProps.linkName) {
      newProps.linkName = linkName
    }
    return cloneElement(tab, newProps)
  })

  // change roles from tablist/tabpanel to navigation/group when all tabs are links
  const allTabsAreLinks = tabs.length ? tabs.every((tab) => tab.props.to) : false

  // Create TabPanel elements for use with Reach-Tabs
  // Put the children of the selected tab into the panel - ignore all other children - probably for performance?
  const tabPanels = Children.map(children, (tab, i) =>
    i === selectedIndex
      ? createElement(
          TabPanel,
          {
            // eslint-disable-next-line react/no-array-index-key -- TODO explain why it is fine to use key here
            key: `tab_${i}`,
            role: allTabsAreLinks ? 'group' : 'tabpanel',
          },
          tab.props.children
        )
      : // eslint-disable-next-line react/no-array-index-key -- TODO explain why it is fine to use key here
        createElement(TabPanel, { key: `tab_${i}`, role: allTabsAreLinks ? 'group' : 'tabpanel' })
  )

  useEffect(() => {
    if (typeof index !== 'undefined') {
      setSelectedIndex(index)
    }
  }, [index])

  // select a tab when pressing enter/return key
  const onKeyDown = (e) => {
    if (e.key === 'Enter') {
      e.target.click()
    }
  }

  return (
    <ReachTabs
      {...sanitizeProps(props)}
      className={wrapperCss}
      index={selectedIndex}
      defaultIndex={defaultIndex}
      onChange={(ind) => {
        setSelectedIndex(ind)
        moveTabIntoView(tabRefs, ind, scrollerRef.current, setScrollPosition)
        onChange && onChange(ind)

        // If linkName was supplied, and this isn't a link tab, track a click event on tab change
        // If the individual tab has a linkName prop, use that instead
        if (!tabs[ind]?.props?.to && (tabs[ind]?.props?.linkName || linkName)) {
          trackEvent({
            event_name: 'click_action',
            link_name: tabs[ind]?.props?.linkName || linkName,
          })
        }
      }}
      onKeyDown={onKeyDown}
    >
      <TabsListPortal>
        <Bleed sides>
          <Elevation
            className={cx(tabsRow, !isWhite && themeSubsets[color])}
            z={elevated ? 1 : 0}
            iswhite={boolAttr(isWhite)}
            style={{ maxWidth: maxWidth && sizeWidths[maxWidth] }}
          >
            {LeftSide && <div className={leftOfTabsCss}>{LeftSide}</div>}

            <HorizontalScroller
              className={tabListContainerCss}
              setScrollPosition={setScrollPosition}
              scrollPosition={scrollPosition}
              scrollLeftFn={smartLeftScroller('[role="tab"], [role="link"]')}
              scrollRightFn={smartRightScroller('[role="tab"], [role="link"]')}
              ref={scrollerRef}
            >
              <TabList
                style={{ '--tab-count': tabs.length }}
                className={tabListCss}
                fullwidth={boolAttr(fullWidth)}
                centered={boolAttr(centered)}
                role={allTabsAreLinks ? 'navigation' : 'tablist'}
              >
                {tabs}
              </TabList>
            </HorizontalScroller>

            {RightSide && <div className={rightOfTabsCss}>{RightSide}</div>}
          </Elevation>
        </Bleed>
      </TabsListPortal>
      {tabPanels && tabPanels.length > 0 && <TabPanels>{tabPanels}</TabPanels>}
    </ReachTabs>
  )
}

function RouterTabs(props) {
  return <RenderTabs {...props} location={useLocation()} />
}

Tabs.propTypes = {
  /** Whether to spread tabs across the full width of the screen */
  fullWidth: PropTypes.bool,

  /** Whether to center tabs on the tab bar */
  centered: PropTypes.bool,

  /** The color of tabs when selected or hovered */
  color: PropTypes.oneOf(['blue', 'green', 'yellow', 'red', 'purple']),

  /** Optional. Tracking name to log when a tab is clicked (overridden by individual tabs with a linkName prop) */
  linkName: PropTypes.string,

  /** The max width for the Tabs. Useful when "centered" with lots of Tab children */
  maxWidth: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl', 'xxl']),

  /** The index of the currently selected tab */
  index: PropTypes.number,

  /** The index of the initially selected tab */
  defaultIndex: PropTypes.number,

  /** Function that runs when the selected tab changes */
  onChange: PropTypes.func,

  /** Whether the tabs are elevated */
  elevated: PropTypes.bool,
}

export default Tabs
