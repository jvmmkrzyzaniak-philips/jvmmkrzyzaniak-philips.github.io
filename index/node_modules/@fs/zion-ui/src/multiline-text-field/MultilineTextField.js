import React, { useEffect, useRef, forwardRef, useCallback } from 'react'
import PropTypes from 'prop-types'
import { sanitizeProps, useForwardRef, useResizeObserver } from '@fs/zion-frontend-friends'
import TextArea from '../text-area/TextArea'

/**
 * Resizes a textarea to match its content height.
 * Respects the CSS max-height and enables overflow-y when necessary.
 * Overflow logic adapted from https://github.com/jackmoore/autosize
 *
 * @param {HTMLTextAreaElement} textArea
 * @returns void
 */
function updateHeight(textArea) {
  if (!textArea) return

  function resize() {
    textArea.style.height = 'unset'
    textArea.style.height = `${textArea.scrollHeight}px`
  }

  resize()

  const computedStyle = window.getComputedStyle(textArea, null)
  const computedHeight = Number.parseInt(computedStyle.height, 10)
  const styleHeight = Number.parseInt(textArea.style.height, 10)

  // If text has gone over the maxHeight, allow scrolling
  // Normally keep overflow hidden, to avoid flash of scrollbar as the textarea expands
  // And when the page is scaled up high enough, textareas might get an unnecessary overflow
  const newOverflowY = styleHeight > computedHeight ? 'scroll' : 'hidden'

  if (textArea.style.overflowY !== newOverflowY) {
    textArea.style.overflowY = newOverflowY
    resize()
  }
}

/** TextField that dynamically expands and shrinks as the user types. */
const MultilineTextField = forwardRef(function MultilineTextField(props, ref) {
  const { value } = props
  const { maxHeight = null, rows = 1, ...rest } = props
  const textAreaRef = useForwardRef(ref)

  // Apply maxHeight CSS directly, since className/style canâ€™t be passed down
  useEffect(() => {
    if (textAreaRef.current && maxHeight) {
      textAreaRef.current.style.maxHeight = `${maxHeight}px`
    }
  }, [maxHeight, textAreaRef])

  // Update height when value changes
  useEffect(() => {
    updateHeight(textAreaRef.current)
  }, [value, textAreaRef])

  // Update height when width changes
  const lastWidthRef = useRef()
  const resizeCallback = useCallback(
    (entry) => {
      const newWidth = entry.contentRect.width
      if (lastWidthRef.current !== newWidth) {
        updateHeight(textAreaRef.current)
        lastWidthRef.current = newWidth
      }
    },
    [textAreaRef]
  )
  useResizeObserver(textAreaRef, resizeCallback)

  // Spread props first, so the rest of the props can't be overidden
  return <TextArea {...sanitizeProps(rest)} ref={textAreaRef} rows={rows} disableResize multiline />
})

export default MultilineTextField
export const meta = {
  name: 'MultilineTextField',
  isZionFormComponent: true,
}

MultilineTextField.meta = meta

MultilineTextField.propTypes = {
  /** Max height of the input in px. */
  maxHeight: PropTypes.number,

  /** Max number of characters allowed. */
  maxLength: PropTypes.number,

  /** Identifier for the input. */
  name: PropTypes.string,

  /** [REQUIRED OUTSIDE OF ZIONFORM] - Handler run every time the value of the input changes. */
  onChange: PropTypes.func,

  /** Handler run every time the user presses enter while the input has focus. */
  onEnterKey: PropTypes.func,

  /** Placeholder text to display to the user. */
  placeholder: PropTypes.string,

  /** Minimum number of rows to show (e.g., when there is no text). The field will still grow beyond this as needed, up to maxHeight. */
  rows: PropTypes.number,

  /** Determines if native browser autofill is disabled */
  autoComplete: PropTypes.string,

  /**  [REQUIRED OUTSIDE OF ZIONFORM] - The input value */
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
}
