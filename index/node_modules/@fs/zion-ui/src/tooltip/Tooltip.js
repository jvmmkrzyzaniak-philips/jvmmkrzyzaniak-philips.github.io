import React, { Fragment, cloneElement, useRef, Children, useEffect, useImperativeHandle, forwardRef } from 'react'
import { css } from '@linaria/core'
import PropTypes from 'prop-types'
import { boolAttr, sanitizeProps } from '@fs/zion-frontend-friends'
import { colors, Theme } from '../theme'
import { Paragraph } from '../typography'
import Portal, { PopperPortalContext } from '../portal'
import Popper from '../popper'
import { useOverlay } from '../overlay'
import OpenCloseAnimation from '../open-close-animation'

const tooltipCss = css`
  max-width: 300px;
  padding: 0 8px;
  text-align: center;
  background: ${colors.gray00};
  border-radius: 4px;

  & p {
    padding: 0;
  }
  &[more-padding] {
    padding: 8px;
  }

  & img {
    display: block;
    width: 100%;
    height: auto;
  }
`

const spanCss = css`
  display: inline-block;
  max-width: 100%;
  vertical-align: inherit; /* Fixes issues with text-alignment in tables */
  & > *:disabled,
  & > *[aria-disabled='true'] {
    pointer-events: none;
  }
`

// Create a stacking context, so all things inside this overlay will be contained (and on top of the main ui)
const commonStyles = { zIndex: 2, margin: 4, config: { tension: 350, clamp: true } }
const animStyles = {
  openStyles: { opacity: 1, scale: 1, ...commonStyles },
  closeStyles: { opacity: 0, scale: 0.85, ...commonStyles },
}

/**
 * Most of the time we wrap the contents of `target` in a span, so it has some css powers.
 * But some internal components want to provide their own target, like Button.
 */
const DefaultTarget = forwardRef((props, ref) => <span {...props} ref={ref} className={spanCss} />)

/**
 * useOverlay always be like "Don't you know you wanna focus on something after I close dat overlay?"
 * noFocusRef be like, "nah man, stop that!"
 */
const noFocusRef = { current: { focus: () => {} } }

export default function Tooltip({
  label,
  target,
  placement,
  description,

  /** [HIDDEN]: For internal Zion-UI use only */
  targetAs,
  targetAsProps,

  interactive, // Deprecated, and can be removed when linkProps are removed from Description/ComboTooltip in v11
  morePadding,
  onOpenFinished,
  onCloseFinished,
  openTimeout,

  /** [SCRUBBED]: Don't pass on to children */
  linkProps, // LabelTooltip doesn't use this, it's passed on from the other tooltip types, so we filter it out here instead of passing it on to dom elements
  keyboardShortcut, // LabelTooltip doesn't use this, it's passed on from the other tooltip types, so we filter it out here instead of passing it on to dom elements

  ...props
}) {
  placement = placement || 'bottom'
  const Target = targetAs || DefaultTarget
  const enterTimer = useRef()
  const leaveTimer = useRef()

  const { isOpen, transitioning, targetRef, handleTransitioned, open, close } = useOverlay({ focusBackRef: noFocusRef })
  useImperativeHandle(targetAsProps?.ref, () => targetRef.current)

  const handleOpen = (event) => {
    if (event?.type === 'keyup' && event?.key !== 'Tab') {
      return
    }
    clearTimeout(enterTimer.current)
    clearTimeout(leaveTimer.current)
    if (!(label || description)) return
    if (openTimeout) {
      enterTimer.current = setTimeout(open, openTimeout)
    } else {
      open()
    }
  }

  const handleClose = React.useCallback(() => {
    clearTimeout(enterTimer.current)
    clearTimeout(leaveTimer.current)
    // This gives closing a slight delay long enough for the user to shift focus to the tooltip
    leaveTimer.current = setTimeout(close, 200)
  }, [close])

  // when an element disappears or loses focus because it was disabled, the onBlur doesn't fire - do some special handling so that we still cancel the tooltip -- see ZIONUI-729
  const focusoutHandler = React.useCallback(
    (event) => {
      if (event.target === targetRef?.current) {
        handleClose()
      }
    },
    [handleClose, targetRef]
  )

  useEffect(() => {
    if (!transitioning) {
      if (isOpen) {
        onOpenFinished?.()
      } else {
        onCloseFinished?.()
      }
    }
  }, [isOpen, transitioning, onOpenFinished, onCloseFinished])

  const interactiveProps = {
    onMouseOver: handleOpen,
    onMouseOut: handleClose,
    onKeyUp: handleOpen,
    onBlur: handleClose,
  }

  const targetIsFragment = !target?.type || target?.type === Fragment
  const targetChildren = targetIsFragment
    ? target
    : Children.only(cloneElement(target, { onKeyUp: handleOpen, onBlur: handleClose }))

  const targetFocusProps = targetIsFragment ? { onKeyUp: handleOpen, onBlur: handleClose } : {}

  useEffect(() => {
    document.addEventListener('focusout', focusoutHandler)
    return () => {
      document.removeEventListener('focusout', focusoutHandler)
    }
  }, [focusoutHandler])

  return (
    <>
      <Target
        onMouseEnter={handleOpen}
        onMouseLeave={handleClose}
        aria-description={description}
        {...targetFocusProps}
        {...targetAsProps}
        ref={targetRef}
      >
        {targetChildren}
      </Target>
      {!isOpen && !transitioning ? null : (
        <Portal context={PopperPortalContext}>
          <Popper
            isOpen={isOpen || (!isOpen && transitioning)}
            targetRef={targetRef}
            placement={placement}
            centerPlacement
            updateOnChildrenChange
            elevatedZIndex
          >
            <OpenCloseAnimation
              isOpen={isOpen}
              {...animStyles}
              onOpenFinished={handleTransitioned}
              onCloseFinished={handleTransitioned}
            >
              <Theme theme="complementary" transparent>
                <div
                  {...sanitizeProps(props)}
                  className={tooltipCss}
                  more-padding={boolAttr(morePadding)}
                  role="tooltip"
                  {...(interactive ? interactiveProps : {})}
                >
                  <Paragraph size="xs" as="div">
                    {label}
                  </Paragraph>
                </div>
              </Theme>
            </OpenCloseAnimation>
          </Popper>
        </Portal>
      )}
    </>
  )
}

Tooltip.propTypes = {
  /** Text displayed in the tooltip. If you don't provide something, the tooltip won't show up. */
  label: PropTypes.oneOfType([PropTypes.element, PropTypes.node]),

  /** A single dom node or component that renders a single dom node to which the tooltip gets attached. */
  target: PropTypes.oneOfType([PropTypes.element, PropTypes.node]).isRequired,

  /** Which side of the target to place the tooltip. Use an array of placement values to use as backup when the first placement value would render the tooltip offscreen. */
  placement: PropTypes.oneOfType([
    PropTypes.oneOf(['top', 'end', 'bottom', 'start']),
    PropTypes.arrayOf(PropTypes.oneOf(['top', 'end', 'bottom', 'start'])),
  ]),

  /** [HIDDEN]: Callback called when the tooltip opens. Param is the popper instance object. */
  // onOpenFinished: PropTypes.func,

  /** [HIDDEN]: Adds extra padding. Used internally by other Tooltip components. */
  // morePadding: PropTypes.func,

  /** [HIDDEN]: Callback called when the tooltip closes. */
  // onCloseFinished: PropTypes.func,

  /** [HIDDEN]: Only used for DescriptionTooltip If true, the tooltip will remain open if the mouse moves into it. */
  // interactive: PropTypes.bool,

  /** [HIDDEN]: How long to wait before opening after trigger. */
  // openTimeout: PropTypes.string,
}
