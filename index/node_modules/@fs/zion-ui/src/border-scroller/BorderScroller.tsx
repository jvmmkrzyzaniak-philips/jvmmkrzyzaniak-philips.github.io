import type { HTMLAttributes } from 'react'
import React, { forwardRef, useCallback, useEffect, useState } from 'react'
import PropTypes from 'prop-types'
import { css, cx } from '@linaria/core'
import { ObserverRootContext, useForwardRef, useResizeObserver } from '@fs/zion-frontend-friends'
import { colors } from '../index'

const containerCss = css`
  display: flex;
  flex-grow: 1;
  flex-shrink: 1;
  flex-direction: column;
  position: relative;
  overflow: hidden;
`

const contentCss = css`
  display: flex;
  flex-direction: column;
  flex: 1;
  -ms-overflow-style: -ms-autohiding-scrollbar; /* Makes the scrollbar auto-hide/show on edge */

  /* better mobile scrolling */
  overflow-scrolling: touch;
  -webkit-overflow-scrolling: touch;

  overflow-x: hidden;
  min-height: 0;
`

const borderCss = css`
  pointer-events: none;
  transition: border 0.3s;
  border-top: 1px solid transparent;
  border-bottom: 1px solid transparent;
  position: absolute;
  top: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
`

type Props = HTMLAttributes<HTMLDivElement> & {
  /** Whether to hide the borders temporarily */
  hideBorders?: boolean

  /** Prevents the scrollbar from appearing and disappearing (useful for animations) */
  freezeScrollbar?: boolean
}

export const BorderScroller = forwardRef<HTMLDivElement, Props>(
  (
    { children, className, hideBorders, freezeScrollbar, style, ...props }: Props,
    ref: React.Ref<HTMLDivElement>
  ): JSX.Element => {
    const [scrolledToTop, setScrolledToTop] = useState(true)
    const [scrolledToBottom, setScrolledToBottom] = useState(false)
    const [overflowY, setOverflowY] = useState<'auto' | 'hidden' | 'scroll'>('auto')
    const scrollerRef = useForwardRef<HTMLDivElement | null>(ref)

    const handleScroll = useCallback(() => {
      const scrollerEl = scrollerRef.current
      if (!scrollerEl) return
      const scrollableAmount = scrollerEl.scrollHeight - scrollerEl.offsetHeight
      setScrolledToTop(scrollerEl.scrollTop === 0)
      // use "- 1" here for a little bit of wiggle room
      setScrolledToBottom(scrollerEl.scrollTop >= scrollableAmount - 1)
    }, [scrollerRef])

    useResizeObserver(scrollerRef, handleScroll)

    useEffect(() => {
      if (!freezeScrollbar) {
        setOverflowY('auto')
        return
      }

      const scrollerEl = scrollerRef.current
      const hasScrollbar = scrollerEl.offsetWidth - scrollerEl.clientWidth > 0
      setOverflowY(hasScrollbar ? 'scroll' : 'hidden')
    }, [freezeScrollbar, scrollerRef])

    return (
      <div className={containerCss}>
        <div
          ref={scrollerRef}
          {...props}
          style={{ ...style, overflowY }}
          className={cx(contentCss, className)}
          onScroll={handleScroll}
          data-scrollable=""
        >
          <ObserverRootContext.Provider value={scrollerRef}>{children}</ObserverRootContext.Provider>
        </div>
        {/* We need to put the border on as an absolute element because we want the border to be on the inside edge of the content, not wrapping it, so it can use its transparent powers. This is also better than an inset box-shadow because bleeding content will cover up the box-shadow */}
        <div
          className={borderCss}
          style={{
            borderTopColor: scrolledToTop || hideBorders ? 'transparent' : colors.transparent.gray10,
            borderBottomColor: scrolledToBottom || hideBorders ? 'transparent' : colors.transparent.gray10,
          }}
        />
      </div>
    )
  }
)

export default BorderScroller

BorderScroller.propTypes = {
  /** The content of the scrollable container. */
  children: PropTypes.node,
}
