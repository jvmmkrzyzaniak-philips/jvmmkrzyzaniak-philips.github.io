import React, { createContext, useContext, memo, Children, cloneElement, useState } from 'react'
import { css, cx } from '@linaria/core'
import PropTypes from 'prop-types'
import { boolAttr, sanitizeProps, useResizeObserver } from '@fs/zion-frontend-friends'
import VisuallyHidden from '@reach/visually-hidden'
import { ResponsiveProvider } from '../responsive'
import { GutterBox, gutterChildCss } from '../gutter-box'
import GridStart from '../grid/GridStart'
import { colors } from '../theme'
import useSelection from '../use-selection'
import useResponsiveTable from './useResponsiveTable'

export const ResponsiveTableContext = createContext(null)

const tableCss = css`
  --table-width: calc(var(--cell-width, var(--grid-width)) + var(--gutters-x) * 2);
  --background-color: ${colors.gray00};

  display: table;
  margin: 0 calc(-1 * var(--gutters-x)) !important; // this overrides GutterBox's margin so that ResponsiveTables have a gutter on the top and bottom of the table. It needs the !important because otherwise the linaria build prioritizes GutterBox's css.
  width: var(--table-width);
  border-collapse: separate;
  border-spacing: 0;
  table-layout: fixed;
  position: relative;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch; /* allow drag to continue scrolling after user lets go for mobile (iOS Safari) */
  color: ${colors.gray100};

  thead {
    --table-vertical-align: bottom; // verticalAlign shouldnâ€™t affect the alignment of the header, or else things tend to look weird.
  }
`

export const rowPaddingCss = css`
  th,
  td {
    padding: var(--gutters-y) var(--gutters-x);
    &:first-child {
      padding-inline-start: 0;
    }

    &:last-child {
      padding-inline-end: 0;
    }
  }
`

export const rowBaseCss = css`
  vertical-align: var(--table-vertical-align);

  th,
  td {
    text-align: start;
    border-bottom: 1px solid ${colors.transparent.gray10};

    &:first-child {
      border-inline-start: var(--gutters-x) solid transparent;
    }

    &:last-child {
      border-inline-end: var(--gutters-x) solid transparent;
    }
  }
`

export const headerCss = css`
  /* prevents the header from appearing in weird places when printing */
  @media not print {
    &[sticky] > * {
      position: sticky;
      top: var(--sticky-below, 0);
      z-index: 1; /* position: sticky goes above some things, but not above position:relative or things with z-index. */
      background: var(--background-color);
    }
  }
`

// Provide a lookup table to optimize how to find the columnRules for a specific column
// This function turns a column mapping set like:
//    combinationRules: [ ['column1', 'column3'], ['column2', 'column4'] ]
// into an indexable association list, like this:
//    { 1:0, 2:1, 3:0, 4:1 }
export function generateAssociationList(rules) {
  const ruleMap = {}
  rules.forEach((rule, placementCol) => {
    rule.forEach((column) => {
      const targetCol = parseInt(column.replace('column', ''), 10)
      ruleMap[targetCol] = placementCol
    })
  })
  return ruleMap
}

const dummyRef = { current: null }

export const checkboxCellWidth = 48
export const expanderButtonCellWidth = 36

export function ResponsiveTableBaseComponent({
  children,
  verticalAlign = 'top',
  stickyHeader = true,
  stickyBelowRef = dummyRef,
  gutters = 'xs',
  guttersY = gutters,
  getPropsForTh,
  caption,
  backgroundColor,
  selectAllCheckbox, // provided by ResponsiveCheckboxTable
  ...props
}) {
  const {
    currentColumns: { labels, columnWidths = [] },
    rowLevelHeaders,
    hasExpandableContent,
    maxDisplayColumns,
  } = useContext(ResponsiveTableContext)

  // This extra value preserves the 12-column grid sizing even with fixed-width columns,
  // Like the Expandable Control, the Checkbox column, or other custom columns
  let actualPixelDoneStolenFromNextColumn = selectAllCheckbox ? checkboxCellWidth : 0

  const widthStyles = [...Array(maxDisplayColumns)].map((_, idx) => {
    const columnWidth = columnWidths.length ? columnWidths[idx] : 12 / maxDisplayColumns
    let width

    if (hasExpandableContent && idx === maxDisplayColumns - 1) {
      // Make room for the expander button at the end.
      actualPixelDoneStolenFromNextColumn += expanderButtonCellWidth
    }

    if (typeof columnWidth === 'string') {
      // WE only support string-widths that are like `##px`
      const [, pixelAmount] = columnWidth.match(/(\d+)px/) || []
      if (!pixelAmount) throw new Error('Unrecognized column width: ', columnWidth)
      width = Number(pixelAmount)
      actualPixelDoneStolenFromNextColumn += width
    } else if (actualPixelDoneStolenFromNextColumn === 0) {
      width = `calc(var(--table-width) * ${columnWidth / 12})`
    } else {
      width = `calc(var(--table-width) * ${columnWidth / 12} - ${actualPixelDoneStolenFromNextColumn}px)`
      actualPixelDoneStolenFromNextColumn = 0
    }

    return width
  })

  // if labels aren't provided, give column widths to first row
  if (!labels) {
    children = Children.map(children, (child, idx) => {
      if (idx !== 0) return child

      return cloneElement(child, { columnWidths: widthStyles })
    })
  }

  const [stickyBelow, setStickyBelow] = useState(0)
  useResizeObserver(stickyBelowRef, () => {
    const { current } = stickyBelowRef
    if (current) {
      const height = current.getBoundingClientRect().height || 0
      const top = parseFloat(getComputedStyle(current).top)
      setStickyBelow(height + (Number.isNaN(top) ? 0 : top))
    } else {
      setStickyBelow(0)
    }
  })

  return (
    <ResponsiveProvider>
      <GridStart>
        <GutterBox
          as="table"
          guttersX={gutters}
          guttersY={guttersY}
          {...sanitizeProps(props)}
          className={tableCss}
          style={{
            '--table-vertical-align': verticalAlign,
          }}
        >
          {caption && (
            <caption>
              <VisuallyHidden>{caption}</VisuallyHidden>
            </caption>
          )}
          {labels && (
            <thead>
              <tr
                className={cx(rowBaseCss, rowPaddingCss, headerCss, gutterChildCss)}
                sticky={boolAttr(stickyHeader)}
                style={{ '--background-color': backgroundColor, '--sticky-below': `${stickyBelow}px` }}
              >
                {/* The select-all checkbox is in a `td` rather than a `th` for accessibility. `th` elements require inner text to function properly across all screen readers. (supposedly - we haven't been able to recreate any issues with it) */}
                {selectAllCheckbox && <td style={{ width: checkboxCellWidth }}>{selectAllCheckbox}</td>}
                {labels.map((label, i) => {
                  // Label is node or object of shape { ariaLabel: 'string' }
                  const isVisuallyEmpty = typeof label === 'object' && !!label.ariaLabel
                  const visualLabel = isVisuallyEmpty ? null : label

                  // Allow custom props and children (e.g., for SortableResponsiveTable)
                  const customProps = getPropsForTh?.(label, i) || {}

                  return (
                    <th
                      key={i} // eslint-disable-line react/no-array-index-key -- No other sensible option
                      aria-label={isVisuallyEmpty ? label.ariaLabel : undefined}
                      style={{ width: widthStyles[i], verticalAlign: 'middle' }}
                      scope={rowLevelHeaders ? 'col' : undefined}
                      {...customProps}
                    >
                      {customProps.children ?? visualLabel}
                    </th>
                  )
                })}
                {/* th should never be empty, so we use a td - which seems to be ok */}
                {hasExpandableContent && <td style={{ width: expanderButtonCellWidth }} />}
              </tr>
            </thead>
          )}
          <tbody>{children}</tbody>
        </GutterBox>
      </GridStart>
    </ResponsiveProvider>
  )
}

export const ResponsiveTableBase = memo(ResponsiveTableBaseComponent)

const defaultGetPropsForTh = () => ({})

export const ResponsiveTableComponent = ({
  // For useResponsiveTable
  atSizeColumns,
  rowLevelHeaders,
  totalColumnCount,
  getPropsForCheckbox,
  checkedItems,
  separator,

  // For ResponsiveTableBase
  ...props
}) => {
  const tableState = useResponsiveTable({
    atSizeColumns,
    rowLevelHeaders,
    totalColumnCount,
    getPropsForCheckbox,
    checkedItems,
    separator,
  })

  return (
    <ResponsiveTableContext.Provider value={tableState}>
      <ResponsiveTableBase {...props} getPropsForTh={defaultGetPropsForTh} />
    </ResponsiveTableContext.Provider>
  )
}
const ResponsiveTable = memo(ResponsiveTableComponent)
export default ResponsiveTable

ResponsiveTableComponent.propTypes = {
  /** `ResponsiveTableRow` instances */
  children: PropTypes.node,

  /** The max number of columns this table can take up in it's _widest_ layout */
  totalColumnCount: PropTypes.number.isRequired,

  /**
   * Sometimes you need to put this component over a colored background.
   * If you have a sticky header, that header needs a solid background to match,
   * or things will look weird.
   */
  backgroundColor: PropTypes.string,

  /** `atWidth()` configuration object. Each size (default, xxs, xs, sm, md, lg, xl, xxl) can have their own configuration:
   *
   * - `labels<Array<String | { ariaLabel: string }>>`: _ordered array of column label strings or objects._
   * - `columnWidths<Number[]>`: _ordered array of widths for each column (must add up to 12)_
   * - `combinationRules<Array[String[]]>`: _ordered array of desired sets of columns to combine_
   */
  atSizeColumns: PropTypes.shape({
    default: PropTypes.shape({
      labels: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.node.isRequired, PropTypes.shape({ ariaLabel: PropTypes.string.isRequired })])
      ),
      columnWidths: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.string, PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])])
      ),
      combinationRules: PropTypes.array,
    }).isRequired,
    xxs: PropTypes.shape({
      labels: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.node.isRequired, PropTypes.shape({ ariaLabel: PropTypes.string.isRequired })])
      ),
      columnWidths: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.string, PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])])
      ),
      combinationRules: PropTypes.array,
    }),
    xs: PropTypes.shape({
      labels: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.node.isRequired, PropTypes.shape({ ariaLabel: PropTypes.string.isRequired })])
      ),
      columnWidths: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.string, PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])])
      ),
      combinationRules: PropTypes.array,
    }),
    sm: PropTypes.shape({
      labels: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.node.isRequired, PropTypes.shape({ ariaLabel: PropTypes.string.isRequired })])
      ),
      columnWidths: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.string, PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])])
      ),
      combinationRules: PropTypes.array,
    }),
    md: PropTypes.shape({
      labels: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.node.isRequired, PropTypes.shape({ ariaLabel: PropTypes.string.isRequired })])
      ),
      columnWidths: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.string, PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])])
      ),
      combinationRules: PropTypes.array,
    }),
    lg: PropTypes.shape({
      labels: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.node.isRequired, PropTypes.shape({ ariaLabel: PropTypes.string.isRequired })])
      ),
      columnWidths: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.string, PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])])
      ),
      combinationRules: PropTypes.array,
    }),
    xl: PropTypes.shape({
      labels: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.node.isRequired, PropTypes.shape({ ariaLabel: PropTypes.string.isRequired })])
      ),
      columnWidths: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.string, PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])])
      ),
      combinationRules: PropTypes.array,
    }),
    xxl: PropTypes.shape({
      labels: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.node.isRequired, PropTypes.shape({ ariaLabel: PropTypes.string.isRequired })])
      ),
      columnWidths: PropTypes.arrayOf(
        PropTypes.oneOfType([PropTypes.string, PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])])
      ),
      combinationRules: PropTypes.array,
    }),
  }).isRequired,

  /** Specify a separator between combined cells (`<br/>` for example) */
  separator: PropTypes.node,

  /** Specify how cell contents are aligned (same as the CSS rule) */
  verticalAlign: PropTypes.oneOf(['top', 'middle', 'bottom']),

  /** Makes the header sticky (default true). */
  stickyHeader: PropTypes.bool,

  /** If you want the header to be placed below something else that's sticky, pass a Ref to that node here. */
  stickyBelowRef: PropTypes.shape({ current: PropTypes.instanceOf(Element) }),

  /** Visually-hidden descriptive text for the table */
  caption: PropTypes.string,

  /** Gutter distance between cells */
  gutters: PropTypes.oneOf(['lg', 'md', 'sm', 'xs', 'xxs', 'nano']),

  /** Vertical gutter distance between cells (matches 'gutters' if not specified) */
  guttersY: PropTypes.oneOf(['lg', 'md', 'sm', 'xs', 'xxs', 'nano']),
}

export function ResponsiveCheckboxTableComponent({
  children,
  onSelectionChange,
  initialAllSelected = false,
  initialSelection,
  atSizeColumns,
  ...rest
}) {
  const { getPropsForCheckbox, selectAllCheckbox, checkedItems } = useSelection({
    onSelectionChange,
    selectAllLabel: '',
    initialAllSelected,
    initialSelection,
    children,
  })
  return (
    <ResponsiveTable
      getPropsForCheckbox={getPropsForCheckbox}
      selectAllCheckbox={selectAllCheckbox}
      atSizeColumns={atSizeColumns}
      checkedItems={checkedItems}
      {...rest}
    >
      {children}
    </ResponsiveTable>
  )
}

export const ResponsiveCheckboxTable = memo(ResponsiveCheckboxTableComponent)

ResponsiveCheckboxTableComponent.propTypes = {
  /** The callback for when a checkbox is selected in a row. Returns an array of the `name` for each selected `ResponsiveTableRow` */
  onSelectionChange: PropTypes.func.isRequired,

  /** Set `true` to make all the checkboxes start off as checked */
  initialAllSelected: PropTypes.bool,

  /** Names of checkbox table rows that should start out in a checked state */
  initialSelection: PropTypes.arrayOf(PropTypes.string),
}
