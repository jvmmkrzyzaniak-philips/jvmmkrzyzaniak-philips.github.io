import React, { Fragment, memo, useCallback, useContext, useEffect, useRef, useState } from 'react'
import { css, cx } from '@linaria/core'
import PropTypes from 'prop-types'
import { boolAttr, sanitizeProps, useEvent, useResizeObserver } from '@fs/zion-frontend-friends'
import { Link } from '@fs/zion-router'
import { ArrowCaret } from '@fs/zion-icon'
import { animated, useSpring } from '@react-spring/web'
import { useTranslation } from 'react-i18next'
import { IconButton } from '../buttons'
import { colors } from '../theme'
import Checkbox from '../checkbox'
import { LabelTooltip } from '../tooltip'
import {
  checkboxCellWidth,
  expanderButtonCellWidth,
  ResponsiveTableContext,
  rowBaseCss,
  rowPaddingCss,
} from './ResponsiveTable'

const rowCss = css`
  & > * {
    position: relative;
    transition: background 0.2s;
  }

  /* Hide the bottom border in the following cases:
  *  1. It's the last row in the table,
  *  2. The consumer asked for the border to be hidden,
  *  3, The row is at least partially expanded.
  */
  &:last-child,
  &[no-bottom-divider] {
    & > * {
      border-bottom: 0;
    }
  }

  /* Hover and focus styles when the row is clickable */
  &[interactable]:hover,
  &[interactable]:has(:focus-visible) {
    & > * {
      background: ${colors.transparent.gray03};
    }
  }

  /* Background and hover/focus styles when the row is "selected" */
  &[rowselected] {
    & > * {
      background: ${colors.transparent.gray02};
    }

    &[interactable]:hover,
    &[interactable]:has(:focus-visible) {
      & > * {
        background: ${colors.transparent.gray03};
      }
    }
  }

  &[interactable] {
    & > * {
      cursor: pointer;
      &:first-child {
        border-start-start-radius: 4px;
        border-start-end-radius: 0;
        border-end-end-radius: 0;
        border-end-start-radius: 4px;
      }
      &:last-child {
        border-start-start-radius: 0;
        border-start-end-radius: 4px;
        border-end-end-radius: 4px;
        border-end-start-radius: 0;
      }
    }
    &[rowselected] {
      & > * {
        &:first-child {
          border-end-start-radius: 0;
        }
        &:last-child {
          border-end-end-radius: 0;
        }
      }
    }
  }
`

const expandableRowCss = css`
  & > th,
  & > td {
    padding: 0;
  }
`

const expandableContentCss = css`
  padding: var(--gutters-y) 0;
`

const explainIconCss = css`
  margin: 6px -2px;
  display: inline-block;
  cursor: not-allowed;
`

const expandRowButtonCellCss = css`
  // We need a little less padding for the IconButton to properly align with the text of other cells
  padding: calc(var(--gutters-y) - 4px) 0 !important; // Using this !important to override those complex selectors above
`

const linkCellCss = css`
  display: block;
  color: inherit; /* Prevent user-agent link colors when not in a Type component */

  /* makes the entire cell clickable for links */
  &::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    inset-inline-end: 0;
    inset-inline-start: 0;
  }

  *:first-child > &::after {
    inset-inline-start: calc(var(--gutters-x) * -1);
  }

  *:last-child > &::after {
    inset-inline-end: calc(var(--gutters-x) * -1);
  }
`

const noBoldCss = css`
  font-weight: normal;
`

const LinkWrapper = (props) => <Link {...props} noLinkStyles className={linkCellCss} />

// Helper for positioning an Icon with Tooltip when a user cannot select a checkbox row
function DisabledExplanation({ reason, Icon, name }) {
  if (Icon) {
    return reason ? (
      <LabelTooltip
        label={reason}
        target={
          <div className={explainIconCss}>
            <Icon color={colors.transparent.gray40} />
          </div>
        }
      />
    ) : (
      <span style={{ cursor: 'not-allowed' }}>
        <Icon color={colors.transparent.gray40} />
      </span>
    )
  }
  return reason ? (
    <LabelTooltip label={reason} target={<Checkbox name={name} disabled />} />
  ) : (
    <Checkbox name={name} disabled />
  )
}

// Provide a lookup table to optimize how to find the columnRules for a specific column
// This function turns a column mapping set like:
//    combinationRules: [ ['column1', 'column3'], ['column2', 'column4'] ]
// into an indexable association list, like this:
//    { 1:0, 2:1, 3:0, 4:1 }
export function generateAssociationList(rules) {
  const ruleMap = {}
  rules.forEach((rule, placementCol) => {
    rule.forEach((column) => {
      const targetCol = parseInt(column.replace('column', ''), 10)
      ruleMap[targetCol] = placementCol
    })
  })
  return ruleMap
}

// insert cell contents into the correct column based on:
// specified position, respective order, or overflow on the right most column
export function partitionCellContents(
  columnProps,
  { maxDisplayColumns, totalColumnCount, combinationRules = [], associationList = {} }
) {
  const span = Array(maxDisplayColumns)
  const row = Array.from({ length: maxDisplayColumns }, () => [])
  let lastPossibleColumn = maxDisplayColumns - 1

  // insertion sort of column values into the correct cells of the `row`
  for (let i = 1; i <= totalColumnCount; i++) {
    // get our key and value to insert
    const itemKey = `column${i}`
    const itemContent = columnProps[itemKey]

    // get our span key and value
    const itemSpanKey = `column${i}span`
    const itemSpan = columnProps[itemSpanKey] || 1
    if (itemSpan > 1) {
      span[i - 1] = itemSpan
      for (let s = itemSpan - 1; s > 0; s--) {
        if (i < row.length) {
          lastPossibleColumn -= 1
          row.pop()
        }
      }
    }

    // determine the default cell position to insert
    // if there is room, insert it based on column number
    // if not enough room, put the overflow into the furthest right cell
    const preferredPosition = i - 1
    const defaultInsertionIndex = preferredPosition < lastPossibleColumn ? preferredPosition : lastPossibleColumn

    // see if the developer specified a column insertion set for this key
    const cellIndex = associationList[i]
    const rowCombinationRules = combinationRules[cellIndex]

    // If there is an explicitly specified position, honor that
    if (rowCombinationRules !== undefined) {
      // respect the order of insertion in the dev's specification
      const insertionIndex = rowCombinationRules.findIndex((x) => x === itemKey)
      row[cellIndex][insertionIndex] = itemContent
    } else {
      row[defaultInsertionIndex].push(itemContent)
    }
  }

  return [row, span]
}

function insertSeparators(arr, separator) {
  const separated = []
  arr
    .filter((x) => x !== undefined) // filter out nonexistent items
    .forEach((item, i, { length }) => {
      separated.push(item)
      if (i < length - 1) {
        separated.push(separator)
      }
    })
  return separated
}

function ControlledResponsiveTableRowComponent({
  children,
  name,
  onClick,
  to,
  action,
  linkName,
  rowExpanded,
  setRowExpanded,
  showExpansionControl,
  disabled = false,
  explainWhyDisabled,
  selected = false,
  columnWidths = [],
  noBottomDivider = false,
  keepVisible = false,
  initiallyExpanded,
  ...props // column* can more easily be grepped in an object
}) {
  const [expandableContentHeight, setExpandableContentHeight] = useState(initiallyExpanded ? undefined : 0)
  const [rowTransitioning, setRowTransitioning] = useState(false)
  const styles = useSpring({
    height: rowExpanded ? expandableContentHeight : 0,
    onRest: () => setRowTransitioning(false),
    onStart: () => setRowTransitioning(true),
    overflow: 'hidden',
  })
  const expandableContentRef = useRef()
  const hasChildrenDisplayedRef = useRef(initiallyExpanded)
  const [t] = useTranslation()

  // make sure the columns will fit within the allowed regions
  const {
    maxDisplayColumns,
    totalColumnCount,
    associationList,
    getPropsForCheckbox,
    separator,
    combinationRules,
    rowLevelHeaders,
    verticalAlign,
    hasExpandableContent,
    setHasExpandableContent,
  } = useContext(ResponsiveTableContext)

  const hasChildren = Boolean(children)
  const isUserExpandable = showExpansionControl && hasChildren

  useEffect(() => {
    if (!hasChildren) {
      // If the children got removed while this was expanded, we need to collapse it, so that it won't
      // jump back open if children get added back in.
      setRowExpanded(false)
    }
  }, [hasChildren, setRowExpanded])

  useEffect(() => {
    // This implemenation will add an extra "expander" column to the parent table if ANY of the rows have CHILDREN
    // EVER. If all rows stop being expandable, this column won't go away. We think this is an edge-case, because
    // A consumer of this table will probably always have expandableness or not, and not switch between.
    if (isUserExpandable) {
      setHasExpandableContent(true)
    }
  }, [isUserExpandable, setHasExpandableContent])

  const row = partitionCellContents(props, {
    maxDisplayColumns,
    totalColumnCount,
    associationList,
    combinationRules,
    separator,
  })

  const span = row[1]
  let columns = row[0]

  if (separator) {
    columns = columns.map((cell) => insertSeparators(cell, separator))
  }

  // we need to un-bold columns that have combined with a rowLevelHeader column
  if (rowLevelHeaders && Array.isArray(columns[0]) && columns[0].length > 1) {
    const combinedItems = columns[0].splice(1).map((item, i, arr) => {
      const key = `0|2|${arr.length}|${i}`
      return <Fragment key={key}>{item}</Fragment>
    })
    columns[0].push(<span className={noBoldCss}>{combinedItems}</span>)
  }

  // UID added here for use in `key` props
  columns = columns.map((cell, idx) => {
    const key = `${idx}|${cell?.length || 0}`
    // cell[] needs key props for every item
    if (Array.isArray(cell))
      cell = cell.map((item, i) => {
        const cKey = `${key}|${i}`
        return <Fragment key={cKey}>{item}</Fragment>
      })
    return { cell, key }
  })

  // Linkable props will have to be applied around the contents of each cell to make any sense a11y wise
  const linkProps = { to, action, linkName }

  // don't let checkbox clicks fire the main click action
  const handleClick = (event) => {
    const interactiveElementFound = event.target.closest('button, input, textarea, [data-interactive]')
    if (!interactiveElementFound) {
      if (isUserExpandable) setRowExpanded((prev) => !prev)
      onClick?.(event)
    }
  }

  if (rowLevelHeaders && getPropsForCheckbox?.current) {
    throw new Error(`ResponsiveTable:: ResponsiveCheckBoxTable cannot have rowLevelHeaders.`)
  }

  // Determine if the children should show while hidden, before row is expanded, or if it has already been rendered
  const showChildren = rowTransitioning || rowExpanded || (keepVisible && hasChildrenDisplayedRef.current)

  const updateHeight = useCallback((entry) => {
    setExpandableContentHeight(entry.target.clientHeight)
    hasChildrenDisplayedRef.current = true
  }, [])

  useResizeObserver(showChildren && expandableContentRef, updateHeight)

  // The effective column count is the number of columns in the row at the current breakpoint plus any additional columns for expandable row buttons or checkboxes
  // This value should be accurate to the current number of columns in the row, or else the table will think it has more columns than it actually does and may split any remaining width values to non-existent columns
  let effectiveColumnCount = columns.length
  if (isUserExpandable || hasExpandableContent) effectiveColumnCount += 1
  if (!rowLevelHeaders && getPropsForCheckbox?.current) effectiveColumnCount += 1

  return (
    <>
      <tr
        {...sanitizeProps(props)}
        className={cx(rowCss, rowBaseCss, rowPaddingCss)}
        no-bottom-divider={boolAttr(hasChildren || noBottomDivider)}
        style={{ '--table-vertical-align': verticalAlign }}
        data-is-link={boolAttr(to)}
        interactable={boolAttr(onClick || to || isUserExpandable)}
        rowselected={boolAttr(selected)}
        onClick={handleClick}
      >
        {!rowLevelHeaders && getPropsForCheckbox?.current && (
          // We need to set width on the checkbox cell or else if the `rowLevelHeaders` prop is set, the table will split its remaining width with other columns that do not have a width set, which could potentially make the sizing of the checkbox cell inconsistent from when `rowLevelHeaders` is not set.
          <td style={{ width: checkboxCellWidth }}>
            {/* If the dev provides an explanation why a row is not selectable, render that info as an affordance. */}
            {typeof disabled === 'object' ? (
              <DisabledExplanation {...disabled} name={name} />
            ) : (
              <Checkbox {...getPropsForCheckbox.current({ name, disabled: Boolean(disabled) })} />
            )}
          </td>
        )}
        {columns.map(({ cell, key }, colIdx) => {
          const isHeaderCell = colIdx === 0 && rowLevelHeaders
          const Type = isHeaderCell ? 'th' : 'td'
          return (
            <Type
              key={key}
              scope={isHeaderCell ? 'row' : undefined}
              colSpan={span[colIdx]}
              style={{ width: columnWidths[colIdx] }}
            >
              {to ? <LinkWrapper {...linkProps}>{cell}</LinkWrapper> : cell}
            </Type>
          )
        })}
        {isUserExpandable ? (
          // We need to set width on the expander button cell or else if the `rowLevelHeaders` prop is set, the table will split its remaining width with other columns that do not have a width set, which could potentially make the sizing of the expander button cell inconsistent from when `rowLevelHeaders` is not set.
          <td style={{ width: expanderButtonCellWidth }} className={expandRowButtonCellCss}>
            <IconButton
              color="gray"
              Icon={ArrowCaret}
              iconDirection={rowExpanded ? 'up' : 'down'}
              onClick={() => setRowExpanded((prev) => !prev)}
              title={
                rowExpanded
                  ? t('common-ui:button.collapse.action', 'Click to collapse this section')
                  : t('common-ui:button.expand.action', 'Click to expand this section')
              }
            />
          </td>
        ) : (
          hasExpandableContent && <td />
        )}
      </tr>
      {hasChildren && (
        <tr
          role="row"
          aria-hidden={!showChildren}
          className={cx(rowBaseCss, rowCss, expandableRowCss)}
          rowselected={boolAttr(selected)}
        >
          <ExpandedCell colSpan={effectiveColumnCount} rowLevelHeaders={rowLevelHeaders} expanded={showChildren}>
            <animated.div style={styles}>
              <div className={expandableContentCss} ref={expandableContentRef}>
                {showChildren && children}
              </div>
            </animated.div>
          </ExpandedCell>
        </tr>
      )}
    </>
  )
}

function ExpandedCell({ rowLevelHeaders, expanded, ...props }) {
  const Type = rowLevelHeaders ? 'th' : 'td'

  // th's can never be empty. So if we are a th, then we need to make sure we
  // don't render ourselves when closed
  if (rowLevelHeaders && !expanded) return null

  // Putting in the normal font weight because we don't want content to be bolded in this context
  return <Type scope={rowLevelHeaders ? 'row' : undefined} {...props} style={{ fontWeight: 'normal' }} />
}

export const ControlledResponsiveTableRow = memo(ControlledResponsiveTableRowComponent)

const UncontrolledResponsiveTableRow = ({
  initiallyExpanded = false,
  explainWhyDisabled,
  onExpandToggle = () => {},
  ...props // column* can more easily be grepped in an object
}) => {
  const [rowExpanded, setRowExpanded] = useState(initiallyExpanded)
  const handleExpandToggle = useEvent(onExpandToggle)
  useEffect(() => handleExpandToggle(rowExpanded), [rowExpanded, handleExpandToggle])
  return (
    <ControlledResponsiveTableRowComponent
      showExpansionControl
      rowExpanded={rowExpanded}
      setRowExpanded={setRowExpanded}
      initiallyExpanded={initiallyExpanded}
      {...props}
    />
  )
}

export const ResponsiveTableRow = memo(UncontrolledResponsiveTableRow)

ResponsiveTableRow.propTypes = {
  children: PropTypes.node,

  /** The content of each column in the row. The number represents the respective slot it will take up. A row may take up to 12 columns. */
  'column1 column2 ... column12': PropTypes.node,

  /** The span of each column in the row. The number represents the respective slot that will span multiple columns. */
  'column1span column2span ... column12span': PropTypes.number,

  /** The callback when the row is clicked on */
  onClick: PropTypes.func,

  /** Specify how cell contents are aligned. Prefer applying this prop to the ResponsiveTable component unless you need to override.  */
  verticalAlign: PropTypes.oneOf(['top', 'middle', 'bottom']),

  /** The name of the row when selected in `ResponsiveCheckboxTable` */
  name: PropTypes.string,

  /** When inside a `ResponsiveCheckboxTable`, mark the checkbox as disabled. Provide an object to display a tooltip affordance that explains to the user why the row selection is disabled. */
  disabled: PropTypes.oneOfType([
    PropTypes.bool,
    PropTypes.shape({
      reason: PropTypes.string,
      Icon: PropTypes.elementType,
    }),
  ]),

  /** Show this item as selected */
  selected: PropTypes.bool,

  /** If you want multiple consecutive rows to appear as if they are part of one row, turn off the borders between them. */
  noBottomDivider: PropTypes.bool,

  /** Callback for when the row is expanded/collapsed. One parameter is passed: a boolean for whether it is expanded (`true`) or collapsed (`false`) */
  onExpandToggle: PropTypes.func,

  /** If you want the children of this row to be expanded by default set this to true */
  initiallyExpanded: PropTypes.bool,
}
