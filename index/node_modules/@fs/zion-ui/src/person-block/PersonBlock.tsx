import React, { useState, useCallback } from 'react'
import type { InferProps } from 'prop-types'
import PropTypes from 'prop-types'
import { css } from '@linaria/core'
import { boolAttr, sanitizeProps } from '@fs/zion-frontend-friends'
import Avatar, { MultiAvatar } from '../avatar'
import type { MultiAvatarProps } from '../avatar/MultiAvatar'
import { Overline, Subheading } from '../typography'
import { GenericHeading } from '../typography/Headings'
import type { HeadingLevel } from '../typography/Headings'
import { Row, Grid, Cell, Paragraph, Ellipsis } from '..'
import type { BaseButtonProps } from '../buttons/types'
import Affordance from '../affordance/AffordableAffordance'

type TShirtSizes = 'xs' | 'sm' | 'md' | 'lg' | 'xl'

const avatarPropTypes = PropTypes.shape({
  /** The url for the person's portrait. */
  src: PropTypes.string,

  /** The monogram displayed on the avatar when no image is available. */
  monogram: PropTypes.string,

  /** Online chat presence */
  presence: PropTypes.oneOf(['online', 'offline'] as const),

  /** The sex of the person's information being displayed. */
  sex: PropTypes.oneOf(['male', 'female', 'unknown'] as const),

  /** callback for if image fails to load */
  imageFailedCallback: PropTypes.func,

  /**
   * Set to true if you want the avatar to be gray. This is helpful when you
   * want sex specific gray avatars.
   */
  gray: PropTypes.bool,
})

const propTypes = {
  /**
   * Monogram used for CJK names. Displays vertically and shows up to nine characters.
   * Used for a centered PersonBlock when there is no avatar image or the image failed to load.
   */
  cjkMonogram: PropTypes.string,

  /** Locale of the CJK name being shown in the monogram. Used for screen readers and fonts. */
  cjkMonogramLang: PropTypes.string,

  /** The name of the person. */
  name: PropTypes.oneOfType([PropTypes.string, PropTypes.element]).isRequired,

  /**
   * The text to display below the person's name. It is recommended
   * that you limit JSX in here, so as to keep consistency.
   */
  details: PropTypes.node,

  /** The size of the component. */
  size: PropTypes.oneOf(['xl', 'lg', 'md', 'sm'] as const),

  /** The optional overline text passed in (i.e. relationship) */
  overline: PropTypes.string,

  /** If true, the component will center all of its content. */
  centered: PropTypes.bool,

  /**
   * Increment/Decrement the size of the avatar. Actual avatar size change depends on the
   * size prop. Some size values result in no change.
   */
  avatarSize: PropTypes.oneOf(['smaller', 'default', 'bigger'] as const),

  /**
   * Props passed to the Avatar component.
   * (note that avatars are aria-hidden, so no additional props are needed)
   */
  avatarProps: avatarPropTypes,

  /**
   * Props passed to the MultiAvatar component, if needed.
   * (note that avatars are aria-hidden, so no additional props are needed)
   */
  multiAvatarProps: PropTypes.shape({
    /** The url for the person's portrait. */
    size: PropTypes.string,

    /** Options for the first avatar */
    avatar1: avatarPropTypes.isRequired,

    /** Options for the second avatar */
    avatar2: avatarPropTypes.isRequired,
  }),

  /**
   * **AVATAR IS MANDATORY!**
   *
   * Unless youâ€™re using PersonBlock in a Tree Pedigree view or Descendency view,
   * etc., where the tree-shape of the experience provides context. Do not use this
   * property anywhere else on FamilySearch.
   */
  noAvatar: PropTypes.bool,

  /**
   * Add custom props to the name element. This is where you would pass in properties
   * like `{ as: 'h2' }` to change the tag for the name.
   */
  nameProps: PropTypes.object,

  /** Make the name part of the PersonBlock not bold */
  noBold: PropTypes.bool,

  /** Dense mode: Normally when you add a `to` or `onclick`, more padding is added for hover zone.
   *  Dense mode allows you to tuck that padding away in tight spaces.
   *
   * **NOTICE** This property doesn't do anything if `to` or `onclick` are not provided. */
  dense: PropTypes.bool,

  /** If true, the PersonBlock will be inline, which switches it to a DataBlock */
  inline: PropTypes.bool,
}

type PersonBlockBaseProps = InferProps<typeof propTypes>
type PersonBlockProps = Omit<
  Omit<BaseButtonProps, keyof PersonBlockBaseProps> & PersonBlockBaseProps,
  'children' | 'className'
>

type SizeOptions = {
  default: TShirtSizes
  bigger?: TShirtSizes
  smaller?: TShirtSizes
}

type SizeMapProps = Partial<
  Record<
    TShirtSizes,
    {
      gutters: TShirtSizes | 'xxs'
      avatar: SizeOptions
      centeredAvatar?: SizeOptions
      size: HeadingLevel
      shyable?: boolean // Because sometimes a PersonBlock wants to not be bold
    }
  >
>

const cjkMonogramCss = css`
  text-align: start;
  writing-mode: vertical-rl;
  height: 8ch;
  line-height: 1.15;
  &[data-serif] {
    padding-right: 0.5em; /* Noto-Serif has an alighment issue */
  }
`

/**
 * `avatar` and `centeredAvatar` define the following properties:
 * - size: the default size for the avatar (required)
 * - smaller: if the avatar can go one step smaller from the default size
 * - bigger: if the avatar can go one step bigger from the default size
 */
export const sizeMap: SizeMapProps = {
  xl: {
    avatar: { default: 'lg', smaller: 'md', bigger: 'xl' },
    size: 'H4',
    gutters: 'xs',
  },
  lg: {
    avatar: { default: 'md', smaller: 'sm', bigger: 'lg' },
    centeredAvatar: { default: 'lg', smaller: 'md', bigger: 'xl' },
    size: 'H5',
    gutters: 'xs',
    shyable: true,
  },
  md: {
    avatar: { default: 'md', smaller: 'sm' },
    centeredAvatar: { default: 'md', smaller: 'sm', bigger: 'lg' },
    size: 'H6',
    gutters: 'xxs',
    shyable: true,
  },
  sm: {
    avatar: { default: 'sm', smaller: 'xs' },
    centeredAvatar: { default: 'md', smaller: 'sm' },
    size: 'H6',
    gutters: 'xxs',
    shyable: true,
  },
}

export function computeAvatarSize(
  size: TShirtSizes,
  centered: boolean,
  adjustment: keyof SizeOptions = 'default'
): TShirtSizes {
  const { avatar, centeredAvatar } = sizeMap[size]
  const sizeProps = centered && centeredAvatar ? centeredAvatar : avatar
  return sizeProps[adjustment] || sizeProps.default
}

const centeredCss = css`
  margin: 0 auto;
  width: fit-content;
`

const PersonBlockBase = ({
  avatarProps,
  avatarSize: avatarSizeAdjustment = 'default',
  centered = false,
  cjkMonogram,
  cjkMonogramLang,
  details,
  multiAvatarProps,
  name,
  nameProps,
  noAvatar = false,
  overline,
  size: blockSize = 'lg',
  noBold = false,
  inline = false,
  ...props
}: PersonBlockBaseProps): JSX.Element => {
  // const blockRef = useRef()
  // const [additionalBottomPadding, setAdditionalBottomPadding] = useState(0)
  const [imageFailed, setImageFailed] = useState(false)
  const { size, gutters, shyable } = sizeMap[blockSize]
  const avatarSize = inline
    ? computeAvatarSize('sm', false, avatarSizeAdjustment)
    : computeAvatarSize(blockSize, centered, avatarSizeAdjustment)

  const handleImageFailed = useCallback(() => {
    setImageFailed(true)
    avatarProps?.imageFailedCallback?.()
  }, [avatarProps])

  // If we're showing the cjk monogram, we don't want to show the name in bold below it again.
  // The secondary nameform will be shown in the details.
  const showCjkMonogram = (imageFailed || !avatarProps?.src) && cjkMonogram && centered
  const nameContent = showCjkMonogram ? (
    <span className={cjkMonogramCss} lang={cjkMonogramLang} data-serif={boolAttr(blockSize === 'xl')}>
      {cjkMonogram}
    </span>
  ) : (
    name
  )

  let avatarContent = null
  if (!noAvatar && !showCjkMonogram) {
    avatarContent = multiAvatarProps ? (
      <MultiAvatar {...(multiAvatarProps as MultiAvatarProps)} size={avatarSize} />
    ) : (
      <Avatar {...avatarProps} imageFailedCallback={handleImageFailed} size={avatarSize} />
    )
  }

  const textContent = (
    <GenericHeading centered={centered} size={size} as="div" supplementary={noBold && shyable} {...nameProps}>
      {overline ? <Overline>{overline}</Overline> : null}
      {nameContent}
      {details ? <Subheading>{details}</Subheading> : null}
    </GenericHeading>
  )

  if (centered)
    return (
      <Grid {...sanitizeProps(props)} gutters="nano">
        {!!avatarContent && <div className={centeredCss}>{avatarContent}</div>}
        {textContent}
      </Grid>
    )

  if (inline)
    return (
      <Row gutters="xxs" {...sanitizeProps(props)}>
        <Cell noShrinkX>{avatarContent}</Cell>
        <Cell alignY="middle">
          {overline ? (
            <Paragraph secondary size="xs">
              {overline}
            </Paragraph>
          ) : null}
          <Row gutters="nano" alignY="middle">
            <GenericHeading size="H6" as="div" supplementary={noBold && shyable} data-full-width>
              <Ellipsis>{name}</Ellipsis>
            </GenericHeading>
            {details ? (
              <Paragraph noShrinkX secondary size="xs" alignY="middle">
                {details}
              </Paragraph>
            ) : null}
          </Row>
        </Cell>
      </Row>
    )

  return (
    <Row gutters={gutters} {...sanitizeProps(props)}>
      <Cell noShrinkX>{avatarContent}</Cell>
      <Cell alignY="middle">{textContent}</Cell>
    </Row>
  )
}

export default function PersonBlock({
  to,
  linkName,
  onClick,
  disabled,
  dense = false,
  debounce,
  ...props
}: PersonBlockProps): JSX.Element {
  if (to || onClick) {
    const affordanceProps = { to, linkName, onClick, disabled, debounce, dense }
    return (
      <Affordance margin="xxs" {...affordanceProps}>
        <PersonBlockBase {...props} />
      </Affordance>
    )
  }
  return <PersonBlockBase {...props} />
}

PersonBlock.propTypes = propTypes
