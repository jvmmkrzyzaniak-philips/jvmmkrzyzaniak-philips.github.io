import React, { useContext, useEffect } from 'react'
import PropTypes from 'prop-types'
import { focusableSelectors, useEvent } from '@fs/zion-frontend-friends'
import { PortalContext } from '../portal'
import { useFocusManagerContext } from './FocusManagerProvider'
import isVisible from './isVisible'

const focusableSelectorsArray = (container) => {
  return Array.from(container.querySelectorAll(focusableSelectors))
}

// filter out any elements that are not visible
export const getFocusableChildren = (container) => focusableSelectorsArray(container).filter(isVisible)

// returns true if any focusable element is visible
const hasFocusableChildren = (container) => focusableSelectorsArray(container).some(isVisible)

const getTabbableItem = (focusableElements, lastIsWanted = false) => {
  if (!focusableElements.length) return undefined
  const firstOrLast = focusableElements[lastIsWanted ? focusableElements.length - 1 : 0]
  if (firstOrLast.type !== 'radio' || firstOrLast.checked) return firstOrLast
  const radioName = firstOrLast.name
  const otherRadiosInGroup = focusableElements.filter((item) => item.type === 'radio' && item.name === radioName)
  return (
    otherRadiosInGroup.find((item) => item.checked || item === document.activeElement) ||
    otherRadiosInGroup[lastIsWanted ? otherRadiosInGroup.length - 1 : 0]
  )
}

export const getFirstTabbableItem = (elements) => getTabbableItem(elements, false)
const getLastTabbableItem = (elements) => getTabbableItem(elements, true)

const getIsOnTopOfStack = (stack, container) => {
  if (!stack || !container) {
    return false
  }
  const lastIndex = stack.length - 1
  if (lastIndex >= 0 && lastIndex === stack.indexOf(container)) {
    return true
  }
  return false
}

/**
 * useFocusManager is the customizable version of `useFocusLock` and is intended to be used on overlays to determine where focus should end up when certain focus conditions are met. The conditions are:
 *
 * - A user hits the tab key while focused on the last element in an overlay,
 * - A user hits shift+tab while focused on the first element in an overlay,
 * - Something is focused outside of the overlay (via click or programmatic focusing)
 *
 * At the fulfillment of one of these conditions, `useFocusManager` will run the `handler` function and provide it with information regarding which condition caused it to run. The consumer of this component can then use that information to determine the correct focus behavior.
 *
 * As a courtesy to `useFocusLock`, the `handler` will also receive the next focusable element in the containerRef as if the containerRef was it's own document (i.e. tabbing on the last focusable element will cycle back to the first focusable element and shift+tabbing on the first will cycle to the last), or it will receive the currently focused element if an element outisde of the container is about to be focused.
 */
export default function useFocusManager({ enabled, containerRef, originatorRef, handler }) {
  const portalDiv = useContext(PortalContext)
  const container = containerRef?.current || portalDiv // if no container is passed, use the portal div

  const {
    removeFromStack,
    addToStack,
    state: { stack },
  } = useFocusManagerContext()

  // Runs if tabbing out of the container
  const onKeyDown = useEvent((event) => {
    const { target, code, shiftKey } = event
    if (code === 'Tab') {
      const focusableElements = getFocusableChildren(container)
      const firstElement = getFirstTabbableItem(focusableElements)
      const lastElement = getLastTabbableItem(focusableElements)

      if (target === lastElement && !shiftKey) {
        event.preventDefault()
        handler(firstElement, 'forward')
      } else if (target === firstElement && shiftKey) {
        event.preventDefault()
        handler(lastElement, 'backward')
      }
    }
  })

  // Runs if an element outside the container is about to be focused
  const onFocusIn = useEvent((event) => {
    const { target, relatedTarget } = event

    // prevents the handler from running if the target is inside the container or if the target is the originatorRef
    if (container.contains(target) || target.closest('[aria-modal="false"]') || target === originatorRef?.current) {
      return
    }

    // gets the currently-focused element or the first focusable element
    const focusableChild = relatedTarget?.focus ? relatedTarget : getFirstTabbableItem(getFocusableChildren(container))

    handler(focusableChild, null)
  })

  useEffect(() => {
    if (!enabled) return () => {}

    if (hasFocusableChildren(container)) {
      // remove portalDiv from stack when containerRef.current becomes available
      if (container !== portalDiv) removeFromStack(portalDiv)

      addToStack(container)
    } else {
      removeFromStack(container)
    }

    if (!getIsOnTopOfStack(stack, container)) return () => {}

    container.addEventListener('keydown', onKeyDown)
    document.addEventListener('focusin', onFocusIn)

    return () => {
      container.removeEventListener('keydown', onKeyDown)
      document.removeEventListener('focusin', onFocusIn)
    }
  }, [addToStack, container, enabled, onFocusIn, onKeyDown, portalDiv, removeFromStack, stack])
}

export const HookConfigOptions = (props) => <div {...props} />

const DomElement = typeof Element === 'undefined' ? () => {} : Element

HookConfigOptions.propTypes = {
  /** If true, then focus-manager be enabled. */
  enabled: PropTypes.bool,

  /** Ref to the container that focus-manager will target. */
  containerRef: PropTypes.oneOfType([
    // Either a function
    PropTypes.func,
    // Or the instance of a DOM native element
    PropTypes.shape({ current: PropTypes.instanceOf(DomElement) }),
  ]),

  /** Ref to the element that opened the container. The handler will not run when this element is focused. */
  originatorRef: PropTypes.oneOfType([
    // Either a function
    PropTypes.func,
    // Or the instance of a DOM native element
    PropTypes.shape({ current: PropTypes.instanceOf(DomElement) }),
  ]),

  /** Function that runs when one of the following conditions are met:
   * - A user hits the tab key and the item focused at the time is the last focusable element in the containerRef
   * - A user hits shift+tab and the item focused at the time is the first focusable element in the containerRef
   * - An element that was outside of the containerRef is about to receive focus
   *
   * @param nextElement A focusable element inside the containerRef. If focus is about to escape by tabbing, then this is the first element. If it is about to escape by shift+tabbing, this is the last element. If it is about to escape by focusing another element, this is the currently-focused element or the first element if there is no currently-focused element.
   * @param {Object} options An object that describes what caused the handler to run
   * @param {string} options.type "tab" if focus out was caused by tabbing, or "focus" if it was caused by an element outside of the container receiving focus
   * @param {string} options.shifting True if tabbing out was caused by shift+tabbing
   */
  handler: PropTypes.func,
}
