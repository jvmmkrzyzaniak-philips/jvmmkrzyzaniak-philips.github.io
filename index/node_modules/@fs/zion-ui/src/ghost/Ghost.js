import React, { useCallback, useState, useEffect, useMemo, forwardRef } from 'react'
import PropTypes from 'prop-types'
import { useObserver, useForwardRef } from '@fs/zion-frontend-friends'
import { css, cx } from '@linaria/core'

/** The containing divs for Ghost need to allow flexible sizing. */
const sizeInheritCss = css`
  display: inherit !important; /* There are some cases where Grid-like components will try to give this display: none, but we don't want that */
  flex-direction: inherit;
  flex-grow: inherit;
  flex-shrink: inherit;
`
export function Ghost(
  { widthEstimate, heightEstimate, keepVisible, children, className, style, as: TagName = 'div', ...props },
  ref
) {
  const ghostRef = useForwardRef(ref)
  const [visible, setVisible] = useState(false)
  const [actualHeight, setActualHeight] = useState(heightEstimate)
  const [actualWidth, setActualWidth] = useState(widthEstimate)

  const intersectCallback = useCallback(
    (entry) => setVisible((previouslyVisible) => entry.isIntersecting || (previouslyVisible && keepVisible)),
    [keepVisible]
  )

  const resizeCallback = useCallback(() => {
    // Resize when resized. aka whatDoFat
    const { height, width } = ghostRef.current?.getBoundingClientRect() || {}
    setActualHeight((previousHeight) => height || previousHeight)
    setActualWidth((previousWidth) => width || previousWidth)
  }, [ghostRef])

  useEffect(() => {
    // Measure height when scrolled into view
    if (visible) {
      resizeCallback()
    }
  }, [resizeCallback, visible])

  useEffect(() => {
    setActualHeight(heightEstimate)
    setActualWidth(widthEstimate)
  }, [heightEstimate, widthEstimate])

  const styles = useMemo(
    () => ({
      ...style,
      height: visible ? undefined : actualHeight,
      width: visible ? undefined : actualWidth,
      flexShrink: visible ? undefined : 0,
    }),
    [actualHeight, actualWidth, style, visible]
  )

  useObserver(ghostRef, intersectCallback, resizeCallback)
  return (
    <TagName ref={ghostRef} className={cx(sizeInheritCss, className)} style={styles} {...props}>
      {visible ? children : null}
    </TagName>
  )
}

export default forwardRef(Ghost)

Ghost.propTypes = {
  /** The height estimate for the area the Ghost is representing */
  heightEstimate: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,

  /** The width estimate for the area the Ghost is representing */
  widthEstimate: PropTypes.number,

  /** Forces a previously visible Ghosts contents to stay in memory to avoid being loaded again. */
  keepVisible: PropTypes.bool,

  /** Content to go inside the Ghost. */
  children: PropTypes.node.isRequired,

  /**
   * <p><strong>Add any desired custom-css here.</strong></p>
   * <p>NOTE: Should be background-only rules, maybe some borders.</p>
   */
  className: PropTypes.string,

  /** The CSS */
  style: PropTypes.shape({ height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]) }),

  /** Semantically render as something else. This should be something simple as Ghost represents empty space. */
  as: PropTypes.elementType,
}
