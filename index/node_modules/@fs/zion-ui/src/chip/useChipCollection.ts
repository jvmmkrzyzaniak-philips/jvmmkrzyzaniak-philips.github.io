import { useCallback, useReducer, useRef, useMemo } from 'react'
import type PropTypes from 'prop-types'
import _debounce from 'lodash.debounce'
import { shallowEqual } from '@fs/zion-frontend-friends'
import type { propTypes as inputChipPropTypes } from './InputChip'

type Chip = PropTypes.InferProps<typeof inputChipPropTypes>
type ChipCollection = {
  addChip: (chips: Chip | Chip[]) => void
  chips: Chip[]
  debounce: number
  lastTouched: Chip | null
  removeChip: (chips: Chip | Chip[]) => void
  resetChips: (newChips?: Chip[]) => void
  selectChip: (chips: Chip | Chip[]) => void
  selectedChips: Chip[]
}

type State = {
  chips: Chip[]
  defaultChips?: Chip[]
  lastTouched?: Chip
}

type AddAction = {
  type: 'add'
  data: Chip
}

type RemoveAction = {
  type: 'remove'
  data: Chip
}
type SelectAction = {
  type: 'select'
  data: Chip
}

type ResetAction = {
  type: 'reset'
  data?: Chip[]
}

type Action = AddAction | RemoveAction | SelectAction | ResetAction

export const defaultState: State = { chips: [], defaultChips: [], lastTouched: null }

const includesChip = (chips: Chip[], value: string): boolean => chips.some((c) => c.value === value)

export const reducer = (state = defaultState, action: Action): State => {
  if (!action) return state

  const { type, data } = action
  const { chips, defaultChips } = state

  const value = Array.isArray(data) ? '' : data?.value?.trim()

  switch (type) {
    case 'add': {
      if (includesChip(chips, value)) return state
      const chip = { ...data, value }
      return { ...state, chips: [chip, ...chips] }
    }

    case 'remove': {
      if (!includesChip(chips, value)) return state
      return { ...state, chips: chips.filter((chip) => chip.value !== value) }
    }

    case 'select': {
      if (!includesChip(chips, value)) return state

      let lastTouched
      const newState = {
        ...state,
        chips: chips.map((chip) => {
          const { value: chipValue, selected } = chip
          if (value !== chipValue) return chip
          lastTouched = { ...chip, selected: !selected }
          return lastTouched
        }),
        lastTouched,
      }
      return newState
    }

    case 'reset': {
      const newChips = ensureIsArray(data) || defaultChips
      if (newChips.length === chips.length && chips.every((chip, index) => shallowEqual(chip, newChips[index])))
        return state
      return { ...state, chips: ensureIsArray(data) || defaultChips, lastTouched: null }
    }

    default: {
      // we are doing an exhaustive check to make sure we don't miss a case
      const exhaustiveCheck: never = action
      throw new Error(`Unsupported Action: ${JSON.stringify(exhaustiveCheck)}`)
    }
  }
}

function ensureIsArray<T>(item: T): T[] {
  if (!item) return []
  return Array.isArray(item) ? item : [item]
}

export default function useChipCollection(defaultChips: Chip[] = [], debounce = 200): ChipCollection {
  const [{ chips, lastTouched }, dispatch] = useReducer(reducer, {
    chips: defaultChips,
    defaultChips,
    lastTouched: null,
  })

  const resetChips = useCallback((newChips) => dispatch({ type: 'reset', data: newChips }), [dispatch])
  const addChip = useCallback(
    (targetChips) => ensureIsArray(targetChips).forEach((chip) => dispatch({ type: 'add', data: chip })),
    [dispatch]
  )
  const removeChip = useCallback(
    (targetChips) => ensureIsArray(targetChips).forEach((chip) => dispatch({ type: 'remove', data: chip })),
    [dispatch]
  )

  const unDebouncedSelectChip = useCallback(
    (targetChips) => ensureIsArray(targetChips).forEach((chip) => dispatch({ type: 'select', data: chip })),
    [dispatch]
  )

  // Must use a ref here to keep the debounced function working correctly
  const selectChip = useRef(_debounce(unDebouncedSelectChip, debounce, { leading: true, trailing: false })).current

  const selectedChips = useMemo(() => chips.filter((c) => c.selected), [chips])

  return {
    chips,
    resetChips,
    addChip,
    removeChip,
    selectChip,
    selectedChips,
    lastTouched,
    debounce,
  }
}
