import React, { useState, useEffect, useCallback, useRef } from 'react'
import PropTypes from 'prop-types'
import { useTranslation } from 'react-i18next'
import { css } from '@linaria/core'
import { ArrowCaret } from '@fs/zion-icon'
import { sanitizeProps, useRandomId, useResizeObserver } from '@fs/zion-frontend-friends'
import { IconButton } from '../buttons/icon-button'
import TextField from '../text-field'
import { Paragraph } from '../typography'
import { inputBaseCss } from '../input-base/InputBase'
import Row from '../row'

const thinganatorCss = css`
  .${inputBaseCss} {
    margin-bottom: 0;
  }
`

function updateWidth(textField) {
  if (!textField) return

  function resize(padding = 0) {
    textField.style.width = '0'
    textField.style.width = `${textField.scrollWidth + padding}px`
  }

  // In Safari, scrollWidth does not include padding.
  // offsetWidth is only larger than scrollWidth in browsers that don't include the padding.
  if (textField.scrollWidth < textField.offsetWidth) {
    const textFieldStyle = getComputedStyle(textField)
    const computedPadding =
      Number.parseInt(textFieldStyle.paddingInlineStart, 10) + Number.parseInt(textFieldStyle.paddingInlineEnd, 10)
    resize(computedPadding)
  } else {
    resize()
  }
}

const Thinganator = ({ hideArrows, noTextField, label, length, index = 0, setIndex, nextTo, prevTo, ...props }) => {
  const { t } = useTranslation()

  const [displayIndex, setDisplayIndex] = useState(index + 1)
  const textFieldRef = useRef()

  useEffect(() => {
    setDisplayIndex(index + 1)
  }, [index])

  // When the contents of the text field get really wide, resize the input to match
  useEffect(() => {
    updateWidth(textFieldRef.current)
  }, [displayIndex])

  /* User clicked "previous" button */
  const onPrevPage = useCallback(() => {
    const newIndex = Math.max(index - 1, 0)
    setIndex(newIndex)
  }, [index, setIndex])

  /* User clicked "next" button */
  const onNextPage = useCallback(() => {
    const newIndex = Math.min(index + 1, length - 1)
    setIndex(newIndex)
  }, [index, setIndex, length])

  /* User tried to change page number */
  const onChangeIndex = useCallback(
    ({ target }) => {
      if (!target) return

      // Calculate a new offset based the page number they entered.
      const newIndex = parseInt(target.value, 10) - 1

      // Do some validation
      if (newIndex < 0 || newIndex > length - 1 || Number.isNaN(newIndex)) {
        setDisplayIndex(index + 1)
        return
      }

      // only send event if offset (page) actually changed
      if (newIndex !== index) {
        setIndex(newIndex)
      }
    },
    [index, setIndex, length]
  )

  const resizeCallback = useCallback(() => {
    updateWidth(textFieldRef.current)
  }, [])

  useResizeObserver(textFieldRef, resizeCallback)

  const validateInput = (input) => {
    // Accept integers only
    const text = input.replace(/[^0-9]/g, '')
    return Number(text)
  }

  const handleOnChange = (e) => {
    const inputValue = validateInput(e.target.value)
    if (inputValue < 0 || inputValue > length) return
    setDisplayIndex(inputValue)
  }

  const id = useRandomId()

  if (!length) return null

  const remainingText = t('zion.paginator.pageInfo', 'of {pages, number}', {
    pages: length,
    number: index + 1,
  })

  return (
    <Row className={thinganatorCss} alignY="middle" gutters="xxs" {...sanitizeProps(props)}>
      {!hideArrows && (
        <IconButton
          title={t(
            'zion.paginator.prevPage',
            `Go to previous {label}. Currently on {label} {displayIndex} of {length}`,
            {
              label,
              displayIndex,
              length,
            }
          )}
          disabled={index === 0}
          Icon={ArrowCaret}
          iconDirection="backward"
          onClick={onPrevPage}
          debounce={0}
          to={prevTo}
        />
      )}
      {noTextField ? (
        <Paragraph size="xs">
          {label} {displayIndex} {remainingText}
        </Paragraph>
      ) : (
        // Using array notation instead of a fragment keeps each of these items as their own individual Cell in the Row
        [
          <Paragraph size="sm" id={id} key="data2-label">
            {label}
          </Paragraph>,
          <TextField
            key="text-field"
            aria-label={t('zion.paginator.changePage', `Enter {label} number`, { label })}
            aria-describedby={id}
            pageNumber
            onEnterKey={onChangeIndex}
            onBlur={onChangeIndex}
            onChange={handleOnChange}
            value={displayIndex}
            type="text"
            ref={textFieldRef}
          />,
          <Paragraph size="sm" key="data2-remainingText">
            {remainingText}
          </Paragraph>,
        ]
      )}
      {!hideArrows && (
        <IconButton
          title={t('zion.paginator.nextPage', `Go to next {label}. Currently on {label} {displayIndex} of {length}`, {
            label,
            displayIndex,
            length,
          })}
          disabled={index >= length - 1}
          Icon={ArrowCaret}
          iconDirection="forward"
          onClick={onNextPage}
          debounce={0}
          to={nextTo}
        />
      )}
    </Row>
  )
}

export default Thinganator

Thinganator.propTypes = {
  /** Make the left and right arrows hidden */
  hideArrows: PropTypes.bool,

  /** Replace the numeric input with a simple text number to prevent arbitrary jumps and to simplify the user interface. */
  noTextField: PropTypes.bool,

  /** Translated string for the first word in the label 'Page # of #' */
  label: PropTypes.string.isRequired,

  /** total number of items in the list */
  length: PropTypes.number.isRequired,

  /** zero-based index of first result, defaults to 0 */
  index: PropTypes.number,

  /** function used to set the index */
  setIndex: PropTypes.func.isRequired,

  /** Link for the "to" prop of the next icon button. This allows crawlers to browse through multiple pages. */
  nextTo: PropTypes.string,

  /** Link for the "to" prop of the previous icon button. This allows crawlers to browse through multiple pages. */
  prevTo: PropTypes.string,
}
