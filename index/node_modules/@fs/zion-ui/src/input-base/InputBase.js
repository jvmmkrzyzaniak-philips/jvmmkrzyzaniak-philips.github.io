import React, { useState, useContext, useMemo, useEffect } from 'react'
import { css, cx } from '@linaria/core'
import PropTypes from 'prop-types'
import { ContentCheck, NoticeWarning, NoticeImportant } from '@fs/zion-icon'
import { useRandomId, boolAttr } from '@fs/zion-frontend-friends'
import { formatValue } from '@fs/zion-locale'
import { useTranslation } from 'react-i18next'
import InputLabel from '../input-label'
import { Paragraph } from '../typography'
import { colors } from '../theme'
import FeedbackText from '../feedback-text'
import useKeyboardShortcuts from '../use-keyboard-shortcuts'
import { WhiteThemeContext } from '../theme/white-theme'

export const inputBaseCss = css`
  --icon-inline-text: 0;
  margin-bottom: 16px;
  position: relative;
  max-width: 80ch;

  /* color label text */
  [data-status='none'] &:focus-within label > p {
    color: ${colors.blue30};
  }

  &[data-dense] {
    margin-bottom: 0;
  }

  &[data-full-width] {
    max-width: 100%;
  }

  /* only show characters remaining if the user is focused on the field */
  & [level='dynamic'] {
    display: none;
  }
  &:focus-within [level='dynamic'] {
    display: block;
  }
`

// We export this className, so additional styling can be added on other components, like TextInput and Select
export const childrenContainerCss = css`
  border-radius: 4px;
  border: solid 1px ${colors.gray100};
  background: ${colors.gray00};
  cursor: text;
  padding: 1px; /* Necessary for when focus styling makes border 2px */
  position: relative; /* Helpful for absolute positioning on Select */

  [data-status='valid'] & {
    border-color: ${colors.green50};
  }
  [data-status='warning'] & {
    border-color: ${colors.yellow50};
  }
  [data-status='error'] & {
    border-color: ${colors.danger50};
  }
  [data-status='none'] &:focus-within,
  [data-status='help'] & {
    border-color: ${colors.blue50};
  }

  [data-billboard] & {
    padding: 12px 8px;
  }

  [iswhite] & {
    border-color: ${colors.gray100};
    background-color: ${colors.gray10};
    backdrop-filter: blur(20px);
    -webkit-text-fill-color: ${colors.gray100};
    :focus-within {
      border-color: ${colors.gray50};
    }
    &[isdisabled] {
      border-color: ${colors.transparent.gray02};
      background: ${colors.gray02};
    }
  }

  &[autowidth] {
    width: fit-content;
  }

  /* Disabled styling - applied separately rather than on :disabled since it applies to the container, not the input */
  &[isdisabled] {
    background: ${colors.gray05};
    -webkit-text-fill-color: ${colors.gray40} !important;
    -webkit-text-fill-color: ${colors.gray02};
    cursor: not-allowed;
  }

  /* Focus styling: remove the extra padding and use it for the border instead */
  &:focus-within {
    border-width: 2px;
    padding: 0;

    [data-billboard] & {
      padding: 11px 7px;
    }
  }

  /* Workaround for !important in browser autofill styling: https://css-tricks.com/snippets/css/change-autocomplete-styles-webkit-browsers/ */
  *:-webkit-autofill,
  *:-webkit-autofill:hover,
  *:-webkit-autofill:focus {
    -webkit-text-fill-color: ${colors.gray100};
    box-shadow: 0 0 0px 1000px ${colors.blue02} inset;
    transition: background-color 5000s ease-in-out 0s;
  }
`

const childrenCss = css`
  display: flex;
  align-items: center;
  border-radius: 2px;
`

// helpMessage styling
const messageCss = css`
  color: var(--special-type-color, ${colors.transparent.gray70});
  align-items: center;
  display: flex;
  margin-top: 4px;
  [iswhite] & {
    margin-top: 6px;
  }
`

// Wraps around the status icon before the helpMessage
const statusIconContainer = css`
  margin-top: -2px;
  padding-inline-end: 8px;
`

const messageTextCss = css`
  flex-grow: 1;
  // Clearfix Hack for maxLengthCss. https://css-tricks.com/snippets/css/clear-fix/
  &::after {
    content: '';
    clear: both;
    display: table;
  }
`

const maxLengthCss = css`
  margin: 0;
  margin-bottom: -4px; // we use a negative margin here to help the 2nd line of feedback text to wrap full-width.
  margin-inline-start: 20px;
  float: right;
`

export const labelSpaceCss = css`
  height: 28px;
`

const specialShortcuts = ['KeyA', 'KeyZ', 'KeyX', 'KeyC', 'KeyV']
const specialKeyCodes = ['Enter', 'ArrowLeft', 'ArrowRight']

const minCharsRemainingThreshold = 20
function computeCharactersRemaining(maxLength, value, level) {
  if (!maxLength || level === 'never') return null
  const showThreshold = Math.max(minCharsRemainingThreshold, Math.floor((maxLength * 1) / 3))
  const remainingCount = maxLength - value.length
  if (level === 'dynamic') {
    // don't show chars remaining if the max length is really small.
    if (maxLength > minCharsRemainingThreshold) {
      return remainingCount <= showThreshold ? remainingCount : null
    }
    return null
  }
  return remainingCount
}

function setCursorPosition(input, position) {
  if (!input) return

  // At one point we explored the behavior of temporarily switching the input
  // value to `text` when the user hit the Home/End keys. We can't do that,
  // because that implementation has side effects:
  // - it broke `password` type functionality
  // - firefox resets the cursor position to the end when the type changes
  //   so it undid the cursor position moving, haha

  try {
    input.setSelectionRange(position, position, 'none')
  } catch (_) {
    // we don't care if the field doesn't support moving the cursor position.
    // most field types do not support it, actually. See https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange#exceptions
    // So we just want to catch the error in the case that the user hits
    // Home/End on number field or something. Some browsers will move the
    // cursor on their own, other's won't. It's a wild card of support.
    // A wildcard that we don't care to maintain parity.
  }
}

/** Wrapper component used to provide validation styling, labels, and help text to inputs */
export default function InputBase({
  id,
  label: rawLabel,
  largerLabel = false,
  allowLabelWrapping = false,
  billboard,
  description,
  dense,
  disabled,
  helpMessage = '',
  validMessage = '',
  errorMessage,
  warningValidate,
  children,
  value = '',
  maxLength,
  validateAtGroupLevel,
  charactersRemainingLevel = 'always',
  status = 'none',
  autoWidth,
  inputContainerRef,
  inputRef,
  setDefaultAriaDescribedBy,
  ...props
}) {
  const { t } = useTranslation()
  const inputId = useRandomId(id)

  const warningMessage = warningValidate && warningValidate(value)
  // VALID STATUS
  if (!errorMessage && validMessage) status = 'valid'

  // WARNING STATUS
  if (!errorMessage && warningMessage) status = 'warning'

  // ERROR STATUS
  if (errorMessage) status = 'error'

  // Map statuses to the correct icons
  const iconMap = {
    valid: ContentCheck,
    warning: NoticeWarning,
    error: NoticeImportant,
  }

  // Map statuses to the correct messages
  const messageMap = {
    none: helpMessage && <i>{helpMessage}</i>,
    valid: validMessage,
    error: errorMessage,
    warning: warningMessage,
  }

  const feedbackColorMap = {
    warning: 'warning',
    error: 'error',
    valid: 'success',
    help: 'help',
  }

  const StatusIcon = (warningMessage || errorMessage || validMessage) && iconMap[status]

  let label = rawLabel
  if (typeof label === 'string') {
    label = rawLabel.trim()
  }
  if (typeof label === 'number') {
    label = String(label)
  }

  // The label should not be shown:
  // if it's a falsy value (like "" or null),
  // and a boolean value was provided
  // or if the label is a function, only allow for TypeSkeleton to be passed in
  const showLabel =
    Boolean(label) &&
    label !== true &&
    (typeof label?.type !== 'function' || (label?.type?.identity || '').startsWith('Skeleton'))

  // Label space should be rendered instead of the label:
  // when the label is not shown and if the label property is equal to true or an empty string
  // but not if the label property is null, undefined, or false
  const showLabelSpace = !showLabel && (label === true || (typeof label === 'string' && label.length === 0))

  const charactersRemaining = computeCharactersRemaining(maxLength, value, charactersRemainingLevel)

  const [isFocused, setIsFocused] = useState(false)

  // The `Home` and `End` keys are scrolling pages rather than moving the cursor.
  // These handlers will override the default behavior so that `Home` brings the cursor to the beginning
  // and `End` to the end of the input.
  const handlers = useMemo(
    () =>
      inputRef
        ? {
            Home: {
              title: 'Navigate cursor to the beginning of the input',
              action: () => {
                setCursorPosition(inputRef.current, 0)
                return false
              },
            },
            End: {
              title: 'Navigate cursor to the end of the input',
              action: () => {
                setCursorPosition(inputRef.current, -1)
                return false
              },
            },
          }
        : {},
    [inputRef]
  )

  useKeyboardShortcuts({
    handlers: {
      ...handlers,
      wildCard: {
        /**
          When focused on the input, we want to prevent all keyboard shortcuts that would interfere with the behavior
          of an input: printable characters, ctrl+v (paste), cmd+c (copy), etc.
          Returning false stops propagation and allows default behavior of printable characters and common text-manipulation codes
          **Returning true lets other handlers try and handle the shortcut**
        */
        action: ({ key, code, ctrlKey, metaKey }) => {
          // "Handle" any text-manipulation shortcuts, preventing other
          // shortcut handlers from hijacking copy/paste, undo, etc.
          // but ignore any other shortcuts involving the ctrl/commmand
          // (e.g., something like ctrl+F), if other shortucts exist
          if (ctrlKey || metaKey) return !specialShortcuts.includes(code)

          // Likewise, certain keys need to always work with inputs and
          // we need to ensure they maintain their default behaviors
          if (specialKeyCodes.includes(key)) return false

          // "Handle" all printable characters. The `key` prop on the event
          // has only 1 character if it's a printable one,
          // while non-printable characters have more than one, e.g. "A" vs "Escape"
          // If the key cannot be identified, treat it like a printable character, because that is the safer default for an input
          return key?.length > 1
        },
      },
    },
    enabled: isFocused,
  })

  const isWhite = useContext(WhiteThemeContext)
  const showHelpText =
    (helpMessage || warningMessage || errorMessage || validMessage || charactersRemaining !== null) &&
    !validateAtGroupLevel

  useEffect(() => {
    setDefaultAriaDescribedBy?.(showHelpText ? `${inputId}_description` : undefined)
  }, [showHelpText, setDefaultAriaDescribedBy, inputId])

  return (
    <div
      {...props}
      className={inputBaseCss}
      data-billboard={boolAttr(billboard)}
      data-full-width={boolAttr(props['data-full-width'])}
      data-status={status}
      data-interactive="true"
      data-dense={boolAttr(dense)}
      inputbase="true"
      iswhite={boolAttr(isWhite)}
      onFocus={(evt) => {
        if (props.onFocus) props.onFocus(evt)
        setIsFocused(true)
      }}
      onBlur={(evt) => {
        if (props.onBlur) props.onBlur(evt)
        setIsFocused(false)
      }}
    >
      {/* LABEL */}
      {showLabel && (
        <FeedbackText type={isWhite ? undefined : feedbackColorMap[status]}>
          <InputLabel
            disabled={disabled}
            htmlFor={inputId}
            description={description}
            largerLabel={largerLabel}
            ellipses={!allowLabelWrapping}
            data-full-width="" // Because this should be handled by the wrapper, not the paragraph styles
          >
            {label}
          </InputLabel>
        </FeedbackText>
      )}
      {showLabelSpace && <div className={labelSpaceCss} />}
      {/* CHILDREN (INPUT) CONTAINER */}
      <div
        isdisabled={boolAttr(disabled)}
        className={childrenContainerCss}
        autowidth={boolAttr(autoWidth)}
        ref={inputContainerRef}
      >
        <div className={childrenCss}>{children}</div>
      </div>
      {/* HELP TEXT - Beneath the input */}
      {showHelpText && (
        <FeedbackText
          id={`${inputId}_description`}
          className={messageCss}
          type={feedbackColorMap[status]}
          withWhiteText={isWhite && status !== 'none'}
        >
          {/* STATUS ICON */}
          {StatusIcon && (
            <span className={statusIconContainer} aria-hidden>
              <StatusIcon size={isWhite ? 'xs' : 'sm'} />
            </span>
          )}

          {/* HELP TEXT */}
          <div className={cx('help-message-container', messageTextCss)}>
            {charactersRemaining !== null && (
              // we have this section hidden from screen readers as not to spam the user
              // when the count updates.
              // We want to show it when the characters get below a certain threshold.
              // that way the user does not think their input was accepted past the maxLength
              <div
                className={maxLengthCss}
                level={charactersRemainingLevel}
                aria-hidden={Boolean(charactersRemaining > minCharsRemainingThreshold).toString()}
                aria-label={
                  charactersRemaining <= minCharsRemainingThreshold
                    ? t(
                        'textfield.characters-remaining.aria-label',
                        '{count, plural, one {# character} other {# characters}} remaining',
                        { count: charactersRemaining }
                      )
                    : undefined
                }
              >
                <Paragraph size="xs" secondary>
                  {formatValue(charactersRemaining)}
                </Paragraph>
              </div>
            )}
            <Paragraph size="xs">{messageMap[status]}</Paragraph>
          </div>
        </FeedbackText>
      )}
    </div>
  )
}

InputBase.propTypes = {
  /** Very optional unique ID for the input. One is generated if one isn't supplied. */
  id: PropTypes.string,

  /** The text for the label for the input. If you wish to hide the label visually, please set a valid `aria-label` for the field, and pass in `false` for the label. */
  label: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.oneOf([true, false, null]),
    PropTypes.node, // node type here is for TypeSkeleton ONLY! Do not put anything else in here.
  ]),

  /** Increases label size when set to true */
  largerLabel: PropTypes.bool,

  /** Disables ellipses and allows label to wrap when set to true */
  allowLabelWrapping: PropTypes.bool,

  /** Increase the padding around the input for landing page type experiences  */
  billboard: PropTypes.bool,

  /** Optional additional text to be rendered in a ToolTip for the label. */
  description: PropTypes.string,

  /** Removes the bottom-margin, to allow more custom spacing options. */
  dense: PropTypes.bool,

  /** Disables the input. */
  disabled: PropTypes.bool,

  /** Valid message text. */
  validMessage: PropTypes.string,

  /** Error message text. */
  errorMessage: PropTypes.node,

  /** Help message text. */
  helpMessage: PropTypes.node,

  /** For displaying status without an error message. Only applies when errorMessage, warningValidate, or validMessage do not return values. Ignores helpMessage. */
  status: PropTypes.oneOf(['none', 'help', 'valid', 'warning', 'error']),

  /** Function that runs to check if a warning should be displayed. Must return a string or null. */
  warningValidate: PropTypes.func,

  /** The maximum number of characters the input can take. */
  maxLength: PropTypes.number,

  /** Specify how often the remaining characters count shows. */
  charactersRemainingLevel: PropTypes.oneOf(['always', 'never', 'dynamic']),

  /** Function that sets the default aria described by string based on if we are showing help text or not */
  setDefaultAriaDescribedBy: PropTypes.func,
}
