import type { ElementType, RefObject, ReactNode } from 'react'
import React, { useRef, forwardRef, useContext, Fragment, useCallback, useState, useMemo } from 'react'
import { css, cx } from '@linaria/core'
import { boolAttr, sanitizeProps, useForwardRef, useResizeObserver } from '@fs/zion-frontend-friends'
import { MenuClose } from '@fs/zion-icon'
import { useTranslation } from 'react-i18next'
import type { Rect, Bounds } from '../draggable-container'
import { DraggableContainer, MoveHandle, ResizableBoundaries } from '../draggable-container'
import OpenCloseAnimation from '../open-close-animation'
import Overlay, { useOnClose } from '../overlay'
import Portal from '../portal'
import Scrim from '../scrim'
import { Theme, colors } from '../theme'
import colorThemes from '../theme/themeSubsets'
import useAutoFocus from '../use-auto-focus'
import useBodyScrollLock from '../use-body-scroll-lock'
import useClickAway from '../use-click-away'
import useEscHandler from '../use-esc-handler'
import useFocusLock from '../use-focus-lock'
import { usePageWidth } from '../responsive'
import TabsPortalProvider from '../tabs/TabsPortalProvider'
import { PopperModifiersContext, defaultModifierCreator } from '../popper/PopperContext'
import { LayoutBandContext } from '../layout-band/LayoutBand'
import { IconButton } from '../buttons/icon-button'
import type { UseOverlayReturnOptions } from '../overlay/useOverlay'
import type { PolymorphicComponentPropsWithRef, PolymorphicRef } from '../polymorphic-prop-types'
import MarginBox from '../margin-box'
import { ProgressOverlayContext } from '../progress-overlay/ProgressOverlayContext'
import { Cell } from '../grid'
import Row from '../row'
import { getOverlayHeader } from '../use-auto-focus/useAutoFocus'
import { fitContentAreaCss } from '../scrim/Scrim'
import useScrollInputIntoView from '../use-scroll-input-into-view'

export const sizeWidths = {
  nano: 550,
  xxs: 700,
  xs: 850,
  sm: 1000,
  md: 1200,
  lg: 1400,
  xl: 1600,
  xxl: 1900,
}

const stackingCss = css`
  position: fixed;
  top: 0;
  inset-inline-start: 0;
  z-index: 2; /* Create a stacking context, so all things inside this overlay will be contained (and on top of the main ui) */
`
const draggableContainerCss = css`
  pointer-events: none;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2; /* Create a stacking context, so all things inside this overlay will be contained (and on top of the main ui) */
`
// We need both of the zIndex's in the draggableContainerCss and the dialogOverlayCss for the stacking context to work in mobile and in desktop
const dialogOverlayCss = css`
  pointer-events: auto;
  z-index: 2; /* Create a stacking context, so all things inside this overlay will be contained (and on top of the main ui) */
  transform-style: preserve-3d;
  width: 100%;
  outline: none;
  max-width: inherit;
  overflow: hidden;

  &,
  /* When ZionForm is used inside DialogOverlay, it needs this styling too */
  & > form {
    height: 100%;
    display: flex;
    flex-direction: column;
    overflow-y: hidden;
  }

  &:not([data-fullscreen]) {
    transition: width 0.1s;

    &[data-size='xs'] {
      width: 320px;
    }
    &[data-size='sm'] {
      width: 420px;
    }
    &[data-size='md'] {
      width: 564px;
    }
    &[data-size='lg'] {
      width: 700px;
    }
    &[data-size='xl'] {
      width: 900px;
    }
    &[data-size='xxl'] {
      width: 1200px;
    }
  }

  &[data-fullscreen] {
    max-height: calc(
      var(--page-content-height, 100vh) - var(--virtual-keyboard-height, 0) - var(--progress-overlay-screen-bottom, 0)
    );
    margin: 0;
  }
`

export const headerColorCss = css`
  &[data-color] {
    border-top: 8px solid ${colors.color40};
  }
  &[data-color='green'] {
    border-color: ${colors.green30};
  }
  &[data-color='yellow'] {
    border-color: ${colors.yellow10};
  }
  &[data-color='purple'] {
    border-color: ${colors.purple60};
  }
  &[data-color='gray'] {
    border-color: ${colors.gray90};
  }
`

const headerWrapperCss = css`
  flex-shrink: 0;
  background: ${colors.gray00};
  transition: background 0.3s;
  &:not([data-fullscreen]):not([data-disable-hover]):hover {
    background: ${colors.color02};
  }
`

const closeButtonCss = css`
  border-radius: 500px; // Matches the IconButton. Needed so the corners don't trigger the mouseOver event and disable the header hover styles
  margin: -3px 0; // Tucks in the size of the header when there's only one line of text.
  height: 40px; // When the dialog is non-closable, we maintain a consistent header height
`

const maxSizeCss = css`
  max-width: inherit;
`

const noOp = (): void => undefined

const desktopAnimStyles = {
  openStyles: { opacity: 1, config: { tension: 300 } },
  closeStyles: { opacity: 0, config: { tension: 300 } },
  derivedStyles: {
    transform: [['opacity'], (opacity: number) => `scale(${0.75 + opacity * 0.25})`],
  },
}
const fullscreenAnimStyles = {
  openStyles: {
    y: '0vh',
    position: 'fixed',
    top: 0,
    bottom: 0,
    left: 0, // @codemod-ignore:right-to-left -- we don't need to use `inset` since it's all symmetrical, and inset had issues (ZIONUI-1533)
    right: 0, // @codemod-ignore:right-to-left -- we don't need to use `inset` since it's all symmetrical, and inset had issues (ZIONUI-1533)
    config: { tension: 250 },
  },
  closeStyles: {
    y: '100vh',
    position: 'fixed',
    top: 0,
    bottom: 0,
    left: 0, // @codemod-ignore:right-to-left -- we don't need to use `inset` since it's all symmetrical, and inset had issues (ZIONUI-1533)
    right: 0, // @codemod-ignore:right-to-left -- we don't need to use `inset` since it's all symmetrical, and inset had issues (ZIONUI-1533)
    config: { tension: 300 },
  },
}

export type Props = UseOverlayReturnOptions & {
  'aria-label'?: string
  /** Bool prop that determines if the overlay can be closed with a click outside of the overlay */
  closeOnClickAway?: boolean

  disableFullscreen?: boolean
  focusRef?: RefObject<HTMLElement>
  footer?: ReactNode
  fullscreen?: boolean
  header?: ReactNode
  headingColor?: 'blue' | 'green' | 'yellow' | 'red' | 'purple' | 'gray'
  maxHeight?: number
  minHeight?: number
  nonClosable?: boolean
  onClose?: () => void
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'
}

export type DialogOverlayBaseProps<C extends ElementType = 'div'> = PolymorphicComponentPropsWithRef<C, Props>

const sizePadding = 24

const DialogOverlayBase = <C extends ElementType = 'div'>(
  {
    as,
    children,
    footer,
    header,
    closeLabel,

    'aria-label': ariaLabel,

    closeOnClickAway = true,
    disableFullscreen = false,
    focusRef,
    fullscreen = true,
    headingColor,
    maxHeight: proposedMaxHeight = Infinity, // needs to be a number so that it can work inside the Math.mins below
    minHeight: proposedMinHeight = 0,
    nonClosable = false,
    size = 'md',

    // [Scrubbed]: from useOverlay()
    close,
    focusBackRef,
    handleClick, // eslint-disable-line @typescript-eslint/no-unused-vars -- not needed, ignored
    handleTransitioned,
    isOpen,
    onClose,
    open, // eslint-disable-line @typescript-eslint/no-unused-vars -- not needed, ignored
    targetRef,
    transitioning,

    ...props
  }: DialogOverlayBaseProps<C>,
  ref: PolymorphicRef<C>
): JSX.Element | null => {
  const internalRef = useForwardRef<HTMLElement>(ref)
  const isSmBreakpoint = usePageWidth()({ md: true })
  const isFullscreenMobile = !isSmBreakpoint && fullscreen && !disableFullscreen
  const overlayRef = useRef<HTMLDivElement>(null)
  const tabsRef = useRef<HTMLDivElement>(null)
  const portalRef = useRef<HTMLDivElement>(null)
  const [t] = useTranslation()
  const progressOverlay = useContext(ProgressOverlayContext)
  const { screenBottom } = progressOverlay as { screenBottom: unknown }

  // onClose handler
  useOnClose({
    isOpen,
    transitioning,
    onClose,
  })

  // Lock body scrolling when open
  useBodyScrollLock(isOpen, overlayRef)

  // Close the dialog when clicking off the dialog - when click away is not turned off we still need to stop propagation of the click event so if we were spawned from something else that uses ClickAway we won't just close the second anyone tries to do anything inside of us
  useClickAway({
    enabled: isOpen && !nonClosable,
    originatorRef: targetRef,
    focusBackRef,
    contentRef: overlayRef,
    handler: closeOnClickAway ? close : noOp,
  })

  useFocusLock({
    enabled: isOpen,
    containerRef: portalRef,
  })

  useAutoFocus({
    isOpen,
    enabled: transitioning,
    focusRef,
    containerRef: overlayRef,
    whatToFocusInContainer: getOverlayHeader,
  })

  // Close on escape key
  useEscHandler({
    handler: close,
    enabled: isOpen && !nonClosable,
  })

  /* This disables the header hover styles when the close button is being hovered */
  const [disableHoverStyles, setDisableHoverStyles] = useState(false)

  /* This makes the header a color when a heading color is chosen */
  const colorTheme = colorThemes[headingColor || 'gray']

  /* If fullscreen, there's no drag-ability, so we don't want to render the MoveHandle. */
  const MoveHandleWrapper = isFullscreenMobile ? Fragment : MoveHandle

  const TagName = as || 'div'

  const scrimRef = useRef<HTMLElement>(null)
  // we need to know when the scrim is mounted so we can enable the resizeObservers on it
  const [scrimIsMounted, setScrimIsMounted] = useState(false)
  // using a callbackRef to set the scrimRef so that we don't need to use a bunch of booleans in order to find out when the scrim mounts
  const setScrimRef = useCallback((node: HTMLElement) => {
    scrimRef.current = node
    setScrimIsMounted(!!node)
  }, [])

  // these maxHeight/maxWidth values are based on the scrim's dimensions and will update when the scrim mounts/changes sizes
  const [maxHeight, setMaxHeight] = useState(Infinity)
  const [maxWidth, setMaxWidth] = useState(Infinity)

  // update the maxWidth and maxHeight state values
  useResizeObserver(
    scrimRef,
    (entry) => {
      const { clientHeight, clientWidth } = entry.target
      // maxHeight and maxWidth should stay less than the scrim's dimensions - some padding
      setMaxHeight(clientHeight ? clientHeight - sizePadding : Infinity)
      setMaxWidth(clientWidth ? clientWidth - sizePadding : Infinity)
    },
    scrimIsMounted
  )

  const overlaySizingStyles = useMemo(() => {
    // the real maxHeight should be the smaller value between the calculated maxHeight and the proposedMaxHeight
    const realMaxHeight = Math.min(maxHeight, proposedMaxHeight)
    // the proposed minHeight shouldn't be bigger than the maxHeight
    const realMinHeight = Math.min(realMaxHeight, proposedMinHeight)

    // the CSS maxHeight attribute does not support infinity, but does support none
    return {
      maxHeight: realMaxHeight === Infinity ? 'none' : realMaxHeight,
      maxWidth: maxWidth === Infinity ? 'none' : maxWidth,
      minHeight: realMinHeight,
    }
  }, [maxHeight, maxWidth, proposedMaxHeight, proposedMinHeight])

  const scrollInputIntoView = useScrollInputIntoView()
  useResizeObserver(isOpen || transitioning ? internalRef : { current: null }, () => {
    scrollInputIntoView()
  })

  const getBounds = useCallback((draggableRect: Rect): Bounds => {
    const topPadding = 12
    const sidePadding = 200
    const { x = 0, y = 0, width = 0, height = 0 } = scrimRef.current?.getBoundingClientRect() || {}
    const boundary = {
      x: x - draggableRect.x - draggableRect.width + sidePadding,
      y: y - draggableRect.y + topPadding,
      width: width + draggableRect.width * 2 - sidePadding * 2,
      height: height + draggableRect.height - 100,
    }
    return { boundary, minWidth: 0, minHeight: 0 }
  }, [])

  return !isOpen && !transitioning ? null : (
    <Portal ref={portalRef}>
      <PopperModifiersContext.Provider value={defaultModifierCreator}>
        {!isFullscreenMobile && <Scrim ref={setScrimRef} isOpen={isOpen} />}
        <div className={stackingCss}>
          <div
            className={cx(draggableContainerCss, fitContentAreaCss)}
            style={{ '--progress-overlay-screen-bottom': `${screenBottom}px` }}
          >
            <DraggableContainer disabled={isFullscreenMobile} getBounds={getBounds}>
              <ResizableBoundaries boundaryRef={scrimRef} enabled={scrimIsMounted && maxHeight !== Infinity} />
              <OpenCloseAnimation
                key={isFullscreenMobile ? 'fullscreen' : 'dialog'} // This resets this component when switching between fullscreen and dialog modes which prevents odd behavior where OpenCloseAnimation isn't updating with new values.
                onOpenFinished={handleTransitioned}
                onCloseFinished={handleTransitioned}
                isOpen={isOpen}
                className={maxSizeCss}
                {...(isFullscreenMobile ? fullscreenAnimStyles : desktopAnimStyles)}
              >
                <Overlay ref={overlayRef} aria-modal aria-label={ariaLabel} fixSize>
                  {/* Make it so LayoutBands within this component don't use ResponsiveProvider */}
                  <LayoutBandContext.Provider value>
                    <Theme
                      as={TagName}
                      {...sanitizeProps(props)}
                      className={cx(dialogOverlayCss, isFullscreenMobile && fitContentAreaCss)}
                      style={!isFullscreenMobile ? overlaySizingStyles : undefined}
                      data-size={size}
                      data-fullscreen={boolAttr(isFullscreenMobile)}
                      ref={internalRef}
                    >
                      <div
                        className={cx(headerWrapperCss, colorTheme, headerColorCss)}
                        data-color={headingColor}
                        data-disable-hover={boolAttr(disableHoverStyles)}
                      >
                        <MoveHandleWrapper>
                          <MarginBox marginX="sm" marginY="xxs" data-fullscreen={boolAttr(isFullscreenMobile)}>
                            <Row alignY="middle">
                              <Cell growX>{header}</Cell>
                              <div
                                noShrinkX
                                className={closeButtonCss}
                                onMouseOver={() => setDisableHoverStyles(true)} // eslint-disable-line jsx-a11y/mouse-events-have-key-events -- Disabling this rule because the mouseevents only affect the hover visuals
                                onMouseLeave={() => setDisableHoverStyles(false)}
                              >
                                {!nonClosable && (
                                  <IconButton
                                    Icon={MenuClose}
                                    color="gray"
                                    title={closeLabel || t('common-ui:close.action', 'Close')}
                                    onClick={() => close()}
                                  />
                                )}
                              </div>
                            </Row>
                          </MarginBox>
                        </MoveHandleWrapper>
                      </div>
                      {/* Tabs will render in this div. */}
                      <div ref={tabsRef} />
                      <TabsPortalProvider location={tabsRef}>{children}</TabsPortalProvider>
                      {footer}
                    </Theme>
                  </LayoutBandContext.Provider>
                </Overlay>
              </OpenCloseAnimation>
            </DraggableContainer>
          </div>
        </div>
      </PopperModifiersContext.Provider>
    </Portal>
  )
}

export default forwardRef(DialogOverlayBase)
