import type { ReactElement, ReactNode, ComponentType, MutableRefObject } from 'react'
import React, { useMemo, useState, useEffect, useRef } from 'react'
import { css } from '@linaria/core'
import { MemoryRouter } from '@fs/zion-router'
import type { BroadcastingRouteProps, OverlaySwitchState } from '../switches'
import {
  OverlaySwitch,
  OverlaySwitchProvider,
  TransitionSwitch,
  TransitionSwitchContext,
  useOverlayState,
  useOverlayUpdate,
} from '../switches'
import type { Props as BaseProps } from './DialogOverlayBase'
import DialogOverlayBase from './DialogOverlayBase'
import { DialogFooterWrapper as DialogFooter, DialogFooterContext } from './DialogOverlayFooter'
import DialogHeader from './DialogOverlayHeader'
import BorderScroller from '../border-scroller'
import MarginBox from '../margin-box'
import { ResponsiveProvider } from '../responsive'
import { GridStart } from '../grid'
import DialogOverlayHeaderWithBack from './DialogOverlayHeaderWithBack'
import { SquishMeTransition } from '../animations'
import type { PolymorphicComponentProps } from '../polymorphic-prop-types'
import useA11yLabelRef from '../use-a11y-ref-label'

type Entries = (string | { pathname: string; search: string; hash: string; state: unknown })[]
type TransitioningDialogProps = Omit<BaseProps, 'header'> & {
  /**
   * The text that goes in the heading.  Should usually be a string, but JSX is allowed, as long as it's not interactive, because this is part of a draggable header.
   *
   * **NOTE**: Instead of using this prop, you may instead choose to add individual `title` props to each of the `<Route>` children
   * of this component. The title will then change when the location changes
   */
  title?: ReactNode

  /**
   * the text that goes in the sub heading - should usually be a string, but JSX is allowed, as long as it's not interactive, because this is part of a draggable header.
   *
   * **NOTE**: Instead of using this prop, you may instead choose to add individual `subtitle` props to each of the `<Route>` children
   * of this component. The title will then change when the location changes
   */
  subtitle?: ReactNode

  /**
   * This is a flag designed to set aria-busy inside the overlay.
   *
   * Set to `true` when fetching data to help indicate to screen readers that the app is in an intermediate state
   */
  busy?: boolean

  /** Route components to go inside the body of the overlay. Treat TransitioningDialogOverlay like a Switch component. The children may only be Route components. */
  children:
    | ReactElement<BroadcastingRouteProps<OverlaySwitchState>>
    | ReactElement<BroadcastingRouteProps<OverlaySwitchState>>[]

  /**
   * Content to go inside the footer of the overlay
   *
   * **NOTE**: Instead of using this prop, you may instead choose to add individual `footer` props to each of the `<Route>` children
   * of this component. You can also use the `updateFooter` hook to update the footer. Look at the NoFooter story for an example using the subtitle.
   *
   * **IMPORTANT**: Do not use `<DialogOverlayFooter>` in place of the `footer` prop. There is a circular state dependency on Router that could put your overlay in an infinite render loop.
   */
  footer?: ReactElement
} & (
    | {
        /**
         * The starting location when loaded. Must match the path of one of the route children of this component.
         */
        initialLocation: string
        initialIndex?: undefined
        initialEntries?: undefined
      }
    | {
        /**
         * Array of paths. Acts as a starting history. Will override initialLocation if provided.
         */
        initialEntries: Entries

        /**
         * Determines which route from initialEntries to display initially. If not provided, it will default to 0.
         */
        initialIndex?: number
        initialLocation?: undefined
      }
  )

const contentWrapper = css`
  display: flex;
  flex-direction: column;
  flex-grow: 1;
`

const DialogOverlayFooterProvider = ({ children }): JSX.Element => {
  const updateFooter = useOverlayUpdate('footer')
  return <DialogFooterContext.Provider value={updateFooter}>{children}</DialogFooterContext.Provider>
}

const DialogRouteContentWrapper = ({ children }: { children: ReactNode }): JSX.Element => {
  return (
    <MarginBox marginX="sm" marginY="sm" className={contentWrapper}>
      {children}
    </MarginBox>
  )
}

type ContentProps = {
  transitioning: boolean
  scrollerRef: MutableRefObject<HTMLElement>
  defaults: OverlaySwitchState
} & Pick<TransitioningDialogProps, 'children'>

// exporting for testing purposes (not public)
export const TransitioningDialogContent = ({
  transitioning,
  scrollerRef,
  defaults,
  children,
}: ContentProps): JSX.Element => {
  return (
    // The ResponsiveProvider needs to be outside of the BorderScroller or else content that has width-based heights (i.e. using --cell-width or --grid-width
    // values to determine height) will cause stroby resize loops at certain sizes due to the scrollbar changing the width of the ResponsiveProvider when it appears/disappears. (ZIONUI-1398)
    // NOTE: We have tried other methods (mainly trying to keep --cell-width and --grid-width consistent) to counteract this, but they both came with caveats.
    //  1. using negative margins makes the scrollbar overlap the content if there isn't enough margin.
    //  2. Adding the width of the scrollbar to the overlays is doable, but it is complicated, hard to maintain, can still behave a bit wonky sometimes.
    <ResponsiveProvider className={contentWrapper} style={{ overflow: 'hidden' }}>
      {/** Freezing scrollbar during transition to prevent Images from getting stuck in a resize loop */}
      <BorderScroller hideBorders={transitioning} freezeScrollbar={transitioning} ref={scrollerRef}>
        <GridStart className={contentWrapper}>
          <DialogOverlayFooterProvider>
            <OverlaySwitch defaultValues={defaults} as={TransitionSwitch} WrapperComponent={DialogRouteContentWrapper}>
              {children}
            </OverlaySwitch>
          </DialogOverlayFooterProvider>
        </GridStart>
      </BorderScroller>
    </ResponsiveProvider>
  )
}

const TransitioningDialogInner = <C extends ComponentType>({
  title: defaultTitle,
  subtitle: defaultSubtitle,
  footer: defaultFooter,
  children,
  transitioning: overlayTransitioning,
  'aria-label': ariaLabel,
  ...props
}: PolymorphicComponentProps<
  C,
  Omit<TransitioningDialogProps, 'initialLocation' | 'initialEntries' | 'initialIndex'>
>): JSX.Element => {
  const scrollerRef = useRef<HTMLElement>()
  const [routeTransitioning, setRouteTransitioning] = useState(false)
  const [a11yLabel, labelRef] = useA11yLabelRef(ariaLabel)

  const { title, subtitle, footer, focusRef, busy } = useOverlayState()

  const defaults = useMemo(
    () => ({ title: defaultTitle, subtitle: defaultSubtitle, footer: defaultFooter }),
    [defaultTitle, defaultSubtitle, defaultFooter]
  )

  useEffect(() => {
    routeTransitioning && scrollerRef.current?.scrollTo?.({ top: 0, behavior: 'smooth' })
  }, [routeTransitioning])

  const value = useMemo(() => ({ setTransitioning: setRouteTransitioning }), [])

  return (
    <DialogOverlayBase
      focusRef={focusRef}
      header={
        <DialogOverlayHeaderWithBack>
          <DialogHeader title={title} subtitle={subtitle} busy={busy} ref={labelRef} />
        </DialogOverlayHeaderWithBack>
      }
      footer={<SquishMeTransition>{footer && <DialogFooter>{footer}</DialogFooter>}</SquishMeTransition>}
      transitioning={overlayTransitioning || routeTransitioning}
      {...props}
      aria-label={a11yLabel}
    >
      <TransitionSwitchContext.Provider value={value}>
        <TransitioningDialogContent
          transitioning={overlayTransitioning || routeTransitioning}
          scrollerRef={scrollerRef}
          defaults={defaults}
        >
          {children}
        </TransitioningDialogContent>
      </TransitionSwitchContext.Provider>
    </DialogOverlayBase>
  )
}

const TransitioningDialogOverlay = <C extends ComponentType>({
  children,
  initialLocation,
  initialEntries = initialLocation ? [initialLocation] : [],
  initialIndex,
  as,
  ...props
}: PolymorphicComponentProps<C, TransitioningDialogProps>): JSX.Element | null => {
  let entries: Entries

  if (initialEntries.length > 0) {
    entries = initialEntries
  } else if (initialLocation) {
    entries = [initialLocation]
  } else {
    throw new Error(
      'Either "initialLocation" or "initialEntries" prop is required for TransitioningDialogOverlay to work correctly. It should match the path of the first route you would like to display.'
    )
  }

  return entries.length > 0 ? (
    <MemoryRouter initialEntries={entries} initialIndex={initialIndex}>
      <OverlaySwitchProvider>
        <TransitioningDialogInner
          {...props}
          as={
            // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Not sure why the as props are not compatible here; they should be...
            as as any
          }
        >
          {children}
        </TransitioningDialogInner>
      </OverlaySwitchProvider>
    </MemoryRouter>
  ) : null
}

export default TransitioningDialogOverlay
