import React, { useReducer, useEffect, useCallback, useMemo, useRef } from 'react'
import PropTypes from 'prop-types'
import { useTranslation } from 'react-i18next'
import Checkbox from '../checkbox'
/**
 * @function getNumberOfCheckedItems - get the number of items that are checked
 * @param {Object<string, Boolean>} checkedItems - Object storing states of checkboxes that have been touched (values are checked states)
 *
 * @returns {number} - the number of items that are checked
 */
function getNumberOfCheckedItems(checkedItems) {
  return Object.values(checkedItems).filter((x) => x).length
}

/**
 * @function getAllSelected - figure out if all items are selected or not selected (or somewhere in between)
 *
 * @param {Set<string>} allNames - a Set of all the names of checkboxes in our scope
 * @param {Object<string, Boolean>} checkedItems - Object storing states of checkboxes that have been touched (values are checked states)
 *
 * @returns {true|false|undefined} - Represents the checked state of the selectAllCheckbox. `undefined` represents a "mixed" state
 */
function getAllSelected({ allNames, checkedItems, selectionLimit }) {
  const allCheckboxes = [...allNames]
    .map((x) => !!checkedItems[x])
    .reduce((a, c) => ({ andReduction: a.andReduction && c, orReduction: a.orReduction || c }), {
      andReduction: true,
      orReduction: false,
    })
  const allItemsAreSelected =
    (allNames.size > 0 && allCheckboxes.andReduction === true) ||
    getNumberOfCheckedItems(checkedItems) >= selectionLimit
  const allItemsAreUnselected = allCheckboxes.orReduction === false

  // eslint-disable-next-line no-nested-ternary
  return allItemsAreSelected ? true : allItemsAreUnselected ? false : undefined
}

function checkBoxes(checkedItems, names, selectionLimit) {
  let numberOfCheckedItems = getNumberOfCheckedItems(checkedItems)
  return Object.fromEntries(
    [...names].map((x) => {
      if (checkedItems[x]) return [x, true]
      const atMax = numberOfCheckedItems >= selectionLimit
      if (!atMax) numberOfCheckedItems++
      return [x, !atMax]
    })
  )
}

/**
 * Initialize reducer state. Turn the initialSelectionArray into an object with the names being keys for easy access
 * @param {Array} initialSelection - the list of selected checkbox names
 * @param {Boolean} initialAllSelected - true if all checkboxes should be initially checked
 * @returns {{lastTouched: null, checkedItems: {[p: string]: boolean}, allSelected}} initialized state
 */
function reducerInitializer({ initialSelection, initialAllSelected, selectionLimit }) {
  return {
    checkedItems: Object.fromEntries([...initialSelection].map((x) => [x, true])),
    allSelected: initialAllSelected,
    lastTouched: null,
    selectionLimit,
  }
}

function reducer(state, action) {
  const { type, allNames } = action
  let newState
  switch (type) {
    case 'multiple': {
      const { checkedItems, selectionLimit } = state
      const { names, checked } = action
      const newlyChangedChecked = checked
        ? checkBoxes(checkedItems, names, selectionLimit)
        : Object.fromEntries([...allNames].map((x) => [x, false]))

      const newCheckedItems = { ...checkedItems, ...newlyChangedChecked }
      const name = action.names[action.names.length - 1]
      newState = {
        ...state,
        checkedItems: newCheckedItems,
        allSelected: getAllSelected({ allNames, checkedItems: newCheckedItems, selectionLimit }),
        size: allNames.size,
        lastTouched: { name, checked: action.checked },
      }
      break
    }

    case 'single': {
      const { name, checked } = action
      const { checkedItems, selectionLimit } = state
      const numberOfCheckedItems = getNumberOfCheckedItems(checkedItems)
      const checkYoself = !!(checked && numberOfCheckedItems < selectionLimit)
      const newCheckedItems = { ...checkedItems, [name]: checkYoself }
      newState = {
        ...state,
        checkedItems: newCheckedItems,
        allSelected: getAllSelected({ allNames, checkedItems: newCheckedItems, selectionLimit }),
        size: allNames.size,
        lastTouched: { name, checked },
      }
      break
    }

    case 'all': {
      const { checked } = action
      const { checkedItems, selectionLimit } = state

      const newCheckedItems = checked
        ? checkBoxes(checkedItems, allNames, selectionLimit)
        : Object.fromEntries([...allNames].map((x) => [x, false]))

      newState = {
        ...state,
        allSelected: checked,
        checkedItems: newCheckedItems,
        size: allNames.size,
        lastTouched: null,
      }
      break
    }

    // 'update' is always called after children are changed/added/removed
    case 'update': {
      let { checkedItems } = state
      const { selectionLimit } = state

      // remove names from checkedItems that don't exist any more
      checkedItems = Object.fromEntries(
        Object.keys(checkedItems)
          .filter((name) => {
            return allNames.has(name)
          })
          .map((name) => [name, checkedItems[name]])
      )

      newState = {
        ...state,
        checkedItems,
        allSelected: getAllSelected({ allNames, checkedItems, selectionLimit }),
        size: allNames.size,
      }
      break
    }

    default:
      newState = state
  }

  return newState
}

// Without stopping propagation, the click handler on ListItem fires when you click on the checkbox
const stopProp = (e) => {
  e.stopPropagation()
}

/**
 * @hook useSelection - Manage state for checkbox collections
 *
 * @param {Function} onSelectionChange - Callback that receives an array of names from the selected checkboxes (when that list changes)
 * @param {string} selectAllLabel - label for the main SelectAll checkbox
 * @param {Boolean} initialAllSelected - `true` if all checkboxes start out checked
 * @param {string[]} initialSelection - array of names of individual checkboxes start out checked
 * @param {*} children - know if the checkbox collection items need refreshing. This way we can disregard old checkbox states for removed children.
 *
 * @returns {getPropsForCheckbox<Function>, selectAllCheckbox<Checkbox>}
 */
export default function useSelection({
  onSelectionChange,
  selectAllLabel = '',
  children,
  initialAllSelected = false,
  initialSelection = [],
  selectionLimit = Infinity,
} = {}) {
  const [state, dispatch] = useReducer(
    reducer,
    {
      initialSelection,
      initialAllSelected,
      selectionLimit,
    },
    reducerInitializer
  )
  const { t } = useTranslation()

  const currentlyRenderedCheckboxes = useMemo(() => new Set(), [])
  const checkboxNames = useRef(new Set())
  const getPropsForCheckbox = useRef(() => {})

  const changeCallback = useCallback(
    ({ currentTarget: { checked, name } }) =>
      dispatch({ type: 'single', name, checked, allNames: checkboxNames.current }),
    []
  )

  /**
   * @method getPropsForCheckbox - Get all the managed props for a Checkbox.
   * It is assumed that getPropsForCheckbox will get called every render for each checkbox,
   * which is how the internal `checkboxNames` Set gets populated with all the current checkbox names
   *
   * @param {string} name - the name of the checkbox which is required for this hook to manage the state
   * @param {Boolean} [disabled] - true if the checkbox should be disabled
   *
   * @example // apply the output of getPropsForCheckbox directly to a Checkbox
   * const { getPropsForCheckbox } = useSelection({...})
   * <Checkbox {...getPropsForCheckbox.current({ name: 'item1' })}>
   */
  getPropsForCheckbox.current = useCallback(
    ({ name, disabled }) => {
      if (getNumberOfCheckedItems(state.checkedItems) >= selectionLimit && !state.checkedItems[name]) {
        disabled = true
      }
      // If a checkbox is disabled, then we should treat it like it does not exist with regards to the SelectAll behavior
      if (!disabled) {
        currentlyRenderedCheckboxes.add(name)
        checkboxNames.current.add(name)
      }
      const checked = disabled ? initialSelection?.includes(name) : !!state.checkedItems[name]
      return {
        name,
        disabled,
        onClick: stopProp,
        onChange: disabled ? undefined : changeCallback,
        debounce: 0, // we don't need/want debouncing of checkboxes for this hook
        checked,
        'aria-label': t('select.item.action', 'Select Item'),
      }
    },
    [state.checkedItems, initialSelection, changeCallback, currentlyRenderedCheckboxes, selectionLimit, t]
  )

  /**
   * @method toggleSelectAll - Update the state of all the checkboxes at the same time
   * @param {Boolean} checked - The checkbox state to update the checkboxes too
   *
   * @example // check all the checkboxes
   * const { toggleSelectAll } = useSelection({...})
   * toggleSelectAll(true)
   */
  const toggleSelectAll = (checked) => {
    dispatch({ type: 'all', allNames: checkboxNames.current, checked })
  }

  /**
   * @method updateMultiple - Update the state of multiple checkboxes at the same time
   * @param {string[]} names - Array of the names of the checkboxes to update
   * @param {Boolean} checked - The checkbox state to update each checkbox too
   *
   * @example // set two checkboxes (item1 and item3) to a checked state
   * const { updateMultiple } = useSelection({...})
   * updateMultiple({ names: ['item1', 'item3'], checked: true })
   */
  const updateMultiple = ({ names, checked }) => {
    dispatch({ type: 'multiple', names, checked, allNames: checkboxNames.current })
  }

  // watch for the children to change so we can remove or add names to allNames as needed
  useEffect(() => {
    // Each time the children change, clear any checkboxes from currentlyRenderedCheckboxes that are not on the page anymore.
    Array.from(currentlyRenderedCheckboxes.values()).forEach((name) => {
      if (!document.querySelector(`input[name="${name}"][type="checkbox"]`)) {
        currentlyRenderedCheckboxes.delete(name)
      }
    })

    // since we optimized and made `checkboxNames` a ref, we have to manage the state changes ourselves.
    // `currentlyRenderedCheckboxes` is always up to date, but only ever used here when we know we will need
    // to re render all the checkboxes.
    checkboxNames.current = currentlyRenderedCheckboxes
    dispatch({ type: 'update', allNames: checkboxNames.current })
  }, [children]) // eslint-disable-line react-hooks/exhaustive-deps
  // Putting children in the dependency list causes it to update at appropriate times.
  // Because checkboxNames is reset every time children changes, putting checkboxNames in the dependency list here causes an infinite loop.

  useEffect(() => {
    if (initialAllSelected) {
      dispatch({ type: 'all', allNames: checkboxNames.current, checked: true })
    }
    // We truly only want this ro run on the first render, so we will not list dependencies
  }, []) // eslint-disable-line

  const checkedCount = Object.values(state.checkedItems).filter(Boolean).length
  useEffect(() => {
    if (onSelectionChange) {
      onSelectionChange(
        Object.entries(state.checkedItems)
          .filter(([, v]) => !!v)
          .map(([k]) => k),
        state.lastTouched
      )
    }
    // Because useReducer requires an immutable state pattern, and because the state reference changes every time the
    // state updates, we cannot have the useEffect run on state.checkedItems. This will causes an infinite render loop.
    // We need some way to figure out if state.checkedItems has actually changed. Hence using the checkedCount instead.
  }, [checkedCount, onSelectionChange]) // eslint-disable-line

  return {
    updateMultiple,
    toggleSelectAll,
    getPropsForCheckbox,
    ...state,
    selectAllCheckbox: (
      <Checkbox
        label={selectAllLabel}
        name="select-all"
        aria-label={selectAllLabel || t('select.all.action', 'Select All')}
        checked={state.allSelected}
        onChange={({ currentTarget: { checked } }) => toggleSelectAll(checked)}
        mixedState={state.allSelected === undefined}
        disabled={state.size < 1}
      />
    ),
  }
}

// Dummy component to display the props in Storybook. This should get tree shaken out in the real build.
export const UseSelectionProps = ({ initialAllSelected = false, ...props }) => (
  <div initialAllSelected={initialAllSelected} {...props} />
)

UseSelectionProps.propTypes = {
  /** Callback that receives an array of names from the selected checkboxes (when that list changes). Of the form: `(checkedNames, lastTouched) => {...}` */
  onSelectionChange: PropTypes.func.isRequired,

  /** The label for the main SelectAll checkbox */
  selectAllLabel: PropTypes.string,

  /** Set to `true` if you want all checkboxes to start out checked */
  initialAllSelected: PropTypes.bool,

  /** Provide an array of names of individual checkboxes you want to start out checked */
  initialSelection: PropTypes.arrayOf(PropTypes.string),

  /** Max number of checked boxes allowed. */
  selectionLimit: PropTypes.number,

  /** Used by this hook to know if the checkbox collection items need refreshing. This way we can disregard old checkbox states for removed children.  */
  children: PropTypes.node,
}
