import React, { forwardRef } from 'react'
import { css } from '@linaria/core'
import { Link } from '@fs/zion-router'
import PropTypes from 'prop-types'
import { oneOfComponentType, useEvent } from '@fs/zion-frontend-friends'
import ListItemCore from './ListItemCore'
import Checkbox from '../checkbox'
import Toggle from '../toggle'
import Radio from '../radio'
import * as mediaTypes from './mediaTypes'
import { colors } from '../theme'
import { useMenuOverlayContext } from '../menu-overlay/MenuOverlayContext'
import { Avatar as AvatarSkeleton, Icon as IconSkeleton } from '../skeleton/AtomSkeletons'
import BaseButton from '../buttons/BaseButton'

const listItemCss = css`
  list-style: none;
  padding: 0;
  margin: 0 -12px;
  overflow: hidden;
  border-radius: 4px;
  &:focus {
    outline: none;
  }
`
const interactableLink = css`
  color: ${colors.gray100};

  // When this is used as a Link under a MemoryRouter, we have to override the user agent styles
  // because Links are transformed into a button instead of an anchor in the DOM
  button& {
    background-color: inherit;
    border: none;
    border-radius: 4px;
    padding: 0;
    width: 100%;
  }
`
// we give it a tabIndex so that we can programmatically call `.focus`
// but not allow the user to be able to focus via tab.
// see https://www.w3.org/TR/wai-aria-practices/examples/menu-button/menu-button-actions.html
const menuItemTabIndex = '-1'

function MenuItem(props) {
  return <BaseButton {...props} as="li" tabIndex={menuItemTabIndex} />
}

const ListItemComponent = (
  {
    to,
    linkName,
    external,
    action,
    target,
    rel,
    disabled,
    onClick,
    download,

    // In rare cases, the role needs to be overridden for accessibility (e.g. 'option' in listboxes)
    role,
    'aria-selected': ariaSelected,
    id,

    ...props
  },
  ref
) => {
  const isInMenu = useMenuOverlayContext()

  let listItemRole = role
  if (isInMenu) {
    if (to) {
      listItemRole = 'none'
    } else {
      listItemRole = 'menuitem'
    }
  }

  const keyPress = useEvent((e) => {
    // If you add "Enter" to this if statement, the enter button breaks on repeat use
    if (e.key === ' ') {
      e.preventDefault()
      // Links need extra help because they do not like to select on " "
      if (e.currentTarget.querySelector('a')) {
        e.currentTarget.querySelector('a').click()
      }
      onClick(e)
    }
  })

  const TagName = isInMenu ? MenuItem : 'li'

  return (
    <TagName
      className={listItemCss}
      role={listItemRole}
      {...(isInMenu
        ? {
            disabled,
            onKeyPress: disabled ? undefined : keyPress,
            onClick: disabled ? undefined : onClick,
            linkName,
          }
        : {})}
      {...(role === 'option'
        ? {
            id,
            'aria-selected': ariaSelected,
          }
        : {})}
    >
      {to && !disabled ? (
        <ListItemCore
          ref={ref}
          {...props}
          focusable={false}
          interactable
          tabIndex={undefined} // override the tabIndex supplied by interactable
          linkName={linkName}
          // We do some dependency injection here because Link has its props
          // sorted out at this level, but only ListItemCore knows where in the
          // DOM the Link needs to be placed.
          contentWrapper={Link}
          contentWrapperProps={{
            to,
            external,
            download,
            action,
            linkName,
            onClick,
            noLinkStyles: true,
            target,
            className: interactableLink,
            rel,
            role: isInMenu ? 'menuitem' : undefined,
            tabIndex: isInMenu ? menuItemTabIndex : undefined,
          }}
        />
      ) : (
        <ListItemCore
          {...props}
          {...(role !== 'option'
            ? {
                id,
                'aria-selected': ariaSelected,
              }
            : {})}
          ref={ref}
          disabled={disabled}
          interactable={!disabled && onClick}
          linkName={linkName}
          onClick={isInMenu ? undefined : onClick}
        />
      )}
    </TagName>
  )
}

const ListItem = forwardRef(ListItemComponent)
export default ListItem

// Add all of the leading/trailing components as compound components
Object.entries(mediaTypes).forEach(([name, component]) => {
  ListItem[name] = component
})

export const meta = { name: 'ListItem' }
ListItem.meta = meta

ListItem.propTypes = {
  /** Displays the number provided as a count next to the primary text. */
  badgeCount: PropTypes.number,

  /** If true, reduces the vertical padding on the list item. */
  dense: PropTypes.bool,

  /** If true, disables the item. It does not cascade the disable to the endElement. This must be done explicitly. e.g. <IconButton disabled ... /> */
  disabled: PropTypes.bool,

  /** Add emphasis to this item */
  emphasized: PropTypes.bool,

  /** Displays media on the starting side of the list item. Must one of these */
  startElement: oneOfComponentType([
    ListItem.Icon,
    ListItem.Avatar,
    ListItem.MultiAvatar,
    ListItem.Image,
    ListItem.Filler,
    ListItem.FillerMedia,
    Checkbox,

    // needed for Skeleton composition
    AvatarSkeleton,
  ]),

  /** Used only when using CheckboxList. Provides a name for the checkbox. */
  name: PropTypes.string,

  /** Click handler when clicking anywhere on the list item. */
  onClick: PropTypes.func,

  /** Adds overline text to the list item's text block. */
  overline: PropTypes.string,

  /** Primary line of text. */
  primaryText: PropTypes.node.isRequired,

  /** Displays media on the ending side of the list item. Must be one of these */
  endElement: oneOfComponentType([
    ListItem.Icon,
    ListItem.IconButton,
    ListItem.MetaText,
    Checkbox,
    Toggle,
    Radio,

    // needed for Skeleton composition
    IconSkeleton,
  ]),

  /** Secondary line of text. */
  secondaryText: PropTypes.node,

  /** Show this item as selected */
  selected: PropTypes.bool,
}
