import React, { forwardRef, createContext, useMemo } from 'react'
import { css } from '@linaria/core'
import { boolAttr, sanitizeProps } from '@fs/zion-frontend-friends'
import { trackEvent } from '@fs/zion-analytics'
import { BaseIcon } from '@fs/zion-icon/BaseIcon'
import TextBlock from './TextBlock'
import { colors } from '../theme'
import * as mediaTypes from './mediaTypes'

const outerContainerCss = css`
  position: relative;
`

const innerContainerCss = css`
  display: flex;
  padding: 12px;
  min-height: 52px;
  transition: background 0.3s;

  &:focus {
    outline: none;
  }

  &[dense] {
    min-height: 36px;
    padding: 4px 12px;
  }

  &[interactable]:not([aria-disabled='true']) {
    cursor: pointer;

    &:hover {
      background: ${colors.transparent.gray03};
      text-decoration: none;
    }

    /* MenuOverlay ListItems programmatically put focus on the <li> element
     * which in this case is a parent of ListItemCore. We still want to show
     * this focus styling when the <li> gets focus.
     * Also when under MemoryRouter, Links are transformed into buttons, so
     * we need to specify styling to match the designs, else the user agent
     * styles make ListItem look bad in that context.
     */
    li:focus &,
    a:focus &,
    button:focus &,
    &:focus,
    &[itemselected] {
      background: ${colors.transparent.gray05};
    }

    li:focus-visible &,
    a:focus-visible &,
    button:focus-visible &,
    &:focus-visible {
      background: ${colors.transparent.gray05};
    }

    li:focus:not(:focus-visible) &,
    a:focus:not(:focus-visible) &,
    button:focus:not(:focus-visible) &,
    &:focus:not(:focus-visible):not([itemselected]) {
      background: transparent;
      &:hover {
        background: ${colors.transparent.gray03};
      }
      &:active {
        background: ${colors.transparent.gray05};
      }
    }
  }

  &[aria-disabled='true'] {
    cursor: not-allowed;
    color: ${colors.transparent.gray40};
    --text-primary: ${colors.transparent.gray40}; /* Icons use text-primary only */
    --special-type-color: ${colors.transparent.gray40};
    --special-type-secondary-color: ${colors.transparent.gray40};
  }

  &[emphasized]:not([aria-disabled='true']) {
    font-weight: bold;
    color: ${colors.gray100};
  }
`

const textContainerCss = css`
  flex-grow: 2;
  display: flex;
  align-items: center;
  /* Requires min-width of 0 so the ellipses will work */
  min-width: 0;
`

const sideCarCss = css`
  max-height: 56px;
  display: flex;
  align-items: center;

  /* Since the TextBlock on a ListItem has flex-grow: 2, it tries to push the start and end elements to their absolute minimum width,
   * even if it means wrapping the text. flex-shrink of 0 prevents this from forcing text to wrap. */
  flex-shrink: 0;

  &[side='start'] {
    margin-inline-end: 16px;
  }
  &[side='start'][is-icon] {
    margin-inline-start: 8px;
    margin-inline-end: 24px;
  }
  *[dense] &[side='start'][is-icon] {
    margin-inline-start: 0;
  }
  *[dense] &[side='start'] {
    margin-inline-end: 12px;
  }
  &[side='end'] {
    margin-inline-start: 16px;
  }
  /* When checkbox is present and this is the startElement, it needs some spacing between it and the checkbox */
  & + & {
    margin-inline-start: 8px;
  }
`
// When both the endElement and the innerContainer are clickable, we need to
// position the endElement on top of the innerContainer to avoid nested affordances.
const outerSideCarCss = css`
  position: absolute;
  top: calc(50% - 20px);
  inset-inline-end: 20px;

  &[has-overline] {
    top: 16px;
  }

  &[dense] {
    &[has-overline] {
      top: 8px;
    }
  }
`

// This is a spacer used to reserve the space for the endElement
// it is needed because the endElement is absolutely positioned
// on top of the innerContainer when both are clickable - because
// otherwise we would have nested click affordances which is
// an accessibility problem.
const iconSpacer = (
  <div aria-hidden className={sideCarCss} side="end">
    <mediaTypes.Icon Icon={BaseIcon} />
  </div>
)

export const ListItemContext = createContext()

function ListItemCore(
  {
    badgeCount,
    dense = false,
    startElement,
    linkName,
    onClick,
    overline,
    primaryText,
    secondaryText,
    selected,
    endElement,
    disabled = false,
    emphasized,
    focusable: forceFocus = false,
    interactable,
    textId,

    // ListItem needs to be able to pass a contentWrapper to properly construct Links
    // It knows how the Link should be configured, but not where in the DOM it should be
    // placed. This is allows us to solve that problem.
    contentWrapper: ContentWrapper,
    contentWrapperProps,

    // The following are passed down by Autosuggest, and we don't want them to print to the DOM.
    // It is computationally less expensive to mute them here than above, where they are needed.
    globalIndex,
    international,
    tertiaryText,
    isStandard,

    ...props
  },
  ref
) {
  const focusable = Boolean(forceFocus || interactable || onClick)

  const handleOnClick = (event) => {
    if (disabled) {
      return
    }
    linkName &&
      trackEvent({
        event_name: 'click_action',
        link_name: linkName,
      })
    onClick?.(event)
  }

  // Allows spacebar to work, since we're making the container div a button when its clickable (buttons normally work with spacebar)
  const handleKeyEvent = (event) => {
    const { code } = event.nativeEvent
    if (code === 'Space' || code === 'Enter') {
      handleOnClick(event)
      event.preventDefault()
    }
  }

  // We coerce this div into a button so we can have another button (IconButton) within it (normally not allowed)
  const interactableProps = onClick
    ? { onClick: handleOnClick, role: 'button', onKeyDown: handleKeyEvent, 'aria-disabled': disabled.toString() }
    : { 'aria-disabled': disabled.toString() }
  const focusableProps = focusable ? { tabIndex: 0 } : {}

  const textProps = {
    overline,
    primaryText,
    secondaryText,
    badgeCount: endElement?.type === mediaTypes.MetaText ? undefined : badgeCount,
  }

  const endElementIsClickable =
    Boolean(endElement?.props?.onClick) ||
    Boolean(endElement?.props?.to) ||
    Boolean(endElement?.type === mediaTypes.IconButton)
  const endNode = endElement && (
    <div className={sideCarCss} side="end" ref={endElement?.ref}>
      {endElement}
    </div>
  )
  const innerEndNode = endElementIsClickable ? iconSpacer : endNode
  const outerEndNode = endElementIsClickable ? endNode : null

  const value = useMemo(() => ({ dense }), [dense])

  const innerContent = (
    <div
      className={innerContainerCss}
      dense={boolAttr(dense)}
      emphasized={boolAttr(emphasized)}
      {...interactableProps}
      {...focusableProps}
      interactable={boolAttr(interactable)}
      itemselected={boolAttr(selected)}
      {...sanitizeProps(props)}
      ref={ref}
    >
      {startElement && (
        <div className={sideCarCss} side="start" is-icon={boolAttr(startElement.type === mediaTypes.Icon)}>
          {startElement}
        </div>
      )}
      <div className={textContainerCss} id={textId}>
        <TextBlock {...textProps} />
      </div>
      {innerEndNode}
    </div>
  )

  return (
    <ListItemContext.Provider value={value}>
      <div className={outerContainerCss}>
        {ContentWrapper ? (
          <ContentWrapper {...(contentWrapperProps || {})}>{innerContent}</ContentWrapper>
        ) : (
          innerContent
        )}
        {outerEndNode && (
          <div className={outerSideCarCss} has-overline={boolAttr(overline)} dense={boolAttr(dense)}>
            {outerEndNode}
          </div>
        )}
      </div>
    </ListItemContext.Provider>
  )
}

export default forwardRef(ListItemCore)
