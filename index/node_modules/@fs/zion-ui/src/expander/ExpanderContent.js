import React, { useRef, useLayoutEffect } from 'react'
import { useSpring, animated } from '@react-spring/web'
import { cx, css } from '@linaria/core'
import { useEvent, useResizeObserver } from '@fs/zion-frontend-friends'
import PropTypes from 'prop-types'
import { useExpanderContext } from './Expander'
import { Bleed } from '../bleed'

const containerCss = css`
  // This padding repositions the contents when the Bleed takes effect.
  padding: 0 var(--bleedable-sides);

  overflow: hidden;

  // These rules allow negative x-margins to not be hidden during animations
  @supports (overflow: clip) {
    overflow-y: clip;
    overflow-x: unset;
  }
`

const printHeight = css`
  // This is needed just in case someone prints while an expander is animating
  @media print {
    height: auto !important;
  }
`

export default function ExpanderContent({
  children,
  onTransitionEnd,
  collapsedHeight = 0,
  setDoesExpand = () => {},

  ...props
}) {
  const { open: isOpen, ariaControlsId } = useExpanderContext()
  const initializingRef = useRef(isOpen || collapsedHeight > 0)
  const shouldAnimateDuringResizeRef = useRef(false)
  const isExpandableRef = useRef()
  const contentRef = useRef()

  const [animStyles, api] = useSpring(() => ({
    // setting the height to 'auto' allows instant updates to the expander height when the children resize. This also allows the `initiallyOpen` functionality to not animate
    height: isOpen ? 'auto' : collapsedHeight,
    display: isOpen || collapsedHeight ? 'block' : 'none',
    config: {
      precision: 1, // makes the ending of animations a bit smoother (no more slowness)
    },
  }))

  const animateHeight = useEvent((disableOnTransitionEnd) => {
    const clientHeight = contentRef.current.clientHeight
    const maxHeight = Math.max(clientHeight, collapsedHeight)
    const minHeight = Math.min(clientHeight, collapsedHeight)

    // in this case the height is still 'auto' so we need to set the height back to an integer for the api.start method to be able to animate between the values without complaining
    if (!isOpen) api.set({ height: maxHeight })

    api.start({
      height: isOpen ? maxHeight : minHeight,
      onProps: () => {
        // here we enable animating during content resize only during the opening animation and we disable it as soon as the closing animation begins
        shouldAnimateDuringResizeRef.current = isOpen
      },
      onRest: ({ value: { height } }, controller) => {
        shouldAnimateDuringResizeRef.current = false // because the animation has finished, we no longer animate during content resize

        if (isOpen && height) controller.set({ height: 'auto' })
        if (!height) controller.set({ display: 'none' })
        if (!disableOnTransitionEnd) onTransitionEnd?.()
      },
    })
  })

  // Animate the height when opening/closing the expander
  useLayoutEffect(() => {
    // For cases in which there is a collapsedHeight or the expander is initially open but the children are gated by a network request, we cannot allow the spring to animate and set the display to 'none' on the first render or else the expander cannot update when the children are finally loaded
    if (initializingRef.current) {
      initializingRef.current = false
      return undefined
    }

    // Opening animation
    if (isOpen) {
      // We need to change the `display` from `none` to `block` before we start the animation so that the contentRef's clientHeight can be calculated
      api.set({ display: 'block' })
      const request = requestAnimationFrame(() => animateHeight())
      return () => cancelAnimationFrame(request)
    }

    // Closing animation
    animateHeight()
    return undefined
  }, [animateHeight, api, isOpen])

  useResizeObserver(contentRef, (entry) => {
    // Keep height up to date when the expander's children change during the opening animation
    if (shouldAnimateDuringResizeRef.current) animateHeight(true)

    // Update the consumers when the content becomes expandable or not
    const isExpandable = entry.target.clientHeight > collapsedHeight
    if (isExpandable !== isExpandableRef.current) {
      isExpandableRef.current = isExpandable
      setDoesExpand(isExpandable)
    }
  })

  return (
    // This bleed allows the expander to be as wide as it needs to be to completely contain any content that's bleeding out of its container.
    <Bleed sides>
      <animated.div id={ariaControlsId} style={animStyles} className={cx(containerCss, printHeight)}>
        <div ref={contentRef} {...props}>
          {children}
        </div>
      </animated.div>
    </Bleed>
  )
}

ExpanderContent.propTypes = {
  /** The contents of the expander. */
  children: PropTypes.node,
  /** The height of the expandable content when collapsed. Defaults to 0.
   *  NOTE: If the height of the content is less than the collapseHeight, we override the collapsedHeight and use the height of the content instead. */
  collapsedHeight: PropTypes.number,
  /** Optional callback ran each time the expander finishes expanding or collapsing. */
  onTransitionEnd: PropTypes.func,
  /** Sometimes an expander's content is so short that it won't expand (and the expander button won't show). Would you like to know when this happens? Pass a function to this prop and we'll call it when `doesExpand` changes. */
  setDoesExpand: PropTypes.func,
}
