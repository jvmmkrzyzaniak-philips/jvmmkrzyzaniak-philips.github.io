import type { RefObject, ReactNode } from 'react'
import React, { useEffect, useCallback, useRef, useState, createContext } from 'react'
import { css } from '@linaria/core'
import { animated } from '@react-spring/web'
import { sanitizeProps, useResizeObserver, boolAttr } from '@fs/zion-frontend-friends'
import { useTranslation } from 'react-i18next'
import type { Instance } from '@popperjs/core'
import zoomPanMath from './zoomPanMath'
import useKeyboardShortcuts from '../use-keyboard-shortcuts'
import { PopperPortalContext } from '../portal'
import { PopperContext, PopperModifiersContext, zoomPanModifierCreator } from '../popper/PopperContext'
import { colors, useTheme } from '../theme'
import { origins, isCloseEnough } from './useZoomPan'
import useGestures from './events/useGestures'
import type { HandlersType } from '../use-keyboard-shortcuts'
import type {
  ZoomPanRefs,
  ZoomPanController,
  ZoomPanBounds,
  ZoomPanInitial,
  ZoomPanLimits,
  ZoomPanOptions,
  NeverNullRef,
  Rect,
  TransformMatrix,
  ViewOrigin,
  NumOrFunc,
  Point,
} from './types'

export const ZoomPanContext = createContext(false)

const overLayerCss = css`
  z-index: 1;
`
export const overlaysPortalCss = css`
  height: 0; // we need to prevent the portal from adding additional height to the viewer, but 'position: absolute' messes with overlay widths for some reason
  position: relative;
  z-index: 1;
`

export const viewerCss = css`
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: relative;
  z-index: 0; // create a new stacking context
  user-select: none; // Selecting text is super weird when you're zooming and panning.
  touch-action: none; // prevent the browser from handling zooming and panning

  &[parent-scrolls] {
    touch-action: pan-x pan-y; // allow normal page panning, but prevent browser from handling multi-touch
  }

  img {
    pointer-events: none; // Images are dorks. They try to be dragged as ghost images.
  }
`

const stageBackgroundCss = css`
  width: 100%;
  height: 100%;
  flex-grow: 1;
  background: ${colors.gray05};
  [data-theme='night'] & {
    background: ${colors.gray02};
  }
`

const stageCss = css`
  position: absolute;
  top: 0;
  /* DO NOT CHANGE THIS TO "inset-inline-start"! For things to work
   * properly, this needs to be "left", because it relies on transform-origin */
  left: 0;
  transform-origin: top left;
  opacity: 0;
  transition: opacity 0.3s;

  /** NOT SUPPORTED YET:
  *    font-smoothing: antialiased;
  * We have this because when things get transformed, they get aliased by some browsers.
  * This makes things look a little blurry, so we turn on font-smoothing to make it look
  * better. However, this is not supported in all browsers, so we have to use the
  * vendor-prefixed versions. When this is supported in all browsers, we can remove
  * the vendor-prefixed versions.
  */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale; /* yes this will ONLY work on the Mac Firefox - Windows is out of luck */

  [data-ready]& {
    opacity: 1;
  }
`

export type ZoomPanBaseProps = ZoomPanRefs &
  Partial<Exclude<ZoomPanBounds, 'viewerHeight' | 'viewerWidth'>> &
  Partial<ZoomPanInitial> &
  Partial<Omit<ZoomPanOptions, 'isDrawing'>> &
  Partial<Pick<ZoomPanLimits, 'minZoom' | 'maxZoom'>> & {
    /**
     * Use this prop to add any content on top of the content. This content will
     * not be scaled or moved when the ZoomPan is zoomed or panned
     */
    overLayer?: ReactNode

    /**
     * Any items that will exist on the stage, and will be zoomed and panned with the stage
     */
    children?: ReactNode

    /**
     * An event that will fire when a user has clicked on the ZoomPan without dragging
     */
    onClick?: (point: Point) => void
  }

const defaultMatrix: TransformMatrix = [0, 1, 1, 0, 1, 1]

const identity: <T>(input: T) => T = (x) => x

const getOrigin = (input: ViewOrigin): [number, number] => origins[input]

/**
 * Passes all props to the controllerRef
 */
const usePassProps = (
  controllerRef: NeverNullRef<ZoomPanController>,
  propName: keyof ZoomPanController,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I can't figure out a way to do this without using 'any'
  prop: any,
  transform: (input: unknown) => unknown = identity
): void => {
  useEffect(() => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- see above
    ;(controllerRef.current as any)[propName] = transform(prop)
  }, [prop, controllerRef, propName, transform])
}

// Yusing Yuuge is better than infinity, because Infinity - Infinity = NaN
// We want something like Infinity that doesn't cause NaNs during mathy-times
const YUUGE = Number.MAX_SAFE_INTEGER / 10
const worthlessRect: Rect = {
  x: YUUGE,
  y: YUUGE,
  width: -YUUGE,
  height: -YUUGE,
}

function getNumber(val: NumOrFunc | number, refs: ZoomPanRefs): number {
  return typeof val === 'function' ? val(refs) : val
}

const centerX: NumOrFunc = ({ controllerRef: ref }) => ref.current.stageBounds.stageRight / 2
const centerY: NumOrFunc = ({ controllerRef: ref }) => ref.current.stageBounds.stageBottom / 2
const leftSide: NumOrFunc = (refs) =>
  refs.controllerRef.current.stageBounds.stageLeft - getNumber(refs.controllerRef.current.panMarginX, refs)
const rightSide: NumOrFunc = (refs) =>
  refs.controllerRef.current.stageBounds.stageRight + getNumber(refs.controllerRef.current.panMarginX, refs)
const topSide: NumOrFunc = (refs) =>
  refs.controllerRef.current.stageBounds.stageTop - getNumber(refs.controllerRef.current.panMarginY, refs)
const bottomSide: NumOrFunc = (refs) =>
  refs.controllerRef.current.stageBounds.stageBottom + getNumber(refs.controllerRef.current.panMarginY, refs)

type OriginGetters = {
  initialPanX: NumOrFunc
  initialPanY: NumOrFunc
}

const originInitials: Record<ViewOrigin, OriginGetters> = {
  center: {
    initialPanX: centerX,
    initialPanY: centerY,
  },

  top: {
    initialPanX: centerX,
    initialPanY: topSide,
  },

  bottom: {
    initialPanX: centerX,
    initialPanY: bottomSide,
  },

  left: {
    initialPanX: leftSide,
    initialPanY: centerY,
  },

  right: {
    initialPanX: rightSide,
    initialPanY: centerY,
  },
}

export const ZoomPanBase = ({
  minZoom = 0.9,
  maxZoom = 8,
  imageMode = false,
  viewOrigin = 'center',
  initialZoom = 1,
  initialRotation = 0,
  stageTop = 0,
  stageBottom = 100,
  stageLeft = 0,
  stageRight = 100,
  panMarginX = 32,
  panMarginY = 32,
  initialPanX = imageMode ? 0.5 : originInitials[viewOrigin].initialPanX,
  initialPanY = imageMode ? 0.5 : originInitials[viewOrigin].initialPanY,
  scrollMeansZoom = false,
  parentScrolls = false,
  rotate = false,
  controllerRef,
  viewerRef,
  stageRef,
  overLayer,
  children,
  onClick,
  ...props
}: ZoomPanBaseProps): JSX.Element => {
  const [isReady, setIsReady] = useState(false)
  // Don't actually care about storing these values. See huge comment down below.
  const [, setViewerSize] = useState([0, 0])
  const { t } = useTranslation()
  usePassProps(controllerRef, 'minZoom', minZoom)
  usePassProps(controllerRef, 'maxZoom', maxZoom)

  usePassProps(controllerRef, 'isReady', isReady)
  usePassProps(controllerRef, 'scrollMeansZoom', scrollMeansZoom)
  usePassProps(controllerRef, 'parentScrolls', parentScrolls)
  usePassProps(controllerRef, 'rotate', rotate)
  usePassProps(controllerRef, 'origin', viewOrigin, getOrigin)

  usePassProps(controllerRef, 'initialPanX', initialPanX)
  usePassProps(controllerRef, 'initialPanY', initialPanY)
  usePassProps(controllerRef, 'initialZoom', initialZoom)
  usePassProps(controllerRef, 'initialRotation', initialRotation)

  usePassProps(controllerRef, 'panMarginX', panMarginX)
  usePassProps(controllerRef, 'panMarginY', panMarginY)

  useEffect(() => {
    if (controllerRef.current.imageMode !== imageMode) {
      controllerRef.current.math = zoomPanMath({ viewerRef, stageRef: imageMode ? stageRef : viewerRef })
      controllerRef.current.imageMode = imageMode
    }
  }, [imageMode, controllerRef, stageRef, viewerRef])

  const [activePoppers, setActivePoppers] = useState<RefObject<Instance>[]>([])
  const [popperRect, setPopperRect] = useState(worthlessRect)

  const transform = controllerRef.current.springValues.to((...zpArray: [number, number, number, number]) => {
    const matrix = controllerRef.current.math.transformMatrix(zpArray) || defaultMatrix
    return `matrix(${matrix.join(',')})`
  })

  const calculatePopperRect = useCallback(
    (poppers: RefObject<Instance>[]): Rect => {
      const result = { ...worthlessRect }
      if (!viewerRef.current || !stageRef.current) return result
      if (!poppers.length) return result

      poppers.forEach((popper) => {
        const popperNode = popper.current?.state.elements.popper
        if (!popperNode) return
        const { x, y, right, bottom } = popperNode.getBoundingClientRect()
        const popBottom = result.y + result.height
        const popRight = result.x + result.width
        const newBottom = Math.max(bottom, popBottom)
        const newRight = Math.max(right, popRight)
        result.x = Math.min(result.x, x)
        result.y = Math.min(result.y, y)
        result.width = newRight - result.x
        result.height = newBottom - result.y
      })

      const viewRect = viewerRef.current.getBoundingClientRect()
      result.x -= viewRect.x
      result.y -= viewRect.y
      return controllerRef.current.rectFromViewToStage(result, false)
    },
    [controllerRef, stageRef, viewerRef]
  )

  useEffect(() => {
    // if the viewer height or width is 0, a calculation is done later that divides by them which leads to NaNs.
    if (!isReady) return
    controllerRef.current.updateBounds({ stageLeft, stageRight, stageTop, stageBottom }, popperRect)
  }, [popperRect, stageTop, stageBottom, stageLeft, stageRight, isReady, controllerRef, viewerRef])

  useGestures({ controllerRef, viewerRef, stageRef, onClick })

  const onViewerResize = useCallback(() => {
    const controller = controllerRef?.current as ZoomPanController
    const { offsetWidth, offsetHeight } = viewerRef.current as HTMLDivElement
    if (offsetHeight <= 0 || offsetWidth <= 0) return

    // Ok, take some time to understand these words...
    //
    // When we're in image mode, the zoomPanValues are independent of viewer size. If I resize
    // the view, the panX/panY/zoom values don't change. But when we're in non-image mode,
    // we want these values to change when the view changes width or height. The funny thing
    // about react-spring is that if you call spring.set() with values that are exactly the same
    // as what is already set, it's a no-op. HOWEVER, if you trigger a re-render, the animated.div
    // will recalculate things. We are calculating a matrix transform with these values and applying it
    // to an animated.div. So when a resize happens, we MUST trigger a re-render when in image mode,
    // but must NOT trigger a re-render in non-image-mode, but instead tell the controller to update
    // its values based on the new size of the viewer.

    // We MUST calculate currentPublicValues BEFORE changing the viewerWidth and viewerHeight,
    // because we need those values to compare in the `else{}` statement below.
    const currentPublicValues = controller.toPublicValues(controller.currentValues)
    controller.viewerWidth = offsetWidth
    controller.viewerHeight = offsetHeight

    if (imageMode) {
      // Trigger a re-render by calling a setState
      setViewerSize([offsetWidth, offsetHeight])
    } else {
      // Tell the controller what the new values should be, by converting the old values to
      // the public-facing number space, changing the viewer dimensions, then converting
      // the old public-facing values back to the internal number space.
      controller.set(controller.fromPublicValues(currentPublicValues))
    }

    setIsReady(!!offsetHeight && !!offsetWidth)
  }, [imageMode, controllerRef, viewerRef])
  useResizeObserver(viewerRef, onViewerResize)

  // Update the locations of the poppers whenever things change in ZoomPan
  useEffect(() => {
    const controller = controllerRef.current
    const listener = (): void => {
      activePoppers.forEach((instanceRef) => instanceRef.current?.update())
      setPopperRect((prev) => {
        const newPopperRect = calculatePopperRect(activePoppers)
        return isCloseEnough(prev, newPopperRect) ? prev : newPopperRect
      })
    }
    listener()
    controller.addOnChange(listener)
    return () => controller.removeOnChange(listener)
  }, [activePoppers, controllerRef, calculatePopperRect])

  // Change to the initial values on load
  useEffect(() => {
    if (isReady) controllerRef.current.reset(true)
  }, [isReady, controllerRef])

  const overlaysRef = useRef<HTMLDivElement | null>(null)

  const handlers: HandlersType = {
    Equal: {
      action: () => controllerRef.current.zoomIn(),
      title: t('zoom-pan.controls.zoom-in.button', 'Zoom In'),
    },
    Minus: {
      action: () => controllerRef.current.zoomOut(),
      title: t('zoom-pan.controls.zoom-out.button', 'Zoom Out'),
    },
    ArrowUp: {
      shift: {
        action: () => controllerRef.current.panUp(),
        title: t('zoom-pan.controls.pan-up.button', 'Pan Up'),
      },
    },
    ArrowDown: {
      shift: {
        action: () => controllerRef.current.panDown(),
        title: t('zoom-pan.controls.pan-down.button', 'Pan Down'),
      },
    },
    ArrowLeft: {
      shift: {
        action: () => controllerRef.current.panLeft(),
        title: t('zoom-pan.controls.pan-left.button', 'Pan Left'),
      },
    },
    ArrowRight: {
      shift: {
        action: () => controllerRef.current.panRight(),
        title: t('zoom-pan.controls.pan-right.button', 'Pan Right'),
      },
    },
  }

  if (rotate) {
    handlers.Period = {
      shift: {
        action: () => controllerRef.current.rotateRight(),
        title: t('zoom-pan.adjustments.rotate-right.button', 'Rotate Right'),
      },
    }
    handlers.Comma = {
      shift: {
        action: () => controllerRef.current.rotateLeft(),
        title: t('zoom-pan.adjustments.rotate-left.button', 'Rotate Left'),
      },
    }
  }

  useKeyboardShortcuts({
    handlers,
    enabled: true,
  })

  const theme = useTheme()

  return (
    <ZoomPanContext.Provider value>
      <div
        className={viewerCss}
        ref={viewerRef}
        {...sanitizeProps(props)}
        parent-scrolls={boolAttr(parentScrolls)}
        data-theme={theme}
      >
        <div className={overLayerCss}>{overLayer}</div>
        <div className={stageBackgroundCss}>
          <animated.div
            data-ready={boolAttr(isReady)}
            className={stageCss}
            ref={stageRef}
            style={{
              transform,
              width: stageRight,
              height: stageBottom,
            }}
          >
            <PopperContext.Provider value={setActivePoppers}>
              <PopperPortalContext.Provider value={overlaysRef.current || document.body}>
                <PopperModifiersContext.Provider value={zoomPanModifierCreator}>
                  {children}
                </PopperModifiersContext.Provider>
              </PopperPortalContext.Provider>
            </PopperContext.Provider>
          </animated.div>
        </div>
        <div ref={overlaysRef} className={overlaysPortalCss} data-overlays-portal />
      </div>
    </ZoomPanContext.Provider>
  )
}

export default ZoomPanBase
