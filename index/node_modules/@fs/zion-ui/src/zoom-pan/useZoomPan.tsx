import type { MutableRefObject } from 'react'
import React, { useRef, useMemo, useCallback, useState } from 'react'
import type { InferProps } from 'prop-types'
import PropTypes from 'prop-types'
import { useSpring, type AnimationResult } from '@react-spring/web'
import { shallowEqual } from '@fs/zion-frontend-friends'

import zoomPanMath from './zoomPanMath'
import { minMax, limitRotation } from './limiters'
import type {
  Point,
  ZoomPanController,
  ZoomPanArray,
  ZoomPanValues,
  ZoomPanRefs,
  ZoomPanUtils,
  NumOrFunc,
  ViewOrigin,
  ChangeListener,
  NeverNullRef,
  Rect,
} from './types'

const initialStageBounds = { stageLeft: 0, stageRight: 100, stageTop: 0, stageBottom: 100 }

export const isCloseEnough = <T extends Record<string, number>>(a: T, b: T & Record<string, unknown>): boolean => {
  if (a === b) return true
  return Object.keys(a).every((key) => a[key] === b[key] || Math.abs(a[key] - b[key]) <= 1)
}

const equiv = (a: number, b: number): boolean => Math.abs(a - b) < 0.0001

/* react-spring can't handle animatable objects, but it can handle animatable
 * arrays. So we need to convert this to an object before our logic handles it,
 */
const fromArray = ([zoom, panX, panY, rotation]: ZoomPanArray): ZoomPanValues => ({
  zoom,
  panX,
  panY,
  rotation,
})

/**
 * Sometimes the ZoomPan values are calculated with missing information. Examples:
 *  - Before the viewer has been initialized with the size of the canvas
 *  - If the viewer's height is temporarily set to zero (causing division by zeros)
 *  - If the viewer is set to `display: none;`, like when a Suspense is currently loading.
 *
 *  This function prevents the Spring animation system from getting stuck in an unrecoverable
 *  state where the zoomPan values contain NaNs, thus causing future values (often derived
 *  from previous values) to be NaNs.
 */
const isNaNs = ({ zoom = 0, panX = 0, panY = 0, rotation = 0 }: Partial<ZoomPanValues>): boolean =>
  [zoom, panX, panY, rotation].some(Number.isNaN)

const toArray = ({ zoom, panX, panY, rotation }: ZoomPanValues): ZoomPanArray => [zoom, panX, panY, rotation]

const combineZoomPanValues = (currentValues: ZoomPanValues, newValues: Partial<ZoomPanValues>): ZoomPanValues => ({
  panX: newValues.panX || currentValues.panX,
  panY: newValues.panY || currentValues.panY,
  zoom: newValues.zoom || currentValues.zoom,
  rotation: newValues.rotation || currentValues.rotation,
})

type UseSpringType = {
  values: ZoomPanArray
}

export const origins: Record<ViewOrigin, [number, number]> = {
  center: [0, 0],
  top: [0, 0.5],
  left: [0.5, 0],
  bottom: [0, -0.5],
  right: [-0.5, 0],
}

const initial = {
  zoom: 1,
  panX: 0.5,
  panY: 0.5,
  rotation: 0,
}

const DEFAULT_RECT = {
  top: 0,
  left: 0,
  width: 100,
  height: 100,
}

const useZoomPan = (): [ZoomPanRefs, ZoomPanUtils & ZoomPanValues] => {
  const prefersReducedMotion = window?.matchMedia('(prefers-reduced-motion)')?.matches
  const viewerRef = useRef<HTMLDivElement>(null)
  const stageRef = useRef<HTMLDivElement>(null)

  // This is meant as a copy of controllerRef.current.userValues.
  // We keep this copy around to update any consumer of useZoomPan
  // occassionally, and not on every animation frame. Whenever the
  // spring animations settle down, then we update this value, so that
  // consumers will get less-chatty updates if they are watching zoomPan
  // values in useEffects, etc.
  const [stableValues, setStableValues] = useState<ZoomPanValues>(initial)

  let controllerRef: MutableRefObject<ZoomPanController> | null = null

  const [{ values: springValues }, springApi] = useSpring<UseSpringType>(() => ({
    values: toArray(initial),
    onChange: (change) =>
      controllerRef?.current.changeListeners.forEach((listener: ChangeListener) => listener(change)),
  }))

  const getNumber: (val: NumOrFunc) => number = useCallback(
    (val) =>
      typeof val === 'function'
        ? val({ viewerRef, stageRef, controllerRef: controllerRef as MutableRefObject<ZoomPanController> })
        : val,
    [controllerRef, viewerRef, stageRef]
  )

  controllerRef = useRef<ZoomPanController>({
    springValues,
    currentValues: stableValues,
    origin: origins.center,
    imageMode: false,
    minZoom: 0.9,
    maxZoom: 8,
    isInitialized: false,
    panMarginX: 32,
    panMarginY: 32,
    viewerWidth: 100,
    viewerHeight: 100,
    stageBounds: initialStageBounds,
    tempStageBounds: initialStageBounds,
    isReady: false,
    scrollMeansZoom: false,
    parentScrolls: false,
    rotate: false,
    initialPanX: 0,
    initialPanY: 0,
    initialZoom: 1,
    initialRotation: 0,
    isDrawing: false,
    isGesturing: false,

    math: zoomPanMath({ viewerRef, stageRef: viewerRef }),

    get() {
      return fromArray(this.springValues.get())
    },

    changeListeners: new Set<ChangeListener>(),

    addOnChange(changeFn) {
      this.changeListeners.add(changeFn)
      // Update the newly-added function of the current values
      changeFn({ value: { values: springValues.get() } })
    },

    removeOnChange(changeFn) {
      this.changeListeners.delete(changeFn)
    },

    getPanLimits(values) {
      const {
        minPanX: origMinPanX,
        minPanY: origMinPanY,
        maxPanX: origMaxPanX,
        maxPanY: origMaxPanY,
        math,
        viewerWidth,
        viewerHeight,
        panMarginX,
        panMarginY,
      } = this

      if (viewerWidth > 0 && viewerHeight > 0) {
        const [left, top] = math.fromViewToStage(
          viewerWidth - getNumber(panMarginX),
          viewerHeight - getNumber(panMarginY),
          {
            ...values,
            panX: origMinPanX,
            panY: origMinPanY,
          }
        )
        const [right, bottom] = math.fromViewToStage(getNumber(panMarginX), getNumber(panMarginY), {
          ...values,
          panX: origMaxPanX,
          panY: origMaxPanY,
        })
        // When zoomed far-out enough, the max will end up being smaller than the min, because the stage
        // has extra room. When we sort these numbers, it allows the stage to be able to float around in the
        // view even if it's smaller than the view.
        const [minPanX, maxPanX] = [right, left].sort((a, b) => a - b) // numeric, not alphabetic sort
        const [minPanY, maxPanY] = [top, bottom].sort((a, b) => a - b) // numeric, not alphabetic sort
        return { minPanX, minPanY, maxPanX, maxPanY }
      }
      return { minPanX: origMinPanX, minPanY: origMinPanY, maxPanX: origMaxPanX, maxPanY: origMaxPanY }
    },

    limitValues(values) {
      const { zoom, panX, panY, rotation } = values
      const { minZoom, maxZoom } = this

      const correctZoom = minMax(zoom, minZoom, maxZoom)
      const correctRotation = limitRotation(rotation)

      const { minPanX, minPanY, maxPanX, maxPanY } = this.getPanLimits({ ...values, zoom: correctZoom })

      const correctPanX = minMax(panX, minPanX, maxPanX)
      const correctPanY = minMax(panY, minPanY, maxPanY)
      return fromArray([correctZoom, correctPanX, correctPanY, correctRotation])
    },

    start(values) {
      if (isNaNs(values)) return
      const requestedValues = { ...this.currentValues, ...values }
      // Update the zoom/pan values to be within the limits of max and min
      const correctValues = this.limitValues(requestedValues)
      setStableValues(correctValues)

      const doAnimation = (): void => {
        if (isNaNs(correctValues)) return
        this.currentValues = correctValues
        springApi.start({
          values: toArray(correctValues),
          onRest: () => {
            const { rotation } = this.currentValues
            if (-Math.PI > rotation || rotation > Math.PI) {
              // Update the rotation to be something sensible, so resets don't cause crazy-spinning!
              // TODO: Run tests on this sucker. It isn't working all the time. maybe move the logic to `limiters.ts`?
              const rotationReset = (((rotation % (4 * Math.PI)) - 3 * Math.PI) % (Math.PI * 2)) + Math.PI
              const newValues = { ...this.currentValues, rotation: rotationReset }
              this.set(newValues)
              setStableValues(newValues)
            }
          },
        })
      }

      // If some limiting happened, we want to give the user a little bounce animation
      // to help them see that the button (or whatever interaction) was clicked, and the
      // ZoomPan tried to animate to the requested values, but hit the limits.
      // So basically we are going to the requested values for a brief moment, then animating
      // back to the limited values.
      // except for those who have the reduced motion setting on
      if (!shallowEqual(correctValues, requestedValues) && !prefersReducedMotion) {
        springApi.start({ values: toArray(requestedValues) })
        setTimeout(doAnimation, 100)
      } else {
        doAnimation()
      }
    },

    set(values) {
      if (isNaNs(values)) return
      const v = { ...this.currentValues, ...values }
      springApi.start({ values: toArray(v), immediate: true })
      this.currentValues = v

      // Alert all changeListeners
      // @TODO: Do we actually need to do this, or is it being handled in the useSpring already?
      // We know it works when we call `api.start`, but we don't know for sure if it happens on
      // `api.set`
      const change: AnimationResult = { value: { values: springValues.get() } }
      this.changeListeners.forEach((listener: ChangeListener) => listener(change))
    },

    publicSet(values, immediate = false) {
      const newValues = this.limitValues(this.fromPublicValues(values))
      if (immediate) {
        this.set(newValues)
        setTimeout(() => {
          // Doing this inside of a settimeout because we get a https://fb.me/setstate-in-render warning on load
          setStableValues(newValues) // if `immediate` is true, the `set` function won't persist the stable values
        })
      } else {
        this.start(newValues)
      }
    },

    reset(immediate) {
      const { initialPanX, initialPanY, initialZoom } = this

      this.publicSet(
        {
          zoom: getNumber(initialZoom),
          panX: getNumber(initialPanX),
          panY: getNumber(initialPanY),
        },
        immediate
      )
      this.isInitialized = true
    },

    isReset() {
      if (!this.isInitialized) return true
      const { initialPanX, initialPanY, initialZoom } = this
      const { panX, panY, zoom } = this.toPublicValues(this.currentValues)
      return (
        equiv(panX, getNumber(initialPanX)) &&
        equiv(panY, getNumber(initialPanY)) &&
        equiv(zoom, getNumber(initialZoom))
      )
    },

    fromViewToStage(x, y, toPercent = false, withCurrentValues = false): Point {
      const {
        math,
        imageMode,
        viewerHeight,
        viewerWidth,
        stageBounds: { stageRight, stageBottom },
      } = this
      let [stageX, stageY] = math.fromViewToStage(x, y, withCurrentValues ? this.currentValues : this.get())
      if (!imageMode) {
        stageX = (stageX * viewerWidth) / stageRight
        stageY = (stageY * viewerHeight) / stageBottom
      }
      if (!toPercent) return [stageX * stageRight, stageY * stageBottom]
      return [stageX, stageY]
    },

    fromStageToView(x, y, fromPercent = false, withCurrentValues = false): Point {
      const {
        math,
        imageMode,
        viewerHeight,
        viewerWidth,
        stageBounds: { stageRight, stageBottom },
      } = this
      let stageX = x
      let stageY = y
      if (!fromPercent) {
        stageX = x / stageRight
        stageY = y / stageBottom
      }
      if (!imageMode) {
        stageX = (stageX * stageRight) / viewerWidth
        stageY = (stageY * stageBottom) / viewerHeight
      }
      return math.fromStageToView(stageX, stageY, withCurrentValues ? this.currentValues : this.get())
    },

    rectFromStageToView({ x, y, width, height }: Rect, fromPercent): Rect {
      const [left, top] = this.fromStageToView(x, y, fromPercent)
      const [right, bottom] = this.fromStageToView(x + width, y + height, fromPercent)
      const rect = { x: left, y: top, width: right - left, height: bottom - top }

      // if ZoomPan is rotated, the rectangle needs to be normalized
      if (rect.height < 0) {
        rect.y += rect.height
        rect.height = Math.abs(rect.height)
      }
      if (rect.width < 0) {
        rect.x += rect.width
        rect.width = Math.abs(rect.width)
      }

      return rect
    },
    // Convert rectangle values from view to stage coordinates
    rectFromViewToStage({ x, y, width, height }: Rect, toPercent): Rect {
      const [left, top] = this.fromViewToStage(x, y, toPercent)
      const [right, bottom] = this.fromViewToStage(x + width, y + height, toPercent)

      const rect = { x: left, y: top, width: right - left, height: bottom - top }

      // if ZoomPan is rotated, the rectangle needs to be normalized
      if (rect.height < 0) {
        rect.y += rect.height
        rect.height = Math.abs(rect.height)
      }
      if (rect.width < 0) {
        rect.x += rect.width
        rect.width = Math.abs(rect.width)
      }

      return rect
    },

    getBoundingRect(node, toPercent = false, withCurrentValues = false) {
      const { top: vTop, left: vLeft } = viewerRef.current?.getBoundingClientRect() || DEFAULT_RECT
      const rect = node.getBoundingClientRect()
      const [left, top] = this.fromViewToStage(rect.left - vLeft, rect.top - vTop, toPercent, withCurrentValues)
      const [right, bottom] = this.fromViewToStage(rect.right - vLeft, rect.bottom - vTop, toPercent, withCurrentValues)
      return new DOMRect(left, top, right - left, bottom - top)
    },

    anchoredZoom(x, y, newZoom, newRotate) {
      const [panX, panY] = this.math.anchoredZoomRotate(x, y, this.currentValues, newZoom, newRotate)
      return { zoom: newZoom, panX, panY, rotation: newRotate != null ? newRotate : this.currentValues.rotation }
    },

    fromPublicValues(externalValues) {
      const { viewerWidth, viewerHeight, currentValues: current } = this
      if (this.imageMode) return combineZoomPanValues(current, externalValues)

      const [originX, originY] = this.origin
      const { zoom = current.zoom, panX, panY, rotation } = externalValues
      return {
        zoom,
        panX: panX != null ? panX / viewerWidth + originX / zoom : current.panX,
        panY: panY != null ? panY / viewerHeight + originY / zoom : current.panY,
        rotation: rotation != null ? rotation : current.rotation,
      }
    },

    toPublicValues(internalValues) {
      if (this.imageMode) return internalValues
      const { viewerWidth, viewerHeight } = this
      const [viewOriginX, viewOriginY] = this.origin
      const { zoom, panX, panY, rotation } = internalValues
      return {
        zoom,
        panX: viewerWidth * (panX - viewOriginX / zoom),
        panY: viewerHeight * (panY - viewOriginY / zoom),
        rotation,
      }
    },

    updateBounds(stageBounds, { x, y, width, height }) {
      this.stageBounds = stageBounds
      const { stageTop, stageBottom, stageLeft, stageRight } = stageBounds

      const top = Math.min(stageTop, y)
      const bottom = Math.max(stageBottom, y + height)
      const left = Math.min(stageLeft, x)
      const right = Math.max(stageRight, x + width)

      const newTempBounds = { stageTop: top, stageBottom: bottom, stageLeft: left, stageRight: right }
      if (!isCloseEnough(newTempBounds, this.tempStageBounds)) {
        this.tempStageBounds = newTempBounds
        // Trigger a re-calculation of the current values, in case the zoom-pan values are now
        // out of bounds of the new stage size
        if (!this.isGesturing && this.isInitialized) {
          const limitedValues = this.limitValues(this.currentValues)
          // Only call for an animation if the current values are out-of-bounds
          if (!isCloseEnough(limitedValues, this.currentValues)) this.start(this.currentValues)
        }
      }
    },

    get minPanX() {
      const {
        viewerWidth,
        imageMode,
        stageBounds: { stageLeft, stageRight },
        tempStageBounds: { stageLeft: tempStageLeft },
      } = this
      if (!imageMode) return tempStageLeft / viewerWidth
      return tempStageLeft / (stageRight - stageLeft)
    },

    get minPanY() {
      const {
        viewerHeight,
        imageMode,
        stageBounds: { stageTop, stageBottom },
        tempStageBounds: { stageTop: tempStageTop },
      } = this
      if (!imageMode) return tempStageTop / viewerHeight
      return tempStageTop / (stageBottom - stageTop)
    },

    get maxPanX() {
      const {
        viewerWidth,
        imageMode,
        stageBounds: { stageLeft, stageRight },
        tempStageBounds: { stageRight: tempStageRight },
      } = this
      if (!imageMode) return tempStageRight / viewerWidth
      return tempStageRight / (stageRight - stageLeft)
    },

    get maxPanY() {
      const {
        viewerHeight,
        imageMode,
        stageBounds: { stageTop, stageBottom },
        tempStageBounds: { stageBottom: tempStageBottom },
      } = this
      if (!imageMode) return tempStageBottom / viewerHeight
      return tempStageBottom / (stageBottom - stageTop)
    },

    zoomIn() {
      this.start({ zoom: this.currentValues.zoom * 1.3 })
    },

    zoomOut() {
      this.start({ zoom: this.currentValues.zoom / 1.3 })
    },

    rotateLeft() {
      this.start({ rotation: this.currentValues.rotation - Math.PI / 2 })
    },

    rotateRight() {
      this.start({ rotation: this.currentValues.rotation + Math.PI / 2 })
    },

    pan(dirX: 1 | 0 | -1, dirY: 1 | 0 | -1) {
      const { zoom, panX, panY, rotation } = this.currentValues
      const moveX = dirX * Math.cos(rotation) - dirY * Math.sin(-rotation)
      const moveY = dirY * Math.cos(-rotation) - dirX * Math.sin(rotation)
      this.start({ panX: panX + (moveX * 0.3) / zoom, panY: panY + (moveY * 0.3) / zoom })
    },

    panLeft() {
      this.pan(-1, 0)
    },
    panRight() {
      this.pan(1, 0)
    },
    panUp() {
      this.pan(0, -1)
    },
    panDown() {
      this.pan(0, 1)
    },

    panIntoView(rect) {
      // The visibleRect holds the stageValues of what is visible in the viewer with a bit of padding around the edges
      const visibleRect = getVisibleRect(this)

      // If the rect we are panning to cannot not fit inside the visibleRect due to being too far zoomed in,
      // we adjust the zoom and apply it to the visibleRect so that it can fit
      const deltaZoom = getDeltaZoom(this.currentValues.zoom, visibleRect, rect)

      // Then we transform the values of the visibleRect so that the rect we are panning to will be just inside the visible area
      const [left, right] = transformVisibleAxis('x', visibleRect, rect)
      const [top, bottom] = transformVisibleAxis('y', visibleRect, rect)

      // Finally, we animate to the center of the calculated values with the new zoom level
      this.publicSet({
        panX: left && right ? (left + right) / 2 : undefined,
        panY: top && bottom ? (top + bottom) / 2 : undefined,
        zoom: deltaZoom,
      })

      /** HELPER FUNCTIONS BELOW */

      function getVisibleRect(c: ZoomPanController): Rect {
        // Adding the padding here allows the other calculations to result in there always being exactly 16px of padding around the edges after panning,
        // otherwise, adding the padding elsewhere will make the value susceptible to transformations due to zooming
        const padding = 64
        return c.rectFromViewToStage(
          {
            x: padding,
            y: padding,
            width: c.viewerWidth - padding * 2,
            height: c.viewerHeight - padding * 2,
          },
          c.imageMode
        )
      }

      function getDeltaZoom(zoom: number, currentRect: Rect, rectToFit: Rect): number {
        let dZoom = zoom
        if (rectToFit.width > currentRect.width || rectToFit.height > currentRect.height) {
          // zoom out so that the rectToFit's longest edge fits inside the currentRect
          dZoom *= Math.min(currentRect.width / rectToFit.width, currentRect.height / rectToFit.height)

          // then we tranform the currentRect to reflect the new zoom level
          const deltaVisibleWidth = (currentRect.width * zoom) / dZoom
          const deltaVisibleHeight = (currentRect.height * zoom) / dZoom
          currentRect.x -= (deltaVisibleWidth - currentRect.width) / 2
          currentRect.y -= (deltaVisibleHeight - currentRect.height) / 2
          currentRect.width = deltaVisibleWidth
          currentRect.height = deltaVisibleHeight
        }
        return dZoom
      }

      function transformVisibleAxis(
        axis: 'x' | 'y',
        currentRect: Rect,
        rectToFit: Rect
      ): [deltaStart: number | null, deltaEnd: number | null] {
        const edge = axis === 'x' ? 'width' : 'height'
        const [currentStart, currentEnd] = [currentRect[axis], currentRect[axis] + currentRect[edge]]
        const [rectToFitStart, rectToFitEnd] = [rectToFit[axis], rectToFit[axis] + rectToFit[edge]]

        const shouldPanStart = rectToFitStart < currentStart
        const shouldPanEnd = rectToFitEnd > currentEnd

        if (shouldPanStart) {
          const deltaStart = rectToFitStart
          const deltaEnd = currentEnd - (currentStart - deltaStart)
          return [deltaStart, deltaEnd]
        }

        if (shouldPanEnd) {
          const deltaEnd = rectToFitEnd
          const deltaStart = currentStart + (deltaEnd - currentEnd)
          return [deltaStart, deltaEnd]
        }

        /** This scenario should never happen because the visibleRect has already been transformed by the deltaZoom,
          meaning the rect we are panning into view can never be bigger than the visibleRect at this point, so it can't both be lesser and greater than
          the visibleRect bounds */
        // if (shouldPanStart && shouldPanEnd) return [null, null]

        return [null, null]
      }
    },
  })

  const apiFunctions: ZoomPanUtils = useMemo(() => {
    const { current } = controllerRef as MutableRefObject<ZoomPanController>
    return {
      reset: current.reset.bind(current),
      fromViewToStage: (x: number, y: number, toPercent = false) => current.fromViewToStage(x, y, toPercent, true),
      fromStageToView: (x: number, y: number, fromPercent = false) => current.fromStageToView(x, y, fromPercent, true),
      getBoundingRect: (node: HTMLElement, toPercent = false) => current.getBoundingRect(node, toPercent, true),
      anchoredZoom: current.anchoredZoom.bind(current),
      set: current.publicSet.bind(current),
      zoomIn: current.zoomIn.bind(current),
      zoomOut: current.zoomOut.bind(current),
      rotateLeft: current.rotateLeft.bind(current),
      rotateRight: current.rotateRight.bind(current),
      panUp: current.panUp.bind(current),
      panDown: current.panDown.bind(current),
      panLeft: current.panLeft.bind(current),
      panRight: current.panRight.bind(current),
      panIntoView: current.panIntoView.bind(current),
    }
  }, [controllerRef])

  return useMemo(() => {
    const cRef = controllerRef as NeverNullRef<ZoomPanController>
    const controller = cRef.current
    return [
      { viewerRef, stageRef, controllerRef: cRef },
      {
        ...apiFunctions,
        ...controller.toPublicValues(stableValues),
      },
    ]
  }, [stableValues, apiFunctions, controllerRef])
}

export default useZoomPan

const propTypes = {
  /** Reset the ZoomPan component to its initial zoom/pan/rotation props */
  reset: PropTypes.func,

  /** Get the xy position on ZoomPan's stage, given an xy coordinate on the viewer (screen) */
  fromViewToStage: PropTypes.func,

  /** Get the xy position on the viewer (screen), given an xy coordinate of ZoomPan's stage */
  fromStageToView: PropTypes.func,

  /** Get the position and size of a given dom-node, as it relates to ZoomPan's stage */
  getBoundingRect: PropTypes.func,

  /** Ask ZoomPan to update its current values (zoom, panX, panY, rotation). ZoomPan will animate to the requested values */
  set: PropTypes.func,

  /** Indicates if the height and width have been set on initialization */
  isReady: PropTypes.bool,

  /** The current zoom value. This value updates immediatly after `set()` calls, and immediately after a patron finishes a gesture */
  zoom: PropTypes.number,

  /** The current panX value. This value updates immediatly after `set()` calls, and immediately after a patron finishes a gesture */
  panX: PropTypes.number,

  /** The current panY value. This value updates immediatly after `set()` calls, and immediately after a patron finishes a gesture */
  panY: PropTypes.number,

  /** The current rotation value (in radians). This value updates immediatly after `set()` calls, and immediately after a patron finishes a gesture */
  rotation: PropTypes.number,

  /** Ask the viewer to zoom in with animation (as if the + button were clicked) */
  zoomIn: PropTypes.func,

  /** Ask the viewer to zoom out with animation (as if the - button were clicked) */
  zoomOut: PropTypes.func,

  /** Ask the viewer to rotate 90ยบ clockwise with animation. */
  rotateRight: PropTypes.func,

  /** Ask the viewer to rotate 90ยบ counterclockwise with animation. */
  rotateLeft: PropTypes.func,

  /** Ask the viewer to pan right a small amount with animation. */
  panRight: PropTypes.func,

  /** Ask the viewer to pan left a small amount with animation. */
  panLeft: PropTypes.func,

  /** Ask the viewer to pan up a small amount with animation. */
  panUp: PropTypes.func,

  /** Ask the viewer to pan down a small amount with animation. */
  panDown: PropTypes.func,

  /** Ask the viewer to pan the provided rectangle (x, y, width, height) into view. */
  panIntoView: PropTypes.func,
}

type Props = InferProps<typeof propTypes>

export const ZoomPanUtilsProps = ({ ...props }: Props): JSX.Element => <div data-whatever={props.panDown} />

ZoomPanUtilsProps.propTypes = propTypes
