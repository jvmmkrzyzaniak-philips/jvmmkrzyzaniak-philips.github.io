import type { RefObject } from 'react'
import { useState, useCallback, useEffect, useMemo, useRef, useLayoutEffect } from 'react'
import { useEvent } from '@fs/zion-frontend-friends'
import useCancelClickAway from '../../use-click-away/useCancelClickAway'
import type { ZoomPanController, ZoomPanValues, NeverNullRef, Point } from '../types'
import type {
  State,
  PointEmitter,
  GestureEvent,
  ActionType,
  GestureType,
  EventPoint,
  UiPoint,
  ZoomPanEvent,
} from './types'
import { gestureReducer, initialState, useNonRenderingReducer } from './reducer'
import { temperRotation, temperZoom, temperPan } from '../limiters'

const hasWindow = typeof window !== 'undefined'

const hasGestures = hasWindow && typeof window.GestureEvent !== 'undefined'

const ZERO_POINT = {
  top: 0,
  left: 0,
}

const ZERO_UI_POINT = {
  viewX: 0,
  viewY: 0,
  imgX: 0,
  imgY: 0,
}

/**
 * When dragging on these items, panning should not happen.
 * When clicking on these items, onClick should not be invoked.
 */
const draggableSelectors = [
  'a[href]',
  'input:not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])',
  'button',
  '[data-drag-handle]',
  '[role="button"]',
  '[role="checkbox"]',
  '[role="switch"]',
  '[role="slider"]',
  '[role="widget"]',
  '*[contenteditable]',
].join(',')

/** When clicking on these items, onClick should not be invoked. */
const clickableSelectors = [
  '[data-overlays-portal]',
  'iframe',
  'object',
  'embed',
  '[role="dialog"]',
  '[role="button"]',
  'button',
  '*[tabindex]:not([tabindex="-1"])',
].join(',')

const possibleScrollingSelectors = [
  '[data-scrollable]', // ShadowScroller and BorderScroller
  '[role="listbox"] > div', // AutoSuggest's list box
].join(',')

const DBL_CLICK_THRESHOLD = 1.5
const DBL_CLICK_SCALE = 1.8

const WHEEL_SCALE = 0.001

const calcNewZoomPan = (state: State, controller: ZoomPanController): ZoomPanValues | null => {
  const { initialZoomPan, startPoint, currentPoint } = state
  if (!initialZoomPan || !startPoint || !currentPoint) return null

  let { panX, panY, zoom, rotation } = initialZoomPan
  const deltaRotation = (currentPoint.rotation || 0) - (startPoint.rotation || 0)
  rotation = controller.rotate ? temperRotation(initialZoomPan.rotation + deltaRotation) : initialZoomPan.rotation
  if (currentPoint.distance && startPoint.distance) {
    zoom *= currentPoint.distance / startPoint.distance
    const { minZoom = 0.01, maxZoom = 100 } = controller
    zoom = temperZoom(zoom, minZoom, maxZoom)
    ;[panX, panY] = controller.math.anchoredZoomRotate(
      currentPoint.viewX,
      currentPoint.viewY,
      initialZoomPan,
      zoom,
      rotation
    )
  }
  const deltaPanX = currentPoint.imgX - startPoint.imgX
  const deltaPanY = currentPoint.imgY - startPoint.imgY
  panX -= deltaPanX
  panY -= deltaPanY

  // Don't limit pan values if we're only zooming. It jiggles weirdly when you're zooming sometimes
  if (Math.abs(deltaPanX) > 0.01 || Math.abs(deltaPanY) > 0.01) {
    const { minPanX, minPanY, maxPanX, maxPanY } = controller.getPanLimits({ panX, panY, zoom, rotation })
    panX = temperPan(panX, minPanX, maxPanX)
    panY = temperPan(panY, minPanY, maxPanY)
  }

  return { panX, panY, zoom, rotation }
}

// The viewer gets really unstable on devices when we don't debounce
// move and zoom events. Using the animation frame lets the debouncer
// throttle dynamically.
const debounceFrame = <T>(listener: (event: T) => void): ((event: T) => void) => {
  let waiting = false
  return (event: T): void => {
    if (!waiting) {
      listener(event)
      waiting = true
      requestAnimationFrame((): void => {
        waiting = false
      })
    }
  }
}

type EventCondition = (event?: Event) => boolean

const preventDefaults =
  (listener: EventListener, condition: EventCondition = () => true): EventListener =>
  (event) => {
    if (condition(event)) {
      event.preventDefault()
      event.stopPropagation()
    }
    listener(event)
  }

const TO_RADIANS = Math.PI / 180

type UseGesturesProps = {
  controllerRef: NeverNullRef<ZoomPanController>
  viewerRef: RefObject<HTMLDivElement>
  stageRef: RefObject<HTMLDivElement>
  onClick?: (point: Point) => void
}

const isOnClickableElement = (viewerEl: HTMLElement, event?: Event): boolean => {
  if (!event) return false
  const foundElement = (event.target as HTMLElement).closest?.(clickableSelectors)
  return foundElement && viewerEl.contains(foundElement)
}

const isOnDraggableElement = (stageElement: HTMLDivElement, event?: Event): boolean => {
  if (!event) return false
  // Most of the time we want focusable items to prevent dragging, but we don't want to if it is on the stage
  // Fixes https://fhjira.churchofjesuschrist.org/browse/ZIONUI-1596
  if (stageElement.contains(event.target as HTMLElement)) return false
  return !!(event.target as HTMLElement).closest(draggableSelectors)
}

const isOnScrollableElement: EventCondition = (event?: Event) => {
  const scrollingItem = (event.target as HTMLElement).closest(possibleScrollingSelectors)
  return scrollingItem && scrollingItem.scrollHeight > scrollingItem.clientHeight
}

const useGestures = ({ controllerRef, viewerRef, stageRef, onClick }: UseGesturesProps): void => {
  const prefersReducedMotion = window?.matchMedia('(prefers-reduced-motion)')?.matches
  const [gestureType, setGestureType] = useState<GestureType | null>(null)
  const wasDragged = useRef(false)

  const cancelClickAway = useCancelClickAway()

  const update = useEvent((state: State): void => {
    setGestureType(state.gestureType)
    const controller = controllerRef.current
    const { startPoint, currentPoint } = state

    // Update the zoomPan values to respond to user events
    const newZoomPanValue = calcNewZoomPan(state, controller)

    if (newZoomPanValue != null) {
      // we want to make sure that when prefersReducedMotion is true, we don't go past the limits of the zoomPan
      // because we usually animate back to the limits after we stretch beyond them
      controller.set(prefersReducedMotion ? controller.limitValues(newZoomPanValue) : newZoomPanValue)
    } else if (state.gestureType) {
      // If there's no zoomPan value change, (and there's a gestureType) it's because the gesture has just started
      controller.isGesturing = true
      wasDragged.current = false
    } else {
      // If there's no zoomPan value change, (and no gestureType) it's because a gesture has just completed.
      controller.isGesturing = false

      // If we're stretched beyond what's allowed by the limits, animate back!
      controller.start(controller.limitValues(controller.get()))
    }

    // track whether there was any dragging during the gesture
    // ZIONUI-1515 - We want to make sure wasDragged.current doesn't get set when the wheel event happens or ends
    if (
      !wasDragged.current &&
      startPoint &&
      currentPoint &&
      state.gestureType !== 'WHEEL' &&
      state.gestureType !== null
    ) {
      const deltaX = currentPoint.viewX - startPoint.viewX
      const deltaY = currentPoint.viewY - startPoint.viewY
      const delta = Math.sqrt(deltaX ** 2 + deltaY ** 2)
      if (delta > 3) {
        cancelClickAway()
        wasDragged.current = true
      }
    }
  })

  const [stateRef, dispatch] = useNonRenderingReducer(gestureReducer, initialState, update)

  const getAbsolutePixels = useCallback(
    (clientX: number, clientY: number) => {
      const { top, left } = viewerRef.current?.getBoundingClientRect() || ZERO_POINT
      return [clientX - left, clientY - top]
    },
    [viewerRef]
  )

  /**
   * Creates eventlisteners based up on clicks/touches
   */
  const dispatchPoints = useCallback(
    <T extends ZoomPanEvent>(
      type: ActionType,
      gType: GestureType,
      getPoint: PointEmitter<T>,
      shouldDispatch: EventCondition = () => true
    ): EventListener =>
      (event) => {
        if (!shouldDispatch(event)) return
        dispatch({
          type,
          gestureType: gType,
          point: getPoint(event as T),
          zoomPan: controllerRef.current.get(),
          onClickableElement: type === 'POINT_DOWN' && isOnClickableElement(viewerRef.current, event),
          onDraggableElement: type === 'POINT_DOWN' && isOnDraggableElement(stageRef.current, event),
        })
      },
    [dispatch, controllerRef, viewerRef, stageRef]
  )

  /**
   * Calculates extra needed information from regular pointer events (like MouseEvent)
   * from 'clientX' and 'clientY'.
   *
   * Note: This function is also used on individual items from the `touches` property
   * on TouchEvent instances.
   */
  const normalizePoint: PointEmitter<EventPoint> = useCallback(
    ({ clientX, clientY }) => {
      const controller = controllerRef.current
      const zoomPan = stateRef.current.initialZoomPan || controller.get()
      const [viewX, viewY] = getAbsolutePixels(clientX, clientY)
      const [imgX, imgY] = controller.math.fromViewToStage(viewX, viewY, zoomPan)
      return { viewX, viewY, imgX, imgY }
    },
    [controllerRef, getAbsolutePixels, stateRef]
  )

  /**
   * Combines multiple touches into a single normalized point.
   * Just compares the first two points (if more than one are present),
   * finds the midpoint, and calculates the distance/rotation between the two
   */

  const combineTouches: PointEmitter<TouchEvent> = useCallback(
    ({ touches, changedTouches }) => {
      const points = Array.from(touches).map((touch) => normalizePoint(touch))
      const [p1, p2] = points
      // When touch-end happens, no actual touch points are provided, so we just grab the last one from changedTouches
      if (!p1) return normalizePoint(changedTouches[changedTouches.length - 1])
      if (!p2) return p1
      const controller = controllerRef.current
      const viewX = (p1.viewX + p2.viewX) / 2
      const viewY = (p1.viewY + p2.viewY) / 2
      const imgX = (p1.imgX + p2.imgX) / 2
      const imgY = (p1.imgY + p2.imgY) / 2
      const distX = p1.viewX - p2.viewX
      const distY = p1.viewY - p2.viewY
      const distance = Math.sqrt(distX ** 2 + distY ** 2) * controller.math.calcHelperValues().scale
      const rotation = Math.atan2(distY, distX)
      return { viewX, viewY, imgX, imgY, distance, rotation }
    },
    [controllerRef, normalizePoint]
  )

  /**
   * Safari will sometimes do the work of 'combineTouches' for us with GestureEvent,
   * if it's available.
   */
  const touchFromGesture: PointEmitter<GestureEvent> = useCallback(
    (event) => {
      const point = normalizePoint(event)
      point.distance = event.scale * 50
      point.rotation = event.rotation * TO_RADIANS
      return point
    },
    [normalizePoint]
  )

  const wheelListener = useMemo(() => {
    const controller = controllerRef.current
    let timeout: NodeJS.Timeout
    let startedWithZoomyTimes = false
    const endDispatch = (): void => {
      startedWithZoomyTimes = false
      dispatch({ type: 'POINT_UP', gestureType: 'WHEEL', point: stateRef.current.currentPoint })
    }
    return (event: WheelEvent) => {
      if (isOnScrollableElement(event)) return
      const { scrollMeansZoom, parentScrolls } = controller
      if (parentScrolls && !event.metaKey && !event.ctrlKey) return // TODO: Send messaging back to user that they need to use their meta-key (cmd or otherwise)
      const zoomyTimes =
        startedWithZoomyTimes || // in case they let go of a modifier key in the middle of a gesture (necessary for track pad inertia as well)
        event.ctrlKey || // must always happen, see comment below in the zoomytimes section
        (scrollMeansZoom //
          ? !(event.metaKey || event.altKey || event.shiftKey) // true as long as no modifier keys are held
          : event.altKey || event.metaKey) // true if any modifier keys are held (shift key is reserved for panning left and right)

      if (zoomyTimes) startedWithZoomyTimes = true

      if (!stateRef.current.gestureType) {
        const point = normalizePoint(event)
        if (zoomyTimes) point.distance = 100
        dispatch({ type: 'POINT_DOWN', gestureType: 'WHEEL', point, zoomPan: controller.get() })
      }
      const { deltaX, deltaY } = event
      const state = stateRef.current
      const { currentPoint, startPoint, initialZoomPan } = state
      const point: UiPoint = currentPoint || startPoint || ZERO_UI_POINT
      let { viewX, viewY, distance } = point
      if (zoomyTimes) {
        let delta = deltaY
        // The "unofficial" spec states that if the browser detects a pinch-event,
        // The ctrlKey will be set. For more details, see:
        // https://medium.com/@auchenberg/detecting-multi-touch-trackpad-gestures-in-javascript-a2505babb10e
        if (event.ctrlKey) delta *= 10

        // We know this is voodoo, but this is the only way we can get Firefox to be consistent between trackpad and mousewheel
        //
        // Basically, we found that Firefox is not zooming enough when using an external mouse wheel. But fortunately,
        // firefox is the only browser to be setting event.deltaMode when the mouse wheel is in use!
        if (event.deltaMode) delta *= Math.abs(deltaY) * 4

        // The line below fixes these issues that happen on windows pcs when holding ctrl:
        // - When delta is 1000, the distance will be multiplied by 0 and cause no change to the zoom level (ZIONUI-1509)
        // - If the delta is too big, the scrolling will be very jumpy
        delta = Math.max(Math.min(delta, 300), -300)

        // TODO: Review this periodically to see if wheel step values need adjustment
        // (be sure to test when the moon is full and while wearing a headress made of porcupine quills)

        distance = distance || 100
        distance *= 1 - delta * WHEEL_SCALE
      } else {
        // deltaX doesn't get set in windows when holding shift, but deltaY does
        if (event.shiftKey && !deltaX) viewX -= deltaY
        else {
          viewX -= deltaX
          viewY -= deltaY
        }
        distance = undefined
      }
      if (initialZoomPan) {
        const [imgX, imgY] = controller.math.fromViewToStage(viewX, viewY, initialZoomPan)
        dispatch({
          type: 'POINT_MOVE',
          gestureType: 'WHEEL',
          point: { viewX, viewY, imgX, imgY, distance },
        })
      }
      clearTimeout(timeout)
      timeout = setTimeout(endDispatch, 30)
    }
  }, [controllerRef, dispatch, stateRef, normalizePoint])

  // Listeners that stick around for the life of the component (never need to remove them until the component is removed)
  useEffect(() => {
    const controller = controllerRef.current
    let alwaysListening: [keyof HTMLElementEventMap, EventListener][] = []
    const viewer = viewerRef.current

    const shouldDispatchTouches: EventCondition = (event) => {
      const touchEvent = event as TouchEvent
      const { parentScrolls, isDrawing } = controller
      if (touchEvent.touches.length < 2 && (parentScrolls || isDrawing)) return false
      const touchies: Touch[] = Array.from(touchEvent.touches)
      return touchies.some((touch) => touch.target === event?.target)
    }

    alwaysListening = [
      [
        'mousedown',
        dispatchPoints('POINT_DOWN', 'MOUSE', normalizePoint, (event) => {
          return (
            !controller.isDrawing && (event as MouseEvent).button === 0 // Only listen to left-button clicks and not right-clicks. Fixes Zion-UI 1031.
          )
        }),
      ],
      [
        'touchstart',
        dispatchPoints(
          'POINT_DOWN',
          'TOUCH',
          combineTouches,
          (event) => shouldDispatchTouches(event) && !isOnScrollableElement(event)
        ),
      ],
      [
        'wheel',
        preventDefaults(
          wheelListener as EventListener,
          (event) =>
            !isOnScrollableElement(event) &&
            (!controller.parentScrolls || (event as WheelEvent).metaKey || (event as WheelEvent).ctrlKey)
        ),
      ],
      [
        'dblclick',
        (event) => {
          const { onClickableElement, onDraggableElement } = stateRef.current
          if (onClickableElement || onDraggableElement || (event as MouseEvent).button !== 0) return
          const point = { ...normalizePoint(event as MouseEvent), distance: 1 }

          const newPoint = { ...point }
          const initialZoomPan = controller.get()

          newPoint.distance = initialZoomPan.zoom < DBL_CLICK_THRESHOLD ? DBL_CLICK_SCALE : 1 / DBL_CLICK_SCALE

          const newZoomPanValue = calcNewZoomPan(
            { initialZoomPan, startPoint: point, currentPoint: newPoint, drawing: false, gestureType: null },
            controller
          )

          if (newZoomPanValue) controller.start(newZoomPanValue)
        },
      ],
      [
        'click',
        (event) => {
          if (wasDragged.current) {
            wasDragged.current = false
            event.preventDefault()
            event.stopPropagation()
          } else if (onClick) {
            const { onClickableElement, onDraggableElement } = stateRef.current
            if (onClickableElement || onDraggableElement || (event as MouseEvent).button !== 0) return
            const { viewX, viewY } = normalizePoint(event as MouseEvent)
            onClick(controller.fromViewToStage(viewX, viewY, controller.imageMode))
          }
        },
      ],
    ]
    if (hasGestures) {
      alwaysListening.push([
        'gesturestart' as keyof HTMLElementEventMap,
        preventDefaults(dispatchPoints('POINT_DOWN', 'GESTURE', touchFromGesture)),
      ])
    }

    alwaysListening.forEach(([name, listener]) => viewer?.addEventListener(name, listener))

    return () => {
      alwaysListening.forEach(([name, listener]) => viewer?.removeEventListener(name, listener))
    }
  }, [
    viewerRef,
    normalizePoint,
    touchFromGesture,
    combineTouches,
    wheelListener,
    dispatchPoints,
    controllerRef,
    stateRef,
    stageRef,
    onClick,
  ])

  // Listeners that should be turned on only when we're in the middle of a gesture
  const sometimesListening = useMemo((): [keyof HTMLElementEventMap, EventListener][] => {
    const result: [keyof HTMLElementEventMap, EventListener][] = [
      ['mousemove', dispatchPoints('POINT_MOVE', 'MOUSE', normalizePoint)],
      ['touchmove', dispatchPoints('POINT_MOVE', 'TOUCH', combineTouches)],
      ['mouseup', dispatchPoints('POINT_UP', 'MOUSE', normalizePoint)],
      ['touchend', dispatchPoints('POINT_UP', 'TOUCH', combineTouches)],
    ]
    // gesture events only happen on a Mac in Safari if someone uses a trackpad to do two-finger rotate or pinch gestures
    if (hasGestures) {
      result.push([
        'gesturechange' as keyof HTMLElementEventMap,
        preventDefaults(debounceFrame(dispatchPoints('POINT_MOVE', 'GESTURE', touchFromGesture))),
      ])
      result.push([
        'gestureend' as keyof HTMLElementEventMap,
        preventDefaults(dispatchPoints('POINT_UP', 'GESTURE', touchFromGesture)),
      ])
    }
    return result
  }, [normalizePoint, touchFromGesture, combineTouches, dispatchPoints])

  // we need this to be a useLayoutEffect rather than a useEffect otherwise it will not always update quick enough for the listeners to be added,
  // occasionally leading to a `mousedown` event firing without a corresponding 'mouseup' also firing, putting the viewer in a bad state.
  // what to do if this doesn't cut it: We need to add a piece to touchstart and mousedown that adds these other listeners immediately
  useLayoutEffect(() => {
    if (gestureType)
      sometimesListening.forEach(([name, listener]) => hasWindow && window.addEventListener(name, listener))
    else sometimesListening.forEach(([name, listener]) => hasWindow && window.removeEventListener(name, listener))

    return () => {
      sometimesListening.forEach(([name, listener]) => hasWindow && window.removeEventListener(name, listener))
    }
  }, [gestureType, viewerRef, sometimesListening])
}

export default useGestures
