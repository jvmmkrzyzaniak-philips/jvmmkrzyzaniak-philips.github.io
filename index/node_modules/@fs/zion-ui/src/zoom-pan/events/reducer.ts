import type { MutableRefObject } from 'react'
import { useRef, useCallback } from 'react'
import type { State, Action } from './types'

export const initialState: State = {
  gestureType: null,
  drawing: false,
}

export const gestureReducer = (state: State, action: Action): State => {
  const { type, gestureType, point, zoomPan, onClickableElement, onDraggableElement } = action
  const { gestureType: currentGestureType } = state
  switch (type) {
    case 'POINT_DOWN':
      if (currentGestureType && currentGestureType !== gestureType) return state
      return {
        ...state,
        startPoint: point,
        currentPoint: undefined,
        gestureType,
        initialZoomPan: zoomPan,
        onClickableElement,
        onDraggableElement,
      }

    case 'POINT_MOVE':
      if (gestureType !== currentGestureType || state.onDraggableElement) return state
      return { ...state, currentPoint: point }

    case 'POINT_UP':
      if (gestureType !== currentGestureType) return state
      return { ...state, currentPoint: point, initialZoomPan: undefined, gestureType: null }

    default:
      return state
  }
}

/**
 * This is similar to React.useReducer, except it doesn't trigger a re-render
 * with every state update. This is good for rendering performance when you're
 * using non-rendering tools like react-spring's `animated` component.
 *
 * @param reducer the reducer function to use
 * @param startState the initial state
 * @param onUpdate what you'd like to happen when the state changes
 */
export const useNonRenderingReducer = <S, A>(
  reducer: (state: S, action: A) => S,
  startState: S,
  onUpdate: (state: S) => void
): [MutableRefObject<S>, (action: A) => void] => {
  const stateRef = useRef(startState)
  const dispatch = useCallback(
    (action: A): void => {
      const prevState = stateRef.current
      const newState = reducer(prevState, action)
      onUpdate(newState)
      stateRef.current = newState
    },
    [onUpdate, reducer]
  )
  return [stateRef, dispatch]
}
