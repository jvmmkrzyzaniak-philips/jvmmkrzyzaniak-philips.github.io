import type {
  Point,
  ZoomPanValues,
  ZoomPanArray,
  ZoomPanMath,
  ZoomPanRefs as ZpRefs,
  TransformMatrix,
  HelperValues,
} from './types'

const HALF = 0.5

type ZoomPanRefs = Pick<ZpRefs, 'viewerRef' | 'stageRef'>

/**
 * Convert a view-based number space to stage-based
 * @method calcFromViewToStage
 * @param  {Number}   val  the pixel value in question (from the view in the browser)
 * @param  {Number}   pixels the size of the view (whether width or height)
 * @param  {Number}   aspect one part of the aspect ratio of the image... either 1.0 or some number less than 1.0
 * @param  {Number}   zoom   the zoom value of the image on stage
 * @param  {Number}   pan    the pan value of the image on stage between:
 *                              0 (left-or-top edge of image on center of view)
 *                              1 (right-or-bottom edge of image on center of view)
 * @return {Number}          The value on the image that represented by the pixel in view
 */
export const calcFromViewToStage = (val: number, pixels: number, aspect: number, zoom: number, pan: number): number =>
  (val / pixels - HALF) / aspect / zoom + pan

/**
 * Convert the image-space (between 0 and 1) to pixel space
 * @method calcFromStageToView
 * @param  {Number} val    The value representing a spot on the image between 0 and 1
 * @param  {Number} pixels The size in pixels of the view (whether width or height)
 * @param  {Number} aspect one part of the aspect ratio of the image... either 1 or some number less than 1
 * @param  {Number} zoom   the zoom value of the image on stage
 * @param  {Number} pan    the pan value of the image on stage between:
 *                              0 (left-or-top edge of image on center of view)
 *                              1 (right-or-bottom edge of image on center of view)
 * @return {Number}        The pixel value of the image: where it shows in the view
 */
export const calcFromStageToView = (val: number, pixels: number, aspect: number, zoom: number, pan: number): number =>
  ((val - pan) * aspect * zoom + HALF) * pixels

const dummyHelperValues: HelperValues = {
  viewWidth: 100,
  viewHeight: 100,
  stageWidth: 100,
  stageHeight: 100,
  scale: 1,
  aspectX: 1,
  aspectY: 1,
}

const calcHelperValues = ({ viewerRef, stageRef }: ZoomPanRefs): HelperValues => {
  if (!viewerRef.current || !stageRef.current) return dummyHelperValues

  const viewer = viewerRef.current
  const stage = stageRef.current
  const { offsetWidth: viewWidth, offsetHeight: viewHeight } = viewer
  const { offsetWidth: stageWidth, offsetHeight: stageHeight } = stage
  const scale = Math.min(viewWidth / stageWidth, viewHeight / stageHeight)
  const aspectX = (stageWidth * scale) / viewWidth
  const aspectY = (stageHeight * scale) / viewHeight
  return { viewWidth, viewHeight, stageWidth, stageHeight, scale, aspectX, aspectY }
}

/**
 * Calculate the zoom value needed to have the stage completely fill the viewer
 * @method calcFillZoom
 * @param {RefObject} viewerRef The ref for the viewer's dom element
 * @param {RefObject} stageRef  The ref for the viewer's dom element
 * @return {Number}             The zoom value needed to zoom in just enough to fill the whole viewer
 */
export const calcFillZoom = ({ viewerRef, stageRef }: ZoomPanRefs): number => {
  const helperVals = calcHelperValues({ viewerRef, stageRef })
  const { viewWidth, viewHeight, stageWidth, stageHeight } = helperVals
  const zoomVal = Math.max(
    viewWidth / viewHeight / (stageWidth / stageHeight),
    viewHeight / viewWidth / (stageHeight / stageWidth)
  )
  return zoomVal
}

const calcCosineSine = (rotation: number): Point => [Math.cos(rotation), Math.sin(rotation)]

const rotatePoint = (
  x: number,
  y: number,
  rotation: number,
  centerX: number,
  centerY: number,
  direction = 1
): Point => {
  if (rotation === 0) return [x, y]
  const [cos, sin] = calcCosineSine(rotation)
  return [
    centerX + (x - centerX) * cos - (y - centerY) * sin * direction,
    centerY + (x - centerX) * sin * direction + (y - centerY) * cos,
  ]
}

const zoomPanMath = ({ viewerRef, stageRef }: ZoomPanRefs): ZoomPanMath => {
  const fromStageToView = (x: number, y: number, { zoom, panX, panY, rotation }: ZoomPanValues): Point => {
    const { viewWidth, viewHeight, aspectX, aspectY } = calcHelperValues({ viewerRef, stageRef })
    const viewX = calcFromStageToView(x, viewWidth, aspectX, zoom, panX)
    const viewY = calcFromStageToView(y, viewHeight, aspectY, zoom, panY)

    return rotatePoint(viewX, viewY, rotation, viewWidth * HALF, viewHeight * HALF)
  }

  const fromViewToStage = (x: number, y: number, { zoom, panX, panY, rotation }: ZoomPanValues): Point => {
    const { viewWidth, viewHeight, aspectX, aspectY } = calcHelperValues({ viewerRef, stageRef })

    const [rotatedX, rotatedY] = rotatePoint(x, y, rotation, viewWidth * HALF, viewHeight * HALF, -1)

    const stageX = calcFromViewToStage(rotatedX, viewWidth, aspectX, zoom, panX)
    const stageY = calcFromViewToStage(rotatedY, viewHeight, aspectY, zoom, panY)

    return [stageX, stageY]
  }

  const transformMatrix = ([zoom, panX, panY, rotation]: ZoomPanArray): TransformMatrix => {
    const { viewWidth, viewHeight, stageWidth, stageHeight, aspectX, aspectY } = calcHelperValues({
      viewerRef,
      stageRef,
    })
    const [cos, sin] = calcCosineSine(rotation)

    const cosTransform = (cos * zoom * aspectX * viewWidth) / stageWidth
    const sinTransform = (sin * zoom * aspectY * viewHeight) / stageHeight

    const dX = viewWidth * (HALF - panX * aspectX * zoom)
    const dY = viewHeight * (HALF - panY * aspectY * zoom)

    const [rotatedDx, rotatedDy] = rotatePoint(dX, dY, rotation, viewWidth * HALF, viewHeight * HALF)
    return [cosTransform, sinTransform, -sinTransform, cosTransform, rotatedDx, rotatedDy]
  }

  const anchoredZoomRotate = (
    clickX: number,
    clickY: number,
    zpOrig: ZoomPanValues,
    newZoom: number,
    newRotate: number = zpOrig.rotation
  ): Point => {
    // step 1: decide click-distance from center of viewer
    const [centerViewX, centerViewY] = fromStageToView(zpOrig.panX, zpOrig.panY, zpOrig)
    const [clickImgX, clickImgY] = fromViewToStage(clickX, clickY, zpOrig)

    // step 2: temporarily adjust zoom-pan values to put click-position in center of view (get zoomPan of that)
    // step 3: change rotation and zoom from step2, to match arguments
    const intermediateZp: ZoomPanValues = { panX: clickImgX, panY: clickImgY, rotation: newRotate, zoom: newZoom }

    // step 4: adjust zoom-pan values back so that the click-position is back in the same spot
    const newCenterViewX = centerViewX * 2 - clickX
    const newCenterViewY = centerViewY * 2 - clickY
    const result = fromViewToStage(newCenterViewX, newCenterViewY, intermediateZp)
    return result
  }

  const getViewerWidth = (): number => {
    return viewerRef.current ? viewerRef.current.clientWidth : 0
  }

  const getViewerHeight = (): number => {
    return viewerRef.current ? viewerRef.current.clientHeight : 0
  }

  return {
    fromViewToStage,
    fromStageToView,
    transformMatrix,
    anchoredZoomRotate,
    calcHelperValues: () => calcHelperValues({ viewerRef, stageRef }),
    getViewerWidth,
    getViewerHeight,
  }
}

export default zoomPanMath
