import type { Reducer, CSSProperties, ElementType, ReactNode } from 'react'
import React, { forwardRef, useEffect, useReducer, useRef } from 'react'
import type { SpringValues, PickAnimated, UseSpringProps } from '@react-spring/web'
import { useSpring, animated, to } from '@react-spring/web'
import { css } from '@linaria/core'

import { useEvent } from '@fs/zion-frontend-friends'
import type { PolymorphicRef, PolymorphicComponentPropsWithRef } from '../polymorphic-prop-types'

const openCloseAnimWrapperCss = css`
  &:focus {
    outline: none;
  }
`

const deriveTheStyles = <T extends object>(
  derivedStyles: DerivedStylesProps,
  styles: SpringValues<PickAnimated<T>>
): CSSProperties => {
  const derivations = {}
  Object.keys(derivedStyles).forEach((styleName) => {
    const [propNames, deriveFn] = derivedStyles[styleName]
    const propVals = propNames.map((name) => styles[name])
    derivations[styleName] = to(propVals, deriveFn)
  })
  return derivations
}

type DeriveFuntion = (...args: (keyof CSSProperties)[]) => string | number

type DerivedStylesProps = Record<keyof CSSProperties, [(keyof CSSProperties)[], DeriveFuntion]>

type OpenCloseProps = {
  isOpen: boolean
  unmountWhenClosed?: boolean
  openStyles: UseSpringProps
  closeStyles: UseSpringProps
  derivedStyles: DerivedStylesProps
  onOpenFinished: () => void
  onCloseFinished: () => void
  children: ReactNode
}

const noOp = (): void => undefined

type OpenCloseAction = {
  type: 'OPEN_CLOSE'
  isOpen: boolean
}

type TransitioningAction = {
  type: 'TRANSITIONING'
}

type TransitionedAction = {
  type: 'TRANSITIONED'
}

type Action = OpenCloseAction | TransitioningAction | TransitionedAction

type State = {
  /** Whether the open state is open or opening */
  isOpen: boolean

  /** Whether isOpen changed between open and closed */
  transitionRequested: boolean

  /** Whether React Spring is actually animating */
  transitioning: boolean
}

const openCloseReducer = (state: State, action: Action): State => {
  const { type } = action
  const { transitioning } = state
  switch (type) {
    case 'OPEN_CLOSE': {
      const { isOpen } = action
      if (isOpen === state.isOpen) return state
      return {
        isOpen,
        transitionRequested: !transitioning, // If we're actually animating, don't request transitioning to happen
        transitioning,
      }
    }

    case 'TRANSITIONING': {
      if (transitioning) return state
      return { ...state, transitioning: true, transitionRequested: false }
    }

    case 'TRANSITIONED': {
      return { ...state, transitionRequested: false, transitioning: false }
    }

    default: {
      // we are doing an exhaustive check to make sure we don't miss a case
      const exhaustiveCheck: never = action
      throw new Error('unsupported action', exhaustiveCheck)
    }
  }
}

const OpenCloseAnimation = forwardRef(
  <C extends ElementType = 'div'>(
    {
      as,
      isOpen: controlledIsOpen,
      unmountWhenClosed = false,
      openStyles,
      closeStyles,
      derivedStyles,
      onOpenFinished = noOp,
      onCloseFinished = noOp,
      children,
      className,
      ...props
    }: PolymorphicComponentPropsWithRef<C, OpenCloseProps>,
    ref: PolymorphicRef<C>
  ) => {
    const [{ isOpen, transitionRequested, transitioning }, dispatch] = useReducer<Reducer<State, Action>>(
      openCloseReducer,
      {
        isOpen: controlledIsOpen,
        transitionRequested: true, // because we just mounted
        transitioning: false,
      }
    )

    // Checking to see if this hook was unmounted
    const isMountedRef = useRef(false)
    useEffect(() => {
      isMountedRef.current = true
      return () => {
        isMountedRef.current = false
      }
    }, [])

    useEffect(
      () => isMountedRef.current && dispatch({ type: 'OPEN_CLOSE', isOpen: controlledIsOpen }),
      [controlledIsOpen]
    )

    const handleTransitioned = useEvent(() => {
      if (isOpen) onOpenFinished()
      else onCloseFinished()
    })

    useEffect(() => {
      if (!transitioning && !transitionRequested) handleTransitioned()
    }, [isOpen, transitioning, transitionRequested, handleTransitioned])

    const renderChildren = isOpen || transitioning || !unmountWhenClosed

    const styleProps = useSpring({
      ...(isOpen ? openStyles : closeStyles),
      from: closeStyles,
      onRest: () => isMountedRef.current && dispatch({ type: 'TRANSITIONED' }),
      onChange: () => isMountedRef.current && dispatch({ type: 'TRANSITIONING' }),
      immediate: (name) => ['pointerEvents'].includes(name),
    })

    const AnimatedWrapper = animated(as || 'div')

    return (
      // @ts-expect-error -- This works, but I don't know how to make the TS work.
      <AnimatedWrapper
        {...props}
        className={className || openCloseAnimWrapperCss}
        ref={ref}
        style={{
          ...styleProps,
          ...(derivedStyles ? deriveTheStyles(derivedStyles, styleProps) : {}),
        }}
      >
        {renderChildren ? children : null}
      </AnimatedWrapper>
    )
  }
)

export default OpenCloseAnimation
