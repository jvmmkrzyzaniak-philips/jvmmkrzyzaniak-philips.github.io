import React, { Children, cloneElement, isValidElement, useContext, useMemo } from 'react'
import PropTypes from 'prop-types'
import { css, cx } from '@linaria/core'
import { Observable, boolAttr, sanitizeProps } from '@fs/zion-frontend-friends'
import { usePageWidth, useWidth, gutters as responsiveGutter } from '../responsive'
import GridContext from '../grid/GridContext'
import Ghost from '../ghost'
import ResponsiveCellProvider from '../grid/ResponsiveCellProvider'
import { PageWidthContext } from '../responsive/usePageWidth'
import { gridlikeCss, cellAlignmentCss } from '../grid/Grid'
import { colors } from '../theme'

const gridCss = css`
  --grid-width-and-margins: calc(var(--grid-width) + var(--gutters-x) * 2);
  --cell-width: calc(var(--grid-width-and-margins) / var(--column-count) - (var(--gutters-x) * 2));
  --grid-align: stretch;
  --grid-justify: var(var(--grid-justify), start);
  gap: calc(var(--gutters-y) * 2) calc(var(--gutters-x) * 2);

  &[align-y='middle'] {
    --grid-justify: center;
  }

  &[align-y='bottom'] {
    --grid-justify: end;
  }

  &[orientation='horizontal'] {
    display: flex; /* It's all a lie!!!!! */
    flex-direction: row;
    flex-wrap: wrap;

    &[last-row-align='center'] {
      justify-content: center;
    }
    &[last-row-align='end'] {
      justify-content: flex-end;
    }
  }
  &[orientation='vertical'] {
    column-count: var(--column-count);
    margin: calc(var(--gutters-y) * -1) 0;
  }
`

const cellCss = css`
  position: relative;
  /** The next two lines allow items to match their neighbor's height if someone passes in flex-grow/shrink */
  display: flex;
  flex-direction: column;

  /* noGrowY requires an explicit alignment for the container to size correctly */
  &[no-grow-y] {
    --grid-align: var(--grid-justify);
  }

  [orientation='horizontal'] > & {
    /*
     * Please NOTE:
     *
     * The Line below looks a lot like the --cell-width variable above. Unfortunately we can't just use it
     * here, because it will fail in DialogOverlay. Normally, we have a <GridStart> nested directly inside
     * of a <ResponsiveProvider>. But we can't do that in DialogOverlay without introducing strobing problems.
     */
    width: calc((100% + var(--gutters-x) * 2) / var(--column-count) - (var(--gutters-x) * 2));
    /* width: var(--cell-width); */ /* maybe someday. If we can have the organization start using the aspect-ratio rule */
  }
  [last-row-align='stretch'] > & {
    flex-grow: 1;
  }
  [orientation='vertical'] > & {
    display: inline-block; /* This is to prevent breaks in the cells when the device is a very-small size. */
    break-inside: avoid;
    margin: var(--gutters-y) 0;
    width: 100%;
  }

  [borders-x] &:before,
  [borders-y] &:after {
    content: '';
    position: absolute;
    background: ${colors.transparent.gray10};
  }

  [borders-x] &:not([last-row]):before {
    width: 100%;
    height: 1px;
    bottom: calc(var(--gutters-y) * -1);
    inset-inline-start: 0;
  }

  [borders-x='full'] &:not([last-row]):before {
    inset-inline-start: calc(var(--gutters-x) * -1);
    width: calc(100% + var(--gutters-x) * 2);
  }

  [borders-y] &:not([last-col]):after {
    width: 1px;
    height: 100%;
    top: 0;
    inset-inline-end: calc(var(--gutters-x) * -1);
  }

  [borders-y='full'] &:not([last-col]):after {
    top: calc(var(--gutters-y) * -1);
    height: calc(100% + var(--gutters-y) * 2);
  }

  &:empty {
    display: none;
  }
`

const FlowGridPartition = ({
  children,
  orientation,
  lastRowAlignX,
  heightEstimate,
  keepVisible,
  columnCount,
  last,
}) => {
  const TagName = heightEstimate ? Ghost : 'div'
  const tagProps = heightEstimate ? { heightEstimate, keepVisible } : {}
  const childrenArray = Children.toArray(children)
  const rowCount = Math.ceil(childrenArray.length / columnCount)
  return (
    <div className={cx(gridCss, gridlikeCss)} last-row-align={lastRowAlignX} orientation={orientation}>
      {childrenArray.map((child, index) => {
        // Don’t wrap children that React ignores:
        // https://reactjs.org/docs/jsx-in-depth.html#booleans-null-and-undefined-are-ignored
        if (typeof child === 'boolean' || child == null) return child

        const key = child?.key
        const { alignY, noGrowY, order, ...rest } = child?.props ?? {}
        const clonedChild = isValidElement(child) ? cloneElement({ ...child, props: rest }) : child
        return (
          <TagName
            key={key}
            className={cx(cellCss, cellAlignmentCss)}
            align-y={alignY || 'top'}
            no-grow-y={boolAttr(noGrowY)}
            style={order ? { order } : undefined}
            last-row={boolAttr(
              orientation === 'horizontal' ? last && index / columnCount >= rowCount - 1 : (index + 1) % rowCount === 0
            )}
            last-col={boolAttr(
              ((rowCount === 1 || lastRowAlignX !== 'start') && index === childrenArray.length - 1) ||
                (orientation === 'horizontal'
                  ? (index + 1) % columnCount === 0
                  : last && index / rowCount >= columnCount - 1)
            )}
            {...tagProps}
          >
            {clonedChild}
          </TagName>
        )
      })}
    </div>
  )
}

const partitionGridItems = (items, columnCount) => {
  const maxItemCount = 100
  let cardCount = items.length
  if (cardCount > maxItemCount) cardCount = Math.round(maxItemCount / columnCount) * columnCount
  return items.reduce((itemPartition, item, index) => {
    const needsNewPartition = index % cardCount === 0
    if (needsNewPartition) itemPartition.push([])
    const partitionItems = itemPartition[itemPartition.length - 1]
    partitionItems.push(item)
    return itemPartition
  }, [])
}

const GhostedFlowGridPartition = ({
  itemHeightEstimate,
  columnCount,
  keepVisible,
  orientation,
  lastRowAlignX,
  guttersY,
  children,
}) => {
  const heightEstimate = useMemo(() => {
    let estimate = itemHeightEstimate
    if (typeof itemHeightEstimate === 'string') {
      estimate = parseInt(itemHeightEstimate, 10)
    }
    return estimate
  }, [itemHeightEstimate])

  const partitions = useMemo(() => {
    const losNiños = Children.toArray(children)
    return partitionGridItems(losNiños, columnCount)
  }, [children, columnCount])

  const { spacers } = useContext(PageWidthContext)

  return (
    <Observable rootMargin="100%">
      {partitions.map((partitionItems, index) => {
        const partitionRowCount = Math.ceil(partitionItems.length / columnCount)
        return (
          <Ghost
            key={index} // eslint-disable-line react/no-array-index-key -- There's no other option
            heightEstimate={(heightEstimate + spacers[guttersY]) * partitionRowCount}
            keepVisible={keepVisible}
            className={gridlikeCss}
          >
            <FlowGridPartition
              columnCount={columnCount}
              orientation={orientation}
              lastRowAlignX={lastRowAlignX}
              heightEstimate={heightEstimate}
              keepVisible={keepVisible}
              last={index === partitions.length - 1}
            >
              {partitionItems}
            </FlowGridPartition>
          </Ghost>
        )
      })}
    </Observable>
  )
}

// FlowGridBase is for internal use only. Most of the time, consumers should be restricted to the following column counts:
// 1, 2, 3, 4, 6, 12
// There may be use-cases that allow any column count: i.e., ImageViewer's ImageGrid.
const FlowGridBase = ({
  as,
  columnCount = 1,
  orientation = 'horizontal',
  itemHeightEstimate,
  keepVisible,
  gutters = 'sm',
  guttersY = gutters,
  guttersX = gutters,
  children,
  lastRowAlignX = 'start',
  bordersX,
  bordersY,
  ...props
}) => {
  const TagName = as || 'div'
  const actualColumns = 12 / columnCount
  const atWidth = usePageWidth()
  const width = useWidth()
  const currentGutter = atWidth(responsiveGutter[gutters])
  const cellWidth = (width + currentGutter * 2) / columnCount - currentGutter * 2

  return (
    <ResponsiveCellProvider width={cellWidth}>
      <GridContext.Provider value={actualColumns}>
        <TagName
          {...sanitizeProps(props)}
          style={{
            '--column-count': columnCount,
            '--gutters-x': `calc(var(--spacer-${guttersX}) / 2)`,
            '--gutters-y': `calc(var(--spacer-${guttersY}) / 2)`,
          }}
          borders-x={bordersX === 'full' ? 'full' : boolAttr(bordersX)}
          borders-y={bordersY === 'full' ? 'full' : boolAttr(bordersY)}
        >
          {itemHeightEstimate && orientation === 'horizontal' ? (
            <GhostedFlowGridPartition
              {...{ itemHeightEstimate, columnCount, keepVisible, orientation, lastRowAlignX, guttersY }}
            >
              {children}
            </GhostedFlowGridPartition>
          ) : (
            <FlowGridPartition
              orientation={orientation}
              columnCount={columnCount}
              lastRowAlignX={lastRowAlignX}
              keepVisible={keepVisible}
              last
            >
              {children}
            </FlowGridPartition>
          )}
        </TagName>
      </GridContext.Provider>
    </ResponsiveCellProvider>
  )
}

const FlowGrid = ({
  as = 'div',
  columnCount = 1,
  orientation = 'horizontal',
  itemHeightEstimate,
  gutters = 'sm',
  guttersY = gutters,
  keepVisible = false,
  lastRowAlignX = 'start',
  ...props
}) => {
  return (
    <FlowGridBase
      as={as}
      columnCount={columnCount}
      orientation={orientation}
      itemHeightEstimate={itemHeightEstimate}
      gutters={gutters}
      guttersY={guttersY}
      keepVisible={keepVisible}
      lastRowAlignX={lastRowAlignX}
      {...props}
    />
  )
}

export { FlowGrid, FlowGridBase }

FlowGrid.propTypes = {
  /** Define a custom tag-name to use (or component) */
  as: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType]),

  /** Number of columns in the FlowGrid */
  columnCount: PropTypes.oneOf([1, 2, 3, 4, 6, 12]),

  /** Direction that the children components are laid out */
  orientation: PropTypes.oneOf(['horizontal', 'vertical']),

  /** Determines how much space there is between cells in the grid */
  gutters: PropTypes.oneOf(['xxl', 'xl', 'lg', 'md', 'sm', 'xs', 'xxs', 'nano', 'pico']),

  /** Determines how much space there is horizontally between cells in the grid (defaults to gutters) */
  guttersX: PropTypes.oneOf(['xxl', 'xl', 'lg', 'md', 'sm', 'xs', 'xxs', 'nano', 'pico', 'none']),

  /** Determines how much space there is vertically between cells in the grid (defaults to gutters) */
  guttersY: PropTypes.oneOf(['xxl', 'xl', 'lg', 'md', 'sm', 'xs', 'xxs', 'nano', 'pico', 'none']),

  /** If you'd like to incorporate Ghosting into the FlowGrid, you'll need to provide a number here, so FlowGrid knows what to pass to each Ghost. */
  itemHeightEstimate: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Allow Ghost contents to remain in memory to avoid being loaded again. */
  keepVisible: PropTypes.bool,

  /** Aligns the last row along the X axis. Not supported in Vertical orientation */
  lastRowAlignX: PropTypes.oneOf(['start', 'center', 'end', 'stretch']),

  /**
   * Whether to put horizontal borders between rows
   *
   * If you set the property to "full", the borders will try to connect between columns.
   * If you just set it to `true`, the vertical gutters will stay clear.
   */
  bordersX: PropTypes.oneOf([false, true, 'full']),

  /**
   * Whether to put vertical borders between columns
   *
   * If you set the property to "full", the borders will try to connect between rows.
   * If you just set it to `true`, the horizontal gutters will stay clear.
   */
  bordersY: PropTypes.oneOf([false, true, 'full']),
}

export const FlowGridChild = (props) => <div {...props} />

FlowGridChild.propTypes = {
  /** Vertical alignment options. Defaults to 'top'. This property is ignored if noGrowY is false. */
  alignY: PropTypes.oneOf(['top', 'middle', 'bottom']),

  /** Whether to **not** stretch the content vertically to match neighboring cells. The vertical alignment is set by alignY, which defaults to 'top'. */
  noGrowY: PropTypes.bool,

  /**
   * Set a specific order placement inside of the Row
   *
   * If you set this value to something positive, it will be placed after all other items
   * that don't have an order property. If you set it to something <= 0, it will be placed
   * before all other items that don't have an order property.
   */
  order: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
}
