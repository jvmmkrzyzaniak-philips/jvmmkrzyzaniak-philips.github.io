import type { ElementType } from 'react'
import React, { Children, cloneElement, forwardRef, isValidElement } from 'react'
import { css, cx } from '@linaria/core'
import type { InferProps, ReactElementLike } from 'prop-types'
import PropTypes from 'prop-types'
import { boolAttr } from '@fs/zion-frontend-friends'
import { gridlikeCss } from '../grid/Grid'
import LabelSpacer from '../input-label/LabelSpacer'
import type { PolymorphicRef, PolymorphicComponentPropsWithRef } from '../polymorphic-prop-types'

const rowCss = css`
  display: flex;
  min-width: 0; /* Allow ellipsis to work in some cases */
  gap: calc(var(--gutters-y) * 2) calc(var(--gutters-x) * 2);

  &[wrap='true'] {
    flex-wrap: wrap;
  }
  &[wrap='reverse'] {
    flex-wrap: wrap-reverse;
  }
  &[align-x='center'] {
    justify-content: center;
  }
  &[align-x='end'] {
    justify-content: flex-end;
  }
  &[align-y='middle'] {
    align-items: center;
  }
  &[align-y='bottom'] {
    align-items: flex-end;
  }
`

// exported for test purposes
export const cellCss = css`
  /** The next two lines are needed to vertically align content,
  * as well as match their neighbor's height if someone passes 
  * in flex-grow/shrink */
  display: flex;
  flex-direction: column;

  min-width: 0;

  /* In the case the component that this gets wrapped around doesn't return anything (e.g. it returns null),
   * we need this element to not take up any space or columns. We don't allow free-loaders.
   */
  &:empty {
    display: none;
  }

  &[grow-x] {
    flex-grow: 1;
  }
  &[no-shrink-x] {
    flex-shrink: 0;
  }
  &[no-grow-y] {
    align-self: start;
  }
  &[align-y='middle'] {
    align-self: center;
  }
  &[align-y='bottom'] {
    align-self: flex-end;
  }
`
const propTypes = {
  /** Any collection of items you wish to be placed in a row with spacing between each item. */
  children: PropTypes.node,

  /** Spacing between items */
  gutters: PropTypes.oneOf(['xxl', 'xl', 'lg', 'md', 'sm', 'xs', 'xxs', 'nano', 'pico', 'none'] as const),

  /** Horizontal spacing between items (matches 'gutters' if not provided) */
  guttersX: PropTypes.oneOf(['xxl', 'xl', 'lg', 'md', 'sm', 'xs', 'xxs', 'nano', 'pico', 'none'] as const),

  /** Vertical spacing between items (matches 'gutters' if not provided) */
  guttersY: PropTypes.oneOf(['xxl', 'xl', 'lg', 'md', 'sm', 'xs', 'xxs', 'nano', 'pico', 'none'] as const),

  /** Whether the Row should wrap its content. If the content doesn't wrap it will use flex-box to keep the content on one line. */
  wrap: PropTypes.oneOf([true, false, 'reverse'] as const),

  /** Horizontal alignment of children */
  alignX: PropTypes.oneOf(['start', 'center', 'end'] as const),

  /** Vertical alignment of children */
  alignItemsY: PropTypes.oneOf(['top', 'middle', 'bottom'] as const),

  /**
   * Alias for `alignItemsY`, except for when Row is a child of another Row.
   * In that case, use alignY to align the container Row within its parent Row
   * and use alignItemsY to align the children of the container Row.
   */
  alignY: PropTypes.oneOf(['top', 'middle', 'bottom'] as const),

  /**
   * Define a custom tag-name to use
   * @default "div"
   */
  as: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType]),

  /**
   * Define a custom wrapper to go around each child in the Row.
   * @default "div"
   */
  ChildWrapper: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType]),
}

export const Row = forwardRef(
  <C extends ElementType = 'div'>(
    {
      children,
      as,
      ChildWrapper = 'div',
      wrap,
      gutters = 'sm',
      guttersX = gutters,
      guttersY = gutters,
      alignX = 'start',
      alignY = 'top',
      alignItemsY = alignY,
      className,
      style, // eslint-disable-line @typescript-eslint/no-unused-vars -- Ignoring
      ...props
    }: PolymorphicComponentPropsWithRef<C, Omit<InferProps<typeof propTypes>, 'as'>>,
    ref: PolymorphicRef<C>
  ): JSX.Element => {
    const TagName = as || 'div'
    return (
      <TagName
        ref={ref}
        className={cx(rowCss, gridlikeCss, className)}
        wrap={wrap?.toString()}
        align-x={alignX}
        align-y={alignItemsY}
        style={{
          '--gutters-x': `calc(var(--spacer-${guttersX}) / 2)`,
          '--gutters-y': `calc(var(--spacer-${guttersY}) / 2)`,
        }}
        {...props}
      >
        {Children.map(children, (child: ReactElementLike) => {
          // Don't wrap children that React ignores:
          // https://reactjs.org/docs/jsx-in-depth.html#booleans-null-and-undefined-are-ignored
          if (typeof child === 'boolean' || child == null) return child

          const key = child?.key
          const {
            alignY: alignSelfY,
            growX,
            noShrinkX,
            noGrowY,
            order,
            ...rest
          } = (child?.props ?? {}) as {
            alignY?: string
            growX?: boolean
            noShrinkX?: boolean
            noGrowY?: boolean
            order?: number
          }
          const spacer = alignSelfY === 'nextToInput' ? <LabelSpacer /> : null
          const clonedChild = isValidElement(child) ? cloneElement({ ...child, props: rest }) : child
          return (
            <ChildWrapper
              key={key}
              className={cellCss}
              align-y={alignSelfY}
              grow-x={boolAttr(growX)}
              no-shrink-x={boolAttr(noShrinkX)}
              no-grow-y={boolAttr(noGrowY)}
              style={order ? { order } : undefined}
            >
              {spacer}
              {clonedChild}
            </ChildWrapper>
          )
        })}
      </TagName>
    )
  }
)

export default Row

Row.propTypes = propTypes

/**
 * ### _Row is used for aligning things horizontally without adhering to the 12 column grid._
 * */
export const RowPropsTableComponent = (props: InferProps<typeof propTypes>): JSX.Element => <div>{props}</div>

const rowChildPropTypes = {
  /** Vertical alignment */
  alignY: PropTypes.oneOf(['top', 'middle', 'bottom', 'nextToInput']),

  /** Whether to stretch the content horizontally to fill available space */
  growX: PropTypes.bool,

  /** Whether to prevent this item from shrinking horizontally if space runs out (flex-shrink: 0) */
  noShrinkX: PropTypes.bool,

  /** Whether to **not** stretch the content vertically to match neighboring cells */
  noGrowY: PropTypes.bool,

  /**
   * Set a specific order placement inside of the Row
   *
   * If you set this value to something positive, it will be placed after all other items
   * that don't have an order property. If you set it to something <= 0, it will be placed
   * before all other items that don't have an order property.
   */
  order: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
}
export const RowChild = (props: InferProps<typeof rowChildPropTypes>): JSX.Element => <div>{props}</div>
