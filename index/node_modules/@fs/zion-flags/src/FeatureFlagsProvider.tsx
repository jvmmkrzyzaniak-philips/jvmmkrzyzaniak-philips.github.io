import type { ComponentType, PropsWithChildren, Dispatch, SetStateAction, ElementType, ReactNode } from 'react'
import React, { createContext, useContext, useEffect, useMemo, useReducer, useRef, useState } from 'react'
import { css } from '@linaria/core'
import { SplitFactory, useClient } from '@splitsoftware/splitio-react'
import type { ISplitFactoryProps } from '@splitsoftware/splitio-react/types/types'
import { getStandardAttributes } from '@fs/flags-js/react'
import { splitioAuthKey } from '@fs/zion-config'
import zionDebug, { debugVerbose as zionDebugVerbose } from '@fs/zion-debug'
import { NoticeLoading } from '@fs/zion-icon'
import { toSplitIOFeatures } from '@fs/flags-js'
import { i18n } from '@fs/zion-locale'
import type { Flags, StandardAttributes } from './model'
import { flagsAreReady } from './flagsJsHelper'
import useLocalStorageFlags from './overrides/useLocalStorageFlags'

const debug = zionDebug('zion:flags:provider')
const debugVerbose = zionDebugVerbose('zion:flags:provider')
const FLAGS_READY_TIMEOUT = 10000 // this matches the split.io default timeout
const SPLIT_PROXY_URL = typeof process !== 'undefined' ? process?.env?.REACT_APP_SPLIT_PROXY_URL : undefined

export type FeatureFlagsContextValue = {
  sdkConfig: SetStateAction<Partial<ISplitFactoryProps>>
  standardAttributes: StandardAttributes
  flagOverrides: Flags
  setFlagOverrides: Dispatch<SetStateAction<Flags>>
  mockFlags?: Flags
  setClients: Dispatch<SetStateAction<ClientState['clients']>>
  clients: Record<string, SplitIO.IClient | null>
}

export const FeatureFlagsContext = createContext<FeatureFlagsContextValue | undefined>(undefined)

function FeatureFlagsProviderBase({
  context,
  enableRealtime,
  LoadingFallback,
  children,
}: {
  context: FeatureFlagsContextValue
  LoadingFallback: ElementType
  enableRealtime: boolean
  children: ReactNode
}): JSX.Element {
  const { sdkConfig } = context || {}
  debugVerbose('Rendering FeatureFlagsProviderBase with sdkConfig:', sdkConfig, 'enableRealtime:', enableRealtime)
  return (
    <FeatureFlagsContext.Provider value={context}>
      {sdkConfig ? (
        <SplitFactory {...sdkConfig} updateOnSdkTimedout updateOnSdkUpdate={enableRealtime}>
          <>{children}</>
        </SplitFactory>
      ) : (
        <LoadingFallback />
      )}
    </FeatureFlagsContext.Provider>
  )
}

/**
 * The FeatureFlagsProvider renders the SplitFactory at the base of the Provider tree.
 * It holds on to the precomputed StandardAttributes, any overridden Attributes created
 * by the FlagOverride user interface, and any localhost Attributes.
 * These are used by the hook to generate the final flag treatment values.
 */
type FeatureFlagsProviderProps = PropsWithChildren<{
  authKey?: string
  mockFlags?: Flags | Promise<Flags>
  enableRealtime?: boolean
  debugSdk?: boolean
  impressionListener?: { logImpression: (impression: object) => void }
  LoadingFallback?: ComponentType
}>

export default function FeatureFlagsProvider({
  authKey = splitioAuthKey,
  mockFlags,
  enableRealtime = true,
  debugSdk,
  LoadingFallback = LoadingSpinner,
  impressionListener,
  children,
}: FeatureFlagsProviderProps): JSX.Element {
  debugVerbose('FeatureFlagsProvider start with:', { mockFlags, enableRealtime, debugSdk })
  const [standardAttributes, setStandardAttributes] = useState<StandardAttributes>({})
  const [sdkConfig, setSdkConfig] = useState<Partial<ISplitFactoryProps>>()
  const [flagOverrides, setFlagOverrides] = useState<Flags>({})
  const [clients, setClients] = useState<ClientState['clients']>({})
  const { localStorageFlags } = useLocalStorageFlags()
  const mockFlagsRef = useRef<Flags>()

  useEffect(() => {
    setFlagOverrides(localStorageFlags)
  }, [localStorageFlags])

  useEffect(() => {
    async function init(): Promise<void> {
      mockFlagsRef.current = await mockFlags
      const inMockingScenario = !!mockFlagsRef.current

      const attrs = inMockingScenario ? { anonId: 'anon-id', locale: i18n.language } : await getStandardAttributes()
      setStandardAttributes(attrs)
      setSdkConfig({
        config: {
          core: {
            authorizationKey: inMockingScenario ? 'localhost' : authKey,
            key: attrs.cisId || 'unknown',
            trafficType: 'user',
          },
          urls: SPLIT_PROXY_URL
            ? {
                sdk: SPLIT_PROXY_URL,
                events: SPLIT_PROXY_URL,
                auth: SPLIT_PROXY_URL,
              }
            : undefined,
          features: toSplitIOFeatures(mockFlagsRef.current),
          debug: debugSdk,
          impressionListener,
        },
      })
    }
    init()
    function updateLanguage(): void {
      init()
    }
    i18n.on('languageChanged', updateLanguage)
    return () => {
      i18n.off('languageChanged', updateLanguage)
    }
  }, [debugSdk, authKey, mockFlags, impressionListener])

  const value: FeatureFlagsContextValue = useMemo(
    () => ({
      sdkConfig,
      standardAttributes,
      mockFlags: mockFlagsRef.current,
      flagOverrides,
      setFlagOverrides,
      clients,
      setClients,
    }),
    [clients, standardAttributes, flagOverrides, sdkConfig]
  )

  debug('Rendering FeatureFlagsProvider with:', value, enableRealtime, standardAttributes)
  return (
    <FeatureFlagsProviderBase context={value} enableRealtime={enableRealtime} LoadingFallback={LoadingFallback}>
      <SplitClientsComponent
        standardAttributes={standardAttributes}
        LoadingFallback={LoadingFallback}
        setClients={setClients}
      >
        {children}
      </SplitClientsComponent>
    </FeatureFlagsProviderBase>
  )
}

export function FeatureFlagsDocsProvider({
  context,
  enableRealtime,
  children,
}: PropsWithChildren<{
  context: FeatureFlagsContextValue
  enableRealtime: boolean
}>): JSX.Element {
  return (
    <FeatureFlagsProviderBase context={context} enableRealtime={enableRealtime} LoadingFallback={LoadingSpinner}>
      {children}
    </FeatureFlagsProviderBase>
  )
}

function initFlagsJsFactory(mockFlags, flagOverrides): Promise<void> {
  return Promise.race([
    flagsAreReady(mockFlags, flagOverrides),
    new Promise<void>((_resolve, reject) => {
      setTimeout(
        () => reject(new Error('flags-js factory timed out, will render with the control treatment until ready')),
        FLAGS_READY_TIMEOUT
      )
    }),
  ])
}

// Render the children as a separate component so we can use the Split useClient hook.
function SplitClientsComponent({
  standardAttributes,
  LoadingFallback,
  setClients,
  children,
}: PropsWithChildren<{
  standardAttributes: StandardAttributes
  setClients: Dispatch<SetStateAction<ClientState['clients']>>
  LoadingFallback: ComponentType
}>): JSX.Element {
  // Define all the traffic type clients and put them into the 'clients' object
  // with traffic type as key and client as value. The remainder of the code is
  // agnostic to the number and values of the traffic types.
  const user = useClient(standardAttributes.cisId, 'user')
  const anonymous = useClient(standardAttributes.anonId, 'anonymous')
  const clients = useMemo(() => ({ user, anonymous }), [user, anonymous])
  const { mockFlags, flagOverrides } = useContext(FeatureFlagsContext)

  const [state, dispatch] = useReducer(clientReducer, { clients: {}, clientsReady: {}, flagsDone: Boolean(mockFlags) })

  // Set up listeners to determine when the Split clients are ready since there is not a synchronous
  // API to determine if a Split client is ready or not.
  // This is the technique in Split's docs:
  // https://help.split.io/hc/en-us/articles/360038825091-React-SDK#advanced-instantiate-multiple-sdk-clients
  // See the example "Using the hooks".
  // Note that for some reason the "localhost mode" client does not fire these events,
  // so we check for localhost mode specificially.
  useEffect(() => {
    dispatch({ type: 'init', clients })
    setClients(clients)
    // Capture all listeners so we can remove them in the useEffect cleanup
    const listeners: { client: SplitIO.IClient; event: string; handler: () => void }[] = []
    Object.entries(clients).forEach(([trafficType, client]) => {
      if (!client) return
      // When ready, dispatch; listen for timedout event
      client.ready().then(() => dispatch({ type: 'clientReady', trafficType }))
      const timedoutHandler = (): void => {
        dispatch({ type: 'clientTimedOut', trafficType })
      }
      listeners.push({ client, event: client.Event.SDK_READY_TIMED_OUT, handler: timedoutHandler })
      client.on(client.Event.SDK_READY_TIMED_OUT, timedoutHandler)
    })
    return () => listeners.forEach((l) => l.client.off(l.event, l.handler))
  }, [clients, setClients, mockFlags])

  useEffect(() => {
    initFlagsJsFactory(mockFlags, flagOverrides)
      .then(() => dispatch({ type: 'flagsJsReady' }))
      .catch(() => dispatch({ type: 'flagsJsTimedOut' }))
  }, [mockFlags, flagOverrides])
  debug('rendering SplitClientsComponent with state:', state)
  return <>{state.readyToDisplay ? children : <LoadingFallback />}</>
}

type ClientState = {
  readyToDisplay?: boolean
  clients: FeatureFlagsContextValue['clients']
  clientsReady: Record<string, boolean>
  flagsDone: boolean
}
type ClientAction =
  | {
      type: 'init'
      clients: ClientState['clients']
    }
  | {
      type: 'clientReady' | 'clientTimedOut'
      trafficType: string
    }
  | {
      type: 'flagsJsReady' | 'flagsJsTimedOut'
    }
function clientReducer(state: ClientState, action: ClientAction): ClientState {
  debug('clientReducer received action:', action)
  switch (action.type) {
    case 'init':
      return {
        readyToDisplay: false,
        clients: action.clients,
        clientsReady: Object.keys(action.clients).reduce((acc, key) => ({ ...acc, [key]: false }), {}),
        flagsDone: false,
      }
    case 'clientTimedOut':
    case 'clientReady':
      debug(`${action.type}: ${action.trafficType}`)
      state.clientsReady[action.trafficType] = true
      // TODO: Temporary logging to diagnose "Not Ready" state in Split console
      if (action.type === 'clientTimedOut' && process.env.NODE_ENV !== 'test') {
        // Log that we got a timeout
        debug(
          `Traffic type ${action.trafficType} timed out. Setting readyToDisplay to ${Object.values(
            state.clientsReady
          ).every((r) => r)}`
        )
        // Log as soon as the client becomes ready
        state.clients[action.trafficType]
          .ready()
          .then(() => debug(`Traffic type ${action.trafficType} ready after timeout`))
      }
      // End Temporary logging
      return { ...state, readyToDisplay: Object.values(state.clientsReady).every((r) => r) && state.flagsDone }
    case 'flagsJsReady':
      debug(`${action.type}`)
      state.flagsDone = true
      return { ...state, readyToDisplay: Object.values(state.clientsReady).every((r) => r) && state.flagsDone }
    case 'flagsJsTimedOut':
      debug(`${action.type}`)
      console.error('flags-js factory timed out, will render with the control treatment until ready')
      // We don't want to block rendering if the flags-js factory times out
      state.flagsDone = true
      return { ...state, readyToDisplay: Object.values(state.clientsReady).every((r) => r) && state.flagsDone }
    default:
      return state
  }
}

const center = css`
  position: fixed;
  top: 50%;
  inset-inline-start: 50%;
  transform: translate(-50%, -50%);
`

function LoadingSpinner(): JSX.Element {
  return (
    <div role="alert" data-testid="flagLoadingSpinner" aria-busy="true" className={center}>
      <NoticeLoading size="lg" />
    </div>
  )
}
