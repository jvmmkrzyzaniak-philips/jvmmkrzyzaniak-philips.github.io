import { useContext } from 'react'
import { useManager } from '@splitsoftware/splitio-react'
import zionDebug from '@fs/zion-debug'
import { usePreference } from '@fs/zion-preferences'
import { FeatureFlagsContext } from './FeatureFlagsProvider'
import { toFeatureFlags, toFlags } from './utils'
import type { FeatureAttributes, FeatureFlag, FeatureFlags, Flag, Flags } from './model'

const debug = zionDebug('zion:flags:hooks')

const defaultTrafficType = 'user'

type UserPreference = string | boolean | number | null | unknown[] | Record<string, unknown> | undefined
type MultipleUserPreferences = Record<string, { value: unknown }>
type Preferences = UserPreference | MultipleUserPreferences

/**
 * Examines the FeatureFlags context to determine which feature treatments should be
 * displayed to the end user.
 *
 * Pass in the name of the feature(s) to examine, and any custom attributes that should
 * be used in the treatment determination. All features must use the same traffic type.
 *
 * The treatments are returned, in the form of FeatureFlags. The FeatureFlags can be
 * deconstructed to find the specific treatments for each feature. The FeatureFlags
 * keys will exactly match the feature names supplied as input.
 */
export function useFeatureFlags<F extends Flags>(
  features: (keyof F & string)[] = [],
  attributes: FeatureAttributes = {}
): FeatureFlags<F> {
  const manager = useManager()
  const context = useContext(FeatureFlagsContext)
  debug('FeatureFlagProvider context', context)

  if (!context || !manager) {
    // We can get here for 2 reasons:
    //  1. There is no FeatureFlagsProvider wrapper.
    //  2. There are 2 separate instances of FeatureFlagsProvider, one of which hasn't executed.
    //     See https://www.familysearch.org/frontier/docs/architectural-decisions/016-storybook-config-and-providers
    if (process.env.NODE_ENV === 'development') {
      let message = ''
      if (!manager) message += 'No SplitIO Manager. '
      if (!context) message += 'No FeatureFlagsProvider. '
      console.error(`${message}Returning "control" treatment for ${features}`)
    }
    return controlTreatments<F>(features)
  }

  const { standardAttributes, flagOverrides } = context
  const combinedAttrs = { ...standardAttributes, ...attributes }

  const ttFeatures = findFeaturesByTrafficType(manager, features)
  let treatments: SplitIO.TreatmentsWithConfig = {}
  Object.entries(ttFeatures).forEach(([key, ttFs]) => {
    const ts = context.clients[key]?.getTreatmentsWithConfig(ttFs, combinedAttrs)
    treatments = { ...treatments, ...ts }
  })
  const combinedFlags = { ...toFlags(treatments), ...flagOverrides }
  const flags = toFeatureFlags<F>(combinedFlags)
  debug('useFeatureFlags with:', features, 'returning: ', flags)
  return flags
}

export interface FFValues<F extends Flags> {
  data?: FeatureFlags<F>
  loading: boolean
  error: Error | null
}

export interface FFValue<F extends Flag<unknown>> {
  data?: FeatureFlag<F>
  loading: boolean
  error: Error | null
}

function convertPrefKeyToSplitAttributeKey(prefKey: string): string {
  return prefKey.replace('.', '_')
}

export function convertPrefsToAttributes(userPreferences: string[], prefs: Preferences): Record<string, unknown> {
  // prefs is null if the preference asked for is not set for the user
  if (!userPreferences || userPreferences.length === 0 || prefs === null) {
    return {}
  }
  if (userPreferences.length === 1) {
    return { [convertPrefKeyToSplitAttributeKey(userPreferences[0])]: prefs }
  }

  return Object.entries(prefs as MultipleUserPreferences).reduce((aggObj, [key, value]) => {
    aggObj[convertPrefKeyToSplitAttributeKey(key)] = value.value
    return aggObj
  }, {})
}

/**
 * Examines the FeatureFlags context to determine which feature treatments should be
 * displayed to the end user.
 *
 * Pass in the name of the feature(s) to examine, and any custom attributes that should
 * be used in the treatment determination. All features must use the same traffic type.
 *
 * The treatments are returned, in the form of FeatureFlags. The FeatureFlags can be
 * deconstructed to find the specific treatments for each feature. The FeatureFlags
 * keys will exactly match the feature names supplied as input.
 */
export function useFeatureFlagsWithPrefs<F extends Flags>(
  features: (keyof F & string)[] = [],
  attributes: FeatureAttributes = {},
  options: { userPreferences: string[] } | undefined
): FFValues<F> {
  const manager = useManager()
  const context = useContext(FeatureFlagsContext)
  debug('FeatureFlagProvider context', context)

  const prefs: Preferences = usePreference(...options.userPreferences)

  // undefined prefs means the promise hasn't resolved to go get the prefs yet
  if (prefs === undefined) {
    return { loading: true, error: null }
  }

  const prefAttributes = convertPrefsToAttributes(options.userPreferences, prefs)

  if (!context || !manager) {
    // We can get here for 2 reasons:
    //  1. There is no FeatureFlagsProvider wrapper.
    //  2. There are 2 separate instances of FeatureFlagsProvider, one of which hasn't executed.
    //     See https://www.familysearch.org/frontier/docs/architectural-decisions/016-storybook-config-and-providers
    if (process.env.NODE_ENV === 'development') {
      let message = ''
      if (!manager) message += 'No SplitIO Manager. '
      if (!context) message += 'No FeatureFlagsProvider. '
      console.error(`${message}Returning "control" treatment for ${features}`)
    }
    return { data: controlTreatments<F>(features), loading: false, error: null }
  }

  const { standardAttributes, flagOverrides } = context
  const combinedAttrs = { ...standardAttributes, ...attributes, ...prefAttributes }

  const ttFeatures = findFeaturesByTrafficType(manager, features)
  let treatments: SplitIO.TreatmentsWithConfig = {}
  Object.entries(ttFeatures).forEach(([key, ttFs]) => {
    const ts = context.clients[key]?.getTreatmentsWithConfig(ttFs, combinedAttrs)
    treatments = { ...treatments, ...ts }
  })
  const combinedFlags = { ...toFlags(treatments), ...flagOverrides }
  const flags = toFeatureFlags<F>(combinedFlags)
  debug('feature flags', flags)
  return { data: flags, loading: false, error: null }
}

function controlTreatments<F extends Flags>(features: (keyof F & string)[]): FeatureFlags<F> {
  return features.reduce((acc, f) => {
    acc[f] = { treatment: 'control', config: null, isOn: false, isControl: true } as FeatureFlag<F[typeof f]>
    return acc
  }, {} as FeatureFlags<F>)
}

/**
 * Convenience function that takes one feature and returns the treatment.
 */
export function useFeatureFlag<F extends Flag<unknown>>(
  feature: string,
  attributes: FeatureAttributes = {}
): FeatureFlag<F> {
  const flags = useFeatureFlags([feature], attributes)
  return flags[feature] as FeatureFlag<F>
}

/**
 * Convenience function that takes one feature and returns the treatment.
 */
export function useFeatureFlagWithPrefs<F extends Flag<unknown>>(
  feature: string,
  attributes: FeatureAttributes = {},
  options: { userPreferences: string[] }
): FFValue<F> {
  const { data, loading, error } = useFeatureFlagsWithPrefs([feature], attributes, options)
  return { data: data?.[feature] as FeatureFlag<F>, loading, error }
}

/**
 * Splits features by their traffic type. Since Split.io uses a separate client
 * for each traffic type, we need to determine which features belong to which
 * client. This function separates features into traffic types
 * and returns them as an object with key of traffic type and value of features array.
 *
 * Implementation notes:
 * - Assigns the `defaultTrafficType` in the case where traffic type is not known.
 *   This happens in localhost mode, but in no other known cases.
 * - Uses the Split.io manager to determine which traffic type the features use.
 */
// export for tests
export function findFeaturesByTrafficType(manager: SplitIO.IManager, features: string[]): Record<string, string[]> {
  const splits = manager.splits()

  return features.reduce((acc, feature) => {
    const split = splits.find((s) => s.name === feature)
    let trafficType = split?.trafficType ?? defaultTrafficType
    trafficType = trafficType === 'localhost' ? defaultTrafficType : trafficType

    if (!acc[trafficType]) {
      acc[trafficType] = []
    }
    acc[trafficType].push(feature)
    return acc
  }, {})
}
