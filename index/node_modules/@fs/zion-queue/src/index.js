import debounce from 'lodash.debounce'
import isEqual from 'lodash.isequal'

export default class Queue {
  constructor(cb, opts = {}) {
    this.delay = opts.delay || 50
    this.id = opts.id || 'id'
    this.dedupe = opts.dedupe
    this.cb = cb
    this.queue = {}
    this.dupes = {}

    this.debounced = debounce(this.start, this.delay)
  }

  /**
   * Moves current queue item into dupes and adds new item to queue.
   * @param  {string} uniqueIdKey
   * @param  {Object} args Argument object for new queue item.
   */
  replaceQueueItem(uniqueIdKey, args) {
    this.dupes[uniqueIdKey] = this.dupes[uniqueIdKey] || []
    this.dupes[uniqueIdKey].push(Object.assign({}, this.queue[uniqueIdKey]))

    this.addItemToQueue(uniqueIdKey, args)
  }

  /**
   * Adds new item to queue.
   * @param  {string} uniqueIdKey
   * @param  {Object} args Argument object for new queue item.
   */
  addItemToQueue(uniqueIdKey, args) {
    this.queue[uniqueIdKey] = {
      cb: () => this.cb(args),
    }
    this.queue[uniqueIdKey].args = args
    this.queue[uniqueIdKey].promise = new Promise((resolve, reject) => {
      this.queue[uniqueIdKey].resolve = resolve
      this.queue[uniqueIdKey].reject = reject
    })
  }

  add(args) {
    let itemToReplace
    const isObj = typeof args === 'object'

    const uniqueIdKey = isObj ? args[this.id] : args

    if (!uniqueIdKey) {
      throw new Error('No unique id. See docs about Queue options.')
    }

    // if queue has a dedupe function, run it
    if (this.dedupe && this.queue[uniqueIdKey]) {
      // compare queue item's args to new item's args
      const survivingArgs = this.dedupe(this.queue[uniqueIdKey].args, args)
      // replace queue item if surviving args are not queue item's args
      itemToReplace = !isEqual(survivingArgs, this.queue[uniqueIdKey].args)
    }

    if (itemToReplace) {
      this.replaceQueueItem(uniqueIdKey, args)
    }

    if (!this.queue[uniqueIdKey] || itemToReplace) {
      this.addItemToQueue(uniqueIdKey, args)
    }

    this.debounced(this.start)
    return this.queue[uniqueIdKey].promise
  }

  start() {
    Object.keys(this.queue).forEach((queueKey) => {
      this.queue[queueKey]
        .cb()
        .then((resp) => {
          this.queue[queueKey].resolve(resp)
          // resolve all duplicate promises with queue item's promise
          if (this.dupes[queueKey]) {
            Object.values(this.dupes[queueKey]).forEach((dupeValue) => dupeValue.resolve(resp))
          }
        })
        .catch(this.queue[queueKey].reject)
        .finally(() => {
          // remove item from the queue as they are finished.
          delete this.queue[queueKey]
          delete this.dupes[queueKey]
        })
    })
  }
}
