/**
 * This is a collection of field methods for GedcomX records.
 * All functions have field as the first parameter
 * PLEASE add new functions in alphabetical order
 *
 *  Field objects look like this:
 *  { labelId,
 *    fieldType,  // http://gedcomx.org/Gender, http://gedcomx.org/Name, http://gedcomx.org/Given,
 *                // http://gedcomx.org/Surname, http://gedcomx.org/Date, http://gedcomx.org/Year,
 *                // http://gedcomx.org/Place , http://gedcomx.org/Age, etc.
 *    valueType,  // http://gedcomx.org/Original, http://gedcomx.org/Interpreted
 *    value,
 *    values,     // The array of values for this field (may only contain a single entry) - only for @allowInsert=false
 *    personId    // The ID of the person where the value originated from
 *  }
 */

/**
 * Return the best value from the field (interpreted if available, otherwise original).
 *
 * @param {Object} field The field.
 * @returns {String} The best value (interpreted or original), may be empty.
 */
export function getFieldBestValue(field) {
  let value = ''
  if (field?.values) {
    // we are starting at the end of these arrays because the last item in the array should be the most accurate per our contract with CDS
    const reversedValues = [...field.values].reverse()
    let valueObj = getFieldValueByType(reversedValues, 'http://gedcomx.org/Interpreted')
    if (!valueObj) {
      valueObj = getFieldValueByType(reversedValues, 'http://gedcomx.org/Original')
    }
    value = valueObj?.text || ''
  }
  return value
}

/**
 * Retrieve the field value matching the given type.
 * Note: There are cases where we have multiple values of the same type. This code simply returns the first instance
 * of the value that has the matchin type.
 * @param {Array} values - the array of value objects
 * @param {String} type - the desired type to match (e.g. 'http://gedcomx.org/Original' or 'http://gedcomx.org/Interpreted')
 * @return {Object} the matching value object
 *      {text: {String},
 *       type: {String}}
 */
function getFieldValueByType(values, type) {
  return values.find((val) => {
    return val.type === type
  })
}
