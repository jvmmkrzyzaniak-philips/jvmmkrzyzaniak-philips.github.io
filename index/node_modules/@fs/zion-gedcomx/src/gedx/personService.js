/**
 * This is a collection of person accessor methods for GedcomX records.
 * All functions here have person as the first parameter
 * No relationships are parsed in this file... see recordService.js
 *
 * PLEASE add new functions in alphabetical order
 */
import { i18n } from '@fs/zion-locale'
import { getFieldBestValue } from './fieldService'
import { getFactByType, getFactISODateString, getFactPlace, getFactValuesByType } from './factService'
import '../locales' // this import tells the coalesceLocales function to include it in the per-locale bundle.

function initDeceasedLabel() {
  return i18n.t('gedcomx.lifespan.deceased', 'Deceased')
}

function initLivingLabel() {
  return i18n.t('gedcomx.lifespan.living', 'Living')
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {[String, String, String]} An array of a person birth data, death date, and baptism date. Strings may be null.
 */
export function getComparisonFacts(person) {
  const facts = getPersonFacts(person)
  const birthFact =
    getFactByType(facts, 'http://gedcomx.org/Birth') || getFactByType(facts, 'http://gedcomx.org/Christening')
  const deathFact =
    getFactByType(facts, 'http://gedcomx.org/Death') || getFactByType(facts, 'http://gedcomx.org/Burial')
  const baptismFact = getFactByType(facts, 'http://gedcomx.org/Baptism')

  const birthDate = getFactISODateString(birthFact)
  const deathDate = getFactISODateString(deathFact)
  const baptismDate = getFactISODateString(baptismFact)

  return [birthDate, deathDate, baptismDate]
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {[String]} alternate names
 */
export function getPersonAlternateNames(person) {
  return (
    person?.names
      ?.filter((n) => n.type === 'http://gedcomx.org/AlsoKnownAs' && n.nameForms?.[0]?.fullText)
      .map((n) => n.nameForms?.[0]?.fullText) || []
  )
}

/**
 * @param {Object} person The person object (see getPerson)
 * @returns {String|null} age
 */
export function getPersonBestAge(person) {
  const field = getPersonField(person, 'http://gedcomx.org/Age')
  return (
    getFieldBestValue(field) || getPersonCharacteristic(person, 'http://familysearch.org/types/fields/AgeYears') || null
  )
}

/**
 * @param {Object} person The person object (see getPerson)
 * @returns {String} an approximate 4-digit birth year
 */
export function getPersonBestBirthYear(person) {
  return extractYearFromFacts(person, person?.display?.birthDate, [
    'http://gedcomx.org/Birth',
    'http://gedcomx.org/Christening',
  ])
}

/**
 * @param {Object} person The person object (see getPerson)
 * @returns {String} an approximate 4-digit death year
 */
export function getPersonBestDeathYear(person) {
  return extractYearFromFacts(person, person?.display?.deathDate, [
    'http://gedcomx.org/Death',
    'http://gedcomx.org/Burial',
  ])
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {String} person's best full name. If none found, returns 'UNKNOWN'
 */
export function getPersonBestName(person) {
  // 1 - If there is a person.display.name, use that
  if (person?.display?.name) {
    return safeName(person?.display?.name)
  }

  // Otherwise find the best name object and use that
  const nameObject = getPersonBestNameObject(person)

  return safeName(getFirstNameForm(nameObject))
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {Object} person's best full name object. If none found, returns an empty object
 */
export function getPersonBestNameObject(person) {
  // If the type is http://gedcomx.org/BirthName, use that
  // The most recently edited name will be at the end, so look backwards at the array
  const birthNameObject = [...(person?.names || [])].reverse().find(findByType, 'http://gedcomx.org/BirthName')

  // 2 - Otherwise the latest value of any name will do
  return birthNameObject || person?.names?.[person.names.length - 1] || {}
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {String} person's birthplace
 */
export function getPersonBirthplace(person) {
  return getFactPlace(getPersonFact(person, 'http://gedcomx.org/Birth')) || ''
}

/**
 * Retrieves an array of bounding regions for a person
 * @param person
 * @param sourceId {optional} if specified, returns only bounding regions from specified image, eg. sd2
 * @param type {optional} if specified, returns only bounding regions of that Gedxcom type
 * @returns {Array} the formatted field bounding regions for the record. May be empty if none are found
 *     {
 *      type: (string),   // The Gedxcom type of the field associated with the region
 *      startX: {number}, // Percentage of image width (e.g. 0.37950)
 *      startY: {number}, // Percentage of image height (e.g. 0.71806)
 *      endX: {number},   // Percentage of image width (e.g. 0.50477)
 *      endY: {number}    // Percentage of image height (e.g. 0.77163)
 *    }
 */
export function getPersonBoundingRegions(person, sourceId, type) {
  const fields = getFields(person)
  const boundingRegions = []
  fields.forEach((field) => {
    const regions = getBoundingRegionFromField(field, sourceId, type)
    regions.forEach((region) => {
      const alreadyFound = boundingRegions.find((entry) => {
        return (
          entry.startX === region.startX &&
          entry.startY === region.startY &&
          entry.endX === region.endX &&
          entry.endY === region.endY
        )
      })
      if (!alreadyFound) {
        boundingRegions.push(region)
      }
    })
  })
  return boundingRegions
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @param {String} typeOrLabel - The characteristic type (e.g. IMAGE_ARK, PR_AGE, or http://gedcomx.org/Age)
 * @returns {String|null} value of characteristic
 */
export function getPersonCharacteristic(person, typeOrLabel) {
  // The characteristic value can be inside the person fields array OR in the fields array of the person facts array
  let foundValue = getValueForType(person?.fields, typeOrLabel)
  if (!foundValue) {
    const foundFact = person?.facts?.find((fact) => fact.fields?.find(findByTypeOrLabel, typeOrLabel))
    foundValue = getValueForType(foundFact?.fields, typeOrLabel)
  }

  return foundValue || null
}

/**
 * Return the characteristics for the given person (age, birth, gender).
 *
 * @param {Object} person The person
 * @returns [{Object}] Object with field information as follows:
 *    {
 *      {String} key the gedcomx field type key (e.g. http://geddomx.org/Name, etc.)
 *      {String} value the latest/best value for the field
 *      [{String}] values the values for the field (currently only for name)
 *    }
 */
export function getPersonCharacteristics(person) {
  const birthFact = getPersonFact(person, 'http://gedcomx.org/Birth')
  let birthPlaceValues = getFactValuesByType(birthFact?.place?.fields, 'http://gedcomx.org/Interpreted')
  if (!birthPlaceValues?.length) {
    birthPlaceValues = getFactValuesByType(birthFact?.place?.fields, 'http://gedcomx.org/Original')
  }
  return [
    { key: 'http://gedcomx.org/Name', value: getPersonBestName(person), values: getPersonNames(person) },
    { key: 'http://gedcomx.org/Age', value: getPersonBestAge(person) },
    {
      key: 'http://gedcomx.org/Birthplace',
      value: birthPlaceValues[0] ? birthPlaceValues[0] : '',
      values: birthPlaceValues,
    },
    { key: 'http://gedcomx.org/Gender', value: getPersonSex(person) },
  ].filter((item) => item.value)
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {String} person's deathplace
 */
export function getPersonDeathplace(person) {
  const facts = person.facts
  return (
    getFactPlace(getFactByType(facts, 'http://gedcomx.org/Death')) ||
    getFactPlace(getFactByType(facts, 'http://gedcomx.org/Burial')) ||
    ''
  )
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {{birthplace: String, name: (String|null), url: (String|null), age: String}} display data for record details additional persons
 */
export function getPersonDisplayData(person) {
  return {
    url: getPersonURL(person),
    name: getPersonBestName(person),
    age: getPersonBestAge(person),
    sex: getPersonSex(person),
    birthplace: getPersonBirthplace(person),
  }
}

/** @deprecated - see recordService.getAllPersonFacts, factService.getFactByType
 * @param {Object} person - The person object (see getPerson)
 * @param {String} factType - The fact type (e.g. http://gedcomx.org/Birth)
 * @returns {Object|null} first fact object
 */
export function getPersonFact(person, factType) {
  return person?.facts?.find(findByType, factType) || null
}

/** @deprecated - see recordService.getAllPersonFacts
 * @param {Object} person - The person object (see getPerson)
 * @returns {[Object]} facts
 */
export function getPersonFacts(person) {
  return person?.facts || []
}

/** @deprecated - see recordService.getAllPersonFacts
 * Get person facts but exclude
 * @param {Object} person - The person object (see getPerson)
 * @param {Array} excludeFactTypes - array of fact types to exclude
 * @returns {*|*[]}
 */
export function getPersonFactsExcept(person, excludeFactTypes) {
  return person?.facts?.filter((f) => !excludeFactTypes.includes(f.type)) || []
}

/** @deprecated - see recordService.getAllPersonFacts, factService.getFactsVitalAndOther
 * Get person facts organized into "vital" and "other"
 *
 * @param {Object} person - The person object (see getPerson)
 * @returns {{vitals: Array, other: Array}} facts
 */
export function getPersonFactsOrganized(person) {
  // separate facts into vitals and other
  const vitalSort = [
    'http://gedcomx.org/Birth',
    'http://gedcomx.org/Christening',
    'http://gedcomx.org/Death',
    'http://gedcomx.org/Burial',
    'http://gedcomx.org/Male',
    'http://gedcomx.org/Female',
    'http://gedcomx.org/Unknown',
  ]
  const vitals =
    person?.facts
      ?.filter((fact) => vitalSort.indexOf(fact.type) > -1)
      .sort((a, b) => {
        if (vitalSort.indexOf(a.type) < vitalSort.indexOf(b.type)) {
          return -1
        }
        if (vitalSort.indexOf(a.type) > vitalSort.indexOf(b.type)) {
          return 1
        }
        return 0
      }) || []
  const other = person?.facts?.filter((fact) => vitalSort.indexOf(fact.type) === -1) || []
  return { vitals, other }
}

/**
 * Person fields can be inside any of names/gender/facts/fields, so this digs through all of them.
 *
 * @param {Object} person - The person object (see getPerson)
 * @param {String} fieldType - The field type (e.g. http://familysearch.org/types/fields/FsCollectionId)
 * @returns {Object|null} field
 *  { labelId,
 *    fieldType,  // http://gedcomx.org/Gender, http://gedcomx.org/Name, http://gedcomx.org/Given,
 *                // http://gedcomx.org/Surname, http://gedcomx.org/Date, http://gedcomx.org/Year,
 *                // http://gedcomx.org/Place , http://gedcomx.org/Age, etc.
 *    valueType,  // http://gedcomx.org/Original, http://gedcomx.org/Interpreted
 *    value,
 *    values,     // The array of values for this field (may only contain a single entry) - only for @allowInsert=false
 *    personId    // The ID of the person where the value originated from
 *  }
 */
export function getPersonField(person, fieldType) {
  // first look in the normal person fields array
  const normalField = person?.fields?.find(findByTypeOrLabel, fieldType)
  if (normalField) {
    return normalField
  }

  // then look for fields buried inside other arrays
  const types = ['names', 'gender', 'facts']
  for (let i = 0; i < types.length; i++) {
    const foundList = []
    const item = person[types[i]]
    item?.fields?.forEach((f) => {
      ;[...(f?.values || [])].reverse().forEach((v) => {
        if (v.labelId === fieldType) {
          const field = {
            labelId: v.labelId,
            fieldType: f.type,
            valueType: v.type,
            value: v.text,
            values: [v.text],
            personId: person.id,
          }
          foundList.push(field)
        }
      })
    })
    if (foundList.length > 0) {
      if (foundList.length > 1) {
        for (let j = 1; j < foundList.length; j++) {
          foundList[0].values.push(foundList[j].value)
        }
      }
      return foundList[0]
    }
  }

  return null
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {[{Object}]} fields
 */
export function getPersonFields(person) {
  return person?.fields || []
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @param {String} fieldType - The field type regex
 * @returns {[{Object}]} matching fields
 */
export function getPersonFieldsOfType(person, fieldType) {
  return person?.fields?.filter(findByTypeOrLabelRegex, new RegExp(fieldType)) || []
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {Object} Given and Surname names
 */
export function getPersonGivenAndSurname(person) {
  // The most recently edited name will be at the end, so look backwards at the array
  const birthNameObject = [...(person?.names || [])].reverse().find(findByType, 'http://gedcomx.org/BirthName')
  const givenAndSurnameNames = getGivenAndSurnameParts(birthNameObject)

  return givenAndSurnameNames
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {String|null} The person Id, and the person Ark
 */
export function getPersonId(person) {
  const personURL = getPersonURL(person)
  const personArk = personURL.slice(personURL.lastIndexOf('/') + 1)
  const personId = person.id.includes('-') ? person.id : personURL.slice(personURL.lastIndexOf(':') + 1)
  return { personId, personArk }
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {String} Calculated lifespan
 */
export function getPersonLifespan(person) {
  return person?.display?.lifespan || getAbbreviatedLifespan(person)
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {String} - 'living' if person is living; 'deceased' if deceased or 'unknown' if unknown
 */
export function getPersonLivingStatus(person) {
  // Check living status (for tree persons)
  if (typeof person?.display?.living !== 'undefined' || person?.display?.lifespan?.indexOf('Living') > -1) {
    return 'living'
  }
  // Check for death fact
  const deathFact =
    getPersonFact(person, 'http://gedcomx.org/Death') || getPersonFact(person, 'http://gedcomx.org/Burial')
  if (deathFact) {
    return 'deceased'
  }

  return 'unknown'
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {[String]} person's names, most recent first
 */
export function getPersonNames(person) {
  const nameObjects = [...(person?.names || [])].reverse()
  return nameObjects.map((nameObj) => getFirstNameForm(nameObj))
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @param {[String]} nameTypes - acceptable name types
 * @returns {[String]} all person names of a specific type, most recent first
 */
export function getPersonNamesOfType(person, nameTypes) {
  const matchingNameObjects = [...(person?.names || [])]
    .reverse()
    .filter((nameObj) => nameTypes.indexOf(nameObj.type) !== -1)
  return matchingNameObjects.map((nameObj) => getFirstNameForm(nameObj))
}

/**
 * Returns the notes for the person.
 *
 * @param {Object} person - The person object (see getPerson)
 * @returns {[{id: String, text: String}]} notes
 */
export function getPersonNotes(person) {
  return (
    person?.notes?.map((n) => {
      return { id: n.id, text: n.text, href: n.links?.note?.href }
    }) || []
  )
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {'M'|'F'|'U'} code for person's gender
 */
export function getPersonSex(person) {
  switch (person?.gender?.type?.toLowerCase()) {
    case 'http://gedcomx.org/male':
      return 'M'
    case 'http://gedcomx.org/female':
      return 'F'
    default:
      return 'U'
  }
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {'MALE'|'FEMALE'|'UNKNOWN'} full string for person's sex
 */
export function getPersonSexFullString(person) {
  switch (person?.gender?.type?.toLowerCase()) {
    case 'http://gedcomx.org/male':
      return 'MALE'
    case 'http://gedcomx.org/female':
      return 'FEMALE'
    default:
      return 'UNKNOWN'
  }
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {[{attribution, links, description}]} sources
 */
export function getPersonSources(person) {
  return person?.sources || []
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @returns {String|null} URL
 */
export function getPersonURL(person) {
  return (
    (person?.identifiers?.['http://gedcomx.org/Persistent']?.[0] &&
      new URL(person?.identifiers?.['http://gedcomx.org/Persistent']?.[0], window.location.href)?.pathname) ||
    null
  )
}

/**
 * Use this function if you need a fully qualified URL for the person (including the domain)
 *
 * @param {Object} person - The person object (see getPerson)
 * @returns {String|null} URL
 */
export function getPersonURLFull(person) {
  return person?.identifiers?.['http://gedcomx.org/Persistent']?.[0] || ''
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @param {String} idOrURL - The identifier or URL to check. (IDs may start with '#' from internal links)
 * @returns {boolean} true if the person is a match for the ID or URL specified, otherwise false.
 */
export function isPersonMatch(person, idOrURL) {
  if (person && idOrURL) {
    const id = idOrURL.charAt(0) === '#' ? (idOrURL = idOrURL.substring(1)) : idOrURL

    // Look for an easy match
    if (person.id === id || person.id === idOrURL) {
      return true
    }

    // Try to match on both Tree Id format and URL
    if (isTreePersonMatch(person, id) || isPersistentIdentifierMatch(person, idOrURL)) {
      return true
    }
  }

  return false
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @param {Object} sourceDesc - the source description object (see getSourceDescriptionsByType)
 * @returns {boolean} true if the person & source description are a match, otherwise false
 */
export function isPersonSourceDescriptionMatch(person, sourceDesc) {
  let match = false
  if (person && sourceDesc) {
    const personPersistentUrl = person?.identifiers?.['http://gedcomx.org/Persistent']?.[0]
    const srcDescPersistentUrl = sourceDesc?.identifiers?.['http://gedcomx.org/Persistent']?.[0]
    match = personPersistentUrl && personPersistentUrl === srcDescPersistentUrl
  }
  return match
}

// ===================================================================================================================
// PRIVATE FUNCTIONS (alphabetically arranged)
// ===================================================================================================================

/**
 * @param {Object} person - The person object (see getPerson)
 * @param {String|undefined} displayDate - date from person display object, if present
 * @param {Array} factTypes - array of fact types to look through
 * @returns {String|*} Get a 4-digit year from facts matching an array of fact types
 */
function extractYearFromFacts(person, displayDate, factTypes) {
  let date = displayDate || ''
  if (!displayDate) {
    for (let i = 0; i < factTypes.length; i++) {
      date = getFactISODateString(getPersonFact(person, factTypes[i]))
      if (date) {
        break
      }
    }
  }
  // For display date, the last four digits should be the year; for ISO, it's the first four digits
  const matches = date.match(/^(\d{4})|(\d{4})$/)
  return matches?.[1] || matches?.[2] || ''
}

/**
 * Array find function
 * "This" is a a gedcomx type to search for
 *
 * @param {Object} factOrField - fact or field object with a type
 * @returns {Boolean} True if found
 */
function findByType(factOrField) {
  return factOrField.type === this
}

/**
 * Array find function
 * "This" is a string matching the gedcomx type or labelId to search for
 *
 * @param {Object} factOrField - fact or field object with a type and maybe values
 * @returns {Boolean} True if found
 */
function findByTypeOrLabel(factOrField) {
  return (
    factOrField.type === this ||
    [...(factOrField.values || [])].reverse().find((value) => {
      return value.labelId === this
    })
  )
}

/**
 * Array find function
 * "This" is a regex matching the gedcomx type or labelId to search for
 *
 * @param {Object} field - fact or field object with a type and maybe values
 * @returns {Boolean} True if found
 */
function findByTypeOrLabelRegex(field) {
  return (
    this.test(field.type) ||
    [...(field.values || [])].reverse().find((value) => {
      return this.test(value.labelId)
    })
  )
}

/**
 * Gets the abbreviated lifespan for a person.
 *
 * @param {Object} person - The person object (see getPerson)
 * @returns {String} lifespan The abbreviated lifespan for the person
 */
function getAbbreviatedLifespan(person) {
  const birthYear = getPersonBestBirthYear(person)
  const deathYear = getPersonBestDeathYear(person)
  const living = getPersonLivingStatus(person)

  let lifespan = ''
  if (!birthYear && !deathYear) {
    lifespan = getNoDateLifespan()
  } else if (birthYear) {
    lifespan = getBirthYearLifespan()
  } else {
    // have death year, but not birth year
    lifespan = `-${deathYear}`
  }
  return lifespan

  function getBirthYearLifespan() {
    let newLifespan = `${birthYear}-`
    if (living === 'living') {
      newLifespan += initLivingLabel()
    } else if (living === 'deceased') {
      // Use reverse name / logic to support not being passed
      newLifespan += deathYear || initDeceasedLabel()
    }
    return newLifespan
  }

  function getNoDateLifespan() {
    if (living === 'living') {
      return initLivingLabel()
    }
    if (living === 'deceased') {
      return initDeceasedLabel()
    }
    return ''
  }
}

/**
 * Given a field elements, extract the fieldBoundingRegions
 * @param field - the element to search
 * @param sourceId {optional} if specified returns only bounding regions associated with that sourceId
 * @param type {optional} if specified returns only bounding regions of that type
 */
function getBoundingRegionFromField(field, sourceId, type) {
  const boundingRegions = []
  field.forEach((internalField) => {
    if (!type || internalField.type === type) {
      internalField?.sources?.forEach((source) => {
        if (source.qualifiers && (!sourceId || source.description === `#${sourceId}`)) {
          source.qualifiers.forEach((qualifier) => {
            if (qualifier.name && qualifier.name === 'http://gedcomx.org/RectangleRegion' && qualifier.value) {
              const rectParts = qualifier.value.split(',')
              boundingRegions.push({
                type: internalField.type,
                startX: parseFloat(rectParts[0]),
                startY: parseFloat(rectParts[1]),
                endX: parseFloat(rectParts[2]),
                endY: parseFloat(rectParts[3]),
              })
            }
          })
        }
      })
    }
  })
  return boundingRegions
}

/**
 * Starting method for recursively gathering all "field" elements
 * @param person - the person to parse
 * @returns {Array} - all field elements
 */
function getFields(person) {
  return getFieldsR(person, [])
}

/**
 * Recursively search for "field" elements
 * @param property - the current element
 * @param array - all elements found so far
 * @returns {Array} - all field elements
 */
function getFieldsR(property, array) {
  let keys
  if (property.fields) {
    if (property.parts) {
      array.push(...getParts(property.parts))
      return array
    }
    array.push(property.fields)
  }
  if (typeof property === 'object') {
    keys = Object.keys(property)
  } else if (Array.isArray(property)) {
    keys = property
  } else {
    return array
  }

  keys.forEach((newProperty) => {
    return getFieldsR(property[newProperty], array)
  })

  return array

  function getParts(parts) {
    const partArray = []
    if (parts && parts.length) {
      parts.forEach((fieldPart) => {
        if (fieldPart.fields) {
          partArray.push(fieldPart.fields)
        }
      })
    }
    return partArray
  }
}

/**
 * @param {Object} birthNameObject - The most recently edited name object
 * @returns {Object} Given and Surname names
 */
function getGivenAndSurnameParts(birthNameObject) {
  const nameForm = birthNameObject?.nameForms?.[0]
  const givenNames = getNameField('http://gedcomx.org/Given')
  const surnames = getNameField('http://gedcomx.org/Surname')

  return { givenNames, surnames }

  function getNameField(type) {
    const namePart = nameForm?.parts?.filter((part) => part.type === type)?.[0]
    if (namePart?.fields) {
      let nameFromFields = ''
      namePart.fields.forEach((field) => {
        field.values.forEach((fieldValue) => {
          if (fieldValue.type === 'http://gedcomx.org/Interpreted' && fieldValue.text) {
            // Add surname prefix to beginning of a surname name field
            if (
              namePart.type === 'http://gedcomx.org/Surname' &&
              field.type === 'http://familysearch.org/types/fields/SurnamePrefix'
            ) {
              const surname = nameFromFields
              nameFromFields = `${fieldValue.text} ${surname}`
            } else {
              // Take the last item in the list only.
              nameFromFields = fieldValue.text
            }
          }
        })
      })
      return nameFromFields || ''
    }
    return namePart?.value || ''
  }
}

/**
 * Searches through an array of fields for a match on the type or label.
 *
 * @param {Array} fields - fields to search through
 * @param {String} typeOrLabel
 * @returns {String} The best value
 */
function getValueForType(fields, typeOrLabel) {
  const foundField = fields?.find(findByTypeOrLabel, typeOrLabel)
  const foundValue = [...(foundField?.values || [])].reverse().find((value) => value.labelId === typeOrLabel)?.text
  return foundValue || getFieldBestValue(foundField)
}

/**
 * @param {Object} name - the name object
 * @returns {String|null} name string from the first nameForm
 */
function getFirstNameForm(name) {
  const nameForm = name?.nameForms?.[0]
  return (
    nameForm?.fullText ||
    nameForm?.parts?.reduce((acc, e) => {
      const fieldWithValue = e?.fields?.find((field) => getFieldBestValue(field) || false)
      const val = getFieldBestValue(fieldWithValue) || e.value
      return acc ? `${acc} ${val}` : val
    }, '') ||
    null
  )
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @param {String} url - person id or url to look for
 * @returns {Boolean}
 */
function isPersistentIdentifierMatch(person, url) {
  // Compare the full URL and the URL without a domain
  const personIdList = person?.identifiers?.['http://gedcomx.org/Persistent']
  if (personIdList) {
    return Boolean(
      personIdList.find((personId) => {
        // If it has a / - try to parse it as a URL; internal identifiers like p_XXX and sd_XXX don't have slashes
        return (
          personId === url ||
          (personId.includes('/') &&
            new URL(url, window.location.href)?.pathname === new URL(personId, window.location.href)?.pathname)
        )
      })
    )
  }
  return false
}

/**
 * @param {Object} person - The person object (see getPerson)
 * @param {String} id - person id
 * @returns {Boolean} true if it's a tree person ID and a match
 */
function isTreePersonMatch(person, id) {
  const treeUrlRegex = /.{4}-.{3,4}/i
  const match = treeUrlRegex.exec(id)
  return match && person.id?.split(':').at(-1) === match[0]
}

/**
 * @param {String|Null} name - original name
 * @returns {String} name (or 'UNKNOWN' if empty)
 */
function safeName(name) {
  return name && name.length ? name : 'UNKNOWN'
}
