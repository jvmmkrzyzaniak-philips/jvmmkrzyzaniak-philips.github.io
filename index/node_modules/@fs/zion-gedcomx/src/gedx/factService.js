import { formatISO } from '@fs/zion-locale/date-fns'
import vitalFactTypes, {
  birthLikeFactTypes,
  deathLikeFactTypes,
  marriageLikeFactTypes,
  sourceLinkerVitalFactTypes,
} from './vitalFactTypes'
import { getFactTypeLabel } from './factTypeLabels'
import { getFieldBestValue } from './fieldService'
import { isEqualOrBetterDate } from './dateService'

/**
 * This is a collection of fact methods for GedcomX records.
 * All functions have fact as the first parameter
 * PLEASE add new functions in alphabetical order
 */

/**
 * Return the list of dates for this fact (most recent first).
 *
 * @param {Object} fact The fact object returned by getPersonFact.
 * @return [string] The dates for the fact (may be empty).
 */
export function getAllFactDates(fact) {
  const dates = []
  // older dates are stored in the 'altDates' field
  // the current date is stored in the 'date' field
  // The first entry in the array is the latest
  const latestDate = getFactDatePreferNormalized(fact)
  if (latestDate.length > 0) {
    dates.push(latestDate)
  }
  if (fact.altDates) {
    fact.altDates.forEach((altDate) => {
      altDate?.original && dates.push(altDate?.original)
      // If 'original' isn't filled we may need to drill down into fields and get all http://gedcomx.org/Date values
    })
  }
  return dates
}

/**
 * Return the list of places for this fact (most recent first).
 *
 * @param {Object} fact The fact object returned by getPersonFact.
 * @return [string] The places for the fact (may be empty).
 */
export function getAllFactPlaces(fact) {
  const places = []
  // older places are stored in the 'altPlaces' field
  // the current place is stored in the 'place' field
  // The first entry in the array is the latest
  const latestPlace = getFactPlace(fact)
  if (latestPlace.length > 0) {
    places.push(latestPlace)
  }
  if (fact.altPlaces) {
    fact.altPlaces.forEach((altPlace) => {
      altPlace?.original && places.push(altPlace?.original)
      // If 'original' isn't filled we may need to drill down into fields and get all http://gedcomx.org/Date values
    })
  }
  return places
}

/**
 * Return all birth-like facts (birth, christening, baptism, blessing, circumcision)
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @returns {Object[]} fact objects for birth-like events
 */
export function getBirthLikeFacts(facts) {
  return getFactsByTypes(facts, birthLikeFactTypes)
}

/**
 * Return all death-like facts (death, burial, cremation, funeral, obituary, probate, will)
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @returns {Object[]} fact objects for death-like events
 */
export function getDeathLikeFacts(facts) {
  return getFactsByTypes(facts, deathLikeFactTypes)
}

/**
 * Return a fact matching the specified type
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @param {string} factType - The fact type (e.g. http://gedcomx.org/Birth)
 * @returns {Object|null} first fact object
 */
export function getFactByType(facts, factType) {
  return facts?.find((fact) => fact.type === factType) || null
}

/**
 * Return all facts matching the specified array of fact types
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @param {string[]} factTypes - The fact types (e.g. http://gedcomx.org/Birth)
 * @returns {Object[]} fact objects with matching types, ordered to match the list of fact types
 */
export function getFactsByTypes(facts, factTypes) {
  return (
    facts
      ?.filter((fact) => factTypes.includes(fact.type))
      ?.sort((a, b) => {
        if (factTypes.indexOf(a.type) < factTypes.indexOf(b.type)) return -1
        if (factTypes.indexOf(a.type) > factTypes.indexOf(b.type)) return 1
        return 0
      }) || []
  )
}

/**
 * Return the date for a fact (normalized or original)
 *
 * @param {Object} fact The fact object returned by getPersonFact
 * @returns {string} The date for the fact (or an empty string).
 */
export function getFactDate(fact) {
  return fact?.date?.normalized?.[0]?.value || fact?.date?.original || ''
}

/**
 * Return the date for a fact (original or normalized)
 *
 * @param {Object} fact The fact object returned by getPersonFact
 * @returns {string} The date for the fact (or an empty string).
 */
export function getFactDateOriginal(fact) {
  return fact?.date?.original || fact?.date?.normalized?.[0]?.value || ''
}

/**
 * Return the date for a fact (formal or normalized or original)
 *
 * @param {Object} fact The fact object returned by getPersonFact
 * @returns {string} The date for the fact (or an empty string).
 */
export function getFactDateFormal(fact) {
  return { formal: fact?.date?.formal, text: getFactDate(fact) }
}

/**
 * Returns fact label, place, and value.
 *
 * @param {*} fact - The fact to get details about (birth, death, residence, etc.)
 * @returns The label, value, date, and place (if any) of the fact
 */
export function getFactLabelPlaceValue(fact) {
  function hasExistingProperty(property) {
    return fact?.[property] && typeof fact[property] === 'string'
  }
  let label = hasExistingProperty('label') ? fact.label : 'Other'
  if (fact && fact.type) {
    label = getFactTypeLabel(fact.type)
  }

  const value = hasExistingProperty('value') ? fact.value : getFactValue(fact)
  const place = hasExistingProperty('place') ? fact.place : getFactPlace(fact)
  return { label, value, place }
}

/**
 * Returns fact date, preferring original date when the date type is not a string but an object.
 *
 * @param {*} fact
 * @returns {string} fact date
 */
export function getFactDatePreferOriginal(fact) {
  return fact?.date && typeof fact?.date === 'string' ? fact.date : getFactDateOriginal(fact)
}

/**
 * Returns fact date, preferring normalized date when the date type is not a string but an object.
 *
 * @param {*} fact
 * @returns {string} fact date
 */
export function getFactDatePreferNormalized(fact) {
  const interpretedDate = getFactDateBestInterpreted(fact)
  if (interpretedDate?.text) return interpretedDate.text
  return fact?.date && typeof fact?.date === 'string' ? fact.date : getFactDate(fact)
}

/**
 * Returns fact date, preferring formal date when the date type is not a string but an object.
 *
 * @param {*} fact
 * @returns {string} fact date
 */
export function getFactDatePreferFormal(fact) {
  const { resource, text } = getFactDateBestInterpreted(fact) || {}
  if (resource || text) return { formal: resource, text }

  return fact?.date && typeof fact?.date === 'string' ? { text: fact.date } : getFactDateFormal(fact)
}

/**
 * Returns details about a fact. Used to display a fact in FactRows.
 *
 * @param {*} fact - The fact to get details about (birth, death, residence, etc.)
 * @returns The label, value, date, and place (if any) of the fact.
 * Normalized date is preferred if the date's type is not a string.
 */
export function getFactDetails(fact) {
  const { label, place, value } = getFactLabelPlaceValue(fact)
  const date = getFactDatePreferNormalized(fact)
  return { label, place, value, date }
}

/**
 * Returns details about a fact. Used to display a fact in FactRows.
 *
 * @param {*} fact - The fact to get details about (birth, death, residence, etc.)
 * @returns The label, value, date, and place (if any) of the fact.
 * Original date is preferred if the date's type is not a string.
 */
export function getFactDetailsOriginalDate(fact) {
  const { label, place, value } = getFactLabelPlaceValue(fact)
  const date = getFactDatePreferOriginal(fact)
  return { label, place, value, date }
}

/**
 * Returns details about a fact. Used to display a fact in FactRows.
 *
 * @param {*} fact - The fact to get details about (birth, death, residence, etc.)
 * @returns The label, value, date, and place (if any) of the fact.
 * Formal date is preferred if the date's type is not a string.
 */
export function getFactDetailsFormalDate(fact) {
  const { label, place, value } = getFactLabelPlaceValue(fact)
  const date = getFactDatePreferFormal(fact)
  return { label, place, value, date }
}

/**
 * WARNING: Use with care.
 *          This function parses dates differently in different browsers, because it uses Date.parse where possible.
 *
 * @param {Object} fact The fact object, returned by getPersonFact
 * @returns {string} The ISO 8601 date string for the fact (a parsed valid date)
 */
export function getFactISODateString(fact) {
  const dates = getAllISODates(fact)

  // loop through dates, attempting to parse
  let yearFallback = false
  let monthYearFallback = false

  for (let i = 0; i < dates.length; i++) {
    const dateString = processDateString(dates[i])
    if (typeof dateString === 'string') {
      return dateString
    }

    monthYearFallback = getMonthFallback(dates[i]) || monthYearFallback
    yearFallback = getYearFallback(dates[i]) || yearFallback
  }

  // if we get here, no valid complete dates were found; return a partial
  return monthYearFallback || yearFallback || ''
}

/**
 * Return the place for a fact (edited, normalized or original)
 * @param {Object} fact The fact object returned by getPersonFact
 * @returns {string} The place string for the fact (or an empty string).
 */
export function getFactPlace(fact) {
  // Look for the most recent edited fact place from the fact fields
  const placeField = fact?.place?.fields?.find((field) => field.type === 'http://gedcomx.org/Place')
  if (placeField) {
    return getFieldBestValue(placeField)
  }
  return fact?.place?.normalized?.[0]?.value || fact?.place?.original || ''
}

/**
 * Return the place for a fact (original or normalized)
 * @param {Object} fact The fact object returned by getPersonFact
 * @returns {string} The place string for the fact (or an empty string).
 */
export function getFactPlaceOriginal(fact) {
  return fact?.place?.original || fact?.place?.normalized?.[0]?.value || ''
}

/**
 * Return the value from the fact.
 * @param {object} fact The fact object returned by betPersonFact
 * @returns {string} The value for the fact (or an empty string).
 */
export function getFactValue(fact) {
  return fact?.value || ''
}

/**
 * Return the value from the fact.
 * @param {object} fact The fact object returned by betPersonFact
 * @returns {string} The value for the fact (or an empty string).
 */
export function getFactValueOriginal(fact) {
  if (fact?.fields) {
    let origValue = null
    fact.fields.find((field) => {
      if (field?.values) {
        origValue = field.values.find((value) => {
          return value.type === 'http://gedcomx.org/Original'
        })
      }
      return false
    })
    if (origValue?.text) {
      return origValue.text
    }
  }
  return fact?.value || ''
}

/**
 * Get field values from a fact field (e.g. fact.date or fact.place) by the value type.
 *
 * @param {Object} factFields the 'fields' entry for the fact value to read from (e.g. fact.place.fields or fact.date.fields)
 * @param {String} valueType the type of values being retrieved (e.g. http://gedcomx.org/Interpreted or http://gedcomx.org/Original)
 * @returns {[String]} the matching values from the fields. May be an empty array.
 */
export function getFactValuesByType(factFields, valueType) {
  const values = []

  if (factFields && valueType) {
    factFields.forEach((field) => {
      field?.values?.forEach((f) => {
        if (f.type === valueType) {
          values.push(f.text)
        }
      })
    })
  }

  return values
}

/**
 * Get person facts organized into "primary", "vital" and "other"
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @returns {
 *    {object} primary - the primary event (may be null - NOT included in vital or other lists)
 *    {array} vital - the list of vital events (may be empty)
 *    {array} other - the list of non-vital events (may be empty)
 * }
 */
export function getFactsVitalAndOther(facts) {
  // Find the primary event from the list we collected
  const primary = facts?.find((fact) => fact.primary) || null
  const vital = getFactsByTypes(facts, vitalFactTypes).filter((fact) => isDifferentFact(fact, primary))
  const other =
    facts?.filter((fact) => isDifferentFact(fact, primary) && vitalFactTypes.indexOf(fact.type) === -1) || []

  return { primary, vital, other }
}

/**
 * Get person facts organized into "vital", "event" and "other".  Use when you want to separate non-vital facts
 * by facts with a date (ex: Coronation), and facts without a date (ex: jiapu Branch Name).  Used in GenDetailsInfoSheet.
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @returns {
 *    {array} vitalFacts - the list of vital events (may be empty)
 *    {array} eventFacts - the list of non-vital events with dates (may be empty)
 *    {array} otherFacts - the list of non-vital events (may be empty)
 * }
 */
export function getFactsVitalEventOther(facts) {
  const { vital: vitalFacts, other, primary: primaryFact } = getFactsVitalAndOther(facts)
  const eventFacts = other.filter((fact) => fact.date)
  const otherFacts = other.filter((fact) => !fact.date)
  return { vitalFacts, eventFacts, otherFacts, primaryFact }
}

/**
 * Similar to above two functions, but is specifically for use in Source Linker
 * @param {array} facts - List of facts for a person
 * @returns {
 *  {array} vitalFacts - list of vital events (may be empty)
 *  {array} eventFacts - list of non-vital events with dates (may be empty)
 *  {array} otherFacts - list of non-vital events (may be empty)
 *  {object} primaryFact - the primary event (may be null)
 * }
 */
export function getSourceLinkerFactsVitalEventOther(facts) {
  const primaryFact = facts?.find((fact) => fact.primary) || null
  const vitalFacts = getFactsByTypes(facts, sourceLinkerVitalFactTypes).filter((fact) =>
    isDifferentFact(fact, primaryFact)
  )
  const others =
    facts?.filter(
      (fact) => isDifferentFact(fact, primaryFact) && sourceLinkerVitalFactTypes.indexOf(fact.type) === -1
    ) || []
  const eventFacts = others.filter((fact) => fact.date)
  const otherFacts = others.filter((fact) => !fact.date && (fact.place || fact.value))
  return { vitalFacts, eventFacts, otherFacts, primaryFact }
}

/**
 * Get the date from a person's first birth-like event having a date.
 * Convert the date to an ISO 8601 date string
 *
 * @param {array} facts - The list of facts for a person
 * @returns {string} The ISO 8601 date string for the fact (a parsed valid date)
 */
export function getFirstBirthLikeISODate(facts) {
  const birthLikeFacts = getBirthLikeFacts(facts)
  const factWithDate = birthLikeFacts.find((fact) => fact.date !== undefined)
  const ISODateString = getFactISODateString(factWithDate)
  return ISODateString
}

/**
 * Get the date from a person's first death-like event having a date.
 * Convert the date to an ISO 8601 date string
 *
 * @param {array} facts - The list of facts for a person
 * @returns {string} The ISO 8601 date string for the fact (a parsed valid date)
 */
export function getFirstDeathLikeISODate(facts) {
  const deathLikeFacts = getDeathLikeFacts(facts)
  const factWithDate = deathLikeFacts.find((fact) => fact.date !== undefined)
  const ISODateString = getFactISODateString(factWithDate)
  return ISODateString
}

/**
 * Get person "primary" and "vital" facts - limited to one of each vital type (birth, marriage, death)
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @param {boolean} [includeMarriage] - true if you need a marriage fact; false if you do not
 * @returns {array} fact list
 *
 */
export function getLimitedVitalAndPrimaryFacts(facts, includeMarriage = true) {
  const limitedFacts = []
  const primaryFact = getPrimaryFact(facts)
  if (primaryFact) {
    limitedFacts.push(primaryFact)
  }

  const vitalFactArrays = includeMarriage
    ? [birthLikeFactTypes, marriageLikeFactTypes, deathLikeFactTypes]
    : [birthLikeFactTypes, deathLikeFactTypes]
  vitalFactArrays.forEach((factTypes) => {
    const foundFact = getFirstFactOfTypes(facts, factTypes, primaryFact)
    if (foundFact) {
      limitedFacts.push(foundFact)
    }
  })

  return limitedFacts
}

/**
 * Return all marriage-like facts (marriage, engagement, marriage_banns, marriage_contract,
 * marriage_license, marriage_notice, marriage_registration, marriage_settlement)
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @returns {Object[]} fact objects for marriage-like events
 */
export function getMarriageLikeFacts(facts) {
  return getFactsByTypes(facts, marriageLikeFactTypes)
}

/**
 * Get person's primary fact (If there happen to be multiples, this just returns the first one found)
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @returns {array} fact list
 *
 */
export function getPrimaryFact(facts) {
  return facts?.find((fact) => fact.primary)
}

/**
 * Returns true if the facts are different (comparing value, date, and place)
 *
 * @param {*} fact1 - a fact object to compare
 * @param {*} fact2 - the other fact object to compare
 * @returns
 */
export function isDifferentFact(fact1, fact2) {
  const fact1Details = getFactDetails(fact1)
  const fact2Details = getFactDetails(fact2)
  function isEqualProperty(property) {
    return (
      // otherwise, only return true if the properties are equal
      // if only one fact has the property, return false
      (!fact1Details[property] && !fact2Details[property]) || fact1Details[property] === fact2Details[property]
    )
  }

  return !(isEqualProperty('value') && isEqualProperty('date') && isEqualProperty('place'))
}

/**
 * Returns true if the facts are the different or new information can be added (comparing value, date, and place)
 *
 * @param {*} comparingFact - The fact to compare against
 * @param {*} betterFact - The fact that is better (more information)
 * @returns {Object} An object with the following properties: isDifferent (boolean), isUnreliable (boolean)
 */
export function isDifferentFactPreferFormalDate({ comparingFact, betterFact }) {
  const comparingFactDetails = getFactDetailsFormalDate(comparingFact)
  const betterFactDetails = getFactDetailsFormalDate(betterFact)

  const { isEqualOrBetter: datesAreEqual, isReliable } =
    isEqualOrBetterDate({
      betterDate: betterFactDetails?.date,
      comparingDate: comparingFactDetails?.date,
    }) || {}

  return {
    isDifferent:
      !isEqualOrBetterProperty({
        betterProperty: betterFactDetails?.value,
        comparingProperty: comparingFactDetails?.value,
      }) ||
      !isEqualOrBetterProperty({
        betterProperty: betterFactDetails?.place,
        comparingProperty: comparingFactDetails?.place,
      }) ||
      !datesAreEqual,
    isUnreliable: !isReliable,
  }
}

/**
 * Return array of facts sorted in proper search results order: primary (if it exists, usually only in hr), then vitals,
 * then everything else (sorted by date)
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @returns {array} new array with the same facts, sorted in proper search results order
 */
export function sortFactsForDisplay(facts) {
  const primary = facts?.find((fact) => fact.primary) || []
  const vital = getFactsByTypes(facts, vitalFactTypes).filter((fact) => fact !== primary)
  const other =
    facts?.filter((fact) => fact !== primary && vitalFactTypes.indexOf(fact.type) === -1).sort(sortByFactDate) || []
  return [].concat(primary).concat(vital).concat(other)
}

// ===================================================================================================================
// PRIVATE FUNCTIONS (alphabetically arranged)
// ===================================================================================================================

/**
 *
 * @param {Object} fact The fact object returned by getPersonFact
 * @returns {[String]} An array of date strings
 */
function getAllISODates(fact) {
  const dates = fact?.date?.original ? [fact.date.original] : []

  // look in the fields for date values
  const dateFields = getDateFields(fact?.date?.fields)

  // look in the "normalized" date array (tree stores some dates there)
  const normalizedDates = getNormalizedDates(fact?.date?.normalized)

  return [...dates, ...dateFields, ...normalizedDates]
}

/**
 * @param {[Object]} fields - fields array in the fact date
 * @returns {[String]} Array of date strings found in fields
 */
function getDateFields(fields) {
  return (
    fields
      ?.filter(
        (field) =>
          ['http://gedcomx.org/Year', 'http://gedcomx.org/Date'].indexOf(field.type) >= 0 && field?.values?.[0]?.text
      )
      .map((field) => field?.values?.[0]?.text) || []
  )
}

/**
 * Get the best interpreted date from the fact
 * @param {object} fact The fact object returned by getPersonFact
 * @returns {object} The interpreted date object
 */
function getFactDateBestInterpreted(fact) {
  // Try to find the most recently edited value
  const interpretedDateField = fact?.date?.fields?.find((field) => field?.type === 'http://gedcomx.org/Date')
  // we are starting at the end of these arrays because the last item in the array should be the most accurate per our contract with CDS
  const interpretedDate = interpretedDateField?.values?.findLast(
    (date) => date?.type === 'http://gedcomx.org/Interpreted' && date?.labelId !== 'EVENT_TIME' // Ignore event time because we want to get the date, not the time
  )
  return interpretedDate
}

/**
 * Return the first found fact matching the specified array of fact types
 *
 * @param {array} facts - The list of facts for a person (see recordService.getAllPersonFacts)
 * @param {string[]} factTypes - The fact types (e.g. http://gedcomx.org/Birth)
 * @param {object} primaryFact = the primary fact in an array of facts
 * @returns {object} fact object with matching types
 */
function getFirstFactOfTypes(facts, factTypes, primaryFact) {
  return (
    facts?.find((fact) => {
      return factTypes.find((factType) => factType === fact.type && fact.type !== primaryFact?.type)
    }) || null
  )
}

/**
 * Parse numeric month & year fallback, like "2 1711" - which Date.parse can't parse.
 *
 * @param {String} dateString - date string to parse
 * @returns {Boolean|String} ISO-formatted month & year fallback
 */
function getMonthFallback(dateString) {
  const monthYearMatch = /^\s*(\d{1,2})[\s-]+(\d{4})\s*$/.exec(dateString)
  const month = monthYearMatch?.[1] > 0 && monthYearMatch?.[1] < 13 ? monthYearMatch[1] : false
  const year = monthYearMatch?.[2]
  if (month && year) {
    // add leading zeroes to month and day spots (or it's not valid ISO 8601)
    const formattedMonth = month < 10 ? `0${month}` : month
    return `${year}-${formattedMonth}`
  }
  return false
}

/**
 * @param {[Object]} normalized - normalized array in the fact date
 * @returns {[String]} Array of date strings found in normalized
 */
function getNormalizedDates(normalized) {
  return normalized?.filter((normal) => normal.value).map((normal) => normal.value) || []
}

/**
 * @param {String} dateString - date string to parse
 * @returns {Boolean|String} ISO-formatted year fallback
 */
function getYearFallback(dateString) {
  const yearMatch = /\b(\d{4})\b/.exec(dateString)
  return yearMatch?.[1] || false
}

/**
 * Compares two fact properties to see if they are equal or if one fact property has more information than the other.
 *
 * @param {object} betterFactProperty - The fact property that is better (more information)
 * @param {object} comparingFactProperty - The fact property that is being compared to the betterFactProperty
 * @returns {boolean} True if the properties are equal, false otherwise
 */
function isEqualOrBetterProperty({ betterProperty, comparingProperty }) {
  // If there is no comparing fact, return true, because the betterFactProperty is better
  if (!comparingProperty) return true

  const betterPropertyFormatted = betterProperty.toLowerCase()
  const comparingPropertyFormatted = comparingProperty.toLowerCase()

  // Properties are equal to each other so return early
  if (betterPropertyFormatted === comparingPropertyFormatted) return true

  // Try to match by splitting up the comparing fact and seeing if all parts exist in the better fact
  // This is mostly intended for place facts, but will be a good last effort to match for all values.
  // In the future, we may consider comparing better fact parts to the comparing fact value.
  const comparingPropertyParts = comparingPropertyFormatted.split(',').map((part) => part.trim())
  const betterPropertyHasAllParts = comparingPropertyParts.every((part) => betterPropertyFormatted.includes(part))

  return betterPropertyHasAllParts
}

/**
 * Take a date string from a record and turn it into a parsed ISO-formatted date string, if possible
 *
 * @param {String} dateString - string to parse
 * @returns {Boolean|String} A string containing the ISO formatted date string, if possible; false if not
 */
function processDateString(dateString) {
  // Date.parse will get most standard date formats, so try that first (unless we're dealing with a year).
  // NOTE: This is a built-in browser function and results differ for different browsers
  const timestamp = Date.parse(dateString)
  const isYearOnly = /^\s*(\d{4})\s*$/.exec(dateString)
  if (Number.isNaN(timestamp) === false && !isYearOnly) {
    return processTimestamp(timestamp, dateString) || false
  }
  return false
}

/**
 * Take a timestamp and turn it into an ISO-formatted date string, if possible
 * To work around a Chrome bug, also take the original dateString
 *
 * @param {Number} timestamp - timestamp of dateString
 * @param {String} dateString - string to parse
 * @returns {Boolean|String} A string containing the ISO-formatted date string, if possible; false if not
 */
function processTimestamp(timestamp, dateString) {
  const formattedDate = formatISO(timestamp, { representation: 'date' })

  // Google Chrome has a bug where Date.parse returns a date, even for poor date strings
  // It automatically sets the year to 2001
  // Return false so we can use the fallback code to parse this date
  if (/^2001/.exec(formattedDate) && dateString.indexOf('2001') < 0) {
    return false
  }

  // if we don't have day & year granularity (3 tokens minimum, 2 digit tokens minimum),
  // remove the day from the final string
  const dayMonthMatchA = /\S+[\s(?:-|/)]+\S+[\s(?:-|/)]+\S+/.exec(dateString)
  const dayMonthMatchB = /\d+\D+\d+/.exec(dateString)
  if (!(dayMonthMatchA && dayMonthMatchB)) {
    return formattedDate.replace(/-\d\d$/, '')
  }
  return formattedDate
}

/**
 * Removes empty properties, if any.  This includes removing properties that just have an empty object ("place": {}).
 *
 * @param {Object} obj - Gedcomx object, like a fact
 * @returns
 */
export function removeEmptyProperties(obj) {
  if (!obj) return undefined
  Object.keys(obj).forEach((key) => {
    if (obj[key] === null || obj[key] === undefined) {
      delete obj[key]
    } else if (typeof obj[key] === 'object') {
      removeEmptyProperties(obj[key])
      if (Object.keys(obj[key]).length === 0) {
        delete obj[key]
      }
    }
  })
  return obj
}

/**
 * Date Sorting
 */
function sortByFactDate(factA, factB) {
  const factAString = getFactISODateString(factA)
  const factBString = getFactISODateString(factB)
  if (factAString > factBString) {
    return 1
  }
  if (factBString > factAString) {
    return -1
  }
  return 0
}
