/**
 * This is a collection of record methods for GedcomX records.
 * All functions have record as the first parameter
 * PLEASE add new functions in alphabetical order
 */

import { getArkId, decode } from '@fs/zion-ark'
import documentLevelFields from './documentLevelFields'
import { getPersonURL, isPersonMatch, isPersonSourceDescriptionMatch } from './personService'

/**
 * Determines if the record has been retired.
 *
 * @param {Object} record The person record object.
 * @returns {string|null} The URL of the new record if it has been retired, otherwise NULL.
 */
export function getRecordRetiredURL(record) {
  let url = null
  const mainDesc = getMainSourceDescription(record)
  if (mainDesc && mainDesc.replacedBy) {
    url = mainDesc.replacedBy
  } else {
    // In the odd event that the record has been redirected but the persona has not we will use the record redirect.
    // This will navigate to our record details page using the first person in the new record since the person we
    // were trying to view is no longer in the new record.
    const srcDescs = getSourceDescriptionsByType(record, 'http://gedcomx.org/Record')
    const srcDesc = srcDescs?.find((e) => {
      return typeof e.replaceBy !== 'undefined'
    })
    if (srcDesc) {
      url = srcDesc.replaceBy
    }
  }

  return url
}

/**
 * Retrieve all the facts related to a person from the record (including relationship events).
 *
 * @param {object} record - The person record object
 * @param {object} person - The person object
 * @returns {[]} The facts (i.e. events) related to the person
 */
export function getAllPersonFacts(record, person) {
  let facts = []

  if (person?.facts) {
    facts = facts.concat(person.facts)
  }
  const relationships = getPersonRelationshipsRaw(record, person)
  relationships.forEach((rel) => {
    if (rel?.facts) {
      facts = facts.concat(rel.facts)
    }
  })

  return facts
}

/**
   * Use the collection template to get person-level display fields
   *
   * @param {Object} record - The person record object
   * @param {Object} collection - The collection with the record template (display names)
   * @param {Object} person - The person object
   * @param {Boolean} debug - Is it being used in record debugger?
   * 
  
   * @returns {[]} display fields for the person
   *    labelId
   *    fieldType: // http://gedcomx.org/Gender, http://gedcomx.org/Name, http://gedcomx.org/Given,
   *               // http://gedcomx.org/Surname, http://gedcomx.org/Date, http://gedcomx.org/Year,
   *               // http://gedcomx.org/Place , http://gedcomx.org/Age, etc.
   *    valueType: // http://gedcomx.org/Original, http://gedcomx.org/Interpreted
   *    values:    // The array of values for this field (may only contain a single entry)
   *    personId:  // The ID of the person where the value originated from
   */

export function getAllPersonFields(record, collection, person, debug = false) {
  const templateFields = getTemplateFieldsForPersonFields(record, collection, person)

  if (debug) {
    // return all fields, even if they don't have a value, unless their display name is empty or a duplicate
    return removeDuplicateAndEmptyDisplayNames(templateFields)
  }
  const nonEmptyFields = removeEmptyFields(templateFields)
  // need to de-dup the fields
  const uniqueNonEmptyFields = removeDuplicateFields(nonEmptyFields)

  return uniqueNonEmptyFields
}

/**
 * Use the collection template to get person-level display fields
 *
 * @param {Object} record - The person record object
 * @param {Object} collection - The collection with the record template (display names)
 * @param {Object} person - The person object
 * @returns {[]} display fields for the person INCLUDING empty fields
 *    labelId
 *    fieldType: // http://gedcomx.org/Gender, http://gedcomx.org/Name, http://gedcomx.org/Given,
 *               // http://gedcomx.org/Surname, http://gedcomx.org/Date, http://gedcomx.org/Year,
 *               // http://gedcomx.org/Place , http://gedcomx.org/Age, etc.
 *    valueType: // http://gedcomx.org/Original, http://gedcomx.org/Interpreted
 *    values:    // The array of values for this field (may only contain a single entry)
 *    personId:  // The ID of the person where the value originated from
 */
export function getAllPersonFieldsIncludingEmpty(record, collection, person) {
  const templateFields = getTemplateFieldsForPersonFields(record, collection, person)

  // need to de-dup the fields
  const uniqueFields = removeDuplicateFields(templateFields)

  // return all fields, even if they don't have a value, as long as they have a disply name
  return uniqueFields?.filter((fact) => fact.displayName?.[0]?.value)
}

/**
 * @param {Object} record - The persona or record object
 * @returns {{ collectionName, collectionDescription, collectionURL, collectionId }} collection data
 */
export function getCollectionDetails(record) {
  const srcDesc = getSourceDescriptionsByType(record, 'http://gedcomx.org/Collection')
  const recordSrcDesc = getSourceDescriptionsByType(record, 'http://gedcomx.org/Record')

  const { collectionName, collectionDescription } = getCollectionTitleAndDescription(srcDesc?.[0])
  const collectionURL =
    recordSrcDesc?.[0]?.descriptor?.resource || srcDesc?.[0]?.identifiers?.['http://gedcomx.org/Primary']?.[0] || ''
  const parts = collectionURL.match?.(/collections\/(\d*)/) || collectionURL.match?.(/cc=(\d*)/)
  const collectionId = parts?.[1] || ''
  const collectionWebURL = `/search/collection/${collectionId}`
  return { collectionDescription, collectionId, collectionName, collectionURL, collectionWebURL }
}

/**
 * Returns the title and description of a collection
 *
 * @param {Object} srcDesc - The source objects
 * @returns {{ collectionName, collectionDescription }} collection data
 */
export function getCollectionTitleAndDescription(srcDesc) {
  const collectionName = srcDesc?.titles?.[0]?.value || ''
  const collectionDescription = srcDesc?.descriptions?.[0]?.value || ''
  return { collectionName, collectionDescription }
}

/**
 * Returns the contributor information for a record.
 *
 * @param {Object} record A Persona as returned by GedxPersonaPOJO.prototype.getPerson, or an unprocessed record.
 * @returns {Array} Array containing the ID of all contributors. May be empty.
 */
export function getContributorDetails(record) {
  const contributors = []
  const primaryAttribution = record?.attribution?.contributor?.resourceId
  if (primaryAttribution && !isRoboKey(record)) {
    contributors.push(primaryAttribution)
    if (record.additionalAttribution?.length) {
      for (let i = 0; i < record.additionalAttribution.length; i++) {
        const additionAttributor = record.additionalAttribution[i]
        if (additionAttributor.contributor && additionAttributor.contributor.resourceId) {
          contributors.push(record.additionalAttribution[i].contributor.resourceId)
        }
      }
    }
  }
  return contributors
}

/**
 * Returns the contributor ID
 *
 * @param {Object} record The record object
 * @returns {String} ID of the contributor
 */
export function getContributorID(record) {
  return getContributorDetails(getCollectionDescriptionFilterByAbout(record))?.[0]
}

/**
 * Returns the record specific collection description object from a record's sourceDescriptions array.
 *
 * @param {Object} record The record object
 * @returns {Object} The collection description object
 */
export function getCollectionDescriptionFilterByAbout(record) {
  // Get collection description that DOES NOT have 'collection' in the 'about' property
  return record?.sourceDescriptions?.filter(
    (source) => source?.resourceType === `http://gedcomx.org/Collection` && !source?.about?.includes(`collection`)
  )?.[0]
}

/**
 * Returns the parent collection description object from a record's sourceDescriptions array.
 *
 * @param {Object} record The record object
 * @returns {Object} The collection description object
 */
export function getParentCollectionDescriptionFilterByAbout(record) {
  // Get collection description that DOES have 'collection' in the 'about' property
  let recordSrc = record?.sourceDescriptions?.filter(
    (source) => source?.resourceType === `http://gedcomx.org/Collection` && source?.about?.includes(`collection`)
  )?.[0]

  // If our previous criteria yielded no results, just return the first collection description if it exists
  if (!recordSrc) {
    recordSrc = record?.sourceDescriptions?.filter(
      (source) => source?.resourceType === `http://gedcomx.org/Collection`
    )?.[0]
  }
  return recordSrc
}

/**
 * Returns the source ID taken from a URL
 *
 * @param {String} sourceURL The source URL
 * @param {String} prefix Where in the URL the source is located
 * @returns {String} ID of the source
 */
export function getSourceIDFromURL(sourceURL, prefix) {
  return sourceURL.split(prefix)[1]
}

/**
 * Use the collection template to get document-level display fields
 *
 * @param {Object} record - The person record object
 * @param {Object} collection - The collection with the record template (display names)
 * @param {Boolean} debug - Is it being used in record debugger?
 * @returns {Array} display fields for the record/document
 */
export function getDocumentInformation(record, collection, debug) {
  const templateFields = getCollectionTemplateFields(record, collection)
  const focusPerson = getFocusPerson(record)
  setupItemFields({ record, item: focusPerson, templateFields, includeDocumentFields: true })
  setupFieldsForDisplay({ templateFields, fieldsToProcess: record.fields, focusPerson, includeDocumentFields: true })
  let fields = removeEmptyFields(templateFields)
  if (debug) {
    // return all fields, even if they don't have a value, unless they have a duplicate or empty display name
    fields = removeDuplicateAndEmptyDisplayNames(templateFields)
  }

  // de-dup fields with the same display information
  return fields?.filter((field, index, arr) => {
    const theseURLs = JSON.stringify(field.valueURLs)
    const theseValues = JSON.stringify(field.values)
    const theseDisplayNames = JSON.stringify(field.displayName)
    const indexOf = arr.findIndex((otherField) => {
      return (
        JSON.stringify(otherField.displayName) === theseDisplayNames &&
        JSON.stringify(otherField.values) === theseValues &&
        JSON.stringify(otherField.valueURLs) === theseURLs
      )
    })
    return indexOf >= index
  })
}

/**
 * Processes the collection against the record and determines which fields should be editable.
 * @param {Object} record - The person record object
 * @param {Object} collection - The collection with the record template (display names)
 */
export function getEditableFieldMap(record, collection) {
  const editableFields = {}
  const recordDescr = getRecordDescriptor(record, collection)
  if (recordDescr && recordDescr.fields) {
    recordDescr.fields.forEach((fieldDescr) => {
      fieldDescr.values.forEach((field) => {
        // If THIS field is editable, add it
        if (field.editable) {
          editableFields[field.labelId] = true
          // If THIS field has a parent field, add the parent field
          if (field.parentLabelId) {
            editableFields[field.parentLabelId] = true
          }
        }
      })
    })
  }
  return editableFields
}

/**
 * Records are supposed to have a 1:1 persona in the source description's about field.
 * However, if the person doesn't exist for some reason, we'll return the first person in the list
 * @param {Object} record - The persona record object
 * @returns {Object} the focus person on the record
 */
export function getFocusPerson(record) {
  const idOrUrl = getSourceDescription(record)?.about || null
  if (idOrUrl) {
    const aboutPerson = getPerson(record, idOrUrl)
    if (aboutPerson) {
      return aboutPerson
    }
  }
  return record?.persons?.[0]
}

/**
 * @param {Object} record - The persona record object
 * @returns {String} the arkId for image
 */
export function getImageArkId(record) {
  let arkId = ''
  const url = getImageURL(record)
  if (url) arkId = getArkId(url)
  return arkId
}

/**
 * Return the media type for the image for this record.
 *
 * @param {object} record - The persona record object
 * @param {string} [idOrUrl] -  The person Id or URL.
 * @returns {string} media type (e.g. 'image/jpeg' or 'application/json')
 */
export function getImageMediaType(record, idOrUrl) {
  let mediaType = ''

  const sources = getSourceDescriptionsByType(record, 'http://gedcomx.org/DigitalArtifact')
  if (sources?.length > 1) {
    // In the event that we have more than one image, use the one that pertains to the person specified (or focus person)
    const person = idOrUrl ? getPerson(record, idOrUrl) : getFocusPerson(record)
    const descrId = person?.sources?.[0]?.descriptionId
    const source = sources.find((e) => {
      return e.id === descrId
    })
    mediaType = source?.mediaType
  }
  if (mediaType?.length === 0 && sources?.length > 0) {
    // If for any reason we don't have a type selected yet then pick the first one to avoid problems later
    mediaType = sources?.[0]?.mediaType
  }

  return mediaType
}

/**
 * Collect and process the image variables - specifically the third party values.
 *
 * @param {object} record The persona or record object.
 * @param {string|null} [idOrUrl] The person Id or URL. May be NULL for main person. Optional.
 * @param {object} [imageData] The image ark data call response. Optional: we'll use it if included.
 * @returns {object} imageMeta stuff:
 *            imageURL: string (may be empty)
 *            isExternalImage: boolean
 *            thirdPartyHostName: string ("das.famiylsearch.org" for internal images)
 *            thirdPartyURL: string (may be empty)
 */
export function getImageMeta(record, idOrUrl, imageData) {
  const imageURL = getImageURL(record, idOrUrl) // image url or empty string
  const imageMeta = {
    imageURL,
    isExternalImage: imageURL.length > 0 && imageURL.indexOf('familysearch.org') === -1,
    thirdPartyHostName: 'das.familysearch.org',
    thirdPartyURL: '',
  }

  if (imageMeta.isExternalImage) {
    record?.agents?.forEach((agent) => {
      if (agent?.identifiers?.['http://gedcomx.org/Persistent']?.[0]) {
        imageMeta.thirdPartyHostName = agent.identifiers['http://gedcomx.org/Persistent'][0]
      }
    })
    imageMeta.thirdPartyURL = imageMeta.imageURL
  }
  // some third party data is in the image medata - as a supplemental 3rd party image.
  // that data should be shown sometimes, so we need to include it
  else if (imageData) {
    let thirdPartyURL = ''
    let thirdPartyHostname = ''
    let thirdPartyTermsOfUse = ''

    imageData?.agents?.forEach((agent) => {
      thirdPartyTermsOfUse = agent.links?.siteUrl?.href
      thirdPartyHostname = agent.names?.[0]?.value
    })
    // get the third party data from a source descriptions with id sd_variant1
    const thirdPartySourceDescription = imageData?.sourceDescriptions?.find((sourceDesc) => {
      return sourceDesc.id === 'sd_variant1'
    })
    if (thirdPartySourceDescription) {
      thirdPartyURL = thirdPartySourceDescription.identifiers?.['http://gedcomx.org/Primary']?.[0]
      thirdPartyHostname = thirdPartyHostname || new URL(thirdPartyURL).hostname
    }
    if (thirdPartyHostname && thirdPartyURL) {
      imageMeta.thirdPartyURL = thirdPartyURL
      imageMeta.thirdPartyHostName = thirdPartyHostname
      imageMeta.thirdPartyTermsOfUse = thirdPartyTermsOfUse
    }
  }

  return imageMeta
}

/**
 * Return the URL for the image for this record.
 *
 * @param {Object} record The persona record object.
 * @param {String|null} [idOrUrl] The person Id or URL. May be null for main person. Optional.
 * @returns {String} image URL (may be empty)
 */
export function getImageURL(record, idOrUrl) {
  const sources = getSourceDescriptionsByType(record, 'http://gedcomx.org/DigitalArtifact')
  const person = getPerson(record, idOrUrl)
  const personSourceDescId = person?.sources?.[0]?.descriptionId
  const imageSource =
    sources &&
    (sources.find((source) => {
      return source.id === personSourceDescId
    }) ||
      sources[0]) // Pick the first one to avoid nasty behavior later

  if (imageSource && imageSource.about) {
    return imageSource.about
  }

  return imageSource?.identifiers?.['http://gedcomx.org/Persistent']?.[0] || ''
}

/**
 * Return the source description for the main persona.
 *
 * @param {Object} record The record object.
 * @returns {*} The source description for the main persona.
 */
export function getMainSourceDescription(record) {
  let srcDesc = null
  if (record?.description) {
    srcDesc = getSourceDescription(record, record.description)
  }
  return srcDesc
}

/**
 * Get the focus person from the record.
 * @param {Object} record - the GedcomX record.
 * @param {String} idOrUrl - The person ID or URL
 * @returns {any|null} - the persona object or null if not found.
 * {
 *   id: String,
 *   lang: String,
 *   attribution: { contributor: { resource, resourceId } },
 *   links: { next: { href: String }, prev: { href: String }, self: { href: String } },
 *   description: String,
 *   persons: [ {
 *     id: String,
 *     extracted: Boolean,
 *     principal: Boolean,
 *     gender: Object,
 *     links: Object,
 *     sources: Array,
 *     identifiers: Object,
 *     names: Array,
 *     facts: Array,
 *     fields: Array
 *   } ],
 *   relationships: [ {
 *     id: String,
 *     type: String,
 *     person1: { resource, resourceId },
 *     person2: { resource, resourceId }
 *   } ],
 *   sourceDescriptions: [ {
 *     id: String,
 *     mediaType: String,
 *     about: String,
 *     componentOf: Object,
 *     resourceType: String,
 *     created: Number,
 *     modified: Number,
 *     coverage: Array,
 *     citations: Array,
 *     sources: Array,
 *     titles: Array,
 *     rights: Array,
 *     identifiers: Array,
 *     descriptor: Array,
 *   } ],
 *   agents: [ { id: String, identifiers: { 'http://gedcomx.org/Persisistent': [ String ] } } ],
 *   places: [ { id: String, identifiers: { 'http://gedcomx.org/Primary': [ String ] } } ],
 *   fields: [ { type: String, values: [ { type: String, labelId: String, text: String } ] } ],
 *   additionalAttribution: [ { contributor: { resource, resourceId } } ],
 * }
 */
export function getPerson(record, idOrUrl) {
  return record?.persons?.find((p) => isPersonMatch(p, idOrUrl)) || null
}

/**
 * @param {Object} record The persona or record object
 * @param {Object} person The person object (see getPerson).
 * @returns {String} The citation for this person. May be empty string
 */
export function getPersonCitation(record, person) {
  let citation = ''
  if (record && person) {
    const sourceDescs = getSourceDescriptionsByType(record, 'http://gedcomx.org/Person')
    const personSourceDesc = sourceDescs.find((srcDesc) => isPersonSourceDescriptionMatch(person, srcDesc))
    citation = personSourceDesc?.citations?.[0]?.value || ''
  }
  return citation
}

/**
 * Returns the number of people in a record
 *
 * @param {Object} record The record object
 * @returns {Number} The number of people on this record
 */
export function getCollectionPersonCount(record) {
  return record.collections?.[0]?.content?.[0]?.count
}

/**
 * @param {Object} record - The persona or record object
 * @param {Object} person - A person from the record
 * @returns {String|null} person title
 */
export function getPersonTitle(record, person) {
  const personURL = getPersonURL(person)
  const srcDesc = getSourceDescription(record, personURL)
  return srcDesc?.titles?.[0]?.value || null
}

/**
 * Returns the first collection that is a specific kind of ark
 *
 * @param {Object} record The record object
 * @param {Object} regex The kind of ark to look for
 * @returns {Number} The ark ID
 */
export function getCollectionArkFromSource(record, regex) {
  const srcDescriptions = getSourceDescriptionsByType(record, 'http://gedcomx.org/Collection')
  for (let i = 0; i < srcDescriptions.length; i++) {
    const src = srcDescriptions[i]?.about
    if (src?.includes('/ark:/61903/')) return regex.exec(src)[0]
  }
  return null
}

/**
 * @param {Object} record The persona or record object
 * @returns {[Object]} fields
 */
export function getRecordFields(record) {
  return record?.fields || []
}

/**
 * Return the rights array for the record.
 *
 * @param {Object} record The persona or record object
 * @returns {[String]} Array of permissions for this record. May be empty if no restrictions.
 * Possible values include (as of 11/30/2021):
 *   CdsPrmAffiliate
 *   CdsPrmAnyone - this is the default behavior/treatment if there aren't any permissions listed. This is NOT returned.
 *   CdsPrmDataTeam
 *   CdsPrmFhlSLC
 *   CdsPrmFhlc
 *   CdsPrmLdsMember
 *   CdsPrmNoAccess
 *   CdsPrmNotSignedIn - also default behavior, should not add a lock icon. This is also not returned.
 *   CdsPrmRegisteredPatron
 *   CdsPrmSearchEngineering
 */
export function getRecordPermissions(record) {
  const permissions = []
  const recordSourceDesc = getSourceDescriptionsByType(record, 'http://gedcomx.org/Record')?.[0]
  if (recordSourceDesc?.rights) {
    recordSourceDesc.rights.forEach((p) => {
      const shortPermission = p.replace('http://familysearch.org/records/recordPermissions/', '')
      if (shortPermission !== 'CdsPrmAnyone' && shortPermission !== 'CdsPrmNotSignedIn') {
        permissions.push(shortPermission)
      }
    })
  }
  return permissions
}

/**
 * Returns the first principal person on a record.
 * @param {Object} record The persona or record object
 * @returns {Object|null} The pincipal person, if found
 */
export function getRecordPrincipal(record) {
  return record?.persons?.find((person) => person.principal) || null
}

/**
 * @param {Object} record The persona or record object
 * @returns {String} record type (e.g. http://gedcomx.org/Census)
 */
export function getRecordType(record) {
  const srcDesc = getTopLevelDescription(record)
  const coverageDesc = (srcDesc?.coverage || []).find((item) => item.recordType)

  let recordType = coverageDesc?.recordType || ''
  // TODO: Remove this block when the recordType is always in the coverage for Full-Text records (FULLTEXT24-525)
  if (!recordType) {
    // get record source description record type
    const recordSrcDesc = getSourceDescriptionsByType(record, 'http://gedcomx.org/Record')
    const recordSrcDescRecordType = recordSrcDesc?.[0]?.coverage?.[0]?.recordType || ''
    if (recordSrcDescRecordType && recordSrcDescRecordType !== 'http://familysearch.org/types/records/Unspecified') {
      recordType = recordSrcDesc?.[0]?.resourceType || ''
    } else {
      // if not found in record source description coverage, get digital artifact source description record type
      const digitalSrcDesc = getSourceDescriptionsByType(record, 'http://gedcomx.org/DigitalArtifact')
      recordType = digitalSrcDesc?.[0]?.coverage?.[0]?.recordType || ''
    }
  }
  // end Full-Text record type fallback
  return recordType
}

/**
 * Return the URL for the record.
 *
 * @param {Object} record - The persona or record object
 * @returns {String|null} URL
 */
export function getRecordURL(record) {
  const srcDescriptions = getSourceDescriptionsByType(record, 'http://gedcomx.org/Record')
  return srcDescriptions?.[0]?.about || null
}

/**
 * Return the subCollection data
 * @param {Object} record - The persona or record object
 * @returns {{ subCollectionName, subCollectionDescription }} subCollection data
 */
export function getSubCollectionDetails(record) {
  const srcDesc = getSourceDescriptionsByType(record, 'http://gedcomx.org/Collection')
  let subCollectionName
  let subCollectionDescription
  let subCollectionId
  if (srcDesc[1]?.componentOf?.description.replace('#', '') === srcDesc[0]?.id) {
    subCollectionName = srcDesc?.[1]?.titles?.[0]?.value || ''
    subCollectionDescription = srcDesc?.[1]?.descriptions?.[0]?.value || ''
    subCollectionId = srcDesc?.[1]?.id || ''
  } else if (srcDesc[0]?.componentOf?.description.replace('#', '') === srcDesc[1]?.id) {
    subCollectionName = srcDesc?.[0]?.titles?.[0]?.value || ''
    subCollectionDescription = srcDesc?.[0]?.descriptions?.[0]?.value || ''
    subCollectionId = srcDesc?.[0]?.id || ''
  }

  return { subCollectionName, subCollectionDescription, subCollectionId }
}

/**
 * Returns the best name to represent this person.
 * Get the Submitter's Name from the record.
 *
 * @param {Object} record - The persona or record object
 * @returns {String} submitter's name
 */
export function getSubmitterName(record) {
  return record?.agents?.[0]?.accounts?.[0]?.accountName || null
}

/**
 * @param {Object} record - The persona or record object
 * @returns {Boolean} true if this template is person-centric.
 */
export function isPersonCentricTemplate(record) {
  return record?.fields?.find((field) => {
    return field?.type?.match('FsDisplayType') && field?.values?.[0]?.text === 'Person'
  })
}

/**
 * Determines if the record was indexed by a computer (e.g. 'robokeyed').
 *
 * @param {Object} record The persona or record object
 * @returns {Boolean} True if the record was indexed by a computer, otherwise false.
 */
export function isRoboKey(record) {
  const fields = record.fields || []
  const foundRoboRecord = fields.find((field) => {
    return field.type && field.type.match('RecordGroup') && field?.values?.[0]?.text === 'OutputDeliveryAllRobo'
  })
  return Boolean(foundRoboRecord)
}

/**
 * @deprecated Since version 5.0.0. Will be deleted in version 6.0.0. Use getPhysicalDigitalSources() instead.
 * @param {*} record - The persona/record object
 * @returns {Array} - an array of objects containing descriptions of sources for this record
 */

export function getRecordSources(record) {
  // eslint-disable-next-line no-console
  console.warn('getRecordSources() is deprecated. Use getPhysicalDigitalSources() instead.')
  let sources = []
  if (record?.sourceDescriptions) {
    sources = getSourceDescriptionsByType(record, 'http://gedcomx.org/PhysicalArtifact')
  }
  return sources
}

/**
 * Returns the physical and digital sources in a record.  Used in GenDetailsInfoSheet.
 *
 * @param {*} record - The persona/record object
 * @returns {{Array, Array, Array}} - arrays of objects containing descriptions of sources for this record
 */

export function getPhysicalDigitalSources(record) {
  let physical = []
  let digital = []
  if (record?.sourceDescriptions) {
    physical = getSourceDescriptionsByType(record, 'http://gedcomx.org/PhysicalArtifact')
    digital = getSourceDescriptionsByType(record, 'http://gedcomx.org/DigitalArtifact')
  }
  const all = [...physical, ...digital]
  if (!all.length > 0) return null
  return { physical, digital, all }
}

/**
 * Return subcollection data, intended for use with trees (Researcher trees, possibly gen at some point in the future)
 * @param {Object} record - The persona or record object to retrieve details from
 * @returns {{ subCollectionName: String, subCollectionDescription: String, subCollectionId: String }} - subcollection data
 */
export function getTreeSubCollectionDetails(record) {
  let srcDesc = getSourceDescriptionsByType(record, 'http://familysearch.org/ResearchTree')
  // Remove if statement on completion of https://fhjira.churchofjesuschrist.org/browse/SC-7442
  if (!srcDesc?.length) {
    srcDesc = getSourceDescriptionsByType(record, 'http://familysearch.org/ResearcherTree')
  }

  const { collectionName: subCollectionName, collectionDescription: subCollectionDescription } =
    getCollectionTitleAndDescription(srcDesc?.[0])
  const subCollectionId =
    srcDesc?.[0]?.identifiers?.['http://gedcomx.org/Primary']?.[0] || srcDesc?.[0]?.about?.split('/').at(-1) || ''

  return { subCollectionName, subCollectionDescription, subCollectionId }
}

/**
 * Return collection data, intended for use with trees (Researcher trees, possibly gen at some point in the future)
 * @param {Object} record - The persona or record object to retrieve details from
 * @returns {{ subCollectionName: String, subCollectionDescription: String, subCollectionId: String }} - subcollection data
 */
export function getTreeCollectionId(record) {
  const srcDesc = getSourceDescriptionsByType(record, 'http://familysearch.org/Collection')
  const collectionId =
    srcDesc?.[0]?.identifiers?.['http://gedcomx.org/Primary']?.[0] || srcDesc?.[0]?.about?.split('/').at(-1) || ''
  return { collectionId: collectionId ? decode(collectionId) : '' }
}

/**
 * Return collection data for LLS records
 * @param {Object} record - the record object to retrieve details from
 * @returns {{collectionName: String, collectionDescription: String, collectionId: String}}
 */
export function getLLSCollectionDetails(record) {
  const srcDesc = getSourceDescriptionsByType(record, 'http://gedcomx.org/Collection').filter(
    (source) => source.id?.startsWith('sd_') === false
  )
  const { collectionName, collectionDescription } = getCollectionTitleAndDescription(srcDesc?.[0])
  const collectionId = (
    srcDesc?.[0]?.identifiers?.['http://gedcomx.org/Persistent']?.[0] ||
    srcDesc?.[0]?.id ||
    srcDesc?.[0]?.about?.split('/').at(-1) ||
    ''
  )
    .split(':')
    .at(-1)
  return { collectionName, collectionDescription, collectionId }
}

// ===================================================================================================================
// PRIVATE FUNCTIONS (alphabetically arranged)
// ===================================================================================================================

/**
 * Using the descriptor ID from the record, find the matching descriptor in the collection.
 *
 * @param {Object} collection The collection.
 * @param {String} [descId] The descriptor ID from the record.
 * @returns {Object|null} The matching record descriptor. May be null if not found.
 */
function getCollectionRecordDescriptor(collection, descId) {
  if (collection && collection.recordDescriptors && descId) {
    return (
      collection.recordDescriptors.find((descr) => {
        return descr.id === descId
      }) || null
    )
  }
  if (collection && collection.recordDescriptors && !descId) {
    // If no descId, fall back to the first record descriptor. It will probably be a combined grand descriptor.
    return collection.recordDescriptors[0]
  }
  return null
}

/**
 * @param {Object} record - the persona or record object
 * @param {Object} collection - the collection object
 * @returns {Array} collection template fields
 */
function getCollectionTemplateFields(record, collection) {
  const descriptor = getRecordDescriptor(record, collection)
  return getTemplateDescriptorFields(descriptor)
}

/**
 * Return the relationships where the person occurs in the record
 *
 * @param {Object} record The persona record object.
 * @param {Object} person The person object.
 * @returns {[{{id, type, person1, person2}}]} The list of relationships where this person appears. May be empty.
 *  The relationships the person is a part of. May be empty.
 */
function getPersonRelationshipsRaw(record, person) {
  if (!person || !person.id) {
    return []
  }
  return (
    record?.relationships?.reduce((foundRels, relationship) => {
      // See if pid is in this relationship
      if (
        (relationship.person1 && relationship.person1.resourceId === person.id) ||
        (relationship.person2 && relationship.person2.resourceId === person.id)
      ) {
        foundRels.push(relationship)
      }
      return foundRels
    }, []) || []
  )
}

/**
 * @param {Object} record - The persona or record object
 * @param {Object} collection - The collection object
 * @returns {{fields: [{labels: [{labelId, value: String}]}]}|null} record descriptor
 */
function getRecordDescriptor(record, collection) {
  let descriptor = null
  const srcDesc = getTopLevelDescription(record)

  const ref = srcDesc?.descriptor?.resource
  const pos = ref?.indexOf('#')
  if (pos >= 0) {
    descriptor = getCollectionRecordDescriptor(collection, ref.substring(pos + 1))
  }

  if (!descriptor) {
    // fall back to the general record descriptor on the collection
    descriptor = getCollectionRecordDescriptor(collection)
  }

  return descriptor
}

/**
 * Get URLs for name, batch and film fields that can link to other searches and records.
 *
 * @param field
 * @returns {{}}
 */
function getReferenceURLs(field) {
  const referenceURLs = {}
  if (['UDE_BATCH_NUMBER', 'FS_UDE_BATCH_NBR'].find(findLabelId)) {
    referenceURLs.valueURLs = field.values?.map((val) => `/search/record/results?q.batchNumber=${val}`)
  } else if (
    [
      'FILM_NUMBER',
      'DIGITAL_GS_NUMBER',
      'MICROFILMNUMBER',
      'FS_FILM_NBR',
      'FOLDER',
      'DIGITAL_FILM_NUMBER',
      'DIGITAL_GS_NUMBER',
      'FILM_NUMBER',
      'FOLDER',
      'FS_DIGITAL_FILM_NBR',
      'FS_DIGITAL_FILM_NUMBER',
      'FS_FILM_NBR',
      'GSU_FILM_NUMBER',
      'PADDED_DGS_NBR',
      'PADDED_DGS_NUMBER',
      'PADDED_FILM',
      'WP_DIGITAL_GS_NUMBER',
    ].find(findLabelId)
  ) {
    referenceURLs.valueURLs = field.values?.map((val) => `/search/record/results?q.filmNumber=${val}`)
  } else if (['SOURCE_BOOK_NBR'].find(findLabelId)) {
    referenceURLs.valueURLs = field.values?.map(
      (val) => `/search/catalog/results?count=20&query=%2Bcall_number%3A"${val}"`
    )
  }
  return referenceURLs

  function findLabelId(label) {
    return field.labelId.includes(label)
  }
}

/**
 * Return the source description for a given ID.
 *
 * @param {Object} record The GedcomX record. May be null if the main source description is desired.
 * @param {String} [idOrUrl] The source ID or URL.
 * @returns {null|{
 *     id: String,
 *     mediaType: String,
 *     about: String,
 *     componentOf: Object,
 *     resourceType: String,
 *     created: Number,
 *     modified: Number,
 *     coverage: Array,
 *     citations: Array,
 *     sources: Array,
 *     titles: Array,
 *     rights: Array,
 *     identifiers: Array,
 *     descriptor: Array,
 *   }} The source description. May be null if not found.
 */
function getSourceDescription(record, idOrUrl) {
  let source = null
  if (!idOrUrl && record?.description) {
    idOrUrl = record.description
  }

  // Id could be a resource id starting with #. Remove that so we can do a proper match.
  if (idOrUrl && idOrUrl.charAt(0) === '#') {
    idOrUrl = idOrUrl.substring(1)
  }

  if (idOrUrl) {
    // If we get here without an idOrUrl then we have a record structure problem
    source = record?.sourceDescriptions?.find((descr) => {
      /* The usual sourceDescription.about has the format: /ark:/61903/X:X:XXXX-XXXX. In some cases, we just get the last part of it in the format: #X:X:XXXX-XXXX
         Adding the ark part ("/ark:/61903/") and getting rid of the # makes sure to find the correct source */
      let descriptionAbout = descr?.about
      // Could be a sourceDescription.about starting with #. Remove that and add the ark fragment ("/ark:/61903/") so we can do a proper match.
      if (descriptionAbout?.charAt(0) === '#') {
        descriptionAbout = `/ark:/61903/${descriptionAbout.substring(1)}`
      }
      // Descriptions can be in URL format or in internal id format.  Handle both cases.
      let aboutURLObject = null
      let idOrURLObject = null
      // If it has a / - try to parse it as a URL; internal identifiers like p_XXX and sd_XXX don't have slashes
      if (idOrUrl.includes('/')) {
        try {
          aboutURLObject = new URL(descriptionAbout, window.location.href)?.pathname
          idOrURLObject = new URL(idOrUrl, window.location.href)?.pathname
        } catch (e) {
          // this error is benign; this function can work fine without URLs
        }
      }
      return (idOrURLObject && aboutURLObject === idOrURLObject) || descr.id === idOrUrl
    })
  }
  return source
}

/**
 * Return the source descriptor objects matching the type specified.
 *
 * @param {Object} record The persona or record object
 * @param {String} sourceType The type for the source (e.g. http://gedcomx.org/DigitalArtifact)
 * @returns {[Object]} The list of matching descriptors or an empty array if none found.
 */
export function getSourceDescriptionsByType(record, sourceType) {
  return record?.sourceDescriptions?.filter((e) => e.resourceType === sourceType)
}

/**
 * Returns the source URL from sources that also have the 'artifactMetadata' property
 *
 * @param {Object} record The record object
 * @returns {[Object]} The list of matching URLs or an empty array if none found.
 */
export function getDigitalSources(record) {
  const sources = getSourceDescriptionsByType(record, 'http://gedcomx.org/DigitalArtifact').filter(
    (source) => source.artifactMetadata
  )
  return sources.map((src) => {
    return src.about
  })
}

/**
 * Pre-process the fields from the record descriptor.
 * This creates an ordered list of placeholder fields.  Actual person data will be added later.
 *
 * @param {{fields: [{labels: [{labelId, value: String}]}]}|null} collectionDesc The record descriptor from the collection.
 * @returns {Array} The fields to be displayed (this is both an array and a map object). May be empty.
 */
function getTemplateDescriptorFields(collectionDesc) {
  const collectionFields = collectionDesc?.fields || []

  return collectionFields.reduce((fieldArray, field) => {
    Array.prototype.push.apply(
      fieldArray,
      (field.values || []).map((value) => {
        return {
          labelId: value.labelId,
          displayName: [{ value: getValueToDisplay(value, field.values) }],
        }
      })
    )
    return fieldArray
  }, [])
}

/**
 * Recursively loop through record descriptors to get the coverage record
 *
 * @param {Object} record object
 */
function getTopLevelDescription(record) {
  // Track visited source descriptions to avoid infinite loops
  const visited = new Set()
  let srcDesc = getSourceDescription(record)
  while (srcDesc && !srcDesc.coverage && srcDesc.componentOf) {
    const desc = srcDesc.componentOf.description
    if (visited.has(desc)) break
    srcDesc = getSourceDescription(record, desc)
    visited.add(desc)
  }
  return srcDesc
}

/**
 * Find value for display name, if it exists
 *
 * @param {Object} value Value
 * @param {Array} values Fallback values
 * @returns {String} found value, or null
 */
function getValueToDisplay(value, values) {
  const foundValue = value.labels?.[0]?.value
  if (foundValue) {
    return foundValue
  }
  // find the first label in the values for display name to use as a fallback
  const fallbackValue = values.find((val) => val.labels?.[0]?.value)
  if (fallbackValue) {
    return fallbackValue.labels[0].value
  }
  return ''
}

/**
 * If there are multiple film links, separate them
 *
 * @param {Object} value - value to turn into an array
 * @returns {Array} array form of values
 */
function makeValuesArray(value) {
  if (value.labelId === 'FILM_NUMBER' && value.text.includes(',')) {
    return value.text.replace(/ /g, '').split(',')
  }
  return [value.text]
}

/**
 * Removes fields that have duplicate or empty display names
 *
 * @param {Array} fields
 * @returns {Array} an array consisting of fields with unique, non-empty display names
 */
function removeDuplicateAndEmptyDisplayNames(fields) {
  const fieldsToRemove = []
  // if a field has a display name identical to that of another field, either set it up for removal or set the other field
  // up for removal, whichever field has a value. If neither or both fields have values, keep the earlier field
  fields?.forEach((field, index) => {
    const similarField = fields
      .slice(0, index)
      .find((otherField) => field.displayName?.[0]?.value === otherField.displayName?.[0]?.value)
    if (similarField) {
      if (!similarField.value && field.value) {
        fieldsToRemove.push(similarField)
      } else fieldsToRemove.push(field)
    }
  })
  return fields?.filter((field) => fieldsToRemove.indexOf(field) === -1 && !!field.displayName?.[0]?.value)
}
/**
 * Remove all empty fields from an array
 *
 * @param {Array} fields - fields to check
 * @returns {Array} fields without empty things
 */
function removeEmptyFields(fields) {
  return fields?.filter((fact) => fact.displayName?.[0]?.value && fact.value)
}

/**
 * Remove all duplicate fields from an array, based on display name
 *
 * @param {Array} fields - fields to check
 * @returns {Array} fields without duplicates
 */
function removeDuplicateFields(fields) {
  // We want duplicates on some fact labels. All labelIds containing the subStrings in this array
  // will be added regardless of duplicates
  const combineTypes = ['OTHER_ON_PAGE_NAME_']
  const uniqueFields = fields.filter((fact, index) => {
    if (combineTypes.some((combineType) => fact?.labelId?.includes(combineType))) return true
    const previousDuplicateFact = fields
      .slice(0, index)
      .find((field) => field.displayName?.[0]?.value === fact.displayName?.[0]?.value)
    // if the duplicate fact doesn't have a value, and the new one does, we should keep it
    const shouldKeepNewFact = !previousDuplicateFact?.value && fact?.value
    if (previousDuplicateFact && !shouldKeepNewFact) return false

    return true
  })

  return uniqueFields
}

/**
 * Create a new field object to make displaying it easier
 *
 * @param {Object} person - the person object
 * @param {Object} templateField - the template field object
 * @param {Object} valueToProcess - the field object we are processing
 * @param {Object} focusPerson - the record's focus person object
 * @returns {{isFocusPerson: boolean, labelId: *, values: Array, valueType: *, personId: (*|null), fieldType: *, value: *}}
 */
function setUpFieldForDisplay({ person, templateField, valueToProcess, focusPerson }) {
  const fieldForDisplay = {
    values: makeValuesArray(valueToProcess),
    labelId: valueToProcess.labelId,
    fieldType: templateField.type,
    valueType: valueToProcess.type,
    value: valueToProcess.text,
    personId: person?.id || null,
    personURL: getPersonURL(person),
    isFocusPerson: templateField.personId === focusPerson?.id,
    ...templateField,
  }
  return { ...getReferenceURLs(fieldForDisplay), ...fieldForDisplay }
}

/**
 * Set up fields for display
 * SIDE EFFECT: templateFields is modified
 *
 * @param {Object} [person] - the person object; null if we're looking at document-level fields
 * @param {Object} focusPerson - the record's focus person object
 * @param {Array} templateFields - the template fields to add data to
 * @param {Array} fieldsToProcess - the fields to look for values in
 * @param {Boolean} [includeDocumentFields] - true if you want to include document level fields, false to exclude
 * @param {Boolean} useOrigField - true if we want the xxx_ORIG to be used to fill empty fields. When true only
 *  empty fields are 'replaced' by xxx_ORIG field values.
 * @returns {undefined}
 */
function setupFieldsForDisplay({
  person,
  focusPerson,
  templateFields,
  fieldsToProcess,
  includeDocumentFields = false,
  useOrigField = false,
}) {
  ;[...(fieldsToProcess || [])].reverse().forEach((fieldToProcess) => {
    ;[...(fieldToProcess.values || [])].reverse().forEach((valueToProcess) => {
      const idx = templateFields.findIndex((templateField) => {
        const templateFieldId = templateField.labelId + (useOrigField ? '_ORIG' : '')
        return templateFieldId === valueToProcess.labelId
      })

      if (idx > -1 && shouldInclude(valueToProcess.labelId)) {
        const templateField = templateFields[idx]
        // if it's already setup for display, we don't do it twice
        if (templateField.values) {
          // don't include duplicate values and don't use the _ORIG if we already have values
          if (!useOrigField && valueToProcess.text && templateField.values.indexOf(valueToProcess.text) === -1) {
            templateField.values.push(valueToProcess.text)
          }
        } else {
          templateFields[idx] = setUpFieldForDisplay({ person, templateField, valueToProcess, focusPerson })
        }
      }
    })
  })

  /**
   * Decide whether to include this field in the list based on whether or not it's a document-level field (and whether we want that kind of field)
   * @param {String} labelId - labelId to check
   * @returns {boolean} true if this field should be included
   */
  function shouldInclude(labelId) {
    const isDocumentField = documentLevelFields.indexOf(labelId) > -1
    return includeDocumentFields ? isDocumentField : !isDocumentField
  }
}

/**
 * Go through collection template fields and add person values
 * SIDE EFFECT: templateFields is modified
 *
 * @param {Object} record - the persona or record object
 * @param {Object} item - a person or relationship object - any object that can have facts or fields
 * @param {Array} templateFields - extracted from the collection
 * @param {Boolean} includeDocumentFields - true if we want document-level fields instead of person-level fields
 * @param {Boolean} useOrigField - true if we want the xxx_ORIG to be used to fill empty fields. This is designed
 * to be false on the first invocation, after which this code calls itself again with it set to true.
 * @returns {undefined}
 */
function setupItemFields({ record, item, templateFields, includeDocumentFields = false, useOrigField = false }) {
  const focusPerson = getFocusPerson(record)

  if (item) {
    setupFields(item.fields, useOrigField)
    if (!includeDocumentFields) {
      setupFields(item.gender?.fields, useOrigField)
    }

    // we are starting at the end of these arrays because the last item in the array is the most accurate
    // as per our contract with CDS
    ;[...(item.names || [])].reverse().forEach((name) => {
      ;(name.nameForms || []).forEach((nameForm) => {
        setupFields(nameForm.fields, useOrigField)
        ;(nameForm.parts || []).forEach((namePart) => {
          setupFields(namePart.fields, useOrigField)
        })
      })
    })
    ;[...(item.facts || [])].reverse().forEach((fact) => {
      setupFields(fact.fields, useOrigField)
      setupFields(fact?.date?.fields, useOrigField)
      // do "alt" values after actual values so edits show up in the right order
      ;(fact.altDates || []).forEach((altDate) => {
        setupFields(altDate.fields, useOrigField)
      })
      setupFields(fact?.place?.fields, useOrigField)
      ;(fact.altPlaces || []).forEach((altPlace) => {
        setupFields(altPlace.fields, useOrigField)
      })
    })

    // If we haven't already been getting original fields then we want to do that now
    if (!includeDocumentFields && !useOrigField) {
      // This backfills the values with _ORIG content
      setupItemFields({ record, item, templateFields, includeDocumentFields, useOrigField: true })
    }
  }

  function setupFields(fieldsToProcess, _useOrigField) {
    return setupFieldsForDisplay({
      person: item,
      focusPerson,
      templateFields,
      fieldsToProcess,
      includeDocumentFields,
      useOrigField: _useOrigField,
    })
  }
}

/**
 * Use the collection template to get person-level display fields
 *
 * @param {Object} record - The person record object
 * @param {Object} collection - The collection with the record template (display names)
 * @param {Object} person - The person object
 * @returns {[]} unfiltered display fields for the person INCLUDING empty fields
 *    labelId
 *    fieldType: // http://gedcomx.org/Gender, http://gedcomx.org/Name, http://gedcomx.org/Given,
 *               // http://gedcomx.org/Surname, http://gedcomx.org/Date, http://gedcomx.org/Year,
 *               // http://gedcomx.org/Place , http://gedcomx.org/Age, etc.
 *    valueType: // http://gedcomx.org/Original, http://gedcomx.org/Interpreted
 *    values:    // The array of values for this field (may only contain a single entry)
 *    personId:  // The ID of the person where the value originated from
 */
function getTemplateFieldsForPersonFields(record, collection, person) {
  const templateFields = getCollectionTemplateFields(record, collection)
  setupItemFields({ record, item: record, templateFields })
  setupItemFields({ record, item: person, templateFields })

  if (person?.principal) {
    // Add relationship fields
    record?.relationships?.forEach((relationship) => {
      setupItemFields({ record, item: relationship, templateFields })
    })

    // Get values from all record person objects
    // Note: For census and obits we don't include them and display them differently
    const recordType = getRecordType(record)
    if (
      ['http://gedcomx.org/Census', 'http://gedcomx.org/Obituary'].indexOf(recordType) === -1 &&
      !isPersonCentricTemplate(record)
    ) {
      record?.persons?.forEach((item) => {
        // don't process the focus person a second time
        if (item !== person) {
          setupItemFields({ record, item, templateFields })
        }
      })
    }
  }

  return templateFields
}
