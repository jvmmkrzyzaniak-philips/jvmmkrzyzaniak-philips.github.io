/**
 * This is a collection of relationship methods for GedcomX records.
 * PLEASE add new functions in alphabetical order
 */

import { getFactByType, getFactsByTypes } from './factService'
import { getPerson, getRecordType } from './recordService'
import { getPersonCharacteristic, getPersonId, getPersonSex, isPersonMatch } from './personService'
import { siblingRelationshipMap, unknownRelationshipMap, relationshipTypeMaps } from './relationshipMaps'
import { marriageLikeFactTypes, treeAddableRelationshipFactTypes } from './vitalFactTypes'

// ===================================================================================================================
// PUBLIC FUNCTIONS (alphabetically arranged)
// ===================================================================================================================

/**
 * Get an organized list of additional persons for display in record details
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} person - the person object to get relatives for
 * @returns {{
 *   parentsAndSiblings: [{person, relationship}],
 *   spousesAndChildren: [{person, relationship}],
 *   others: [{person, relationship}],
 *   extendedFamily: [{person, relationship}]
 * }} organized list of relatives and other persons
 */
export function getAdditionalPersons(record, person) {
  const parentsAndSiblings = getPersonParentsAndSiblings(record, person)
  const spousesAndChildren = getPersonSpousesAndChildren(record, person)
  const { extendedFamily, others } = getPersonOthers(record, person, parentsAndSiblings?.concat(spousesAndChildren))
  return {
    parentsAndSiblings,
    spousesAndChildren,
    extendedFamily,
    others,
    record,
  }
}

/**
 * Get focus person's siblings
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} focusPerson - the focus person
 * @returns {Array} The person list of siblings.
 */
export function getFocusPersonSiblings(record, focusPerson) {
  return getRelativesByRelTypes(record, focusPerson, [
    { relType: 'http://familysearch.org/types/relationships/Sibling', relPosition: 'person2' },
  ])
}

/**
 * Return person's spouses that are inferred based off of parent-child relationships
 *
 * @param {Object} record - the GedcomX record.
 * @param {Object} person - the person object returned by getPerson
 * @returns {[{person: {Object}, relationship: {Object}, relationshipType: {Object}}]} list of spouses (if any). May be empty
 */
export function getImplicitPersonSpouses(record, person) {
  // Only run this function if we are dealing with people from tree
  if (!record?.childAndParentsRelationships) return []
  // Find all parent-child relationships the focus person is involved with
  const spousesByChildRelationships = record?.childAndParentsRelationships?.filter((relationship) => {
    if (!relationship || !person) return false
    return (
      relationship.parent1?.resourceId &&
      relationship.parent2?.resourceId &&
      (relationship.parent1?.resourceId === person.id || relationship.parent2?.resourceId === person.id)
    )
  })

  // Convert the relationship list into a unique set of the spouse IDs
  const uniquePossibleSpouseIds = new Set()
  spousesByChildRelationships?.forEach((relationship) => {
    uniquePossibleSpouseIds.add(
      relationship?.parent1?.resourceId === person?.id
        ? relationship?.parent2?.resourceId
        : relationship?.parent1?.resourceId
    )
  })

  // Get the person objects that match the ids within the possible spouse IDs list
  const implicitSpouses = record?.persons
    ?.filter((treePerson) => uniquePossibleSpouseIds.has(treePerson?.id))
    .map((spouse) => ({ person: spouse, relationship: {}, relationshipType: {} }))

  return implicitSpouses || []
}

/**
 * Get person's children
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} person - the person object to get children for
 * @returns {Array} The person list of children.
 */
export function getPersonChildren(record, person) {
  return getRelativesByRelTypes(record, person, [{ relType: 'http://gedcomx.org/ParentChild', relPosition: 'person1' }])
}

/**
 * Return the person's children grouped by spouse
 *
 * @deprecated Since version 5.0.0. Will be deleted in version 6.0.0. Use getSpousesWithChildren() instead.
 * @param {Object} record - the GedcomX record
 * @param {Object} focusPerson - the person whose children you want to get
 * @param {Object} spouses - the spouses of the person whose children you want to get
 * @returns {[{parentSet, siblingSet}]} returns an array of objects containing a spouse and the focus person's children that also belong to that spouse
 */

export function getPersonChildrenSets(record, focusPerson, spouses) {
  // eslint-disable-next-line no-console
  console.warn('getPersonChildrenSets() is deprecated. Use getSpousesWithChildren() instead.')
  const childrenSets = spouses?.map((spouse) => {
    const childrenWithSpouse = getPersonChildrenWithSpouse(record, focusPerson, spouse)
    const childrenSet = { spouse, childrenWithSpouse }
    return childrenSet
  })
  return childrenSets || []
}

/**
 * Return the person's children grouped by spouse
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} focusPerson - the person whose children you want to get
 * @param {Object} spouses - the spouses of the person whose children you want to get
 * @param {Boolean} forceRelationships - associate all children with first spouse if they aren't associated with any spouse
 * @returns {[{parentSet, siblingSet}]} returns an array of objects containing a spouse and the focus person's children that also belong to that spouse
 */

export function getSpousesWithChildren(record, focusPerson, spouses, forceRelationships = false) {
  let spouseHasChildRelationship = false
  const childrenSets = spouses?.map((spouse) => {
    const childrenWithSpouse = getPersonChildrenWithSpouse(record, focusPerson, spouse)
    if (childrenWithSpouse?.length > 0) spouseHasChildRelationship = true
    return { spouse, childrenWithSpouse }
  })
  if (forceRelationships && !spouseHasChildRelationship && childrenSets?.length)
    childrenSets[0].childrenWithSpouse = getPersonChildren(record, focusPerson)
  return childrenSets || []
}

/**
 * Return person's children with a specified spouse.  Used in SourceLinker
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} focusPerson - the person whose children you want to get
 * @param {Object} spouse - the spouse of the person whose children you want to get
 * @param {Boolean} forceRelationships - sometimes we have to force the children sets with records- mostly on censuses, where only the head of household/father is given a relationship with the child. This will return all children regardless of relationship
 * @returns {Array} An array of children persons shared between the focusPerson and spouse
 */

export function getPersonChildrenWithSpouse(record, focusPerson, spouse, forceRelationships = false) {
  const children = getPersonChildren(record, focusPerson)
  if (forceRelationships) {
    return children
  }
  const childrenWithSpouse = children?.filter((child) =>
    findRelationshipWithPersons(record, child.person, spouse.person)
  )
  return childrenWithSpouse || []
}

/**
 * Returns a person's children that belong to the person, but do not belong to any of the person's spouses. Used in SourceLinker
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} focusPerson - the person whose children you want to get
 * @returns {Array} An array of children persons
 */
export function getPersonChildrenWithoutSpouse(record, focusPerson) {
  const spouses = getPersonSpouses(record, focusPerson)
  const childrenSets = getSpousesWithChildren(record, focusPerson, spouses)
  const children = getPersonChildren(record, focusPerson)

  const childrenIdsWithSpouses = []
  childrenSets.forEach((childrenSet) => {
    return childrenSet.childrenWithSpouse.forEach((child) => {
      const { personId } = getPersonId(child?.person)
      childrenIdsWithSpouses.push(personId)
    })
  })
  const childrenWithoutSpouse = children?.filter((childRel) => {
    // Sometimes, records can have relationships where the child person's info does not exist on our current record. In this case, we need to
    // make sure we return early and never call 'getPersonId' - FSS-10255
    if (!childRel?.person) return false

    const { personId } = getPersonId(childRel?.person)
    return !childrenIdsWithSpouses.includes(personId)
  })
  return childrenWithoutSpouse
}

/**
 * Get person's extended family and others on record for display in record details
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} focusPerson - the person object to get extended family & others for
 * @param {Array} existingRelatives - array of relatives already found (parents, spouses, children, siblings)
 * @returns {{extendedFamily: [{person, relationshipType}], others: [{person, relationshipType}]}}
 */
export function getPersonOthers(record, focusPerson, existingRelatives) {
  // Remove persons who have already been categorized
  const additionalPersons = record.persons.filter((person) => {
    return (
      !existingRelatives?.find((item) => isPersonMatch(item?.person, person.id)) &&
      !isPersonMatch(person, focusPerson.id)
    )
  })

  // Extended family info comes from record fields
  // Separate remaining persons into extended family and others
  return additionalPersons.reduce(
    (rels, person) => {
      const relationshipType = getRelationshipType(record, person, focusPerson)
      if (!relationshipType || relationshipType?.category === 'othersOnRecord') {
        rels.others.push({ person, relationshipType })
      } else {
        rels.extendedFamily.push({ person, relationshipType })
      }
      return rels
    },
    { extendedFamily: [], others: [] }
  )
}

/**
 * Get person's parents
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} person - the person object to get parents for
 * @returns {[{person: Object, relationship: Object}]} list of parents (if any). May be empty
 */
export function getPersonParents(record, person) {
  return (
    getRelativesByRelTypes(record, person, [{ relType: 'http://gedcomx.org/ParentChild', relPosition: 'person2' }]) ||
    []
  )
}

/**
 * Get person's parents & siblings for display in record details
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} person - the person object to get parents & siblings for
 * @returns {[{person: Object, relationship: Object}]} list of parents and siblings
 */
export function getPersonParentsAndSiblings(record, person) {
  const parents = getPersonParents(record, person)
  const siblings = getPersonSiblings(record, parents, person)
  // de-dup, return array
  return deDupRelatives(parents?.concat(siblings), person)
}

/**
 * Returns a person's parents, grouped into couple relationships
 * Parents who do not exist in the gedcomx person array will not be included
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} person - the person object to get parents for
 * @returns {[[{person, relationship, relationshipType}][{person, relationship, relationshipType}]]} an array of couples (a couple is an array of 1-2 personRels)
 */
export function getPersonParentSets(record, person) {
  const parents = getPersonParents(record, person)
  const parentSets = []

  // Tree has a nice childAndParentsRelationships array for us to read from.
  if (record?.childAndParentsRelationships) {
    const personRelationships = record.childAndParentsRelationships.filter(
      (relationship) => getPersonIdFromResource(relationship?.child) === person?.id
    )
    personRelationships.forEach((relationship) => {
      const parent1 = parents?.filter(
        (parent) => parent?.person?.id === getPersonIdFromResource(relationship?.parent1)
      )?.[0]
      const parent2 = parents?.filter(
        (parent) => parent?.person?.id === getPersonIdFromResource(relationship?.parent2)
      )?.[0]
      if (parent1 && parent2) {
        parentSets.push([parent1, parent2])
      } else if (parent1) {
        parentSets.push([parent1])
      } else if (parent2) {
        parentSets.push([parent2])
      }
    })
    return parentSets
  }

  // Records require us to read relationships the hard way.
  const foundCouples = {}
  for (let i = 0; i < parents.length; i++) {
    const parent = parents[i].person

    if (parent) {
      const parent1Spouses = getPersonSpouses(record, parent)

      if (parent1Spouses.length) {
        for (let j = 0; j < parent1Spouses.length; j++) {
          const spouse = parent1Spouses[j].person
          // skip couple relationships that have already been processed
          if (
            spouse &&
            foundCouples[`${spouse.id}-${parent.id}`] !== true &&
            foundCouples[`${parent.id}-${spouse.id}`] !== true
          ) {
            parentSets.push([parents[i], makePersonRelForParentSpouse(record, person, spouse)])

            // mark this couple relationship as processed
            foundCouples[`${parent.id}-${spouse.id}`] = true
          }
        }
      } else {
        // no spouses; push just the one parent
        parentSets.push([parents[i]])
      }
    }
  }
  return parentSets
}

/**
 * Returns a person's parents, grouped into couple relationships
 * Parents who do not exist in the gedcomx person array will not be included
 *
 * If there are exactly 2 parents of opposite sex in a RECORD but no spouses, and the implicit flag is on,
 * we will put them together (as an "implicit family"), even though they don't have an explicit relationship.
 * We do this because some records - including censuses and obituaries - might miss the spouse relationship,
 * but we still need to them to be related in source linker.
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} person - the person object to get parents for
 * @returns {[[{person, relationship, relationshipType}][{person, relationship, relationshipType}]]} an array of couples (a couple is an array of 1-2 personRels)
 */
export function getPersonParentSetsWithImplicitRels(record, person) {
  const parentSets = getPersonParentSets(record, person)
  const parents = getPersonParents(record, person)

  // Return early if it's easy to figure out not to handle implicit relationships (parent list length is wrong or this is tree)
  if (record?.childAndParentsRelationships || (parentSets.length !== 2 && parents.length !== 2)) {
    return parentSets
  }

  // Decide if they are a candidate for an implicit family and put them together
  const implicitFamilyCandidate = isImplicitFamilyCandidate(record, parents)

  // manufacture a relationship between the two parents if necessary
  if (implicitFamilyCandidate) {
    return [[parents[0], makePersonRelForParentSpouse(record, person, parents[1].person)]]
  }
  return parentSets
}

/**
 * Return the relationships where the person occurs in the record, and data needed from record to interpret relationship
 *
 * @param {Object} record The persona record object.
 * @param {Object} person The person object.
 * @returns {[{focusPerson: {id, relPosition}, otherPerson: {id, gender}, relationship: {id, type, person1, person2}}]}
 *  The relationships the person is a part of. May be empty.
 */
export function getPersonRelationships(record, person) {
  if (!person || !person.id) {
    return []
  }
  return (
    record?.relationships?.reduce((foundRels, relationship) => {
      // See if pid is in this relationship
      let relPosition
      let otherId
      if (relationship?.person1?.resourceId === person.id) {
        relPosition = 'person1'
        otherId = relationship?.person2?.resourceId
      } else if (relationship?.person2?.resourceId === person.id) {
        relPosition = 'person2'
        otherId = relationship?.person1?.resourceId
      }
      if (relPosition) {
        foundRels.push({
          focusPerson: {
            id: person.id,
            relPosition,
          },
          otherPerson: {
            id: otherId,
            gender: getPersonSex(getPerson(record, otherId)),
          },
          relationship,
        })
      }
      return foundRels
    }, []) || []
  )
}

/**
 * Return the relationships where the person occurs in the record and data needed from record to interpret relationship
 * Grouped by relationship (but the siblings and children aren't separated by parent sets)
 *
 * @param {Object} record The persona record object.
 * @param {Object} person The person object.
 * @returns {[{
 *   children: [{person, relationship}],
 *   extendedFamily: [{person, relationship}],
 *   others: [{person, relationship}],
 *   parentSets: [[{person, relationship}, {person, relationship}], [{person, relationship}]],
 *   siblings: [{person, relationship}],
 *   spouses: [{person, relationship}],
 * }]}
 *  The relationships the person is a part of. May be empty.
 */
export function getPersonRelationshipGroups(record, person) {
  const parentArray = getPersonParents(record, person)
  const parentSets = getPersonParentSets(record, person)
  const siblings = getPersonSiblings(record, parentArray, person)
  const spouses = getPersonSpouses(record, person)
  const children = getPersonChildren(record, person)
  const { extendedFamily, others } = getPersonOthers(
    record,
    person,
    parentArray?.concat(siblings)?.concat(spouses)?.concat(children)
  )
  return {
    children,
    extendedFamily,
    others,
    parentSets,
    siblings,
    spouses,
  }
}

/**
 * Get person's siblings
 *
 * @param {Object} record - the GedcomX record
 * @param {Array} parents - the persons parents used to get the siblings
 * @param {Object} focusPerson - the person whose siblings you want to get (to exclude him/her from the list)
 * @returns {Array} The person list of siblings.
 */
export function getPersonSiblings(record, parents, focusPerson) {
  // for each parent of focus person, get all of their children (excluding focus person)
  // these are the focus persons siblings
  const siblings = parents?.reduce((acc, parent) => {
    const parentChildren = getPersonChildren(record, parent.person).filter(
      (child) => child.person?.id !== focusPerson?.id
    )
    return acc.concat(parentChildren)
  }, [])

  const parentSets = getPersonParentSetsWithImplicitRels(record, focusPerson)
  let focusPersonSiblings = []
  let allSiblings = siblings

  /* Many records contain not only ParentChild relationships, from where we get the siblings, but also Sibling relationships with the focus person.
     We need to add those to get the full list of siblings when the family is not polygamist (numberOfParentSets being 0 or 1).
     When the family is polygamist, we don't want to include all the siblings since some of them may not match the same parents,
     therefore we should not place them in the Siblings section */
  if (parentSets?.length <= 1) {
    focusPersonSiblings = getFocusPersonSiblings(record, focusPerson)
    allSiblings = [...(siblings || []), ...(focusPersonSiblings || [])]
  }

  return deDupRelatives(allSiblings, focusPerson)?.map((sibling) => {
    // change `son` and `daughter` to `brother` and `sister` respectively
    const relationship = sibling.relationshipType.labelKey
    if (relationship === 'Son') sibling.relationshipType.labelKey = 'brother'
    if (relationship === 'Daughter') sibling.relationshipType.labelKey = 'sister'
    if (relationship === 'Child') sibling.relationshipType.labelKey = 'sibling'
    return sibling
  })
}

/**
 * Return the person's siblings that share a specified set of parents
 *
 * @param {Object} record - the GedcomX record
 * @param {Array} parents - the persons parents used to get the siblings
 * @param {Object} focusPerson - the person whose siblings you want to get
 * @param {Boolean} forceRelationships - sometimes we have to force the sibling sets with records- mostly on censuses, where only the head of household/father is given a relationship with the child. This will return all siblings regardless of relationship
 * @returns {Array} An array of siblings that share the specified parents
 */
export function getPersonSiblingsFromParents(record, parents, focusPerson, forceRelationships = false) {
  const siblings = getPersonSiblings(record, parents, focusPerson)
  //  debugger
  if (forceRelationships) {
    return siblings || []
  }
  if (parents?.length === 1) {
    //  Get siblings that belong to that one parent, but have no other parents
    const oneParentSiblings = siblings?.filter((siblingRel) => {
      const hasRelationship = findRelationshipWithPersons(record, siblingRel.person, parents?.[0]?.person)
      const siblingParents = getPersonParents(record, siblingRel.person)
      return hasRelationship && siblingParents?.length === 1
    })
    return oneParentSiblings
  }

  const fullSiblings = siblings?.filter((sibling) => {
    const firstParentRel = findRelationshipWithPersons(record, sibling.person, parents?.[0]?.person)
    const secondParentRel = findRelationshipWithPersons(record, sibling.person, parents?.[1]?.person)
    const sharesParent = (firstParentRel && !secondParentRel) || (!firstParentRel && secondParentRel)

    // Add sibling to fullSiblings if they have relationships with both parents
    if (firstParentRel && secondParentRel) {
      return true
    }
    // Force sibling into fullSiblings if they share at least one parent with their siblings and their other parent doesn't exist
    // Fix for bug FSS-9106
    if (sharesParent && !hasMoreThanOneParent(record, sibling?.person)) {
      return true
    }
    return false
  })
  return fullSiblings || []
}
/**
 * Return the person's siblings grouped by parent sets
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} parentSets - the spouse of the person whose children you want to get
 * @param {Object} focusPerson - the person whose children you want to get
 * @returns {[{parentSet, siblingSet}]} returns an array of objects containing a set of parents and the person's siblings that share those parents
 */
export function getPersonSiblingSets(record, parentSets, focusPerson) {
  const siblingSets = parentSets?.map((parents) => {
    const siblingsFromParents = getPersonSiblingsFromParents(record, parents, focusPerson)
    const siblingSet = { parents, siblingsFromParents: siblingsFromParents || [] }
    return siblingSet
  })
  return siblingSets || []
}

/**
 * Return person's spouses
 *
 * @param {Object} record - the GedcomX record.
 * @param {Object} person - the person object returned by getPerson
 * @returns {[{person: {Object}, relationship: {Object}}]} list of spouses (if any). May be empty
 */
export function getPersonSpouses(record, person) {
  return getRelativesByRelTypes(record, person, [
    { relType: 'http://gedcomx.org/Couple', relPosition: 'person1' },
    { relType: 'http://gedcomx.org/Couple', relPosition: 'person2' },
  ])
}

/**
 * Get spouses and children for display in record details
 *
 * @param {Object} record - gedx persona or record
 * @param {Object} person - person to get spouses & children for
 * @returns {Array} spouses and children
 */
export function getPersonSpousesAndChildren(record, person) {
  return (
    getRelativesByRelTypes(record, person, [
      { relType: 'http://gedcomx.org/Couple', relPosition: 'person1' },
      { relType: 'http://gedcomx.org/Couple', relPosition: 'person2' },
      { relType: 'http://gedcomx.org/ParentChild', relPosition: 'person1' },
    ]) || []
  )
}

/**
 * Get persons in the record that have no relationship with the specified person.
 *
 * @param {Object} record The persona or record object
 * @param {Object} person The focus person. Required; must be valid.
 * @returns {[Object]} The list of persons not related to the specified person. May be empty.
 */
export function getPersonsNotRelated(record, person) {
  const relatives = getPersonRelationships(record, person)
  const siblings = getPersonSiblings(record, getPersonParents(record, person), person)
  return record.persons.filter((p) => {
    return (
      p.id !== person.id &&
      !findPersonRelationship(relatives, p) &&
      !siblings.find((sibling) => sibling.person?.id === p.id)
    )
  })
}

/**
 * Returns a fact matching the given type, within the given relationship.  Used in GenDetailsInfoSheet to get
 * a Marriage fact for each spouse (if any).
 *
 * @param {Object} relationship The relationship object to get the fact from
 * @param {String} factType Gedcomx type string (e.g. http://gedcomx.org/Marriage)
 * @returns {Object} A fact matching the given type, within the given relationship.
 */
export function getRelationshipFact(relationship, factType) {
  return getFactByType(relationship.facts, factType)
}

/**
 * Return all marriage-like facts (marriage, engagement, marriage_banns, marriage_contract,
 * marriage_license, marriage_notice, marriage_registration, marriage_settlement)
 *
 * @param {Object} relationship The relationship object to get the fact(s) from
 * @returns {Object[]} fact objects for marriage-like events
 */
export function getRelationshipMarriageLikeFacts(relationship) {
  return getFactsByTypes(relationship.facts, marriageLikeFactTypes)
}

export function getTreeAddableRelationshipFacts(relationship) {
  return getFactsByTypes(relationship.facts, treeAddableRelationshipFactTypes)
}

/**
 * Get relationship information between two people in the record
 *
 * @param {Object} record The record
 * @param {Object} person The person object (the result is how person is related to focusPerson)
 * @param {Object} focusPerson The focus person object
 * @returns {*} - null if focusPerson and person are the same or no relationship is found.
 *    category: {"spouseChildren"|"parentsSiblings"|"extendedFamily"}
 *    gedcomxType: gedcomx type string (e.g. http://gedcomx.org/Couple, http://familysearch.org/types/relationships/Sibling, etc.)
 *    labelKey: label key (e.g. GrandParent.person1.M = Grandson, Grandparent.person2.M = Grandfather, etc.)
 */
export function getRelationshipType(record, person, focusPerson) {
  if (!focusPerson || !person || focusPerson.id === person.id) {
    return {}
  }

  // First look for an explicit relationship between the two persons
  const rel = findRelationshipWithPersons(record, person, focusPerson)
  if (rel) {
    const relPosition = rel?.person1?.resource === `#${focusPerson.id}` ? 'person1' : 'person2'
    return getRelTypeFromRel(rel, relPosition, getPersonSex(person))
  }

  // Check for siblings by looking at the parents of both persons
  const siblingRelationshipType = findSiblingByParents(record, person, focusPerson)

  const recordType = getRecordType(record)
  const canUseCharacteristic =
    (!siblingRelationshipType &&
      recordType === 'http://gedcomx.org/Census' &&
      focusPerson?.fields?.find((field) => field.type?.includes('RelationshipToHeadCode'))?.values?.[0]?.text ===
        'HEAD') ||
    (recordType !== 'http://gedcomx.org/Census' && focusPerson?.principal)

  // For principal persons, if possible, check for relationships using characteristic value
  // Because every person on a census is a principal, if this isn't head of household, can't use characteristic
  return siblingRelationshipType || (canUseCharacteristic && getRelationshipByCharacteristic(person))
}

/**
 * Search through relationships for any of a certain type
 * Then return persons & relationships for the matches
 * ex: give me all parent-child relationships where Joe is person2 (the child)
 *
 * @param {Object} record The record
 * @param {Object} person The person object to find relatives for
 * @param {[{relType: String, relPosition: String}]} types an array of relationship types & person numbers
 * @returns {Array} array of persons and relationships
 */
export function getRelativesByRelTypes(record, person, types) {
  const seenRels = {}
  return (
    record?.relationships
      ?.filter((rel) => {
        // Relationships can be made multiple times between the same people. This function should never return duplicate people.
        // We must keep track of the shape of each rel (person1 & person2) and make sure that duplicate rels in that same shape are
        // not returned. An example of this in action can be seen on source linker with tree person KHSB-FQJ (https://www.familysearch.org/search/linker?ark=/ark:/61903/1:1:6BH5-J14Z&id=L6M9-CVN)
        const person1Id = rel?.person1?.resourceId
        const person2Id = rel?.person2?.resourceId
        const existingRel = seenRels?.[person1Id]
        if (existingRel) {
          if (existingRel.includes(person2Id)) return false
          existingRel.push(person2Id)
        } else {
          seenRels[person1Id] = [person2Id]
        }

        return types.find(
          ({ relType, relPosition }) => relType === rel.type && isPersonMatch(person, rel[relPosition]?.resource)
        )
      })
      .map((rel) => {
        const relPosition = isPersonMatch(person, rel?.person1?.resource) ? 'person1' : 'person2'
        const otherRelPosition = relPosition === 'person1' ? 'person2' : 'person1'
        // use the gender of the other person in the relationship
        const otherPerson = getPerson(record, rel[otherRelPosition]?.resource)
        const relationshipType = getRelTypeFromRel(rel, relPosition, getPersonSex(otherPerson))
        return { person: otherPerson, relationship: rel, relationshipType }
      }) || []
  )
}

// ===================================================================================================================
// PRIVATE FUNCTIONS (alphabetically arranged)
// ===================================================================================================================

/**
 * Take an array of relatives and remove duplicates. Also remove the original person if present.
 *
 * @param {[{person: Object, relationship: Object}]} relatives - Array of relative objects
 * @param {Object} focusPerson - focus person (to remove from relatives array)
 * @returns {[{person: Object, relationship: Object}]} relatives without dupicates
 */
function deDupRelatives(relatives, focusPerson) {
  return relatives?.reduce((unique, item) => {
    if (
      !unique.find(({ person }) => isPersonMatch(item.person, person?.id)) &&
      !isPersonMatch(item.person, focusPerson?.id)
    ) {
      unique.push(item)
    }
    return unique
  }, [])
}

/**
 * Determine if the person provided is found in any of the relationships.
 *
 * @param {[Object]} relations The relationships to check
 * @param {Object} person The person being searched for
 * @returns {Object} The relationship the person belongs to. Undefined if not found
 */
function findPersonRelationship(relations, person) {
  return relations.find((r) => isPersonMatch(person, r.otherPerson.id))
}

/**
 * Look through the relationships list for a rel with both person1 and person2
 *
 * @param {Object} record - record to check relationships for
 * @param {Object} person1 - first person to look for
 * @param {Object} person2 - second person to look for
 * @returns {Object} found relationship object
 */
function findRelationshipWithPersons(record, person1, person2) {
  const pid1 = `#${person1?.id}` // Convert person Ids to a resource form
  const pid2 = `#${person2?.id}`
  return (record?.relationships || []).find((rel) => {
    return (
      (rel?.person1?.resource === pid1 && rel?.person2?.resource === pid2) ||
      (rel?.person1?.resource === pid2 && rel?.person2?.resource === pid1)
    )
  }, [])
}

/**
 * Using the parents of both person objects, determine if a sibling relationship exists.
 *
 * @param {Object} record The record
 * @param {Object} person The focus person object
 * @param {Object} focusPerson The other person object
 * @returns {{category: String, gedcomxType: String, labelKey: String}|null}
 *    category: {"spouseChildren"|"parentsSiblings"|"extendedFamily"}
 *    gedcomxType: gedcomx type string (e.g. http://gedcomx.org/Couple, http://familysearch.org/types/relationships/Sibling, etc.)
 *    labelKey: label key (e.g. GrandParent.person1.M = Grandson, Grandparent.person2.M = Grandfather, etc.)
 */
function findSiblingByParents(record, person, focusPerson) {
  let siblingRel = null
  const gender = getPersonSex(person)

  // Check to see if these person objects share a parent
  const parents = getPersonParents(record, person)
  const focusParents = getPersonParents(record, focusPerson)
  let found = false

  for (let i = 0; i < focusParents.length; i++) {
    for (let j = 0; j < parents.length; j++) {
      if (focusParents[i].person?.id === parents[j].person?.id) {
        // Sibling relation doesn't differentiate on relPosition so we just hardcode it to 'person1'.
        siblingRel = getRelTypeFromMap(siblingRelationshipMap, 'person1', gender)
        found = true
        break
      }
    }
    if (found) {
      break
    }
  }
  return siblingRel
}

/**
 * Get the person Id out of the resource field, taking out any leading # signs
 *
 * @param {{resource: String, resourceId: String}} person - relationship.person type object from the tree GedcomX
 * @returns {null|String} person ID
 */
function getPersonIdFromResource(person) {
  let personId = null
  if (person && (person.resource || person.resourceId)) {
    personId = person.resource || person.resourceId
    personId = personId.replace(/^#/, '') // strip leading # signs
    // If personId is formatted as a URL, get just the ID from it
    const matcher = personId.match(/\/platform\/tree\/persons\/([\w-]+)/)
    if (matcher && matcher[1]) {
      return matcher[1]
    }
  }
  return personId
}

/**
 * Look for the relationship to head in characteristic fields
 * Hyphens in a record relationship field (e.g., 'Son-In-Law') are removed for map comparison
 *
 * @param {Object} person The person to get the relationship for
 * @returns {null|{category: string, gedcomxType: string, labelKey: string, other: string (if labelKey is null)}}
 */
function getRelationshipByCharacteristic(person) {
  const relName = getRelNameByCharacteristic(person).replace(/-/g, '')
  if (relName) {
    const relNameMatch = relName.toLowerCase()
    const foundRelMap = relationshipTypeMaps.find((relMap) => {
      return (
        [
          relMap.person1.M.toLowerCase(),
          relMap.person1.F.toLowerCase(),
          relMap.person1.U.toLowerCase(),
          relMap.person2.M.toLowerCase(),
          relMap.person2.F.toLowerCase(),
          relMap.person2.U.toLowerCase(),
        ].indexOf(relNameMatch) > -1
      )
    })
    if (foundRelMap) {
      const relPosition =
        [
          foundRelMap.person1.M.toLowerCase(),
          foundRelMap.person1.F.toLowerCase(),
          foundRelMap.person1.U.toLowerCase(),
        ].indexOf(relNameMatch) > -1
          ? 'person1'
          : 'person2'
      return getRelTypeFromMap(foundRelMap, relPosition, getPersonSex(person))
    }

    return {
      category: 'othersOnRecord',
      gedcomxType: 'http://familysearch.org/types/relationships/Unknown',
      labelKey: null,
      other: relName,
    }
  }
  return null
}

/**
 * Gets the relationship type object using gedcomx relationship information
 *
 * @param {Object} rel - gedcomx relationship object
 * @param {String} relPosition - position of this person in the relationship (person1 or person2)
 * @param {String} gender - 1-character gender code
 * @returns {{category: String, gedcomxType: String, labelKey: String}|null}
 */
function getRelTypeFromRel(rel, relPosition, gender) {
  let foundRelationship = null

  // For some relationships there is a specific Id that specifies a narrower type (like step child)
  // If this relationship has a specific Id we will also try to match it against the relationshipTypeMap
  const relField = rel.fields?.find((field) => field.type === 'http://familysearch.org/RelativeType')
  const relTypeId = relField?.values.find((field) => field.resource)?.resource
  const relFact = rel.facts?.find((fact) => fact.type)
  const relFactId = relFact?.type

  // find a map entry for the relTypeId (or the fallback with no id)
  const foundMap = relationshipTypeMaps
    .filter((map) => map.type.toLowerCase() === rel?.type?.toLowerCase())
    ?.find((map) => (map.id && map.id === relTypeId) || (map.gedId && map.gedId === relFactId) || !map.id)
  if (foundMap) {
    foundRelationship = getRelTypeFromMap(foundMap, relPosition, gender)
  }

  // create an "unknown" placeholder relationship
  if (!foundRelationship) {
    foundRelationship = getRelTypeFromMap(unknownRelationshipMap, 'person1', gender)
  }
  return foundRelationship
}

/**
 * Use the *RELATIONSHIP_* field to determine what the relationship is.
 *
 * @param {Object} person The person object.
 * @returns {String} that describes the relationship. May be empty.
 */
function getRelNameByCharacteristic(person) {
  return (
    getPersonCharacteristic(person, 'RELATIONSHIP_TO_DEC') ||
    getPersonCharacteristic(person, 'PR_RELATIONSHIP_TO_DEC') ||
    getPersonCharacteristic(person, 'RELATIONSHIP_TO_HEAD') ||
    getPersonCharacteristic(person, 'PR_RELATIONSHIP_TO_HEAD') ||
    getPersonCharacteristic(person, 'PR_RELATIONSHIP_TO_HEAD_ORIG') ||
    getPersonCharacteristic(person, 'RELATIONSHIP_CODE') ||
    ''
  )
}

/**
 * Construct the relationshipType object from the map as appropriate for the person's gender.
 *
 * @param {Object} map The relationship map entry.
 * @param {String} relPosition The relative position in the map (e.g. 'person1' or 'person2')
 * @param {String} gender The gender code (e.g. 'M', 'F', or 'U')
 * @returns {{category: String, gedcomxType: String, labelKey: String}} relationship type object
 */
function getRelTypeFromMap(map, relPosition, gender) {
  return {
    category: map.category || map[relPosition].category,
    gedcomxType: map.type,
    labelKey: map[relPosition][gender],
    unknownLabelKey: map[relPosition].U,
  }
}

/**
 * Determines whether or not a person has more than one parent on a record
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} person - the person object to get parents for
 * @returns {Boolean}
 */
function hasMoreThanOneParent(record, person) {
  return (
    record?.relationships.filter(
      (relationship) =>
        relationship?.type === 'http://gedcomx.org/ParentChild' && relationship?.person2?.resourceId === person?.id
    )?.length > 1
  )
}

/**
 * Decide if we want to mark this parent list as a candidate for an implicit family
 *
 * @param {Object} record - the GedcomX record
 * @param {Object} parents - the parent array we're comparing
 * @returns {boolean} true if it's a candidate for an implicit family
 */
function isImplicitFamilyCandidate(record, parents) {
  if (parents.length === 2) {
    // MS: It's not ideal to get the spouses twice - here and in the for loop - but I can't think of a cleaner way to do this.
    const parent1SpouseRelationships = getPersonSpouses(record, parents[0])
    const parent2SpouseRelationships = getPersonSpouses(record, parents[1])
    const noOtherSpouses = parent1SpouseRelationships.length === 0 && parent2SpouseRelationships.length === 0
    const parent1Sex = getPersonSex(parents[0])
    const parent2Sex = getPersonSex(parents[1])
    const oppositeOrUnknownSex = parent1Sex !== parent2Sex || (parent1Sex === parent2Sex && parent1Sex === 'U')
    return noOtherSpouses && oppositeOrUnknownSex
  }
  return false
}

/**
 * Create a personRel object, including relationship between focus person and parent's spouse

 * @param {Object} record - the GedcomX record
 * @param {Object} person - the person object to get parents for
 * @param {Object} spouse - the parent's new spouse we're creating an object about
 * @returns {{relationshipType: *, person, relationship: *}} PersonRel
 */
function makePersonRelForParentSpouse(record, person, spouse) {
  const spouseToFocusPersonRelationship = findRelationshipWithPersons(record, person, spouse)
  return {
    person: spouse,
    relationship: spouseToFocusPersonRelationship,
    relationshipType: getRelationshipType(record, spouse, person),
  }
}
