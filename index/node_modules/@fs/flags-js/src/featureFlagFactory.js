import { SplitFactory } from '@splitsoftware/splitio-browserjs'
import Cookies from 'js-cookie'
import { v4 as uuid } from 'uuid'
import { debugVerbose } from '@fs/zion-debug'

import { toFeatureFlag, toSplitIOFeatures } from './utils'

const debug = debugVerbose('flags-js:featureFlagFactory')

let factory
let manager
let clients
let flagOverrides = {}

export const controlFeatureFlag = {
  treatment: 'control',
  config: null,
  isOn: false,
  isControl: true,
}

// for tests
export function resetFactory() {
  factory = undefined
  manager = undefined
  clients = undefined
  flagOverrides = {}
}

export function updateFlagsJsOverrides(overrides) {
  debug('updateFlagsJsOverrides:', overrides)
  flagOverrides = overrides
}

const getFeatureFlag = (flagName, attributes = {}) => {
  if (flagOverrides[flagName]) {
    debug('getFeatureFlag: using flagOverrides for flagName:', flagName, flagOverrides[flagName])
    return toFeatureFlag(flagOverrides[flagName])
  }
  const split = manager.split(flagName)
  const curClient = clients[split?.trafficType] ?? clients.anonymous
  if (!curClient) {
    debug('getFeatureFlag: no client found for flagName:', flagName)
    return controlFeatureFlag
  }
  const treatmentWithConfig = curClient.getTreatmentWithConfig(flagName, attributes)

  return toFeatureFlag(treatmentWithConfig)
}

const getFeatureFlags = (flagNames, attributes = {}) => {
  return flagNames.reduce((featureFlagAccumulator, flagName) => {
    featureFlagAccumulator[flagName] = getFeatureFlag(flagName, attributes)
    return featureFlagAccumulator
  }, {})
}

export function handleAndGetAnonIdCookie() {
  // Read cookie for anonymous user
  let anonIdCookie = Cookies.get('fs_anid')

  // this parsing logic is necessary for backwards compatability with clients who had a cookie set as a json object
  if (anonIdCookie) {
    try {
      const parsedAnonIdCookie = JSON.parse(anonIdCookie)
      if (parsedAnonIdCookie.id) {
        anonIdCookie = parsedAnonIdCookie.id
        Cookies.set('fs_anid', anonIdCookie, { expires: 365, path: '/' })
      }
    } catch (e) {
      // don't need to do anything here, let anonIdCookie be what is was from Cookies.get if the JSON.parse fails
    }
  }

  // Create cookie, if it doesn't already exist
  if (!anonIdCookie) {
    anonIdCookie = uuid()
    Cookies.set('fs_anid', anonIdCookie, { expires: 365, path: '/' })
  }
  return anonIdCookie
}

export default async function agnosticFeatureFlagFactory(
  getStandardAttributes = async () => ({}),
  splitioAuthKey = 'localhost',
  mockFlags = undefined,
  flagsJsOverrides = undefined
) {
  if (flagsJsOverrides) {
    flagOverrides = flagsJsOverrides
  }
  const anonIdInfo = handleAndGetAnonIdCookie()

  const splitConfiguration = {
    core: {
      authorizationKey: splitioAuthKey,
      key: anonIdInfo,
    },
  }

  if (mockFlags) {
    splitConfiguration.features = toSplitIOFeatures(mockFlags)
  }

  if (!factory) {
    debug('Creating factory with splitConfiguration:', splitConfiguration)
    factory = SplitFactory(splitConfiguration)
  }

  if (!clients) {
    clients = {}
  }

  if (!clients.user || !clients.anonymous) {
    debug('Creating user and anonymous clients')
    const attributes = mockFlags ? {} : await getStandardAttributes()
    const userClient = factory.client(attributes?.cisId || 'unknown')
    userClient.setAttributes(attributes)
    await userClient.ready()
    clients.user = userClient

    const anonClient = factory.client(attributes?.anonId || 'unknown')
    anonClient.setAttributes(attributes)
    await anonClient.ready()
    clients.anonymous = anonClient
  }

  if (!manager) {
    debug('Creating manager')
    manager = factory.manager()
    await manager.ready()
  }

  debug('agnosticFeatureFlagFactory done. clients:', clients, manager)
  return {
    getFeatureFlag,
    getFeatureFlags,
  }
}
