import React, { forwardRef, useCallback, useEffect, useRef, useState } from 'react'
import PropTypes from 'prop-types'
import { useEvent } from '@fs/zion-frontend-friends'
import {
  Checkbox,
  Radio,
  Toggle,
  TextField,
  TextArea,
  MultilineTextField,
  Select,
  Autosuggest,
  ChoiceChips,
} from '@fs/zion-ui'
import {
  DateSuggest,
  PlaceSuggest,
  LanguageSuggest,
  DateSuggestNEXT,
  PlaceSuggestNEXT,
  LanguageSuggestNEXT,
  useStandardSuggestNEXT,
} from '@fs/zion-standards'
import { Autosuggest as AutosuggestNEXT, useAutosuggest as useAutosuggestNEXT } from '@fs/zion-ui-autosuggest'
import isEqual from 'lodash.isequal'
import { useWatch, useController, useFormState } from 'react-hook-form'
import { useZionFormContext, getByPath } from './Form'

function useRegister({ ref, registerOptions, onChange, onBlur, name }) {
  const { register } = useZionFormContext()

  const {
    ref: registerRef,
    onChange: registerOnChange,
    onBlur: registerOnBlur,
    name: registerName,
  } = register(name, registerOptions)
  // This is the react-hook-form recommended way of sharing ref usage
  const registeredRef = useCallback(
    (domNode) => {
      if (ref) ref.current = domNode
      registerRef(domNode)
    },
    [ref, registerRef]
  )
  const combinedOnChange = useCallback(
    (evt) => {
      registerOnChange && registerOnChange(evt)
      onChange && onChange(evt)
    },
    [registerOnChange, onChange]
  )
  const combinedOnBlur = useCallback(
    (evt) => {
      registerOnBlur && registerOnBlur(evt)
      onBlur && onBlur(evt)
    },
    [onBlur, registerOnBlur]
  )

  return { ref: registeredRef, onChange: combinedOnChange, onBlur: combinedOnBlur, name: registerName }
}

function useValidation({ name, validMessage, ignoreTouchedForWarnings, warningValidate }) {
  const {
    config: { mode },
    getValues,
  } = useZionFormContext()
  const { touchedFields, errors, isSubmitted, dirtyFields } = useFormState()
  const [messages, setMessages] = useState({})
  const error = getByPath(name, errors)
  const isTouched = getByPath(name, touchedFields)
  const isDirty = getByPath(name, dirtyFields)
  let didValidationRunForField = false

  if (mode === 'onSubmit') {
    didValidationRunForField = isSubmitted
  } else if (['onBlur', 'onTouched', 'all'].includes(mode)) {
    didValidationRunForField = isSubmitted || isTouched
  } else if (mode === 'onChange') {
    // onChange doesn't run validation on blur, so we have to ensure that the field has been changed at least once. This doesn't quite do that - because something could get dirty then undirty, but we have no way of saying "has been changed since the last reset"
    didValidationRunForField = isSubmitted || (isTouched && isDirty)
  }

  useEffect(() => {
    const runWarningValidateWithValues = warningValidate
      ? () => {
          const value = getByPath(name, getValues())
          return warningValidate(value)
        }
      : undefined
    const errorMessage = error?.primaryText ? error?.primaryText?.message : error?.message
    // We do not want validation messages to show until either the field has been touched (which happens on the first blur from the field) or the form has been submitted. We make an exception where we can show warnings without being touched if the prop is explicitly set.
    setMessages({
      errorMessage: didValidationRunForField ? errorMessage : undefined,
      validMessage: didValidationRunForField ? validMessage : undefined,
      warningValidate: didValidationRunForField || ignoreTouchedForWarnings ? runWarningValidateWithValues : undefined,
    })
  }, [error, validMessage, warningValidate, ignoreTouchedForWarnings, didValidationRunForField, getValues, name])
  return messages
}

/**
 * Hook up a generic input field to the react-hook-form and zion-form lifecycle. Do not use this if there is a zion component that already supports being used inside of zion-form.
 * @param {ReactComponent} Component - The component to hook into the zion-form lifecycle.
 * @param {string} componentName - optional - only required for TextField special clearable state handling
 * @returns - ForwardedRef wrapped component. Adds the following props:
 * errorMessage, validMessage, warningValidate, (undefined or string)
 * isInForm={true},
 * onChange, onBlur, ref (combined with any existing onChange/onBlur/refs that are passed in)
 */
export function hookUpTextFields(Component, componentName) {
  return forwardRef(
    (
      {
        warningValidate,
        validMessage,
        registerOptions,
        defaultValue,
        onClear,
        onReset,
        ignoreTouchedForWarnings,
        onChange,
        onBlur,
        ...props
      },
      ref
    ) => {
      const componentSpecificProps = { isInForm: true }
      const { name } = props // not listed above because we want it to be part of props that we pass down to Component
      const { setValue, resetField, getFieldState } = useZionFormContext()
      const watchedValue = useWatch({ name, defaultValue })
      const messages = useValidation({ name, validMessage, ignoreTouchedForWarnings, warningValidate })
      const registerProps = useRegister({ ref, registerOptions, name, onChange, onBlur })

      // TextField is the only component that currently supports clearable and resettable
      if (componentName === 'TextField') {
        if (props.clearable) {
          componentSpecificProps.onClear = (...args) => {
            setValue(name, '', {
              shouldValidate: true,
              shouldDirty: true,
            })
            onClear?.(...args)
          }
        }
        if (props.resettable) {
          // Only show reset button when value has changed
          if (getFieldState(name).isDirty) {
            componentSpecificProps.onReset = (...args) => {
              resetField(name)
              onReset?.(...args)
            }
          } else {
            componentSpecificProps.resettable = false
          }
        }
      }

      componentSpecificProps.value = watchedValue || ''

      return <Component {...props} {...componentSpecificProps} {...messages} {...registerProps} />
    }
  )
}

function hookUpBooleanFields(Component) {
  return forwardRef(
    (
      {
        warningValidate,
        validMessage,
        registerOptions,
        defaultValue,
        onClear,
        onChange,
        onBlur,
        ignoreTouchedForWarnings,
        ...props
      },
      ref
    ) => {
      const { value, name } = props
      let checked = false
      const formValue = useWatch({ name, defaultValue })
      if (Array.isArray(formValue)) {
        if (formValue.includes(value)) {
          // this specific toggle or checkbox is checked
          checked = true
        }
      } else if (formValue) {
        // the checkbox is checked
        checked = true
      }
      const componentSpecificProps = {
        isInForm: true,
        checked, // this makes the check mark actually appear
      }
      const registerProps = useRegister({ ref, registerOptions, name, onChange, onBlur })

      return <Component {...props} {...componentSpecificProps} {...registerProps} />
    }
  )
}

// Autosuggest gets its own function because it doesn't need to forward ref and it does a whole bunch of extra useCallbacks that we don't want everything to have to manage. At the time of writing this, Autosuggest and DateSuggest and PlaceSuggest didn't forwardRef. If that is a feature that gets added, we need to forwardRef here, but we must have all 3 components underneath forwarding the ref too.
function hookUpAutosuggest(Component, componentName) {
  return forwardRef(
    (
      {
        warningValidate,
        validMessage,
        registerOptions,
        defaultValue,
        onSuggestionSelected,
        onSelectionChange,
        onClear,
        onBlur,
        onChange,
        onInputTextChange,
        ignoreTouchedForWarnings,
        helpMessage,
        ...props
      },
      ref
    ) => {
      const { name } = props // not listed above because we want it to be part of props that we pass down to Component
      const { control } = useZionFormContext()
      // we don't pull the ref out of the field here and pass it on down because on reset rhf will go through and set the values of the fields if it has access to their ref's and we end up with [object Object] in the input visually. The disadvantage of not using this ref is that it won't be able to focus back to the field on error.
      const {
        field: { onChange: registerOnChange, onBlur: registerOnBlur, value },
      } = useController({ name, control })
      const messages = useValidation({
        name,
        validMessage,
        ignoreTouchedForWarnings,
        warningValidate,
      })

      // Autosuggest functions are wrapped in a useCallback so we don't cause unnecessary thrash by redefining every time. This is why they are outside of the if block for the Autosuggest Components.
      const newOnSuggestionSelected = (suggestion) => {
        // if our current value and suggestion are equal, don't trigger an update to the form - it will put us in an infinite cycle because changing the value in the form triggers onSuggestionSelected.
        if (!isEqual(value, suggestion)) {
          registerOnChange(suggestion)
        }
        onSuggestionSelected && onSuggestionSelected(suggestion)
      }
      const newOnClear = useCallback(
        (suggestion) => {
          registerOnChange(null)
          onClear && onClear(suggestion)
        },
        [onClear, registerOnChange]
      )
      const newOnInputTextChange = useCallback(
        (text) => {
          // we don't want to accidentally call this during a reset of the form because bad things happen if we registerChange during
          // reset with valid and dirty and touched states. The only way I could think of to ensure the user is actually interacting
          // with the input instead of the reset function being called (because rhf's reset function triggers a bunch of side effects
          // that finish after the reset function has already returned) is to verify that we are responding to a user's input event.
          if (!text && window?.event?.type === 'input') {
            registerOnChange(null)
          }
          onInputTextChange && onInputTextChange(text)
        },
        [onInputTextChange, registerOnChange]
      )
      const newOnBlur = useCallback(
        (evt) => {
          registerOnBlur(evt)
          onBlur && onBlur(evt)
        },
        [onBlur, registerOnBlur]
      )

      let componentSpecificProps = {
        onSuggestionSelected: newOnSuggestionSelected,
        onClear: newOnClear,
        onBlur: newOnBlur,
        onChange,
        onInputTextChange: newOnInputTextChange,
        // control the autosuggest - this is important for when we reset the form and default values. Both value and selectedItem are required currently to control autosuggest
        selectedItem: value,
        value,
      }
      if (
        componentName === 'Autosuggest' ||
        componentName === 'DateSuggest' ||
        componentName === 'PlaceSuggest' ||
        componentName === 'LanguageSuggest'
      ) {
        // we disallow validation on standard suggest.
        // standard suggest doesn't forward ref.
        componentSpecificProps = { ...componentSpecificProps, ...messages, helpMessage, ref }
      } else if (process.env.NODE_ENV === 'development' && (helpMessage || validMessage || warningValidate)) {
        /* eslint-disable-next-line no-console -- Needed for warning consumers about misuse */
        console.warn('Validation is not allowed on FormDateSuggest or FormPlaceSuggest - UX decision made March 2021')
      }

      return <Component {...props} {...componentSpecificProps} />
    }
  )
}

function getInitialStandardSuggestState(value) {
  const baseState = {
    userInput: '',
    fieldValue: '',
    selectedItem: null,
    standardSuggestSuggestion: { originalText: null, standard: null },
  }
  if (!value) return baseState
  if (typeof value === 'string') return { ...baseState, userInput: value, fieldValue: value }
  if (value?.primaryText) return { ...baseState, selectedItem: value }
  return { ...baseState, ...value }
}

const defaultHandleSelection = (suggestion, input) => (suggestion ? suggestion.primaryText : input)
function hookUpAutosuggestNEXT(Component, { defaultStandardize = false } = {}) {
  return ({
    handleSelection = defaultHandleSelection,
    name,
    validMessage,
    ignoreTouchedForWarnings,
    warningValidate,
    onBlur,
    standardize = defaultStandardize, // Allow prop to override default
    ...props
  }) => {
    const { control } = useZionFormContext()
    const { field: input, fieldState } = useController({ name, control })

    let initialState = input.value
    if (typeof initialState === 'string') {
      initialState = { userInput: input.value }
    } else if (initialState?.primaryText) {
      initialState = { selectedItem: initialState }
    } else if (standardize) {
      initialState = getInitialStandardSuggestState(input.value)
    }

    const config = standardize
      ? useStandardSuggestNEXT({ initialState, standardize })
      : useAutosuggestNEXT({ initialState, handleSelection })
    const { userInput, selectedItem, set } = config
    const handleChange = useEvent(input.onChange)

    const previousValueRef = useRef({ userInput: '', selectedItem: null })
    useEffect(() => {
      // Prevent calling the handleChange function too often and causing performance issues
      if (
        userInput === previousValueRef.current?.userInput &&
        selectedItem?.primaryText === previousValueRef.current?.selectedItem?.primaryText
      ) {
        return
      }

      previousValueRef.current = { userInput, selectedItem }
      handleChange({
        userInput,
        selectedItem,
        fieldValue: handleSelection(selectedItem, userInput),
      })
    }, [userInput, selectedItem, handleChange, handleSelection])

    const { isDirty } = fieldState
    const wasDirty = useRef(isDirty)
    useEffect(() => {
      // If we changed from dirty to clean, the field was reset
      if (!isDirty && wasDirty.current) {
        set(input.value)
      }
      wasDirty.current = isDirty
    }, [isDirty, input.value, set])

    const messages = useValidation({
      name,
      validMessage,
      ignoreTouchedForWarnings,
      warningValidate,
    })

    const newOnBlur = useCallback(
      (evt) => {
        input.onBlur(evt)
        onBlur?.(evt)
      },
      [input, onBlur]
    )

    return (
      <Component
        {...props}
        {...(standardize ? { standardize } : {})} // only pass when true
        {...messages}
        onBlur={newOnBlur}
        name={`${input.name}.fieldValue`}
        config={config}
      />
    )
  }
}

// choice chips gets its own special function because it doesn't need to do the work of forwarding ref
function hookUpChoiceChips(Component) {
  return ({ chips, registerOptions, defaultValue, ignoreTouchedForWarnings, ...props }) => {
    const componentSpecificProps = { isInForm: true }
    const { name } = props // not listed above because we want it to be part of props that we pass down to Component
    const watchedValue = useWatch({ name, defaultValue })
    const { register } = useZionFormContext()

    // ChoiceChips doesn't really give us a way to set the selected item. We need to do that for resetting the form and for default values. Giving a new chips list on every render ensures that it will check for the selected chip in its use effect after each of our renders. Whenever the watchedValue changes, it will update selected.
    const newChips = chips.map(({ value, ...nisnergs }) => {
      const { onChange, onBlur, ref: chipRef } = register(name)
      return { value, selected: value === watchedValue, onChange, onBlur, chipRef, ...nisnergs }
    })
    componentSpecificProps.chips = newChips

    return <Component {...props} {...componentSpecificProps} />
  }
}

export const FormAutosuggest = hookUpAutosuggest(Autosuggest, 'Autosuggest')
export const FormAutosuggestNEXT = hookUpAutosuggestNEXT(AutosuggestNEXT)
export const FormPlaceSuggestNEXT = hookUpAutosuggestNEXT(PlaceSuggestNEXT)
export const FormDateSuggestNEXT = hookUpAutosuggestNEXT(DateSuggestNEXT)
export const FormLanguageSuggestNEXT = hookUpAutosuggestNEXT(LanguageSuggestNEXT)
export const FormDateSuggest = hookUpAutosuggest(DateSuggest, 'DateSuggest')
export const FormPlaceSuggest = hookUpAutosuggest(PlaceSuggest, 'PlaceSuggest')
export const FormLanguageSuggest = hookUpAutosuggest(LanguageSuggest, 'LanguageSuggest')
export const FormCheckbox = hookUpBooleanFields(Checkbox)
export const FormRadio = hookUpBooleanFields(Radio)
export const FormToggle = hookUpBooleanFields(Toggle)
export const FormTextField = hookUpTextFields(TextField, 'TextField')
export const FormTextArea = hookUpTextFields(TextArea)
export const FormMultilineTextField = hookUpTextFields(MultilineTextField)
export const FormSelect = hookUpTextFields(Select)
export const FormChoiceChips = hookUpChoiceChips(ChoiceChips)

export function FieldsWithValidationProps({ ...props }) {
  return <>{props}</>
}

FieldsWithValidationProps.propTypes = {
  /** Force warningValidate to show up before a field is touched or the form is submitted */
  ignoreTouchedForWarnings: PropTypes.bool,

  /** Ensure that validation and help text do not show up on the field level because validation is displaying in a parent group component */
  validateAtGroupLevel: PropTypes.bool,
}
