import React, { useCallback, useMemo, forwardRef } from 'react'
import PropTypes from 'prop-types'
import { useForm, FormProvider, useFormContext } from 'react-hook-form'

export function useZionFormContext() {
  return useFormContext()
}

// We export ZionFormProvider in the off chance we find somewhere it needs to be used. We don't think it will.
export function ZionFormProvider({ methods, children }) {
  return <FormProvider {...methods}>{children}</FormProvider>
}

/**
 * @description - utility to get values by name out of touchedFields, dirtyFields, errors, getValues(), etc., if they might be names that would turn into an object
 * @param {string} path - the path to lookup in the object (i.e. `'nameTemplate.en.firstName'`, `'searchFields.birthYear'`, `'email'`, etc.)
 * @param {object} object - the object to look into (i.e. results of `getValues()`, `errors`, `touchedFields`, `dirtyFields`, etc.)
 * @returns {any} - the value at the nested path of the object, or if that is strictly undefined (not just falsy), the value of the key at the root of the object.
 */
export function getByPath(path, object) {
  // this is copied from pathToString internal to react-hook-form/dist/utils/pathToString
  const parts = path
    .replace(/["|']|\]/g, '') // remove quotation marks and closing square brackets
    .split(/\.|\[/) // split on . and [ to get all the pieces
    .filter(Boolean) // remove anything in the path that is falsy
  const target = parts.reduce((currentObject, currentKey) => {
    return currentObject && currentObject[currentKey]
  }, object)
  // users have some control over some objects and may not choose to do an unflattened object, such as when they are creating an errors object to return from a validate function. This accounts for that. However, when we have default values that we pass in with the full key rather than as an unflattened object, the value of that does not update when the field updates. Therefore, we only use that value if the target is specifically undefined, meaning that it doesn't exist in the object.
  if (target === undefined && object[path]) return object[path]
  return target
}

/**
 * @description - Zion wrapper for useForm. Under the covers it does the same thing as react-hook-form's useForm but adds a default of shouldUnregister to false.
 * @param {obj} options - options provided to the useForm hook from react-hook-form (see their docs: https://react-hook-form.com/v6/api#useForm)
 * @returns {obj} the methods and state of the form - the same values that useForm hook from react-hook-form provides (see thier docs: https://react-hook-form.com/v6/api#useForm)
 */
export function useZionForm(options = {}) {
  /**
   * Decisions made:
   * shouldUnregister is going away in future versions of react-hook-form, so we are defaulting to setting it to false. Most of our use cases shouldn't unregister on unmount (e.g. changing from mobile to desktop dialogs would trigger an unmount/remount and we would lose all the values)
   * We aren't providing any sugar for validation functions - we will all be writing custom resolvers. This will likely be what we need to allow for multiple errors per field and "form-level" errors that are not associated with any particular field
   * If you want to use yup, just import the custom resolver from react-hook-form and set it up like in their docs
   */

  if (process.env.NODE_ENV === 'development' && !options.defaultValues) {
    throw new Error(
      'defaultValues MUST be provided for ALL fields so that form reset and dirty checking function properly.'
    )
  }

  const smartDefaultsWithOptions = useMemo(
    () => ({
      ...UseZionFormProps.defaultProps,
      ...options,
    }),
    [options]
  )
  const methods = useForm(smartDefaultsWithOptions)

  // we intend this next piece of information to not be used by consumers and only be used internal to @fs/zion-form, but we can't stop them once they get out.
  methods.config = smartDefaultsWithOptions

  return methods
}

// We export ZionFormElement in the off chance we find somewhere it needs to be used. We don't think it will.
export const ZionFormElement = forwardRef(({ children, onSubmit, ...props }, ref) => {
  const { handleSubmit } = useZionFormContext()
  const submitWrapper = useCallback(
    (event) => {
      // When forms are nested in the react tree but not in the dom (e.g. your form opens an overlay with another form in it),
      // React improperly propagates all events including submit up through portals in the react tree. In the HTML DOM the
      // form elements are siblings. In the React tree, they are parent-child. When Return is pressed in the "child" form,
      // we want that form to submit, but we don't want the parent form to submit. Event.stopPropagation() in the submit
      // function prevents the parent form from submitting. We feel confident that the submit event should never bubble up past
      // the html form element that is listening for it.
      event.stopPropagation()
      handleSubmit(onSubmit)(event)
    },
    [handleSubmit, onSubmit]
  )
  return (
    <form {...props} ref={ref} onSubmit={submitWrapper}>
      {children}
    </form>
  )
})

const ZionForm = forwardRef(({ children, methods, ...props }, ref) => {
  return (
    <ZionFormProvider methods={methods}>
      <ZionFormElement {...props} ref={ref}>
        {children}
      </ZionFormElement>
    </ZionFormProvider>
  )
})

export default ZionForm

ZionFormElement.propTypes = {
  /** Function to run on submit of the form */
  onSubmit: PropTypes.func,
}

ZionFormProvider.propTypes = {
  /** Results of useZionForm hook, e.g. `const methods = useZionForm(options)` */
  methods: PropTypes.object.isRequired,
}

ZionForm.propTypes = {
  /** Results of useZionForm hook, e.g. `const methods = useZionForm(options)` */
  methods: PropTypes.object.isRequired,

  /** Function to run on submit of the form */
  onSubmit: PropTypes.func,
}

export function UseZionFormProps({ ...props }) {
  return <>{props}</>
}

UseZionFormProps.defaultProps = {
  mode: 'onSubmit',
  reValidateMode: 'onChange',
  shouldUnregister: false,
  defaultValues: undefined,
  resolver: undefined,
  context: undefined,
  criteriaMode: 'firstError',
  shouldFocusError: true,
}

UseZionFormProps.propTypes = {
  /** When validation triggers - NOTE: `onChange` is weird and won't trigger validation on blur if the field has not been modified - you may not want to use this mode because we don't fully support it with validation. */
  mode: PropTypes.oneOf(['all', 'onBlur', 'onSubmit', 'onTouched', 'onChange']),

  /** You MUST provide default values for every field in your form, even if they are null or empty strings, otherwise reset and dirty checking will not function correctly. This keys off of the name of the fields. If you are trying to change the `defaultValues` of the form, be aware that passing them into the hook doesn't do this - the `useZionForm` hook caches the defaultValues on first run of the component, much like a useState hook does. You will need to call `reset` and pass in your new `defaultValues`. Example: */
  defaultValues: { sex: 'male', status: '', 'accept-cookies': false },

  /** This is the validate function - you can use the pre-built `yupResolver` or you can write a custom resolver (see react-hook-form [docs](https://react-hook-form.com/v6/api#useForm)). */
  resolver: PropTypes.func,

  /** When validation triggers after initial submit. */
  reValidateMode: PropTypes.oneOf(['onChange', 'onBlur', 'onSubmit']),

  /** Whether to focus the first input that has an error when submit is attempted and validation fails. */
  shouldFocusError: PropTypes.bool,

  /** NOTE: We default to false, unlike react-hook-form which defaults to true - most of our use cases want to keep the form field values between mounts, such as when a form inside a dialog is switching from mobile to desktop and it gets remounted. If you set this to `true`, your fields will reset to their default state if they get unmounted/remounted. */
  shouldUnregister: PropTypes.bool,

  /** See react-hook-form docs - you probably won't need this. */
  context: PropTypes.shape({}),

  /** See react-hook-form docs - you probably won't need this. */
  criteriaMode: PropTypes.oneOf(['firstError']),
}
