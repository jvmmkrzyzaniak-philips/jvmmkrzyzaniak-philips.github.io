import { useEffect, useRef, useMemo, useState } from 'react'
import Cache from '@fs/zion-cache'
import type { UseFormReturn } from '@fs/zion-form'
import { useWatch } from '@fs/zion-form'
import zionDebug from '@fs/zion-debug'

const debug = zionDebug('treeWeb:storageSync')

export type ZionCache = {
  getItem: (key: string) => Promise<string>
  setItem: (key: string, value: string) => Promise<void>
  removeItem: (key: string) => Promise<void>
}

export type SyncProps = {
  /** Value to set for database key */
  value: string | null
  /** Database key for Zion Cache */
  key?: string
  /** The Zion Cache */
  cache: ZionCache
}

export function useSyncToStorage({ value, key, cache }: SyncProps): boolean {
  const [loading, setLoading] = useState<undefined[]>([])

  useEffect(() => {
    let isCurrent = true

    debug(`Value is '${value}'.\ndatabaseKey=${key}`)

    if (value && key) {
      setLoading((prev) => [...prev, undefined])
      debug(`Setting the value of '${value}' in the cache.\ndatabaseKey=${key}`)
      cache
        .setItem(key, value)
        .catch(console.error)
        .finally(() => isCurrent && setLoading((prev) => prev.slice(1)))
    }
    if (value === '' && key) {
      setLoading((prev) => [...prev, undefined])
      debug(`Removing value in the cache.\ndatabaseKey=${key}`)
      cache
        .removeItem(key)
        .catch(console.error)
        .finally(() => isCurrent && setLoading((prev) => prev.slice(1)))
    }

    return () => {
      isCurrent = false
    }
  }, [cache, key, value])
  return loading.length > 0
}

export type SyncFieldProps = {
  /** Name of Zion Form field */
  fieldName: string
  /** Unique database key for the storeName. Ex: KW39-ABCD:relationship:edit-reason:LM65-23AF:child */
  databaseKey?: string
  /** Unique name for storing temp reason. Ex: treePersonR9RelationshipReason */
  storeName: string
  /** Methods from useZionForm */
  methods: UseFormReturn
  /** Default text for field */
  defaultText?: string
  /** If the value  from fieldName should be stored */
  canUpdateStorage?: boolean
}

export function useSyncFieldToStorage({
  fieldName,
  databaseKey,
  storeName,
  methods: { control, setValue, resetField },
  defaultText,
  canUpdateStorage = true,
}: SyncFieldProps): () => Promise<void> {
  const [readyToUpdateDatabaseKey, setReadyToUpdateDatabaseKey] = useState<string | undefined>()
  const value = useWatch({ name: fieldName, control, defaultValue: null })

  const cache: ZionCache = useMemo(() => {
    debug(`Cache made with storeName=${storeName}`)
    return new Cache({ storeName })
  }, [storeName])

  useEffect(() => {
    debug(`Not ready to update databaseKey=${databaseKey}`)
    // Whenever the databaseKey changes, don't update the database until we have gotten the first stored value
    setReadyToUpdateDatabaseKey(undefined)
  }, [databaseKey])

  useSyncToStorage({
    value: canUpdateStorage && readyToUpdateDatabaseKey && readyToUpdateDatabaseKey === databaseKey ? value : null,
    key: databaseKey,
    cache,
  })

  useEffect(() => {
    debug(`Resetting ${fieldName} for databaseKey=${databaseKey}`)
    resetField(fieldName)
  }, [resetField, databaseKey, fieldName])

  useEffect(() => {
    if (defaultText) {
      debug(
        `Setting the default text of '${defaultText}' for the field, ${fieldName}\nstoreName=${storeName}\ndatabaseKey=${databaseKey}`
      )
      setValue(fieldName, defaultText, { shouldValidate: true, shouldDirty: true })
    }
  }, [databaseKey, defaultText, fieldName, setValue, storeName])

  useEffect(() => {
    let isCurrent = true
    debug(`Something has changed and will get item.\nstoreName=${storeName}\ndatabaseKey=${databaseKey}`)
    if (databaseKey) {
      cache
        .getItem(databaseKey)
        .then((storedValue) => {
          debug(`The stored value is ${storedValue}.\nstoreName=${storeName}\ndatabaseKey=${databaseKey}`)
          if (storedValue) {
            debug(
              `Setting the stored value of '${storedValue}' for the field, ${fieldName}.\nstoreName=${storeName}\ndatabaseKey=${databaseKey}`
            )
            isCurrent && setValue(fieldName, storedValue, { shouldValidate: true, shouldDirty: true })
          }
          debug(`Ready to update databaseKey=${databaseKey}`)
          isCurrent && setReadyToUpdateDatabaseKey(databaseKey)
          return null
        })
        .catch(console.error)
    }
    return () => {
      isCurrent = false
    }
  }, [cache, databaseKey, fieldName, setValue, storeName])

  return () => {
    if (databaseKey) {
      debug(`Removing item.\nstoreName=${storeName}\ndatabaseKey=${databaseKey}`)
      return cache.removeItem(databaseKey)
    }
    return Promise.resolve()
  }
}

export type SyncDialogFieldProps = SyncFieldProps & {
  /** The value for if the Dialog is open or not (should be provided by useOverlay) */
  isOpen: boolean
}

// This version of the hook handles clearing storage when the dialog is closed by the user intentionally (cancel button, click-away, close button, submit, whatever)
export function useSyncDialogFieldToStorage({
  isOpen,
  methods,
  fieldName,
  databaseKey,
  storeName,
  defaultText,
}: SyncDialogFieldProps): () => Promise<void> {
  const { resetField } = methods
  const [canUpdateStorage, setCanUpdateStorage] = useState(true)
  const removeFieldFromStorage = useSyncFieldToStorage({
    storeName,
    databaseKey,
    methods,
    fieldName,
    defaultText,
    canUpdateStorage,
  })
  const wasOpen = useRef(isOpen)
  useEffect(() => {
    if (!isOpen && wasOpen.current) {
      debug(
        `Resetting the field, ${fieldName}, and removing the stored value.\nstoreName=${storeName}\ndatabaseKey=${databaseKey}`
      )
      wasOpen.current = false
      setCanUpdateStorage(false)
      resetField(fieldName)
      removeFieldFromStorage()
    }
    if (isOpen) {
      setCanUpdateStorage(true)
      wasOpen.current = true
    }
  }, [isOpen, fieldName, resetField, removeFieldFromStorage, setCanUpdateStorage, storeName, databaseKey])

  return removeFieldFromStorage
}
