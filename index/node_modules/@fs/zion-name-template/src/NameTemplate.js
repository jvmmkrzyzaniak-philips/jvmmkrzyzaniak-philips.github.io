import React, { forwardRef, useCallback, useEffect, useReducer, useRef } from 'react'
import PropTypes from 'prop-types'
import { Divider, Separator, H5, Subheading } from '@fs/zion-ui'
import { useZionFormContext, FormSelect } from '@fs/zion-form'
import { NoticeLoading } from '@fs/zion-icon'
import { useTranslation } from 'react-i18next'
import axios from '@fs/zion-axios'
import {
  fieldNames,
  langSupportsSuffix,
  langSupportsTitle,
  langToTransliterationScriptMap,
  sinotypicTemplates,
  useNameTemplateOptions,
  getTemplateLanguages,
  nameTemplateNamespace,
  templateToLanguagesMap,
  langSupportsLastNameDescription,
} from './NameTemplateUtils'

import { setPreferredNameTemplate } from './defaultNameTemplate'
import { collectNonEmptyNameForms, getWarnings, shiftLanguageData } from './formAdapter'
import MismatchingTemplateLangDataProblemHeader from './MismatchingTemplateLangDataProblemHeader'

import NameForm from './NameForm'

const actionType = {
  setDefaultNameTemplate: 'SET_DEFAULT_NAME_TEMPLATE',
  templateChangedManually: 'SET_NEW_NAME_TEMPLATE',
  updateMethods: 'UPDATE_METHODS',
  removeNameForm: 'REMOVE_NAME_FORM',
  transliteratePart: 'TRANSLITERATE_PART',
}

const calculateDisplayStateForNameForms = ({ getValues, languagesList }) => {
  const values = getValues()
  const nonEmptyNameForms = collectNonEmptyNameForms(values)

  // identify if any of the name forms contain or languages support a title or suffix
  let shouldDisplayTitleFields = false
  let shouldDisplaySuffixFields = false
  languagesList.forEach((lang) => {
    if (nonEmptyNameForms[lang]?.[fieldNames.title] || langSupportsTitle(lang)) {
      shouldDisplayTitleFields = true
    }
    if (nonEmptyNameForms[lang]?.[fieldNames.suffix] || langSupportsSuffix(lang)) {
      shouldDisplaySuffixFields = true
    }
  })

  // since languagesList is sorted by the standard items first, we can split our list into standard vs non-standard
  let standardNameFormLanguages = languagesList
  let nonStandardNameFormLanguages = []
  const nonStandardIndex = languagesList.findIndex((lang) => !lang.startsWith(values.template))
  if (nonStandardIndex >= 0) {
    standardNameFormLanguages = languagesList.slice(0, nonStandardIndex)
    nonStandardNameFormLanguages = languagesList.slice(nonStandardIndex)
  }
  const shouldReserveSpaceForCloseBtn = nonStandardNameFormLanguages.length > 0
  return {
    shouldReserveSpaceForCloseBtn,
    standardNameFormLanguages,
    nonStandardNameFormLanguages,
    nonStandardIndex,
    shouldDisplayTitleFields,
    shouldDisplaySuffixFields,
    nonEmptyNameForms,
  }
}

const updateTemplate = ({ getValues, setValue, savePreference, oldNameTemplateLang }) => {
  const values = getValues()
  const { template } = values
  const isEurotypicNameOrder = !sinotypicTemplates.includes(template) // this needs to be set in the form data as well so that it can be shared to parents who might care like the add flow
  setValue('isEurotypicNameOrder', isEurotypicNameOrder)
  savePreference && setPreferredNameTemplate(getValues().template)
  const { languagesToDisplay: languagesList, languagesToMigrate } = shiftLanguageData(
    values,
    getTemplateLanguages(template),
    oldNameTemplateLang
  )

  // migrateLanguages that would create duplicate script entries when switching templates
  // Note migrating Languages should not happen if there is a duplicate script within the same template eg: zh and zh-Hani both map to CHINESE-HAN that logic should be done in shiftLanguageData
  const nameFormsToPossiblyMigrate = collectNonEmptyNameForms(values)
  languagesToMigrate.forEach((languageToMigrate) => {
    const { toLanguage, fromLanguage } = languageToMigrate
    Object.entries(nameFormsToPossiblyMigrate[fromLanguage]).forEach(([namePart, value]) => {
      const fromKey = `${nameTemplateNamespace}.${fromLanguage}.${namePart}`
      const toKey = `${nameTemplateNamespace}.${toLanguage}.${namePart}`
      setValue(toKey, value, { shouldTouch: true, shouldDirty: true, shouldValidate: true })
      setValue(fromKey, null, { shouldDirty: true, shouldValidate: true })
    })
  })

  const newState = calculateDisplayStateForNameForms({ getValues, languagesList })

  return {
    ...newState,
    isEurotypicNameOrder,
    languagesList,
    template,
    oldNameTemplateLang,
  }
}

const removeNameFormAction = ({ languageToRemove, getValues, setValue }) => {
  let values = getValues()
  // remove from form values - this needs to be done before we update the rest of the state because when we get the values in the calculateDisplayStateForNameForms, we need to have already removed these values
  Object.keys(values[nameTemplateNamespace][languageToRemove]).forEach((namePart) =>
    setValue(`${nameTemplateNamespace}.${languageToRemove}.${namePart}`, null, {
      shouldValidate: true,
      shouldDirty: true,
    })
  )

  // refetch the values to update the languages list after we've deleted stuff.
  values = getValues()
  const { template } = values
  const { languagesToDisplay: languagesList } = shiftLanguageData(values, getTemplateLanguages(template))
  const newState = calculateDisplayStateForNameForms({ getValues, languagesList })
  newState.languagesList = languagesList
  return newState
}

const transliteratePart = ({ getValues, setValue, partToReplace, partiallyTransliterated, replacementData }) => {
  if (partiallyTransliterated) {
    setValue('partiallyTransliterated', true)
  }
  setValue(partToReplace, replacementData, { shouldValidate: true, shouldDirty: true, shouldTouch: true })
  const values = getValues()
  const { languagesToDisplay: languagesList } = shiftLanguageData(values, getTemplateLanguages(values.template))
  return calculateDisplayStateForNameForms({ getValues, languagesList })
}

const reducer = (oldState, { type, ...actionData }) => {
  const { getValues, setValue, template: oldNameTemplateLang } = oldState

  let newState = {}
  switch (type) {
    case actionType.setDefaultNameTemplate:
      // sometimes we unmount/remount, and we don't want to change back to the default template if that's all that happened - respect the values inside the form
      if (!getValues().defaultNameTemplateSet) {
        setValue('template', actionData.defaultNameTemplate)
        setValue('defaultNameTemplateSet', true)
      }
      newState = updateTemplate({ getValues, setValue, oldNameTemplateLang })
      return { ...oldState, ...newState }
    case actionType.templateChangedManually:
      newState = updateTemplate({
        getValues,
        setValue,
        savePreference: true,
        oldNameTemplateLang,
      })
      return { ...oldState, ...newState, warningObj: {}, newTemplate: true }
    case actionType.updateMethods:
      return { ...oldState, ...actionData }
    case actionType.removeNameForm:
      newState = removeNameFormAction({ languageToRemove: actionData.languageToRemove, getValues, setValue })
      return { ...oldState, ...newState }
    case actionType.transliteratePart:
      newState = transliteratePart({
        getValues,
        setValue,
        partToReplace: actionData.partToReplace,
        replacementData: actionData.replacementData,
        partiallyTransliterated: actionData.partiallyTransliterated,
      })
      return { ...oldState, ...newState }
    case 'SET_WARNING':
      return { ...oldState, ...actionData, newTemplate: false }
    default:
      console.error('you called an action type I can not do anything with:', type)
      return oldState
  }
}

/**
 * React name template: the canonical source of truth for entering/editing names for Family Tree persons.
 *
 * @see {@link https://github.com/fs-webdev/babylon/blob/master/packages/name-template/src/README.mdx | NameTemplate README}
 * Internally named NameTemplateComponent to hopefully avoid nomenclature confusion.
 * @param {object} props - The props passed into the element, that become destructured into their respective destinations.
 * @param {string} [props.lastNameDescription] - The help text to display underneath the givenPart field.
 * @param {string} [props.defaultNameTemplate] - The defaultNameTemplate from useDefaultNameTemplate or from the pre-populated data. Used for indicating loading state. A value is required to get out of the loading state.
 * @param {func} - The function that the local will be past to on change of the template language picker.
 * @returns {HTMLElement} - The React element itself.
 */
const NameTemplateComponent = forwardRef(
  (
    {
      conclusionType,
      lastNameDescription: lastNameHelpText,
      defaultNameTemplate,
      simple,
      languagePickerCallback,
      validateNameAtGroupLevel,
    },
    ref
  ) => {
    const backupRef = useRef()
    if (!ref) ref = backupRef
    const [t] = useTranslation()
    const lastNameDescription =
      conclusionType === 'ALTERNATE_NAME' ? '' : lastNameHelpText || t('name-template.last-name-help-text')
    const nameTemplateOptions = useNameTemplateOptions()
    const methods = useZionFormContext()
    const {
      getValues,
      setValue,
      formState: { dirtyFields },
    } = methods
    const defaultState = {
      getValues,
      setValue,
      defaultNameTemplate,
      languagesList: [],
      isEurotypicNameOrder: false,
      standardNameFormLanguages: [],
      nonStandardNameFormLanguages: [],
      warningObj: {},
      newTemplate: false,
    }
    const [state, dispatch] = useReducer(reducer, defaultState)
    const hasInitToFirstLanguageList = useRef(false)

    const { languagesList, nonStandardIndex, oldNameTemplateLang } = state
    // what should be in the state: standardNameFormLanguages, nonStandardNameFormLanguages, shouldDisplayTitleFields, shouldDisplaySuffixFields, nonEmptyNameForms, languagesList, shouldReserveSpaceForCloseBtn

    const nameFormBlockRef = useRef(null)

    // Populates the name template component when the defaultNameTemplate is set or changed
    // This is destructive to user data that may have been there, so we should probably only set defaultNameTemplate on initial load of the component/preference get
    useEffect(() => {
      if (defaultNameTemplate) {
        dispatch({ type: actionType.setDefaultNameTemplate, defaultNameTemplate })
        // Setting the language for languagePickerCallback for what it was set to originally
        languagePickerCallback?.(defaultNameTemplate)
      }
    }, [defaultNameTemplate, languagePickerCallback])

    useEffect(() => {
      dispatch({ type: actionType.updateMethods, getValues, setValue })
    }, [getValues, setValue])

    const isLoading = !(defaultNameTemplate && languagesList.length)

    useEffect(() => {
      // Focus the first name part whenever the languagesList changes
      if (hasInitToFirstLanguageList.current && !isLoading) {
        ref.current.focus()
      }
      if (languagesList.length > 0 && hasInitToFirstLanguageList.current === false)
        hasInitToFirstLanguageList.current = true
    }, [languagesList, ref, isLoading])

    useEffect(() => {
      // To avoid conflicts with useAutoFocus (used in DialogOverlay), we too requestAnimationFrame
      requestAnimationFrame(() => {
        if (!isLoading && ref.current && ref.current !== document.activeElement) {
          ref.current.focus()
        }
      })
    }, [isLoading, ref])

    const switchNameTemplate = useCallback(
      ({ target: { value } }) => {
        dispatch({ type: actionType.templateChangedManually })

        // Setting the language for languagePickerCallback each time it is changed (not including what it was set to originally)
        if (value) languagePickerCallback?.(value)
      },
      [languagePickerCallback]
    )

    // When we click the x button on a non standard name form in the UI, we want to remove the data
    const removeNameForm = useCallback(({ currentTarget }) => {
      const languageToRemove = currentTarget?.getAttribute('lang')
      if (languageToRemove) {
        dispatch({ type: actionType.removeNameForm, languageToRemove })
      }
    }, [])

    /**
     * Request and populate transliterations for nameforms that have transliteration enabled.
     * @param {object} evt - The React synthetic event from the UI element triggering a blur.
     * @returns undefined - Sets data directly.
     */
    const callTransliterate = useCallback(
      (evt) => {
        const values = getValues()
        // JAWS reads input fields as the lang if the attribute is just lang that is why we are using data-lang
        const lang = evt?.target?.getAttribute('data-lang')
        const part = evt?.target?.getAttribute('part')
        const latnLanguage = `${values.template}-Latn`
        const latinNameTemplatePart = `${nameTemplateNamespace}.${latnLanguage}.${part}`

        const langIsInTemplateLanguagesMap = templateToLanguagesMap[values.template].includes(lang)
        const partHasValue = evt?.target?.value
        const partIsDirty = dirtyFields?.nameTemplate?.[lang]?.[part]
        const latnPartIsBlank = !values[nameTemplateNamespace]?.[latnLanguage]?.[part]

        // Only transliterate if we are in a primary nameform and the input is dirty or equivalent latn part is blank
        // When switching name templates all the fields will be dirty, so in that case if the roman field is already defined then don't transliterate.

        if (
          langIsInTemplateLanguagesMap &&
          partHasValue &&
          (partIsDirty || latnPartIsBlank) &&
          (!oldNameTemplateLang || latnPartIsBlank)
        ) {
          axios
            .post('/service/tree/tree-data/authorities/transliteration', {
              original: values[nameTemplateNamespace]?.[lang],
              requestedTransliteration: langToTransliterationScriptMap[lang],
            })
            .then((resp) => {
              if (resp.status === 200 && resp.data) {
                // Check the original requested text field's current value against what the endpoint returns as the originally requested text - if they updated it before we transliterated, we've got another call coming.
                const possiblyUpdatedValues = getValues()
                if (
                  (!oldNameTemplateLang || !possiblyUpdatedValues[nameTemplateNamespace]?.[latnLanguage]?.[part]) &&
                  possiblyUpdatedValues[nameTemplateNamespace][lang][part] === resp?.data?.data?.original[part]
                ) {
                  dispatch({
                    type: actionType.transliteratePart,
                    partToReplace: latinNameTemplatePart,
                    partiallyTransliterated: resp?.data?.data?.partiallyTransliterated,
                    replacementData: resp?.data?.data?.generated[part] || null,
                  })
                  // TODO: glow the field... or whatever that might be (UX question)
                }
              }
            })
            .catch(() => {})
        }
      },
      [dirtyFields, getValues, oldNameTemplateLang]
    )

    function updateWarningObj(updatedErrorObj) {
      dispatch({ type: 'SET_WARNING', warningObj: updatedErrorObj })
    }

    useEffect(() => {
      let isCurrent = true
      const changedValues = getValues()

      getWarnings({ t, formValues: changedValues }).then((errorsObject) => isCurrent && updateWarningObj(errorsObject))

      return () => {
        isCurrent = false
      }
    }, [getValues, t])

    return !isLoading ? (
      <>
        <MismatchingTemplateLangDataProblemHeader errors={state.warningObj} values={state.getValues()} />

        <section>
          <FormSelect
            hidePlaceholder
            label={t('name-template.language-selector.label')}
            onChange={switchNameTemplate}
            data-testid={`name-template-picker:${state?.template}`}
            options={nameTemplateOptions}
            name="template"
            autoWidth
            ignoreTouchedForWarnings
            warningValidate={() => {
              if (Object.keys(state.warningObj?.nameTemplate ?? {}).length > 0) {
                const values = getValues()
                return values.template === 'und'
                  ? t('name-template.multiple-scripts.error')
                  : t('name-template.mismatch-lang-template.error')
              }
              return undefined
            }}
          />
          <div id="nameform-block" ref={nameFormBlockRef}>
            {languagesList.map((lang, index) => {
              const isStandard = nonStandardIndex >= 0 ? nonStandardIndex > index : true
              return (
                <React.Fragment key={lang}>
                  <NonStandardNameFormHeader nonStandardIndex={nonStandardIndex} currentIndex={index} />
                  <AnnotatedNameForm
                    ref={index === 0 ? ref : null}
                    isStandard={isStandard}
                    nameFormLang={lang}
                    lastNameDescription={langSupportsLastNameDescription(lang) && lastNameDescription}
                    callTransliterate={callTransliterate}
                    removeNameForm={removeNameForm}
                    simple={simple}
                    validateNameAtGroupLevel={validateNameAtGroupLevel}
                    updateWarningObj={updateWarningObj}
                    {...state}
                  />
                </React.Fragment>
              )
            })}
          </div>
        </section>
      </>
    ) : (
      // This is in a div to make it display: block;
      <div>
        <NoticeLoading />
      </div>
    )
  }
)

export default NameTemplateComponent

// purpose of this function is to get the correct title, suffix, isStandard, and reserveCloseBtnSpace props onto the NameForm Component
const AnnotatedNameForm = forwardRef(
  (
    {
      nameFormLang,
      isStandard,
      shouldDisplayTitleFields,
      shouldDisplaySuffixFields,
      nonEmptyNameForms,
      lastNameDescription,
      removeNameForm,
      isEurotypicNameOrder,
      shouldReserveSpaceForCloseBtn,
      callTransliterate,
      languagesList,
      simple,
      validateNameAtGroupLevel,
      warningObj,
      updateWarningObj,
    },
    ref
  ) => {
    let title = 'hide'
    if (shouldDisplayTitleFields) {
      if (langSupportsTitle(nameFormLang)) {
        title = 'show'
      } else {
        // keep the text field shown, if user previously entered data in that field
        title = nonEmptyNameForms[nameFormLang]?.[fieldNames.title] ? 'show' : 'disabled'
      }
    }
    let suffix = 'hide'
    if (shouldDisplaySuffixFields) {
      if (langSupportsSuffix(nameFormLang)) {
        suffix = 'show'
      } else {
        // keep the text field shown, if user previously entered data in that field
        suffix = nonEmptyNameForms[nameFormLang]?.[fieldNames.suffix] ? 'show' : 'disabled'
      }
    }
    return (
      <NameForm
        ref={ref}
        lastNameDescription={lastNameDescription}
        lang={nameFormLang}
        removeNameForm={removeNameForm}
        isEurotypicNameOrder={isEurotypicNameOrder}
        title={title}
        suffix={suffix}
        isStandard={isStandard}
        reserveCloseBtnSpace={shouldReserveSpaceForCloseBtn}
        callTransliterate={callTransliterate}
        simple={simple}
        // if there is only one language we are displaying just hide the heading
        hideHeading={languagesList.length === 1}
        validateNameAtGroupLevel={validateNameAtGroupLevel}
        warningObj={warningObj}
        updateWarningObj={updateWarningObj}
        languagesList={languagesList}
      />
    )
  }
)

const NonStandardNameFormHeader = ({ currentIndex, nonStandardIndex }) => {
  const [t] = useTranslation()
  return currentIndex === nonStandardIndex ? (
    <>
      <Separator size="xxs" />
      <H5 supplementary>
        <Subheading as="h2">{t('name-template.non-standard-forms-label')}</Subheading>
      </H5>
      <Divider />
      <Separator size="xxs" />
    </>
  ) : null
}

// Stryker disable all
NameTemplateComponent.propTypes = {
  lastNameDescription: PropTypes.string,
  defaultNameTemplate: PropTypes.string,
  simple: PropTypes.bool,
  languagePickerCallback: PropTypes.func,
}
