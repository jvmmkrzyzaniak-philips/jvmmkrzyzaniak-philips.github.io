import React, { forwardRef, useEffect, useRef } from 'react'
import { FormTextField } from '@fs/zion-form'
import { useTranslation } from 'react-i18next'
import { langToTransliterationScriptMap, otherLastNameStrings, nameTemplateNamespace } from './NameTemplateUtils'
import { updateWarningOnBlur } from './formAdapter'

const commonTextFieldProps = {
  ignoreTouchedForWarnings: true,
  autoComplete: 'chrome-off',
  type: 'text',
  maxLength: 256,
}

/**
 * Because at least one first or last name in any of the languages is
 * required, we need to include all the languages' first and last names as
 * "deps" for revalidation.
 */
function getNameValidationDeps(languagesList = [], fieldNames) {
  const deps = []
  languagesList.forEach((language) => {
    deps.push(`${nameTemplateNamespace}.${language}.${fieldNames.given}`)
    deps.push(`${nameTemplateNamespace}.${language}.${fieldNames.surname}`)
  })
  return deps
}

export const GivenNameField = forwardRef(
  (
    {
      callTransliterate,
      fieldNames,
      fullFieldNames,
      lang,
      validateAtGroupLevel,
      warningObj,
      updateWarningObj,
      languagesList,
    },
    ref
  ) => {
    const [t] = useTranslation()
    const { isCurrent } = useCurrent()
    const shouldTransliterateThisLanguage = Object.keys(langToTransliterationScriptMap).includes(lang)
    return (
      <FormTextField
        ref={ref}
        registerOptions={{ deps: getNameValidationDeps(languagesList, fieldNames) }}
        {...commonTextFieldProps}
        warningValidate={() => {
          if (warningObj?.nameTemplate?.[lang]?.firstName) {
            return lang === 'und'
              ? t('name-template.multiple-scripts.error')
              : t('name-template.mismatch-lang-template.error')
          }
          return undefined
        }}
        onBlur={(event) => {
          shouldTransliterateThisLanguage && callTransliterate(event)
          updateWarningOnBlur({
            lang,
            event,
            updateWarningObj,
            nameField: 'firstName',
            warningObj,
            t,
          })
            .then((updater) => {
              isCurrent.current && updater()
            })
            .catch(console.error)
        }}
        part={fieldNames.given}
        data-testid="first-name"
        name={fullFieldNames.givenNameField}
        data-lang={lang}
        label={t('name-template.first-names')}
        focusable
        validateAtGroupLevel={validateAtGroupLevel}
      />
    )
  }
)

export const SurnameField = forwardRef(
  (
    {
      callTransliterate,
      fieldNames,
      fullFieldNames,
      lastNameDescription,
      lang,
      validateAtGroupLevel,
      warningObj,
      updateWarningObj,
      languagesList,
    },
    ref
  ) => {
    const [t] = useTranslation()
    const shouldTransliterateThisLanguage = Object.keys(langToTransliterationScriptMap).includes(lang)
    const label = otherLastNameStrings[lang] || 'name-template.last-names'
    const { isCurrent } = useCurrent()
    return (
      <FormTextField
        ref={ref}
        registerOptions={{ deps: getNameValidationDeps(languagesList, fieldNames) }}
        {...commonTextFieldProps}
        warningValidate={() => {
          if (warningObj?.nameTemplate?.[lang]?.lastName) {
            return lang === 'und'
              ? t('name-template.multiple-scripts.error')
              : t('name-template.mismatch-lang-template.error')
          }
          return undefined
        }}
        onBlur={(event) => {
          shouldTransliterateThisLanguage && callTransliterate(event)
          updateWarningOnBlur({
            lang,
            event,
            updateWarningObj,
            nameField: 'lastName',
            warningObj,
            t,
          })
            .then((updater) => {
              isCurrent.current && updater()
            })
            .catch(console.error)
        }}
        part={fieldNames.surname}
        data-testid="last-name"
        name={fullFieldNames.surnameField}
        data-lang={lang}
        label={t(label)}
        helpMessage={lastNameDescription}
        focusable
        validateAtGroupLevel={validateAtGroupLevel}
      />
    )
  }
)

export const TitleField = ({
  callTransliterate,
  fieldNames,
  fullFieldNames,
  title,
  lang,
  validateAtGroupLevel,
  warningObj,
  updateWarningObj,
}) => {
  const [t] = useTranslation()
  const { isCurrent } = useCurrent()
  const shouldTransliterateThisLanguage = Object.keys(langToTransliterationScriptMap).includes(lang)
  return (
    <FormTextField
      {...commonTextFieldProps}
      warningValidate={() => {
        if (warningObj?.nameTemplate?.[lang]?.title) {
          return lang === 'und'
            ? t('name-template.multiple-scripts.error')
            : t('name-template.mismatch-lang-template.error')
        }
        return undefined
      }}
      onBlur={(event) => {
        shouldTransliterateThisLanguage && callTransliterate(event)
        updateWarningOnBlur({
          lang,
          event,
          updateWarningObj,
          nameField: 'title',
          warningObj,
          t,
        })
          .then((updater) => {
            isCurrent.current && updater()
          })
          .catch(console.error)
      }}
      part={fieldNames.title}
      data-testid="title"
      name={fullFieldNames.titleField}
      data-lang={lang}
      label={t('common-ui:title.person.name')}
      disabled={title === 'disabled'}
      validateAtGroupLevel={validateAtGroupLevel}
    />
  )
}

export const SuffixField = ({
  callTransliterate,
  fieldNames,
  fullFieldNames,
  suffix,
  lang,
  validateAtGroupLevel,
  warningObj,
  updateWarningObj,
}) => {
  const [t] = useTranslation()
  const { isCurrent } = useCurrent()
  const shouldTransliterateThisLanguage = Object.keys(langToTransliterationScriptMap).includes(lang)
  return (
    <FormTextField
      {...commonTextFieldProps}
      warningValidate={() => {
        if (warningObj?.nameTemplate?.[lang]?.suffix) {
          return lang === 'und'
            ? t('name-template.multiple-scripts.error')
            : t('name-template.mismatch-lang-template.error')
        }
        return undefined
      }}
      onBlur={(event) => {
        shouldTransliterateThisLanguage && callTransliterate(event)
        updateWarningOnBlur({
          lang,
          event,
          updateWarningObj,
          nameField: 'suffix',
          warningObj,
          t,
        })
          .then((updater) => {
            isCurrent.current && updater()
          })
          .catch(console.error)
      }}
      part={fieldNames.suffix}
      data-testid="suffix"
      name={fullFieldNames.suffixField}
      data-lang={lang}
      label={t('name-template.suffix')}
      disabled={suffix === 'disabled'}
      validateAtGroupLevel={validateAtGroupLevel}
    />
  )
}

function useCurrent() {
  const isCurrent = useRef(true)

  useEffect(() => {
    isCurrent.current = true
    return () => {
      isCurrent.current = false
    }
  }, [])
  return { isCurrent }
}
