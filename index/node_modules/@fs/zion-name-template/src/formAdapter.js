import { i18n } from '@fs/zion-locale'
import axios from '@fs/zion-axios'
import { fieldNames, languageToScriptMap, templateToLanguagesMap, nameTemplateNamespace } from './NameTemplateUtils'

/**
 * Put the name forms in the proper order for saving.
 * @param {Array<object>} nameForms - an array of nameform objects, in no particular order.
 * @param {string} template - the user selected name template from form values.
 * @returns {Array<object>} an ordered list of name forms
 */
const sortNameForms = (nameForms, template) => {
  // sort the name forms by language alphabetically
  nameForms.sort((nameForm, previousNameForm) => {
    if (nameForm.lang < previousNameForm.lang) {
      return -1
    }
    if (nameForm.lang > previousNameForm.lang) {
      return 1
    }
    return 0
  })
  let templateLanguages = templateToLanguagesMap[template]
  // if the template is of a roman script, pick something else for the template, the first thing we find that is not roman
  // and change the roman script to the new template-latn lang
  if (languageToScriptMap[template] === 'ROMAN' && nameForms.length > 1) {
    // pick a new template. All roman template only have one name form, so we can just get the next nameform and use its template
    template = nameForms[1].lang.split('-')[0]
    // x-Latn is the only execption to the rule of language being `template-addition`
    if (template === 'x') templateLanguages = ['und']
    else templateLanguages = templateToLanguagesMap[template]
    // change the language of the roman nameForm if the new template has a -Latn language
    templateLanguages.forEach((lang) => {
      if (lang.includes('Latn') && lang !== 'x-Latn') {
        nameForms[0].lang = lang
      }
    })
  }
  // move the name Template languages to the front of the list
  let sortedNameForms = []
  templateLanguages.forEach((lang) => {
    const nameFormForThisLang = nameForms.find((nameForm) => nameForm.lang === lang)
    if (nameFormForThisLang) {
      sortedNameForms.push(nameFormForThisLang)
    }
  })
  sortedNameForms = new Set(sortedNameForms.concat(nameForms))
  return [...sortedNameForms]
}

export function convertFormToTreeData(values) {
  if (!values.template) return []

  const nameForms = []

  const fieldValuesByLang = collectNonEmptyNameForms(values)
  Object.entries(fieldValuesByLang).forEach(([lang, fieldValues]) => {
    const theNameForm = {
      familyPart: fieldValues[fieldNames.surname] || null,
      givenPart: fieldValues[fieldNames.given] || null,
      lang,
      prefixPart: fieldValues[fieldNames.title] || null,
      suffixPart: fieldValues[fieldNames.suffix] || null,
    }
    nameForms.push(theNameForm)
  })
  return sortNameForms(nameForms, values.template)
}

export function convertTreeDataToForm(nameForms) {
  // order doesn't matter, because we know the nameTemplate in the UI, and the standard name forms will just show up in the correct order, everything else will fall where it falls alphabetically according to the language code because that's what the ui does
  const formValues = { [nameTemplateNamespace]: {} }
  const overrideUndNameForm = !nameForms.find((nameForm) => nameForm.lang === 'und')

  nameForms.forEach(({ familyPart, givenPart, prefixPart, suffixPart, lang }) => {
    // x-Latn used to be used but now 'und' is the new type we are using. Also the backend will switch x-Latn to und-Latn. Since we still have millions names that use the x-Latn type we need to remap it to und so it will display correctly. Fixes TW-6186
    const reMappedLang = (lang === 'x-Latn' || lang === 'und-Latn') && overrideUndNameForm ? 'und' : lang
    if (familyPart || givenPart || prefixPart || suffixPart) {
      formValues[nameTemplateNamespace][reMappedLang] = {}
      formValues[nameTemplateNamespace][reMappedLang][fieldNames.surname] = familyPart || ''
      formValues[nameTemplateNamespace][reMappedLang][fieldNames.given] = givenPart || ''
      formValues[nameTemplateNamespace][reMappedLang][fieldNames.title] = prefixPart || ''
      formValues[nameTemplateNamespace][reMappedLang][fieldNames.suffix] = suffixPart || ''
    }
  })
  return formValues
}

export function getNameStringFromFormValues({ isEurotypicNameOrder, ...values }) {
  const [firstNameForm] = convertFormToTreeData(values)
  const prefixPart = firstNameForm?.prefixPart || ''
  const givenPart = firstNameForm?.givenPart || ''
  const familyPart = firstNameForm?.familyPart || ''
  const suffixPart = firstNameForm?.suffixPart || ''

  return isEurotypicNameOrder
    ? `${prefixPart} ${givenPart} ${familyPart} ${suffixPart}`
    : `${prefixPart} ${familyPart} ${givenPart} ${suffixPart}`
}

/**
 * Parse Form field values and group them by language. Removing space-only and empty entries.
 *
 * Takes: forms style
 *   {
 *     "first-name-ja-Latn": "First Name ja-Latn",
 *     "last-name-ja-Latn": "Last Name ja-Latn",
 *     "last-name-ja": "苗字 ja",
 *     ...
 *   }
 *
 * And transforms it into:
 *   {
 *     "ja-Latn": {
 *       "first-name": "First Name ja-Latn",
 *       "last-name": "Last Name ja-Latn",
 *     },
 *     "ja": { "last-name": "苗字 ja" }
 *     ...
 *   }
 * .
 * @param {FieldArray} values - field values from a Form form
 * @returns {object|null} - null if field name is not part of NameForm or value is not valid
 */
export function collectNonEmptyNameForms(values) {
  const allNameForms = values[nameTemplateNamespace] || {}
  if (!allNameForms) {
    return {}
  }
  const allNameFormsArray = Object.entries(allNameForms) || []
  const nonEmptyNameFormsArray = allNameFormsArray.filter(([, language]) => {
    return (
      language[fieldNames.given]?.trim() ||
      language[fieldNames.surname]?.trim() ||
      language[fieldNames.suffix]?.trim() ||
      language[fieldNames.title]?.trim()
    )
  })
  return Object.fromEntries(nonEmptyNameFormsArray)
}

export function collectValidNameForms(values, alreadyProcessed = false) {
  const nameForms = alreadyProcessed ? values : collectNonEmptyNameForms(values)

  // if there is not a given or surname value, reject the title/suffix entries
  return Object.fromEntries(
    Object.entries(nameForms).filter(
      ([, nameForm]) => nameForm[fieldNames.given]?.trim() || nameForm[fieldNames.surname]?.trim()
    )
  )
}

/**
 * This function should return isValidAndDirty boolean.
 * @param {object} values - form values
 * @param {Array} initialValues - initialValues are the tree-data nameForms array of the original data. If omitted, isDirty will be set to true
 * @returns {object} - isValid (bool), isDirty (bool), errors (object)
 */
export function isValidAndDirtyNameForms(values, initialValues) {
  let isValid = false
  let isDirty = false
  const errors = {}
  const nonEmptyNameForms = collectNonEmptyNameForms(values)
  const validNameForms = collectValidNameForms(nonEmptyNameForms, true)

  // user entry is dirty if different from initialValues or if there are no initial values
  if (initialValues) {
    // TODO: we probably ought to change so that we are comparing the raw tree-data name forms to the sorted, ordered data we get back from the form data
    // convert our initial tree-data values to form, and collect all non-empty values from that
    const initialNameForms = collectNonEmptyNameForms(convertTreeDataToForm(initialValues))
    isDirty = Object.entries(nonEmptyNameForms).some(([lang, formNameForm]) => {
      if (initialNameForms[lang]) {
        // compare all the name parts to the initialNameForms and if any are different, we are dirty
        return Object.values(fieldNames).some(
          // use an empty string for consistency if the value is falsy (i.e. null/undefined/'' are all the same thing)
          (part) => (formNameForm[part] || '') !== (initialNameForms[lang][part] || '')
        )
      }
      // if we now have a nameForm for a language that is not in our initialValues, we are dirty
      return true
    })
  } else {
    isDirty = true
  }

  // Add errors to all given and surname fields for all language scripts if there is not at least one given or surname
  const allNameFields = Object.entries(values[nameTemplateNamespace] || {})
  const atLeastOneGivenOrSurname = allNameFields.some(([, names]) => names.firstName?.trim() || names.lastName?.trim())
  if (!atLeastOneGivenOrSurname) {
    const message = i18n.t('name-template.name-fields-value-missing')
    const nameErrors = {
      [fieldNames.given]: { message },
      [fieldNames.surname]: { message },
    }
    errors[nameTemplateNamespace] = {}
    allNameFields.forEach(([language]) => {
      errors[nameTemplateNamespace][language] = nameErrors
    })
  }

  if (Object.keys(validNameForms).length && Object.keys(errors).length === 0) {
    isValid = true
  }

  return {
    isDirty,
    isValid,
    errors: {
      ...errors,
      ...forbiddenCharacterErrors(nonEmptyNameForms),
    },
  }
}

function validateNameForms(nameForms) {
  let nameFormHasData = false
  nameForms.forEach((nameForm) => {
    if (nameFormHasData) return
    if (nameForm.givenPart || nameForm.familyPart || nameForm.prefixPart || nameForm.suffixPart) {
      nameFormHasData = true
    }
  })
  return nameFormHasData ? axios.post('/service/tree/tree-data/authorities/name-forms/compliant', nameForms) : {}
}

export async function getWarnings({ t, formValues }) {
  const treeDataNameForms = convertFormToTreeData(formValues)
  const data = await validateNameForms(treeDataNameForms)
  const errorMessage = { message: t('name-template.mismatch-lang-template.error') }
  const nameTemplateErrors =
    data.data?.reduce((acc, nameForm) => {
      const errorObj = {}
      if (nameForm.familyPart === false) {
        errorObj.lastName = errorMessage
      }
      if (nameForm.givenPart === false) {
        errorObj.firstName = errorMessage
      }
      if (nameForm.suffixPart === false) {
        errorObj.suffix = errorMessage
      }
      if (nameForm.prefixPart === false) {
        errorObj.title = errorMessage
      }
      if (Object.keys(errorObj).length > 0) {
        acc[nameForm.lang] = errorObj
      }
      return acc
    }, {}) ?? {}
  const hasErrors = Object.keys(nameTemplateErrors).length > 0
  return hasErrors ? { nameTemplate: nameTemplateErrors } : {}
}

export async function updateWarningOnBlur({ lang, event, updateWarningObj, warningObj, nameField, t }) {
  const translationKey =
    lang === 'und' ? 'name-template.multiple-scripts.error' : 'name-template.mismatch-lang-template.error'
  const errorMessage = { message: t(translationKey) }
  // Only check compliance if there is text to check OR already an error.
  if (updateWarningObj && (Object.keys(Object(warningObj)).length || event?.target?.value?.trim())) {
    return axios
      .get(`/service/tree/tree-data/authorities/text/compliant?lang=${lang}&text=${event.target.value}`)
      .then(({ data: isValid }) => {
        const currentFieldValue = warningObj?.nameTemplate?.[lang]?.[nameField]
        if (!isValid && currentFieldValue) {
          return () => {}
        }
        if (!isValid && !currentFieldValue) {
          const langObj = !warningObj?.nameTemplate?.[lang]
            ? { [nameField]: errorMessage }
            : { ...(warningObj.nameTemplate[lang] ?? {}), [nameField]: errorMessage }
          return () =>
            updateWarningObj?.({
              ...warningObj,
              nameTemplate: {
                ...(warningObj?.nameTemplate ?? {}),
                [lang]: langObj,
              },
            })
        }
        if (currentFieldValue) {
          delete warningObj.nameTemplate[lang][nameField]
          if (Object.keys(warningObj.nameTemplate[lang]).length === 0) {
            delete warningObj.nameTemplate[lang]
          }
          if (Object.keys(warningObj.nameTemplate).length === 0) {
            delete warningObj.nameTemplate
          }
          return () => updateWarningObj?.(warningObj)
        }
        return () => {}
      })
  }
  return () => {}
}

/**
 * Give us an ordered list of all languages that will have a nameForm displayed, and also changes the language of any nameForm that would have a duplicate script to be the appropriate new language.
 * @param {object} values - form values
 * @param {Array<string>} standardNameFormLanguages - new template languages that need to be inserted if they aren't already there
 * @returns {object} - languagesToDisplay: {Array<string>} the array of languages to display, in order, and languagesToMigrate: {object} fromLanguage, toLanguage - anything in the fromLanguage needs to be moved to the toLanguage and then deleted.
 */
export function shiftLanguageData(values, standardNameFormLanguages, oldNameTemplateLang) {
  const formNameForms = collectNonEmptyNameForms(values)
  const currentLanguages = Object.keys(formNameForms).sort()

  // we use a Set to ensure singularity. Otherwise, we could get in a state were there are
  // multiple fields with the same name.
  const languagesToDisplay = new Set([...standardNameFormLanguages, ...currentLanguages])

  // The old template lang value is undefined on first template rendering
  const actuallySwitching = oldNameTemplateLang && values.template !== oldNameTemplateLang

  const languagesToMigrate = []

  standardNameFormLanguages.forEach((newLanguage) => {
    const script = languageToScriptMap[newLanguage]
    // if a name-form script already exists, then transfer the form data around to the new language
    const languageToMigrate = currentLanguages.find(
      (lang) => lang !== newLanguage && languageToScriptMap[lang] === script
    )
    // Note we only want to do this when switching templates otherwise we could not be displaying data we actually have.
    if (languageToMigrate && actuallySwitching) {
      languagesToMigrate.push({ fromLanguage: languageToMigrate, toLanguage: newLanguage })
      languagesToDisplay.delete(languageToMigrate)
    }
  })

  // These scripts refer to the ones defined in the languageToScriptMap eg: ROMAN, CYRILLIC, or CHINESE-HAN
  // {CHINESE-HAN: ['zh', 'zh-Hani]}
  const scriptsFound = {}
  languagesToDisplay.forEach((nameFormLang) => {
    let currentScript = scriptsFound[languageToScriptMap[nameFormLang]]
    // we have already seen this script before, we don't want two name-form fields with the same script type
    if (currentScript) {
      // check if the lang we want to delete has meaningful value because if it does we don't want delete it
      if (Object.values(values.nameTemplate?.[nameFormLang] ?? {}).some(Boolean)) {
        // delete the script found first, instead of 2nd duplicate script because it has meaningful data
        languagesToDisplay.delete(currentScript[0])
      } else {
        languagesToDisplay.delete(nameFormLang)
      }
    } else {
      currentScript = []
    }
    scriptsFound[languageToScriptMap[nameFormLang]] = [...currentScript, nameFormLang]
  })
  return {
    languagesToDisplay: Array.from(languagesToDisplay),
    languagesToMigrate,
  }
}

function forbiddenCharacterErrors(nameFormsToCheck) {
  // Current set of explicitly forbidden characters for name fields: \@#$%&*_+=|~/><[]{}();:0123456789
  // Note that the \ and ] characters need to be escaped
  // NOTE: Numbers are allowed in suffix fields, but exist as contemporary person first names--there will likely be a JIRA
  const forbiddenCharacterRegex = /[\\@#$%&*_+=|~/><[\]{}();:]/
  const forbiddenCharacterAndNumberRegex = /[\\@#$%&*_+=|~/><[\]{}();:0123456789]/
  const errors = {}

  Object.keys(nameFormsToCheck).forEach((lang) => {
    const nameForm = nameFormsToCheck[lang]

    Object.keys(nameForm).forEach((part) => {
      const regexToUse = part === fieldNames.suffix ? forbiddenCharacterRegex : forbiddenCharacterAndNumberRegex
      if (regexToUse.test(nameForm[part])) {
        errors[`${nameTemplateNamespace}.${lang}.${part}`] = {
          message: i18n.t('name-template.error.forbidden-character', {
            forbiddenChars: '\\@#$%&*_+=|~/><[]{}();:0123456789',
          }),
        }
      }
    })
  })

  return errors
}
