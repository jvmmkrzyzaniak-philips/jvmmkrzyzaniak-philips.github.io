import React, { useState } from 'react'
import { NoticeWarning } from '@fs/zion-icon'
import { Separator, Row, Button, Bleed, H2, Subheading } from '@fs/zion-ui'
import { useTranslation } from 'react-i18next'
import axios from '@fs/zion-axios'
import { StreamChat } from 'stream-chat'
import configureStreamClientAPIUsageThrottle from './chatStreamClientAPIUsageThrottle'
import reconnectImage from '../images/cant-connect.svg'
import { useChatDispatch } from '../providers/ChatStateProvider'
import { CHAT_ACTIONS } from '../hooks/useChatReducer'
import { queryChatUserChannels, queryUserUnreadChannels } from '../helpers/stream/streamChatHelper'
import chatLog, { LOG_LEVEL } from '../global/chatLog'
import useChatLog from '../hooks/useChatLog'
import { chatApiBase } from '../global/chatConfig'
import useChatFlags from '../hooks/useChatFlags'

async function loadUserChannels({ client, chatDispatch, chatUser, messagingChatQueryUnreadsIsOn }) {
  try {
    if (messagingChatQueryUnreadsIsOn) {
      const unreadChannels = await queryUserUnreadChannels({ client })
      chatDispatch({ type: CHAT_ACTIONS.SET_UNREAD_CHANNELS, unreadChannels })
    }
    const { channels, hasMoreChannels } = await queryChatUserChannels({
      client,
      restrictToManagedGroups: chatUser?.chatUserType === 'fs_managed_limited',
    })
    chatDispatch({ type: CHAT_ACTIONS.SET_CHANNELS, channels, hasMoreChannels })
  } catch (err) {
    chatLog({ msg: `Error querying user channel list ${err}`, level: LOG_LEVEL.ERROR })
  }
}

async function fsApiAuthenticate() {
  const url = `${chatApiBase}/auth/authenticate`
  const { data } = await axios.get(url, { params: { expireMinutes: 90, allowLimited: true } })
  const { apiKey, token, chatUser } = data
  return { apiKey, token, chatUser }
}

async function fsApiAuthenticateAnonymous() {
  const url = `${chatApiBase}/auth/anonymous`
  const { data } = await axios.get(url)
  return { apiKey: data.apiKey, chatUser: data.anonymousUser }
}

// Timeout should be long enough to support loading a reasonable number of chats on slow 3G
const STREAM_TIMEOUT_MS = 10 * 1000
const MAX_CONNECT_TIME = 60 * 1000

// Only used with embedded chat. No need to fetch channel list or worry about restricted users. All users can view chat anonymously.
export async function connectAnonymousChat({ chatDispatch }) {
  try {
    const { apiKey, chatUser } = await fsApiAuthenticateAnonymous()

    const chatClient = await StreamChat.getInstance(apiKey, { timeout: STREAM_TIMEOUT_MS })
    configureStreamClientAPIUsageThrottle(chatClient)
    await chatClient.connectAnonymousUser()
    chatDispatch({ type: CHAT_ACTIONS.CHAT_LOGIN, client: chatClient, chatUser })
  } catch (err) {
    chatLog({ msg: `Error connecting anonymous user: ${err}`, shouldReadChannels: true, level: LOG_LEVEL.ERROR })
    chatDispatch({ type: CHAT_ACTIONS.SET_CONNECT_ERROR })
  }
}

export async function connectChat({ chatDispatch, isEmbedded, messagingChatQueryUnreadsIsOn }) {
  const FS_MANAGED_LIMITED_CODE = '301'
  const LOCATION_RESTRICTED_CODE = '302'
  try {
    const { apiKey, chatUser, token: initialToken } = await fsApiAuthenticate()
    const firstTokenTimeStamp = Date.now()
    // Stream: This function always returns the same Client instance to avoid issues raised by multiple Client and WS connections
    const chatClient = StreamChat.getInstance(apiKey, { timeout: STREAM_TIMEOUT_MS })

    // If there's an existing anonymous connection, disconnect it first
    if (chatClient.anonymous) {
      chatDispatch({ type: CHAT_ACTIONS.LOGOUT, overrides: ['isEmbedded', 'currentCid', 'threadChannel'] })
      await chatClient.disconnectUser()
    }

    // If another overlay or embedded chat already started a connection, no need to reconnect
    if (!chatClient.wsConnection?.isHealthy) {
      configureStreamClientAPIUsageThrottle(chatClient)

      await chatClient.connectUser({ id: chatUser?.streamId }, async () => {
        if (firstTokenTimeStamp + MAX_CONNECT_TIME < Date.now()) {
          chatDispatch({ type: CHAT_ACTIONS.SET_AUTHENTICATING })
          // make a request to your own backend to get the token
          const { token } = await fsApiAuthenticate()
          return token
        }

        return initialToken
      })
    }
    chatDispatch({ type: CHAT_ACTIONS.CHAT_LOGIN, client: chatClient, chatUser })
    if (!isEmbedded) loadUserChannels({ client: chatClient, chatDispatch, chatUser, messagingChatQueryUnreadsIsOn })
  } catch (err) {
    chatLog({ msg: `Error connecting user: ${err}`, shouldReadChannels: true, level: LOG_LEVEL.ERROR })
    const errorCode = err.response?.headers?.warning ? err.response?.headers?.warning.split(' ')[0] : null
    if (errorCode === FS_MANAGED_LIMITED_CODE) {
      chatDispatch({ type: CHAT_ACTIONS.SET_MINOR_ACCESS_ERROR })
      return
    }
    if (errorCode === LOCATION_RESTRICTED_CODE) {
      chatDispatch({ type: CHAT_ACTIONS.SET_PERSONAL_DATA_ERROR })
      return
    }

    chatDispatch({ type: CHAT_ACTIONS.SET_CONNECT_ERROR })
  }
}

export default function ChatReconnectPage({ isEmbedded, onClick }) {
  const [t] = useTranslation()
  const chatDispatch = useChatDispatch()
  const { track } = useChatLog({ component: '[ChatReconnectPage]' })
  const [imageError, setImageError] = useState(false)
  const { messagingChatQueryUnreadsIsOn } = useChatFlags()

  const reconnectChat = () => {
    track({ link_name: `Chat:Reconnect Page:click reconnect` })
    connectChat({ chatDispatch, isEmbedded, messagingChatQueryUnreadsIsOn })
  }

  return (
    <div style={{ height: '100%', overflowY: 'auto' }}>
      <div style={{ padding: 20 }}>
        <Row alignX="center" gutters="none">
          <Bleed all>
            {imageError ? (
              <NoticeWarning size="lg" />
            ) : (
              <img
                alt={t('chat.reconnect-image.alt-text', 'Reconnect Image')}
                src={reconnectImage}
                onError={() => setImageError(true)}
              />
            )}
          </Bleed>
        </Row>
        <Separator size="md" />
        <Row alignX="center" gutters="none">
          <H2 centered size="H4">
            {t('chat.reconnect.heading', 'Well, this is unexpected...')}
            <Subheading>
              {t(
                'chat.reconnect.subheading',
                'We are unable to connect right now, or your session has expired. ' +
                  'Please click "Try Again", and if you still cannot connect then refresh the page. ' +
                  'If you still cannot connect then please try again in a few minutes.'
              )}
            </Subheading>
          </H2>
        </Row>
        <Row alignX="center" gutters="none">
          <Button onClick={onClick || reconnectChat}>{t('chat.try-again.message', 'Try Again')}</Button>
        </Row>
      </div>
    </div>
  )
}
