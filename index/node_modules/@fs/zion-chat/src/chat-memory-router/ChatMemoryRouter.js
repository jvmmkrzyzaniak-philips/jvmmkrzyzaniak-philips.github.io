import React, { useEffect, useState } from 'react'
import Cache from '@fs/zion-cache'
import { MemoryRouter, useHistory, useLocation } from '@fs/zion-router'
import { CHANNEL_TYPE } from '../services/fsChat/fsChannelEnums'
import { LOG_LEVEL } from '../global/chatLog'
import useChatLog from '../hooks/useChatLog'

export const CHAT_ROUTE_KEY = {
  BLOCKED: 'BLOCKED',
  CHATS: 'CHATS',
  HELPER: 'HELPER',
  HIDDEN: 'HIDDEN',
  CHAT: 'CHAT',
  CHAT_DETAILS: 'CHAT_DETAILS',
  CREATE_DIRECT_CHAT: 'CREATE_DIRECT_CHAT',
  CREATE_EMPTY_DIRECT_CHAT: 'CREATE_EMPTY_DIRECT_CHAT',
  CREATE_EMPTY_GROUP_CHAT: 'CREATE_EMPTY_GROUP_CHAT',
  CREATE_PUBLIC_CHAT: 'CREATE_PUBLIC_CHAT',
  CREATE_ROOTSTECH_CHAT: 'CREATE_ROOTSTECH_CHAT',
  CREATE_SESSION_CHAT: 'CREATE_SESSION_CHAT',
  CREATE_SUPPORT_CHAT: 'CREATE_SUPPORT_CHAT',
  CREATE_VENDOR_CHAT: 'CREATE_VENDOR_CHAT',
}

const CHAT_ROUTE = {
  BLOCKED: '/chat-blocked',
  CHATS: '/chat-window/chats',
  HELPER: '/chat-window/helper',
  HIDDEN: '/chat-hidden',
  CREATE_DIRECT_CHAT: `/chat-create/${CHANNEL_TYPE.FS_DIRECT}`,
  CREATE_EMPTY_DIRECT_CHAT: `/chat-create/empty-direct`,
  CREATE_EMPTY_GROUP_CHAT: `/chat-create/empty-group`,
  CREATE_PUBLIC_CHAT: `/chat-create/${CHANNEL_TYPE.FS_PUBLIC}`,
  CREATE_ROOTSTECH_CHAT: `/chat-create/${CHANNEL_TYPE.FS_ROOTSTECH}`,
  CREATE_SESSION_CHAT: `/chat-create/${CHANNEL_TYPE.FS_SESSION}`,
  CREATE_SUPPORT_CHAT: `/chat-create/${CHANNEL_TYPE.FS_SUPPORT}`,
  CREATE_VENDOR_CHAT: `/chat-create/${CHANNEL_TYPE.FS_VENDOR}`,
}

export function buildChatRoute(chatRouteKey, { cid, pid, mid } = {}) {
  switch (chatRouteKey) {
    case CHAT_ROUTE_KEY.BLOCKED:
      return CHAT_ROUTE.BLOCKED
    case CHAT_ROUTE_KEY.CHATS:
      return CHAT_ROUTE.CHATS
    case CHAT_ROUTE_KEY.HELPER:
      return CHAT_ROUTE.HELPER
    case CHAT_ROUTE_KEY.HIDDEN:
      return CHAT_ROUTE.HIDDEN
    case CHAT_ROUTE_KEY.CHAT: {
      if (!cid) {
        throw new Error('You must provide a valid channelId!')
      }
      const messageParam = mid ? `?messageId=${mid}` : ''
      if (pid) {
        return `/chat/${cid}/thread/${pid}${messageParam}`
      }
      return `/chat/${cid}${messageParam}`
    }
    case CHAT_ROUTE_KEY.CHAT_DETAILS:
      if (!cid) {
        throw new Error('You must provide a valid channelId!')
      }
      return `/chat/${cid}/details`
    case CHAT_ROUTE_KEY.CREATE_DIRECT_CHAT:
      return CHAT_ROUTE.CREATE_DIRECT_CHAT
    case CHAT_ROUTE_KEY.CREATE_EMPTY_DIRECT_CHAT:
      return CHAT_ROUTE.CREATE_EMPTY_DIRECT_CHAT
    case CHAT_ROUTE_KEY.CREATE_EMPTY_GROUP_CHAT:
      return CHAT_ROUTE.CREATE_EMPTY_GROUP_CHAT
    case CHAT_ROUTE_KEY.CREATE_PUBLIC_CHAT:
      return CHAT_ROUTE.CREATE_PUBLIC_CHAT
    case CHAT_ROUTE_KEY.CREATE_ROOTSTECH_CHAT:
      return CHAT_ROUTE.CREATE_ROOTSTECH_CHAT
    case CHAT_ROUTE_KEY.CREATE_SESSION_CHAT:
      return CHAT_ROUTE.CREATE_SESSION_CHAT
    case CHAT_ROUTE_KEY.CREATE_SUPPORT_CHAT:
      return CHAT_ROUTE.CREATE_SUPPORT_CHAT
    case CHAT_ROUTE_KEY.CREATE_VENDOR_CHAT:
      return CHAT_ROUTE.CREATE_VENDOR_CHAT
    default:
      throw new Error(`Unsupported chatRouteKey:${chatRouteKey}!`)
  }
}

export function useChatRoute({ chatRoute }) {
  const history = useHistory()
  useEffect(() => {
    if (chatRoute) {
      history.replace(chatRoute)
    }
  }, [chatRoute, history])
}

const cache = new Cache({ storeName: 'fsChatSync' })
const latestRouteKey = 'latest-route'
const loading = Symbol('initial-route-loading')
const useInitialRoute = () => {
  const { log } = useChatLog({ component: '[useInitialRoute]' })
  const [route, setRoute] = useState(loading)
  useEffect(() => {
    cache
      .getItem(latestRouteKey)
      .then((cachedRoute) => {
        setRoute(cachedRoute)
      })
      .catch((error) => {
        setRoute(undefined)
        log({ msg: `Failed to load cached initial chat route: ${error}`, level: LOG_LEVEL.ERROR })
      })
  }, [log])
  return route
}

const setInitialRoute = (path) => cache.setItem(latestRouteKey, path)
const useRecordInitialRoute = () => {
  const { pathname } = useLocation()
  useEffect(() => {
    if (pathname) {
      setInitialRoute(pathname)
    }
  }, [pathname])
}

const InternalChatRouter = ({ chatRoute, children }) => {
  useRecordInitialRoute()
  useChatRoute({ chatRoute })
  return children
}

export default function ChatMemoryRouter({ chatRoute, children }) {
  const internalInitialRoute = useInitialRoute()
  const targetRoute = chatRoute || internalInitialRoute

  if (targetRoute === loading) {
    return null
  }
  // Only provide initial entry if targetRoute is truthy (it can be either null or undefined from the cache)
  if (targetRoute) {
    return (
      <MemoryRouter initialEntries={[targetRoute]} initialIndex={0}>
        <InternalChatRouter chatRoute={chatRoute}>{children}</InternalChatRouter>
      </MemoryRouter>
    )
  }

  return (
    <MemoryRouter>
      <InternalChatRouter chatRoute={chatRoute}>{children}</InternalChatRouter>
    </MemoryRouter>
  )
}
