import { i18n } from '@fs/zion-locale'
import { CHANNEL_CATEGORY_MAP, CHANNEL_TYPE, RESTRICTED_CATEGORY_MAP } from '../../services/fsChat/fsChannelEnums'
import { isDirectChannel, isThreadChannel } from '../../services/fsChat/fsChatService'
import { removeIllegalProfileNameCharacters } from '../../services/userProfile/userProfileService'

export const CHAT_MESSAGE_TYPE = {
  DELETED: 'deleted',
  REGULAR: 'regular',
  SYSTEM: 'system',
}

export const FS_CHAT_SYSTEM_MESSAGE_TYPE = {
  JOINED_CHAT: 'JOINED_CHAT',
  LEFT_CHAT: 'LEFT_CHAT',
  INVITED_TO_CHAT: 'INVITED_TO_CHAT',
}

export const SYSTEM_USER_IDS = ['family_search_message-sender', 'FamilySearch_System_Message-Sender']

export const isInCisIdFormat = (cisId) => {
  const cisIdPieces = cisId.split('.')
  return cisIdPieces.length === 3
}

// 'cis.user.MMMM-JML1' => 'cis_user_mmmm-jml1
export const chatUserIdFromCisId = (cisId) => {
  if (!cisId) {
    throw Error('cisId must be truthy')
  }

  if (!isInCisIdFormat(cisId)) {
    throw Error(`cisId ${cisId} not in correct format of "cis.usertype.XXXX-XXXX"`)
  }
  return cisId.replace(/\./g, '_').toLowerCase()
}

export const isInUserIdFormat = (streamUserId) => {
  const cisIdPieces = streamUserId.split('_')
  return cisIdPieces.length === 3
}

export const isOrphanedThread = (channels, channel) => {
  if (channel.type === CHANNEL_TYPE.FS_THREAD) {
    const parentChannel = channels.find((c) => c.cid === channel?.data?.fs_parent_channel_cid)
    const isOrphaned = !parentChannel
    if (isOrphaned && channel?.state?.unread_count > 0) {
      channel.markRead()
    }
    return isOrphaned
  }
  return false
}

export const isRestrictedForUser = (channel, restrictToManagedGroups) => {
  if (restrictToManagedGroups) {
    if (channel?.type === 'fs_managed') return false
    if (channel?.type === 'fs_thread' && channel?.data?.fs_parent_channel_cid.includes('fs_managed')) return false
    return true
  }
  return false
}

export const cisIdFromChatUserId = (userId) => {
  if (!userId) {
    throw Error('userId must be truthy')
  }

  if (!isInUserIdFormat(userId)) {
    throw Error('userId must be in the format of "cis_usertype_xxxx-xxxx"')
  }

  const [cis, userType, id] = userId.split('_')
  return `${cis}.${userType}.${id.toUpperCase()}`
}

export function getChannelMembers({ channel, excludeUserId }) {
  const channelMembers = Object.values(channel?.state?.members || {}) || []
  const nonSystemChannelMembers = channelMembers.filter((member) => !SYSTEM_USER_IDS.includes(member?.user?.id))
  if (excludeUserId && channelMembers.length > 1) {
    return nonSystemChannelMembers.filter((member) => member?.user?.id !== excludeUserId)
  }
  return nonSystemChannelMembers
}

export async function findExistingChat(channels, client, cid) {
  let channel = channels.find((chat) => {
    return chat.cid === cid
  })

  if ((!channel || channel.disconnected) && client && cid) {
    const results = await client.queryChannels({ cid: { $eq: cid } })
    channel = results[0]
  }
  return channel
}

function cisIdMatchesChannelMember({ member, cisId }) {
  const memberCisId = member?.user.fs_cis_id
  return Boolean(cisId) && memberCisId === cisId
}

function cisIdsMatchChannel({ channel, cisIds }) {
  const channelMembers = getChannelMembers({ channel })
  const channelMemberLengthMatches = channelMembers?.length === cisIds?.length
  return (
    channelMemberLengthMatches &&
    cisIds.every((cisId) => Boolean(channelMembers.find((member) => cisIdMatchesChannelMember({ member, cisId }))))
  )
}

export const findMatchingDirectChannel = ({ channels, cisIds }) => {
  const directChannels = channels.filter((channel) => channel.type === CHANNEL_TYPE.FS_DIRECT)
  return directChannels.find((channel) => cisIdsMatchChannel({ channel, cisIds }))
}

function getDirectChannelName(channel, excludeUserId) {
  const memberNames = getChannelMembers({ channel, excludeUserId })
    .map((p) => p?.user?.name)
    ?.sort()
  if (memberNames?.length) {
    return memberNames.join(', ')
  }
  return i18n.t('chat.unknown-name.label', 'Unknown Name')
}

export function getChannelName({ channel, excludeUserId }) {
  if (channel?.type === CHANNEL_TYPE.FS_DIRECT) {
    return getDirectChannelName(channel, excludeUserId)
  }

  const name = channel?.data?.name
  if (name) {
    return name
  }

  if (channel) {
    return i18n.t('chat.unknown-name.label', 'Unknown Name')
  }
  return undefined
}

export function getChannelDescription(channel) {
  const description = channel?.data?.description
  if (description) {
    return description
  }
  return ''
}

export const maxRecentContactsInProfileSearch = 50

export const hasPendingInvite = ({ channel, userId }) => {
  const user = channel?.state?.members ? channel?.state?.members[userId] : null
  return !!user?.invited && !user?.invite_accepted_at && !user?.invite_rejected_at
}

export const hasAcceptedInvite = ({ channel, userId }) => {
  const user = channel?.state?.members ? channel?.state?.members[userId] : null
  return !!user?.invited && !!user?.invite_accepted_at
}

export const isChannelOwner = ({ channel, userId }) => {
  return channel?.data?.fs_created_by_stream_id === userId
}

export const isChannelMember = ({ channel, userId }) => {
  const channelMembers = getChannelMembers({ channel })
  return !!channelMembers.find((cm) => cm?.user?.id === userId)
}

export const canJoinChannel = ({ channel, userId }) => {
  const canJoin = (channel?.data?.own_capabilities || []).includes('join-channel')
  return isChannelOwner({ channel, userId }) || canJoin
}

export const upperCaseCisId = (cisId) => {
  if (cisId === 'CURRENT') {
    return cisId
  }
  const idParts = cisId?.split('.')
  return `${idParts[0]}.${idParts[1]}.${idParts[2]?.toUpperCase()}`
}

export const updateChannelInChannels = (channels, channel, shouldAddIfNotFound = true) => {
  if (channel?.cid) {
    const cid = channel?.cid
    const foundChannel = channels.find((c) => c.cid === cid)
    if (!foundChannel && shouldAddIfNotFound) {
      return [channel, ...channels]
    }
  }
  return channels
}

export const removeChannelFromChannels = (channels, channel) => {
  if (channel?.cid) {
    const cid = channel?.cid
    const foundChannel = channels.find((c) => c.cid === cid)
    if (foundChannel) {
      const set = new Set(channels)
      set.delete(foundChannel)
      return [...set]
    }
  }
  return [...channels]
}

export const QUERY_CHANNELS_PAGE_SIZE = 20

export async function queryUserUnreadChannels({ client }) {
  return client.queryChannels(
    {
      has_unread: true,
      members: { $in: [client.userID] },
    },
    [
      {
        last_message_at: -1,
      },
    ],
    {
      watch: true,
      state: true,
      limit: QUERY_CHANNELS_PAGE_SIZE,
    }
  )
}

export async function queryPageOfChannelsByType({ client, types, offset = 0, hidden = false }) {
  const filter = {
    type: { $in: types },
    members: { $in: [client.userID] },
    hidden,
  }
  const sort = [{ last_message_at: -1 }]

  return client?.queryChannels(filter, sort, {
    watch: true, // this is the default
    state: true,
    limit: QUERY_CHANNELS_PAGE_SIZE,
    offset,
  })
}

export async function queryChatUserChannels({ client, restrictToManagedGroups }) {
  // Though it would slightly improve performance to make all of these requests at once, we are making them separately
  // because Stream does not provide operators to limit the number of results returned per type.
  const chatChannelGroups = await Promise.all(
    Object.values(restrictToManagedGroups ? RESTRICTED_CATEGORY_MAP : CHANNEL_CATEGORY_MAP).map(({ types }) => {
      return queryPageOfChannelsByType({ client, types })
    })
  )

  return chatChannelGroups.reduce(
    (previousValue, currentValueChannels) => {
      const { channels, hasMoreChannels } = previousValue
      if (currentValueChannels?.length > 0) {
        const channelCategory = getChannelCategoryKeyForChannel(currentValueChannels[0])
        hasMoreChannels[channelCategory] = currentValueChannels.length >= QUERY_CHANNELS_PAGE_SIZE
        return { channels: [...channels, ...currentValueChannels], hasMoreChannels }
      }
      return previousValue
    },
    { channels: [], hasMoreChannels: {} }
  )
}

function getChannelCategoryKeyForChannel(channel) {
  return Object.values(CHANNEL_CATEGORY_MAP).find(({ types }) => types.includes(channel.type))?.key
}

export async function queryChannelsByType({ client, type, offset = 0 }) {
  const filter = {
    type: { $eq: type },
    // Explicitly filter these out to work around a known Stream issue that otherwise returns partial pages (CCR-361)
    hidden: false,
    disabled: false,
  }
  const sort = [{ name: 1, last_message_at: -1 }]
  return client.queryChannels(filter, sort, {
    watch: false,
    state: true,
    limit: QUERY_CHANNELS_PAGE_SIZE,
    offset,
  })
}

export const deleteMessage = async ({ client, messageId }) => {
  await client.deleteMessage(messageId, true)
}

export const getChildThreadChannels = ({ channel, channels }) => {
  return channels?.filter((c) => c?.data?.fs_parent_channel_cid === channel?.cid) || []
}

export const getChannelUnreadCount = ({ channel, unreadChannelMap = {}, includeChildren = true }) => {
  const channels = Object.values(unreadChannelMap)
  const isParentChannelOfUnreadThreadChannel =
    includeChildren &&
    channels.some((c) => {
      return c?.data?.fs_parent_channel_cid === channel?.cid
    })
  return unreadChannelMap[channel?.cid] || isParentChannelOfUnreadThreadChannel || 0
}

export const getUnreadChatsTotalCount = ({ channels, unreadChannelMap }) => {
  const channelsUnreadCountReducer = (unreadCount, channel) => {
    const channelUnread = !!getChannelUnreadCount({ channel, unreadChannelMap, includeChildren: false })
    if (channelUnread) {
      return unreadCount + 1
    }
    return unreadCount
  }

  return channels?.reduce(channelsUnreadCountReducer, 0) ?? 0
}

export const getUnreadChatsListItemsCount = ({ channels, unreadChannelMap }) => {
  const channelsUnreadCountReducer = (unreadCount, channel) => {
    const channelUnread = !!getChannelUnreadCount({ channel, unreadChannelMap })
    if (channelUnread) {
      return unreadCount + 1
    }
    return unreadCount
  }

  return channels?.reduce(channelsUnreadCountReducer, 0) ?? 0
}

export const canDisplayGroupDetails = (channel) => {
  return Boolean(channel?.cid)
}

export const canReportAbuse = (channel) => {
  return Boolean(channel?.cid)
}

export const canLeaveChat = ({ channel, userId }) => {
  return (
    Boolean(channel) &&
    channel.type !== CHANNEL_TYPE.FS_DIRECT &&
    !isChannelOwner({ channel, userId }) &&
    channel?.data?.own_capabilities?.includes('leave-channel')
  )
}

export const canHideChannel = (channel) => {
  return Boolean(channel) && isDirectChannel(channel)
}

export const canMuteChannel = (channel) => {
  return Boolean(channel) && channel?.data?.own_capabilities?.includes('mute-channel')
}

export const getRecentChannelMessages = async (channel, count = 5) => {
  const messagesQuery = await channel.query({ messages: { limit: count } })
  return messagesQuery.messages
    .map(
      (message) =>
        `ID ${message.id}, ${new Date(message.created_at).toUTCString()} ${message.user?.name}: ${message.text}`
    )
    .join('\n')
}

export const filterChannels = (chats, searchValue) => {
  const chatFilter = (r) => {
    const name = getChannelName({ channel: r }).toLowerCase()
    const description = (r?.data?.description || '').toLowerCase()
    const title = (r?.data?.title || '').toLowerCase()
    const searchTerm = removeIllegalProfileNameCharacters(searchValue || '').toLowerCase()
    return searchValue && (name.includes(searchTerm) || description.includes(searchTerm) || title.includes(searchTerm))
  }
  return searchValue ? (chats || []).filter((r) => chatFilter(r)) : chats || []
}

export const isChannelMuted = (channel) => Boolean(channel?.muteStatus?.()?.muted)

export const isUserBlocked = ({ userId, client }) => client?.mutedUsers?.some((mute) => mute.target.id === userId)

export const isChannelBlocked = ({ channel, client }) => {
  const otherMembers = getChannelMembers({ channel, excludeUserId: client?.userID })
  return (
    (isDirectChannel(channel) || isThreadChannel(channel)) &&
    otherMembers.every((member) => isUserBlocked({ userId: member.user_id, client }))
  )
}

export const isChannelRedacted = (channel) => Boolean(channel?.data?.fs_redacted || channel?.fs_redacted)

export const cidMatchesChannel = ({ cid, channel }) => {
  return Boolean(cid && channel?.cid && cid.toLowerCase() === channel.cid?.toLowerCase())
}

export const updateMessageText = async ({ client, messageId, text }) => {
  return client.partialUpdateMessage(messageId, { set: { text } })
}

// This is our custom implementation of deleting for the parent message of a thread. Instead of deleting it, we just change the text, and set the fs_message_deleted flag
export const deleteThreadParentMessage = ({ client, messageId }) => {
  return client.partialUpdateMessage(messageId, { set: { text: '', fs_message_deleted: true } })
}

// The reaction type can only contain alphanumeric, underscore, dash and dot characters
// Convert the emoji into a suitable format with the constituent code points: 'ðŸ¤·â€â™€ï¸' to '1f937-200d-2640-fe0f'
// See https://unicode.org/emoji/charts/full-emoji-list.html#1f937_200d_2640_fe0f
export const emojiToStreamReactionType = (emoji) => {
  return Array.from(emoji)
    .map((codePoint) => codePoint.codePointAt(0).toString(16))
    .join('-')
}

// Modified from https://github.com/ealush/emoji-picker-react/blob/master/src/dataUtils/parseNativeEmoji.ts
export const streamReactionTypeToEmoji = (reactionType) => {
  return reactionType
    .split('-')
    .map((hex) => String.fromCodePoint(parseInt(hex, 16)))
    .join('')
}

export const toggleMessageReaction = async ({ channel, reactionType, message }) => {
  const isOwnReaction = message.own_reactions?.some((ownReaction) => ownReaction.type === reactionType)
  if (isOwnReaction) {
    return channel.deleteReaction(message.id, reactionType)
  }
  return channel.sendReaction(message.id, { type: reactionType })
}

export function getMessageText({ message, t, isTranslated, fromUser, messagingChatOnDemandTranslationsIsOn }) {
  if (message?.fs_message_deleted || message?.type === CHAT_MESSAGE_TYPE.DELETED) {
    return t('chat.message-was-deleted.message', 'This message was deleted.')
  }
  if (message?.type === CHAT_MESSAGE_TYPE.SYSTEM) {
    switch (message?.fs_type?.type) {
      case FS_CHAT_SYSTEM_MESSAGE_TYPE.LEFT_CHAT:
        return t('chat.user-left-channel.message', '{userName} left the chat.', {
          userName: message?.fs_type?.name,
        })
      case FS_CHAT_SYSTEM_MESSAGE_TYPE.JOINED_CHAT:
        return t('chat.user-accepted-invite.message', '{userName} joined the chat.', {
          userName: message?.fs_type?.name,
        })
      case FS_CHAT_SYSTEM_MESSAGE_TYPE.INVITED_TO_CHAT:
        return t('chat.user-invited.message', '{invitee} was invited to the chat by {inviter}.', {
          invitee: message?.fs_type?.invitee,
          inviter: message?.fs_type?.inviter,
        })
      default:
        break
    }
  }

  // We want to always show the original text for the patron's own messages
  // because the translation toggle will be hidden, so there would be no way
  // to swap back to the original text
  if (fromUser) return message?.text
  if (messagingChatOnDemandTranslationsIsOn && isTranslated) return message?.i18n?.[`${i18n.language}_text`]
  return message?.text
}

// FamilySearch messages sent in a Helper Connect chat
export function getIsSystemUser(user) {
  return SYSTEM_USER_IDS.includes(user?.id)
}

// invite, leave, and join messages
export function getIsSystemMessage(message) {
  return message?.type === CHAT_MESSAGE_TYPE.SYSTEM
}
