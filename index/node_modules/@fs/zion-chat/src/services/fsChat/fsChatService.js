import axios from '@fs/zion-axios'
import { i18n } from '@fs/zion-locale'
import { trackEvent } from '@fs/zion-analytics'
import { getChannelDescription, getChannelMembers, getChannelName } from '../../helpers/stream/streamChatHelper'
import { CHANNEL_TYPE, FS_DIRECT_MAX_PARTICIPANT_COUNT } from './fsChannelEnums'
import { chatApiBase } from '../../global/chatConfig'
import { buildChatRoute, CHAT_ROUTE_KEY } from '../../chat-memory-router/ChatMemoryRouter'

/**
 * https://beta.familysearch.org/service/fs-chat/api/resource_ChannelEndpointsV2.html
 * https://icseng.atlassian.net/wiki/spaces/~thorntonjn/pages/121669060/FS+Chat+-+Stream+Chat+Diagrams
 * https://icseng.atlassian.net/wiki/spaces/Product/pages/133628012/FS-Chat+Channel+Types
 */

export const isDirectChannel = (channel) => {
  return channel?.type === CHANNEL_TYPE.FS_DIRECT
}

export const isHelperConnectChannel = (channel) => {
  return channel?.type === CHANNEL_TYPE.FS_HELPER_CONNECT
}

export const isManagedChannel = (channel) => {
  return channel?.type === CHANNEL_TYPE.FS_MANAGED
}

export const isPublicChannel = (channel) => {
  return channel?.type === CHANNEL_TYPE.FS_PUBLIC
}

export const isSupportChannel = (channel) => {
  return channel?.type === CHANNEL_TYPE.FS_SUPPORT
}

export const isThreadChannel = (channel) => {
  // Don't treat it like a thread if there are no replies
  return channel?.type === CHANNEL_TYPE.FS_THREAD && channel?.state?.messageSets[0].messages.length > 0
}

export const isVendorChannel = (channel) => {
  return channel?.type === CHANNEL_TYPE.FS_VENDOR
}

export const isSessionChannel = (channel) => {
  return channel?.type === CHANNEL_TYPE.FS_SESSION
}

export const isRootsTechChannel = (channel) => {
  return channel?.type === CHANNEL_TYPE.FS_ROOTSTECH
}

export const isEventsChannel = (channel) => {
  return (
    isSessionChannel(channel) ||
    isRootsTechChannel(channel) ||
    isSupportChannel(channel) ||
    isPublicChannel(channel) ||
    isVendorChannel(channel)
  )
}
export function isGroupChannel({ channel, excludeUserId }) {
  return (
    isPublicChannel(channel) ||
    isManagedChannel(channel) ||
    (isDirectChannel(channel) && getChannelMembers({ channel, excludeUserId }).length > 1) ||
    isSupportChannel(channel) ||
    isVendorChannel(channel) ||
    isRootsTechChannel(channel) ||
    isSessionChannel(channel) ||
    isHelperConnectChannel(channel)
  )
}

export function isPubliclyViewableChannel(channel) {
  return (
    isSessionChannel(channel) || isRootsTechChannel(channel) || isPublicChannel(channel) || isVendorChannel(channel)
  )
}

export const isFamilySearchGroup = (channel) => {
  return isManagedChannel(channel)
}

export const addMembers = async ({ cid, cisIds }) => {
  const channelMembersDto = {
    cisIdsToAdd: cisIds,
  }

  const response = await axios.post(`${chatApiBase}/channels/${cid}/members`, channelMembersDto)
  return response.data
}

async function createChannel({ channelParameters: inChannelParameters = {}, createOrGet = false }) {
  const params = createOrGet ? `?createOrGet=true` : ''
  const channelParameters = {
    ...inChannelParameters,
    tags: [...(inChannelParameters.tags || [])],
  }
  trackEvent({
    event_name: 'click_action',
    link_name: `Chat:Create Channel:${channelParameters.type}`,
  })

  const response = await axios.post(`${chatApiBase}/channels${params}`, channelParameters)
  return response.data
}

export async function createSupportChannel({ name, description = '', tags, image, createOrGet, language }) {
  if (!name) {
    throw Error('A support chat requires a unique name!')
  }
  const channelParameters = {
    type: CHANNEL_TYPE.FS_SUPPORT,
    tags: [...(tags || []), { name: 'fs_support_language', value: language }],
    name,
    description,
    image,
  }
  return createChannel({ channelParameters, createOrGet })
}

export async function createVendorChannel({
  name,
  externalId,
  eventLabel,
  description = '',
  tags = [],
  image,
  createOrGet = true,
}) {
  if (!name || !externalId || !eventLabel) {
    throw Error('A vendor chat requires an eventId and an externalId!')
  }
  const channelParameters = {
    name,
    type: CHANNEL_TYPE.FS_VENDOR,
    tags: [{ name: 'fs_event_label', value: eventLabel }, { name: 'fs_external_id', value: externalId }, ...tags],
    description,
    image,
  }
  return createChannel({ channelParameters, createOrGet })
}

export async function createDirectChannel({ cisIds, tags = [], createOrGet = true }) {
  if (!cisIds || cisIds.length > FS_DIRECT_MAX_PARTICIPANT_COUNT) {
    throw Error(`createDirectChannel requires 2 to ${FS_DIRECT_MAX_PARTICIPANT_COUNT} cisIds!`)
  }
  const channelParameters = {
    type: CHANNEL_TYPE.FS_DIRECT,
    tags,
    cisIds: cisIds.filter((value, index, ids) => ids.indexOf(value) === index),
    discoverable: false,
  }
  return createChannel({ channelParameters, createOrGet })
}

export async function createDirectStreamChannel({ cisIds, client }) {
  const { cid } = await createDirectChannel({ cisIds })
  const filter = {
    $or: [{ cid: { $eq: cid } }, { cid: { $eq: cid }, hidden: true }],
  }
  const [channel] = await client.queryChannels(filter)
  if (!channel) {
    throw Error(`unable to query for chat after create! ${cid}`)
  }

  if (channel.data?.hidden) {
    await channel.show()
  }

  if (channel.muteStatus && channel.muteStatus?.()?.muted) {
    await channel.unmute()
  }

  return channel
}

export async function createPublicChannel({ name, description = '', tags = [], cisIds = [], createOrGet }) {
  if (!name) {
    throw Error('A public chat requires a unique name!')
  }
  const channelParameters = { type: CHANNEL_TYPE.FS_PUBLIC, tags, name, description, cisIds }
  return createChannel({ channelParameters, createOrGet })
}

export async function createRootsTechSessionChannel({ name, description, createOrGet = true, externalId, eventLabel }) {
  if (!name) {
    throw Error('A rootsTechSession channel requires a name!')
  }
  const tags = []
  if (eventLabel) {
    tags.push({ name: 'fs_event_label', value: eventLabel })
  }
  if (externalId) {
    tags.push({ name: 'fs_external_id', value: externalId })
  }
  return createChannel({
    channelParameters: { type: CHANNEL_TYPE.FS_SESSION, name, description, tags },
    createOrGet,
  })
}

export async function createRootsTechTopicChannel({ name, cisIds, description }) {
  return createChannel({ channelParameters: { type: CHANNEL_TYPE.FS_ROOTSTECH, name, description, cisIds } })
}

export async function createAUAChannel({ name, cisIds, createOrGet = true, language }) {
  return createSupportChannel({
    name,
    cisIds,
    createOrGet,
    language,
  })
}

export async function createThreadChannel({ parentChannelCid, parentMessageId, tags = [], createOrGet = true }) {
  if (!parentChannelCid || !parentMessageId) {
    throw Error('createThreadChannel requires parentChannelId and parentMessageId!')
  }
  const channelParameters = {
    type: CHANNEL_TYPE.FS_THREAD,
    tags: [
      { name: 'fs_parent_channel_cid', value: parentChannelCid },
      { name: 'fs_parent_message_id', value: parentMessageId },
      ...tags,
    ],
    discoverable: false,
  }
  return createChannel({ channelParameters, createOrGet })
}

export async function createStreamThreadChannel({ parentChannelCid, parentMessageId, client }) {
  const { cid } = await createThreadChannel({ parentChannelCid, parentMessageId })
  const filter = {
    $or: [{ cid: { $eq: cid } }, { cid: { $eq: cid }, hidden: true }],
  }
  const [threadChannel] = await client.queryChannels(filter)
  return threadChannel
}

export const getChatGroupParticipantCountDescription = (channel) => {
  const participantCount = channel?.data?.member_count ?? 0
  let participantCountMessage = null

  // NOTE: would rather show nothing than 0 Participants
  if (participantCount !== 0) {
    participantCountMessage = i18n.t(
      'chat.participants-count.label',
      '{count, plural, =0 {No participants} one {# Participant} other {# Participants}}',
      { count: participantCount }
    )
  }

  return { participantCountMessage, count: participantCount }
}

export const getChannelInfo = (channel, excludeUserId) => {
  if (channel) {
    return (
      `Chat Name: ${getChannelName({ channel, excludeUserId })}\n` +
      `Chat Description: ${getChannelDescription(channel)}\n` +
      `type: ${channel?.type}\n` +
      `cid: ${channel?.cid}`
    )
  }
  return 'Unable to retrieve chat information'
}

export const isChannelNameValidRegex = /^[^{}[\]<>:@]{1,100}$/

export function removeIllegalChannelNameCharacters(str = '') {
  return str.replace(/[@:<>{}[\]]/gi, '').trim()
}

export function showJoinLeaveTypingForChannel({ channel, chatFlags }) {
  // Always hide for these types
  if (isSessionChannel(channel) || isRootsTechChannel(channel)) return false
  // Always show for these types
  if (isDirectChannel(channel) || isVendorChannel(channel) || isSupportChannel(channel)) return true
  // Otherwise, show based on the flag
  return chatFlags?.messagingChatJoinLeaveTypingForAllIsOn
}

// Returns true if the user is allowed to chat with the given users
// Will return false if the calling user or any of the users in the list are restricted
export async function getUsersCanChat({ chatRoute, supportChatInformation }) {
  const users = []
  const restrictedRoutes = [
    buildChatRoute(CHAT_ROUTE_KEY.CREATE_DIRECT_CHAT),
    buildChatRoute(CHAT_ROUTE_KEY.CREATE_VENDOR_CHAT),
    buildChatRoute(CHAT_ROUTE_KEY.CREATE_SUPPORT_CHAT),
    buildChatRoute(CHAT_ROUTE_KEY.CREATE_SESSION_CHAT),
    buildChatRoute(CHAT_ROUTE_KEY.CREATE_PUBLIC_CHAT),
    buildChatRoute(CHAT_ROUTE_KEY.CREATE_ROOTSTECH_CHAT),
    buildChatRoute(CHAT_ROUTE_KEY.CREATE_EMPTY_DIRECT_CHAT),
    buildChatRoute(CHAT_ROUTE_KEY.CREATE_EMPTY_GROUP_CHAT),
  ]
  if (!restrictedRoutes.includes(chatRoute)) {
    return true
  }
  if (chatRoute === buildChatRoute(CHAT_ROUTE_KEY.CREATE_DIRECT_CHAT)) {
    if (supportChatInformation?.to?.some((user) => user === undefined)) {
      // If the user is undefined, wait to call the approval endpoint until the data is available
      return false
    }
    users.push(...(supportChatInformation?.to || []))
  }
  // If this endpoint is called with an empty array, it will only check if the calling user is restricted
  try {
    await axios.post(`${chatApiBase}/approval/channels/membership`, { cisIds: users })
  } catch (error) {
    if (error.response?.status === 403) {
      return false
    }
  }
  return true
}

export async function getIsChannelMember({ channelType, supportInformation }) {
  if (channelType === CHANNEL_TYPE.FS_SESSION) {
    try {
      const tags = []
      if (supportInformation?.eventLabel) {
        tags.push({ name: 'fs_event_label', value: supportInformation?.eventLabel })
      }
      if (supportInformation?.externalId) {
        tags.push({ name: 'fs_external_id', value: supportInformation?.externalId })
      }
      const response = await axios.post(`${chatApiBase}/channels/membershipstatus`, {
        type: CHANNEL_TYPE.FS_SESSION,
        name: supportInformation?.name,
        description: supportInformation?.description,
        tags,
      })
      return response?.data?.member
    } catch (e) {
      return false
    }
  }
  throw new Error(`Unexpected type ${channelType} not handled in getIsChannelMember`)
}
