import { useEvent } from '@fs/zion-frontend-friends'
import { useEffect, useRef } from 'react'
import { connectChat } from '../chat-reconnect/ChatReconnectPage'
import useChatFlags from './useChatFlags'
import { CHAT_ACTIONS } from './useChatReducer'
import useVisibilityChange from './utils/useVisibilityChange'
import { updateChannelInChannels, removeChannelFromChannels } from '../helpers/stream/streamChatHelper'
import useChatLog from './useChatLog'
import { LOG_LEVEL } from '../global/chatLog'
// The purpose of this hook is to manage the websocket connection for the chat. It will disconnect the user if they switch tabs and another tab is visible.
// The most recently active tab will remain open so the user can still get notifications
const useChatWebsocketManager = (chatState, chatDispatch) => {
  const { client, isEmbedded, currentCid, channels, threadChannel } = chatState
  const { log } = useChatLog({ component: '[useChatWebsocketManager]' })

  const {
    messagingChatDisconnectInactiveWebsocketsIsOn,
    messagingChatDisconnectInactiveWebsocketsTimeout,
    messagingChatQueryUnreadsIsOn,
  } = useChatFlags()
  const timeoutSeconds = messagingChatDisconnectInactiveWebsocketsTimeout?.timeoutSeconds ?? 5

  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox')
  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)

  /* If BroadcastChannel is not supported, disable this feature
  NOTE: Firefox and Safari technically support BroadcastChannel, however, these two browsers have efficiency measures in place
  that slow down code execution for background tabs (especially Firefox). This whole feature depends on code executing in tabs that are in the 
  background, so it will be disabled for these browsers. Chromium-based browsers haven't shown notable problems.
  We should do more research into this and determine if there is a better solution to support all browsers. */

  const broadCastChannelEnabled =
    typeof BroadcastChannel !== 'undefined' && messagingChatDisconnectInactiveWebsocketsIsOn && !isFirefox && !isSafari

  const broadCastChannel = useRef(broadCastChannelEnabled ? new BroadcastChannel('fs-chat-activity') : {})

  // This is an array because it is possible that a tab could have two instances of chat open, both of which would send the disconnect broadcasts
  const disconnectTimeoutId = useRef(null)

  // Broadcast the visible state to other tabs when chat first loads
  useEffect(() => {
    if (broadCastChannelEnabled && Document.visibilityState === 'visible') {
      broadCastChannel.current.postMessage?.('visible')
    }
  }, [broadCastChannelEnabled])

  const requeryChannel = useEvent((cid) => {
    try {
      client.queryChannels({ cid: { $eq: cid } }).then((results) => {
        const newChannel = results[0]
        newChannel.couldBeStale = true
        const channelsMinusStaleChannel = removeChannelFromChannels(channels, newChannel)
        const updatedChannels = updateChannelInChannels(channelsMinusStaleChannel, newChannel)
        chatDispatch({ type: CHAT_ACTIONS.SET_CHANNELS, channels: updatedChannels })
      })
    } catch (err) {
      log({ error: `Error requerying channel after connecting chat in a new tab: ${err}`, level: LOG_LEVEL.ERROR })
    }
  })

  useVisibilityChange(
    useEvent((visibilityState) => {
      if (broadCastChannelEnabled && visibilityState === 'visible') {
        clearTimeout(disconnectTimeoutId.current)

        disconnectTimeoutId.current = null
        broadCastChannel.current.postMessage?.('visible')
        if (client) {
          if (client?.wsConnection?.isDisconnected) {
            client.openConnection().catch((err) => {
              log({ error: `Error reopening websocket connection: ${err}`, level: LOG_LEVEL.ERROR })
              chatDispatch({ type: CHAT_ACTIONS.SET_CONNECT_ERROR })
            })
            // If we are open to a channel, requery it when connecting so it can have the latest data.
            if (currentCid) {
              requeryChannel(currentCid)
            }
            if (threadChannel) {
              requeryChannel(threadChannel.cid)
            }
          }
        } else {
          connectChat({ chatDispatch, isEmbedded, messagingChatQueryUnreadsIsOn })
        }
      }
    })
  )

  const disconnectHiddenChat = useEvent(() => {
    // Clear any existing timeouts before setting a new one
    if (disconnectTimeoutId.current) clearTimeout(disconnectTimeoutId.current)
    // The timeout is to prevent the user from needing to reconnect if they only switch tabs for a short time
    const newTimeoutId = setTimeout(() => {
      client?.closeConnection()
    }, timeoutSeconds * 1000)
    disconnectTimeoutId.current = newTimeoutId
  })

  useEffect(() => {
    // If another browser tab becomes visible, it will broadcast a message to tell the other tabs it has become visible. See https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API
    // When we get that message, if this tab is hidden, disconnect, so that there will only be one websocket open at a time.
    broadCastChannel.current.onmessage = (e) => {
      if (!broadCastChannelEnabled) return
      if (document.visibilityState === 'hidden' && e.data === 'visible') {
        disconnectHiddenChat()
      }
    }
  }, [disconnectHiddenChat, broadCastChannelEnabled])

  // cleanup timeoutId array when component unmounts
  useEffect(() => {
    return () => {
      clearTimeout(disconnectTimeoutId.current)
    }
  })
}

export default useChatWebsocketManager
