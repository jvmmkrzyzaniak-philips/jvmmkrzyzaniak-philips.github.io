import { useReducer } from 'react'
import { i18n } from '@fs/zion-locale'
import {
  isUserBlocked,
  removeChannelFromChannels,
  isOrphanedThread,
  isRestrictedForUser,
} from '../helpers/stream/streamChatHelper'
import chatLog, { LOG_LEVEL } from '../global/chatLog'
import { isDocumentFocused } from './usePageVisibility'
import { CHANNEL_TYPE } from '../services/fsChat/fsChannelEnums'

const DEFAULT_STATE = {
  isEmbedded: false,
  client: null,
  // This seems to be used to track when a channel state needs to be updated in the useEffect in chatStateProvideHooks -> useUpdateCurrentChannel
  channelIdToQuery: undefined,
  channelsLoading: true,
  channels: [],
  unreadChannels: [],
  hasMoreChannels: {},

  // Loaded asynchronously from zion-preferences (when in ChatOverlay)
  showEvents: false,
  darkMode: false,
  soundEnabled: true,
  enterSendsMessage: true,

  connectError: false,
  authenticating: false,
  // If the patron is not allowed to add personal data and Chat should not be available
  personalDataError: false,
  // If the patron is a minor and Chat should not be available (under 18 phase 1)
  minorAccessError: false,
  restrictToManagedGroups: false,
  /**
   * We use the unreadChannelMap along with the latest stream chat state
   * to know how and when to play a new message sound notification and how
   * to display unread chats and messages.
   */
  unreadChannelMap: {},
  parentMessage: undefined,
  threadChannel: undefined,
  playSound: false,
  scrollToBottom: false,
  domainWhitelist: [],
  // For use in rare cases where useParams is not available to get the current cid
  currentCid: undefined,
  renderFallback: true,
  announcement: undefined,
}

export const CHAT_ACTIONS = {
  ADDED_TO_CHANNEL: 'ADDED_TO_CHANNEL',
  CLEAR_CHANNEL_ID_TO_QUERY: 'CLEAR_CHANNEL_ID_TO_QUERY',
  CHAT_LOGIN: 'CHAT_LOGIN',
  HIDDEN: 'HIDDEN',
  INVITE_ACCEPTED: 'INVITE_ACCEPTED',
  INVITE_REJECTED: 'INVITE_REJECTED',
  INVITED: 'INVITED',
  LOGOUT: 'LOGOUT',
  REMOVED_FROM_CHANNEL: 'REMOVED_FROM_CHANNEL',
  SET_CHANNELS: 'SET_CHANNELS',
  SET_UNREAD_CHANNELS: 'SET_UNREAD_CHANNELS',
  SET_CHANNEL_MUTES: 'SET_CHANNEL_MUTES',
  CHANNEL_UPDATED: 'CHANNEL_UPDATED',
  MARK_READ: 'MARK_READ',
  NEW_MESSAGE: 'NEW_MESSAGE',
  NEW_MESSAGE_NOT_WATCHED: 'NEW_MESSAGE_NOT_WATCHED',
  NEW_PARENT_MESSAGE: 'NEW_PARENT_MESSAGE',
  MESSAGE_DELETED: 'MESSAGE_DELETED',
  MESSAGE_UPDATED: 'MESSAGE_UPDATED',
  BLOCKED_USERS_UPDATED: 'BLOCKED_USERS_UPDATED',
  SHOW_EVENTS: 'SHOW_EVENTS',
  CONNECTION_CHANGED: 'CONNECTION_CHANGED',
  SET_AUTHENTICATING: 'SET_AUTHENTICATING',
  SET_CONNECT_ERROR: 'SET_CONNECT_ERROR',
  SET_PERSONAL_DATA_ERROR: 'SET_PERSONAL_DATA_ERROR',
  SET_MINOR_ACCESS_ERROR: 'SET_MINOR_ACCESS_ERROR',
  SET_SOUND_ENABLED: 'SET_SOUND_ENABLED',
  SET_PLAY_SOUND: 'SET_PLAY_SOUND',
  CLEAR_PLAY_SOUND: 'CLEAR_PLAY_SOUND',
  SET_SCROLL_TO_BOTTOM: 'SET_SCROLL_TO_BOTTOM',
  CLEAR_SCROLL_TO_BOTTOM: 'CLEAR_SCROLL_TO_BOTTOM',
  DARK_MODE: 'DARK_MODE',
  SET_DOMAIN_WHITELIST: 'SET_DOMAIN_WHITELIST',
  ENTER_SENDS_MESSAGE: 'ENTER_SENDS_MESSAGE',
  SET_CURRENT_CID: 'SET_CURRENT_CHANNEL_CID',
  SET_RENDER_FALLBACK: 'SET_SHOW_FALLBACK',
  SET_IS_EMBEDDED: 'SET_IS_EMBEDDED',
}

function getUnreadChannelMap(channels, unreadChannels, restrictToManagedGroups) {
  const channelsToFilter = unreadChannels ? [...channels, ...unreadChannels] : channels
  return channelsToFilter
    ?.filter(
      (channel) => !isOrphanedThread(channels, channel) && !isRestrictedForUser(channel, restrictToManagedGroups)
    )
    .reduce((unreadMap, channel) => {
      if (channel?.cid) {
        unreadMap[channel.cid] = channel?.countUnread() ? channel : 0
      }
      return unreadMap
    }, {})
}

function handleNewMessageEvent(change, action) {
  announceMessage(change, action)

  change.playSound = shouldPlaySound(change, action)

  // Keep unread channels display in sync with playing a sound
  if (change.playSound) {
    change.unreadChannelMap = getUnreadChannelMap(
      change.channels,
      change.unreadChannels,
      change.restrictToManagedGroups
    )
  }

  // If channel isnâ€™t loaded, mark that we need to load it
  if (!change.channels.some((c) => c.cid === action.event.cid) && !change.isEmbedded) {
    change.channelIdToQuery = action.event.cid
  }
}

function announceMessage(change, action) {
  const userIsMe = change.client?.user?.id === action.event?.user?.id

  if (!userIsMe) {
    change.announcement = {
      text: i18n.t('chat.new-message-from-person.message', 'New Message from {name}: {message}', {
        name: action.event.message?.user?.name,
        message: action.event.message?.text,
      }),
      cid: action.event.cid,
    }
  }
}

function shouldPlaySound(change, action) {
  if (change.isEmbedded) {
    return false
  }

  const { unreadChannelMap, channels, client } = change
  const { event, cid } = action
  const userIsMe = client?.user?.id === event?.user?.id

  // The first isUnread channel whose isUnread count goes from 0 to greater than zero when compared to latest stream-chat state.
  const unreadChannel = channels.find((c) => {
    if (action.type === 'NEW_MESSAGE_NOT_WATCHED') {
      return c?.countUnread() === 0 && !c?.muteStatus().muted
    }
    return c?.countUnread() > 0 && !c?.muteStatus().muted && unreadChannelMap[c?.cid] === 0
  })
  const channelNotLoaded = !change.channels.some((c) => c.cid === action.event.cid)
  const documentIsFocused = isDocumentFocused()
  const channelHasFocus = documentIsFocused && unreadChannel && unreadChannel.cid === cid
  const senderIsBlocked = isUserBlocked({ userId: event?.user?.id, client })
  const isAllowedToViewChannel = !isRestrictedForUser(unreadChannel, change.restrictToManagedGroups)

  // Avoid playing a sound when the user is focused on the tab and channel.
  return Boolean(
    (unreadChannel || channelNotLoaded) && !userIsMe && !channelHasFocus && !senderIsBlocked && isAllowedToViewChannel
  )
}

function reducer(state, action) {
  const change = { ...state }
  chatLog({
    msg: `useChatReducer ${action.type}`,
    component: '[useChatReducer]',
    user: { id: state.client?.userID, cisId: state.client?.user?.fs_cis_id },
    level: LOG_LEVEL.LOG,
  })

  // eslint-disable-next-line sonarjs/max-switch-cases -- yes, this reducer has a lot of actions
  switch (action.type) {
    case CHAT_ACTIONS.SET_AUTHENTICATING:
      change.authenticating = true
      break
    case CHAT_ACTIONS.CONNECTION_CHANGED:
      if (action.online) {
        change.connectError = false
        change.authenticating = false
      } else if (!state.authenticating) {
        change.connectError = true
      }
      break
    case CHAT_ACTIONS.SET_CONNECT_ERROR:
      change.connectError = true
      change.authenticating = false
      break
    case CHAT_ACTIONS.SET_PERSONAL_DATA_ERROR:
      change.personalDataError = true
      break
    case CHAT_ACTIONS.SET_MINOR_ACCESS_ERROR:
      change.minorAccessError = true
      break
    case CHAT_ACTIONS.CHAT_LOGIN:
      change.connectError = false
      change.authenticating = false
      change.client = action.client
      change.restrictToManagedGroups = action.chatUser?.chatUserType === 'fs_managed_limited'
      break
    case CHAT_ACTIONS.LOGOUT: {
      const stateOverrides = {}
      //  Pass in overrides if there is any data that should be persisted after Stream logout
      if (action.overrides) {
        action.overrides.forEach((override) => {
          if (state[override]) {
            stateOverrides[override] = state[override]
          }
        })
      }

      // If the fallback has been removed before, keep it removed
      stateOverrides.renderFallback = state.renderFallback
      return { ...DEFAULT_STATE, ...stateOverrides }
    }
    case CHAT_ACTIONS.SET_CHANNELS:
      change.channelsLoading = false
      change.channels = action.channels || []
      change.hasMoreChannels = action.hasMoreChannels || state.hasMoreChannels
      change.channel = action.channel || state.channel
      change.unreadChannelMap = getUnreadChannelMap(
        change.channels,
        change.unreadChannels,
        state.restrictToManagedGroups
      )
      break
    case CHAT_ACTIONS.SET_UNREAD_CHANNELS:
      change.unreadChannels = action.unreadChannels
      break
    case CHAT_ACTIONS.SET_CHANNEL_MUTES:
    case CHAT_ACTIONS.CHANNEL_UPDATED:
      change.channels = [...state.channels]
      break
    case CHAT_ACTIONS.MARK_READ: {
      const channel = state.channels.find((c) => c.cid === action?.event?.cid)
      if (channel) {
        channel.state.unreadCount = 0
      }
      change.unreadChannelMap = getUnreadChannelMap(state.channels, state.unreadChannels, state.restrictToManagedGroups)
      break
    }
    case CHAT_ACTIONS.NEW_PARENT_MESSAGE:
      change.parentMessage = action?.parentMessage
      change.threadChannel = action?.threadChannel
      break
    case CHAT_ACTIONS.NEW_MESSAGE:
    case CHAT_ACTIONS.NEW_MESSAGE_NOT_WATCHED:
      handleNewMessageEvent(change, action)
      break
    case CHAT_ACTIONS.MESSAGE_DELETED:
      // We need to requery the channel in order to update the unread status when a message is deleted - otherwise it shows as unread
      if (!state.isEmbedded) {
        change.channelIdToQuery = action.event.cid
      }
      if (change?.parentMessage?.id && action?.event?.message?.id === change.parentMessage.id) {
        change.parentMessage = action.event.message
      }
      break
    case CHAT_ACTIONS.MESSAGE_UPDATED:
      if (change?.parentMessage?.id && action?.event?.message?.id === change.parentMessage.id) {
        change.parentMessage = action.event.message
      }
      break
    case CHAT_ACTIONS.INVITE_ACCEPTED:
    case CHAT_ACTIONS.ADDED_TO_CHANNEL:
      // Why is this here? Setting channelIdToQuery causes a new request every time someone joins the channel. Taking this out for embedded chat until this is better understood.
      if (!state.isEmbedded) {
        change.channelIdToQuery = action.event.cid
      }
      change.unreadChannelMap = getUnreadChannelMap(
        change.channels,
        change.unreadChannels,
        state.restrictToManagedGroups
      )
      break
    case CHAT_ACTIONS.CLEAR_CHANNEL_ID_TO_QUERY:
      change.channelIdToQuery = undefined
      break
    case CHAT_ACTIONS.INVITED:
      // Will only run if the current user is invited to the channel
      change.channelIdToQuery = action.event.cid
      change.playSound = true
      break
    case CHAT_ACTIONS.SET_SOUND_ENABLED:
      change.soundEnabled = action.soundEnabled
      break
    case CHAT_ACTIONS.CLEAR_PLAY_SOUND:
      change.playSound = false
      break
    case CHAT_ACTIONS.INVITE_REJECTED:
    case CHAT_ACTIONS.HIDDEN:
    case CHAT_ACTIONS.REMOVED_FROM_CHANNEL: {
      // Embedded chat should continue to display the channel when the checkbox is unchecked
      // removing this code causes the embedded chat toggle to break.
      if (change.isEmbedded && action.event.channel?.type !== CHANNEL_TYPE.FS_THREAD) {
        change.channelIdToQuery = action.event.cid
      } else {
        const channels = removeChannelFromChannels(change?.channels, action?.event?.channel)
        change.channels = channels || []
        change.unreadChannelMap = getUnreadChannelMap(
          change.channels,
          change.unreadChannels,
          state.restrictToManagedGroups
        )
      }
      break
    }
    case CHAT_ACTIONS.BLOCKED_USERS_UPDATED:
      // List of muted/blocked users is read directly from client, but this dispatch is needed to trigger a re-render
      break
    case CHAT_ACTIONS.SHOW_EVENTS:
      change.showEvents = action.showEvents
      break
    case CHAT_ACTIONS.SET_SCROLL_TO_BOTTOM:
      change.scrollToBottom = true
      break
    case CHAT_ACTIONS.CLEAR_SCROLL_TO_BOTTOM:
      change.scrollToBottom = false
      break
    case CHAT_ACTIONS.DARK_MODE:
      change.darkMode = action.darkMode
      break
    case CHAT_ACTIONS.SET_DOMAIN_WHITELIST:
      change.domainWhitelist = action.domainWhitelist
      break
    case CHAT_ACTIONS.ENTER_SENDS_MESSAGE:
      change.enterSendsMessage = action.enterSendsMessage
      break
    case CHAT_ACTIONS.SET_CURRENT_CID:
      change.currentCid = action.currentCid
      break
    case CHAT_ACTIONS.SET_RENDER_FALLBACK:
      change.renderFallback = action.renderFallback
      break
    case CHAT_ACTIONS.SET_IS_EMBEDDED:
      change.isEmbedded = action.isEmbedded
      break
    default:
      chatLog({ msg: `ERROR: Unhandled action type: ${action.type}`, level: LOG_LEVEL.ERROR })
      break
  }
  return { ...change }
}

export default function useChatReducer(initialStateOverrides = {}) {
  return useReducer(reducer, {
    ...DEFAULT_STATE,
    ...initialStateOverrides,
  })
}

export { reducer as chatReducer, DEFAULT_STATE }
