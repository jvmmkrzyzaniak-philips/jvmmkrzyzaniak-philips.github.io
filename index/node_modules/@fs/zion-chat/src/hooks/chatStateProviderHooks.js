import { useEffect, useRef, useState } from 'react'
import axios from '@fs/zion-axios'
import { useUser } from '@fs/zion-user'
import useChatFlags from './useChatFlags'
import { CHAT_ACTIONS } from './useChatReducer'
import { chatApiBase } from '../global/chatConfig'
import { CHAT_PREF, getChatPreference } from '../services/chatUserPreferenceService/chatUserPreferenceService'
import { updateChannelInChannels } from '../helpers/stream/streamChatHelper'
import useChatLog from './useChatLog'
import { LOG_LEVEL } from '../global/chatLog'
import { getIsChannelMember } from '../services/fsChat/fsChatService'
import { CHANNEL_TYPE } from '../services/fsChat/fsChannelEnums'

/*
Hooks for initializing chat state in ChatStateProvider
*/

// Fetches the domain whitelist from the chat API
const useFetchWhitelist = ({ chatDispatch }) => {
  useEffect(() => {
    const fetchWhitelist = async () => {
      const url = `${chatApiBase}/whitelist`
      const { data } = await axios.get(url)
      chatDispatch({ type: CHAT_ACTIONS.SET_DOMAIN_WHITELIST, domainWhitelist: data.results })
    }
    fetchWhitelist()
  }, [chatDispatch])
}

// Fetches and sets preferences for the showEvents, darkMode, and sound toggles
const useLoadChatPreferences = ({ chatDispatch, isEmbedded, cisId }) => {
  useEffect(() => {
    async function getToggleData() {
      const [enterSendsMessage] = await Promise.all([getChatPreference(CHAT_PREF.ENTER_SENDS_MESSAGE, true)])
      chatDispatch({ type: CHAT_ACTIONS.ENTER_SENDS_MESSAGE, enterSendsMessage })

      // These are not needed for embedded chat
      if (!isEmbedded) {
        const [showEvents, darkMode, soundEnabled] = await Promise.all([
          getChatPreference(CHAT_PREF.SHOW_EVENT_CHATS, true),
          getChatPreference(CHAT_PREF.DARK_MODE, false),
          getChatPreference(CHAT_PREF.SOUND_ENABLED, true),
        ])
        chatDispatch({ type: CHAT_ACTIONS.SHOW_EVENTS, showEvents })
        chatDispatch({ type: CHAT_ACTIONS.DARK_MODE, darkMode })
        chatDispatch({ type: CHAT_ACTIONS.SET_SOUND_ENABLED, soundEnabled })
      }
    }

    if (cisId) {
      getToggleData()
    }
  }, [chatDispatch, cisId, isEmbedded])
}

// Determines whether to render the fallback for embedded chat
const useShouldRenderFallback = ({ user, chatDispatch }) => {
  const { messagingChatShowEmbeddedFallbackForAllIsOn } = useChatFlags()
  useEffect(() => {
    const renderFallback = !user.signedIn || messagingChatShowEmbeddedFallbackForAllIsOn
    chatDispatch({
      type: CHAT_ACTIONS.SET_RENDER_FALLBACK,
      renderFallback,
    })
  }, [chatDispatch, user.signedIn, messagingChatShowEmbeddedFallbackForAllIsOn])
}

// Runs an effect that requeries a channel whenever channelIdToQuery is updated
const useUpdateCurrentChannel = ({ chatState, chatDispatch, isEmbedded, overlayLoaded }) => {
  const { client, channels, channelIdToQuery, unreadChannels } = chatState
  const { messagingChatQueryUnreadsIsOn } = useChatFlags()
  const { log } = useChatLog({ component: '[useUpdateCurrentChannel]' })
  const justReadChannelId = useRef()
  useEffect(() => {
    let isLatestRender = true
    const updateChannel = async () => {
      try {
        if (
          (isEmbedded || overlayLoaded) &&
          client &&
          channelIdToQuery &&
          justReadChannelId.current !== channelIdToQuery
        ) {
          justReadChannelId.current = channelIdToQuery
          chatDispatch({ type: CHAT_ACTIONS.CLEAR_CHANNEL_ID_TO_QUERY })
          const [channel] = await client.queryChannels({ cid: { $in: [channelIdToQuery] } })
          if (isLatestRender) {
            const chatChannels = updateChannelInChannels(channels, channel, true)
            if (messagingChatQueryUnreadsIsOn) {
              const unreadChatChannels = updateChannelInChannels(unreadChannels, channel, true)
              chatDispatch({ type: CHAT_ACTIONS.SET_UNREAD_CHANNELS, unreadChannels: unreadChatChannels })
            }
            chatDispatch({ type: CHAT_ACTIONS.SET_CHANNELS, channels: chatChannels })
            justReadChannelId.current = undefined
          } else if (justReadChannelId.current === channelIdToQuery) {
            // ensure values are cleared
            chatDispatch({ type: CHAT_ACTIONS.CLEAR_CHANNEL_ID_TO_QUERY })
            justReadChannelId.current = undefined
          }
        }
      } catch (err) {
        log({ error: `Error updating current channel: ${err}`, level: LOG_LEVEL.ERROR })
      }
    }
    updateChannel()
    return () => {
      // Cleaning up to make sure we don't update the state with the result of an old query
      isLatestRender = false
    }
  }, [
    client,
    channelIdToQuery,
    channels,
    chatDispatch,
    overlayLoaded,
    isEmbedded,
    unreadChannels,
    messagingChatQueryUnreadsIsOn,
    log,
  ])
}

const useShouldConnectAnonymously = ({ isEmbedded, chatRoute, supportChatInformation }) => {
  const { userLoading, signedIn } = useUser()
  const isSessionChannel = chatRoute?.includes('session')
  const { messagingChatAnonymousConnectIsOn } = useChatFlags()
  const canConnectAnonymously = isEmbedded && signedIn && isSessionChannel && messagingChatAnonymousConnectIsOn
  const [shouldConnectAnonymously, setShouldConnectAnonymously] = useState(false)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    let isLatestRender = true
    async function getIsChannelMemberEffect() {
      if (userLoading) return
      if (!canConnectAnonymously) {
        setShouldConnectAnonymously(false)
        setLoading(false)
        return
      }
      const isMember = await getIsChannelMember({
        channelType: CHANNEL_TYPE.FS_SESSION,
        supportInformation: supportChatInformation,
      })
      if (isLatestRender) {
        if (isMember) {
          setShouldConnectAnonymously(false)
        } else {
          setShouldConnectAnonymously(true)
        }
        setLoading(false)
      }
    }
    getIsChannelMemberEffect()
    return () => {
      isLatestRender = false
    }
  }, [supportChatInformation, canConnectAnonymously, userLoading])

  return [shouldConnectAnonymously, loading]
}

export {
  useFetchWhitelist,
  useLoadChatPreferences,
  useUpdateCurrentChannel,
  useShouldRenderFallback,
  useShouldConnectAnonymously,
}
