import { trackEvent } from '@fs/zion-analytics'
import { useEvent } from '@fs/zion-frontend-friends'
import { getUser } from '@fs/zion-user'
import { useCallback, useEffect, useRef } from 'react'
import { getShouldBypassInterrupter } from '../profile-interrupter/profileOptInHelper'
import { useChatProviderContext } from '../providers/useChatProviderContext'

/**
 * Hook called by consumers of chat to control the ChatOverlay
 * @param {string} [destinationChatRoute] - route to initially load, optional
 * @param {Object} [destinationSupportInformation] - additional information for creating a new chat, optional
 * @param {boolean} [forceBypassStartupDialogs] - force skip the help overview and profile opt in dialogs, false by default
 * @returns {Object} same shape that useOverlay() returns
 */
export default function useChatOverlay(
  destinationChatRoute,
  destinationSupportInformation,
  forceBypassStartupDialogs = false
) {
  const {
    chatProfileInterrupterOverlay,
    overlay,
    chatRoute,
    setChatRoute,
    setSupportInformation,
    setForceBypassStartupDialogs,
  } = useChatProviderContext()
  const loginRef = useRef()

  const handleToggleChatOverlay = useEvent(async ({ event, newChatRoute, newSupportInformation }) => {
    // In the helptray-bundle, the click is fired right after the initial render, so useUser is often still loading.
    // Calling getUser will return the cached user if it was already available, so a duplicate network call won’t be made.
    try {
      await getUser()
      // If the user clicked a button to open route A, manually navigated to route B, and then clicked another button to route A,
      // then momentarily clear the chat route so ChatMemoryRouter will detect the A->undefined->A change. (FSCHAT-756)
      setForceBypassStartupDialogs(forceBypassStartupDialogs)
      if (chatRoute === newChatRoute) setChatRoute(undefined)
      setChatRoute(newChatRoute)
      setSupportInformation(newSupportInformation || {})

      const shouldBypassInterrupter = forceBypassStartupDialogs || (await getShouldBypassInterrupter())
      if (shouldBypassInterrupter) {
        // If the overlay is already open, only close it from a Chat button that does not go to a specific route (e.g., from the header)
        if (!overlay.isOpen || !newChatRoute) {
          overlay.handleClick(event)
        }
      } else {
        chatProfileInterrupterOverlay.handleClick(event)
      }
    } catch {
      // User not signed in
      if (!loginRef.current) {
        loginRef.current = true
        window.location.href = `/auth/familysearch/login?returnUrl=${encodeURIComponent(window.location.href)}`
      }
    }
  })
  const handleClick = useCallback(
    // The chat route and support info can be passed to handleClick (to support the helptray-bundle), but they default to those passed to useChatOverlay
    (event, newChatRoute = destinationChatRoute, newSupportInformation = destinationSupportInformation) => {
      // This may or may not be a React synthetic event, if coming from a bifrost page
      event?.persist?.()
      trackEvent({
        event_name: 'click_action',
        link_name: 'Chat:Click Chat Overlay Button',
      })
      event?.preventDefault()
      // Only show the interrupter if user clicks button after user has signed in to FamilySearch
      // In helptray-bundle, the click is fired right after the initial render, so useUser is often still loading.
      // Calling getUser will return the cached user if it was already available, so a duplicate network call won’t be made.
      handleToggleChatOverlay({ event, newChatRoute, newSupportInformation })
    },
    [destinationChatRoute, destinationSupportInformation, handleToggleChatOverlay]
  )

  useEffect(() => {
    if (!overlay.isOpen) {
      setChatRoute(null)
      setSupportInformation(null)
    }
  }, [overlay.isOpen, setChatRoute, setSupportInformation])

  return { ...overlay, handleClick }
}
