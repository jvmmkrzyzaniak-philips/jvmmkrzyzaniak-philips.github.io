import { useState, useRef, useEffect, useCallback } from 'react'
import axios from '@fs/zion-axios'
import { useUser } from '@fs/zion-user'
import useInterval from './utils/useInterval'
import chatLog, { LOG_LEVEL } from '../global/chatLog'
import useChatFlags from './useChatFlags'
import { chatApiBase } from '../global/chatConfig'

// This event is dispatched to the document for interoperability between React and Bifrost code.
const SET_UNREAD_EVENT_NAME = 'fs-chat-set-has-unread-chats'

/**
 * Hook to poll whether the current user has unread chats.
 * Used to show a red dot in ChatOverlayButton and zion-header.
 * Should match the implementation in Bifrost hf.
 * @param {boolean} isChatOpen whether the ChatOverlay is currently open
 * @returns { hasUnreadChats: boolean }
 */
export default function useHasUnreadChats(isChatOpen) {
  const { signedIn } = useUser()

  const firstRunRef = useRef(null)
  const isCurrentRef = useRef(true)
  const [hasUnreadChats, setHasUnreadChats] = useState(false)
  const [isActiveUser, setIsActiveUser] = useState(false)

  const { messagingChatRedDotConfig, messagingChatUseImprovedRedDotApiIsOn } = useChatFlags()
  const showRedDot = messagingChatRedDotConfig?.showRedDot || false
  const pollingEnabled = messagingChatRedDotConfig?.pollingEnabled || false
  const pollingInterval = (messagingChatRedDotConfig?.intervalSeconds ?? 30) * 1000

  const getHasUnreadChats = useCallback(async () => {
    if (!showRedDot) return
    try {
      const unreadResponse = await hasUnread({ useImprovedRedDot: messagingChatUseImprovedRedDotApiIsOn })
      if (isCurrentRef.current) {
        setHasUnreadChats(unreadResponse.hasUnread)
        setIsActiveUser(unreadResponse.isActiveUser)
      }
    } catch (e) {
      if (isCurrentRef.current) {
        setHasUnreadChats(false)
        chatLog({ msg: `Could not get users unread count. ${e.message}`, level: LOG_LEVEL.ERROR })
      }
    }
  }, [showRedDot, messagingChatUseImprovedRedDotApiIsOn])

  useInterval(async () => {
    if (pollingEnabled && isActiveUser && !isChatOpen && !hasUnreadChats && document?.visibilityState === 'visible') {
      getHasUnreadChats()
    }
  }, pollingInterval)

  useEffect(() => {
    isCurrentRef.current = true
    if (!firstRunRef.current && signedIn) {
      firstRunRef.current = true
      getHasUnreadChats()
    }
    return () => {
      isCurrentRef.current = false
    }
  }, [getHasUnreadChats, signedIn])

  useEffect(() => {
    const handleSetUnreadEvent = (event) => {
      if (!showRedDot) return
      if (typeof event?.hasUnreadChats === 'boolean') {
        setHasUnreadChats(event.hasUnreadChats)
      } else {
        getHasUnreadChats()
      }
    }
    document.addEventListener(SET_UNREAD_EVENT_NAME, handleSetUnreadEvent)
    return () => {
      document.removeEventListener(SET_UNREAD_EVENT_NAME, handleSetUnreadEvent)
    }
  }, [getHasUnreadChats, showRedDot])

  return { hasUnreadChats }
}

// Used by ChatStateProvider to control the state based on live unread status from the websocket (rather than polling)
export function dispatchSetUnreadChatsEvent(hasUnreadChats = false) {
  const event = new Event(SET_UNREAD_EVENT_NAME)
  event.hasUnreadChats = hasUnreadChats
  document.dispatchEvent(event)
}

export async function hasUnread({ useImprovedRedDot = true, refreshCache = false }) {
  const options = {
    params: {
      forceNew: useImprovedRedDot,
    },
    headers: {},
  }

  if (refreshCache) {
    options.headers['Cache-Control'] = 'no-cache'
    options.headers.Expires = '0'
  }
  const response = await axios.get(`${chatApiBase}/users/unread`, options)
  return {
    hasUnread: response.data.unreadCount > 0,
    // See possible activityLevels at https://github.com/fs-eng/fs-chat-api/blob/master/fs-chat-model/src/main/java/org/familysearch/chat/api/ChatActivityLevel.java
    isActiveUser: response.data.activityLevel === 'active',
  }
}
