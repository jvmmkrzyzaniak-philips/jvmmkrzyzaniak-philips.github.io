import React, { createContext, useContext, useEffect, useState } from 'react'
import { useChipCollection } from '@fs/zion-ui'
import { useEvent } from '@fs/zion-frontend-friends'
import { useUser } from '@fs/zion-user'
import useChatReducer, { CHAT_ACTIONS } from '../hooks/useChatReducer'
import { dispatchSetUnreadChatsEvent } from '../hooks/useHasUnreadChats'
import useChatWebsocketManager from '../hooks/useChatWebsocketManager'
import {
  useFetchWhitelist,
  useLoadChatPreferences,
  useUpdateCurrentChannel,
  useShouldRenderFallback,
  useShouldConnectAnonymously,
} from '../hooks/chatStateProviderHooks'
import { useChatProviderContext } from './useChatProviderContext'
import { connectChat, connectAnonymousChat } from '../chat-reconnect/ChatReconnectPage'
import useChatFlags from '../hooks/useChatFlags'

export const ChatStateContext = createContext()
export const ChatDispatchContext = createContext()

export const useChatState = () => {
  return useContext(ChatStateContext)
}

export const useChatDispatch = () => {
  return useContext(ChatDispatchContext)
}

export function useChatStateProviderData({
  isEmbedded = false,
  overlayIsOpen,
  chatRoute = '',
  supportChatInformation,
}) {
  const [chatState, chatDispatch] = useChatReducer({ isEmbedded })
  const { client, unreadChannelMap } = chatState
  const hasUnread = Object.values(unreadChannelMap || {}).some((value) => Boolean(value))
  const createChatRecipientChipCollection = useChipCollection()
  const user = useUser()
  const [overlayLoaded, setOverlayLoaded] = useState(false)

  useChatWebsocketManager(chatState, chatDispatch)
  useFetchWhitelist({ chatDispatch })
  useLoadChatPreferences({ chatDispatch, cisId: user?.cisId, isEmbedded })
  useUpdateCurrentChannel({ chatState, chatDispatch, isEmbedded, overlayLoaded })
  useShouldRenderFallback({ user, chatDispatch })
  const [shouldConnectAnonymously, loadingShouldConnectAnonymously] = useShouldConnectAnonymously({
    isEmbedded,
    chatRoute,
    supportChatInformation,
  })

  const { cisId, signedIn } = user
  // This ref in the top-level ChatProvider tracks how many client consumers (ChatOverlay or EmbeddedChat) are currently using the client connection
  const { clientConsumerCountRef } = useChatProviderContext()

  const { messagingChatQueryUnreadsIsOn } = useChatFlags()

  const connect = useEvent(() => {
    if (shouldConnectAnonymously) {
      connectAnonymousChat({ chatDispatch })
    } else {
      connectChat({ chatDispatch, isEmbedded, messagingChatQueryUnreadsIsOn })
    }
    clientConsumerCountRef.current++
  })

  const disconnectIfNeeded = useEvent(() => {
    clientConsumerCountRef.current--
    if (clientConsumerCountRef.current === 0) {
      // If this was the last consumer of the client, disconnect to end the websocket connection
      client?.disconnectUser()
      chatDispatch({ type: CHAT_ACTIONS.LOGOUT })
    }
  })

  const shouldConnect = Boolean((isEmbedded || overlayLoaded) && signedIn && cisId && !loadingShouldConnectAnonymously)
  useEffect(() => {
    if (shouldConnect) connect()
    // ✅ We must disconnect the user when the component dismounts in order to not open
    // multiple WebSocket connections and cause other problems
    // But this cleanup is asymmetric: if this client consumer (overlay or embedded chat) connected first, but another has since
    // connected and is still active, we will not disconnect the client (since the client websocket is shared)
    return () => {
      if (shouldConnect) disconnectIfNeeded()
    }
  }, [connect, disconnectIfNeeded, shouldConnect])

  if (!overlayLoaded && overlayIsOpen) {
    setOverlayLoaded(true)
  }

  useEffect(() => {
    // Embedded chat doesn’t load enough data to have an accurate unread count to control the red dot
    if (!isEmbedded) dispatchSetUnreadChatsEvent(hasUnread)
  }, [hasUnread, isEmbedded])

  const chatStateValue = {
    ...chatState,
    user,
    createChatRecipientChipCollection,
  }

  return { chatDispatch, chatStateValue }
}

export default function ChatStateProvider({ children, chatStateProviderData }) {
  const { chatDispatch, chatStateValue } = chatStateProviderData
  return (
    <ChatStateContext.Provider value={chatStateValue}>
      <ChatDispatchContext.Provider value={chatDispatch}>{children}</ChatDispatchContext.Provider>
    </ChatStateContext.Provider>
  )
}
