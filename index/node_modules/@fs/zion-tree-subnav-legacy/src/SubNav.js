/**
 * Renders a <nav> with a dynamic list based on conditions.
 * Items causing overflow are moved to a "More" menu.
 *
 * The "More" menu is hidden from screen readers. These users will see a
 * normal <nav> with normal list items.
 *
 * A `ResizeObserver` listens for changes on the <nav> size and recalculates
 * the "More" menu as needed.
 *
 * During the calculation, we use a combination of `hidden` attributes and CSS
 * to hide various elements until the calculation is complete. This helps
 * reduce visual jumping.
 */
import React, { lazy, Suspense, useCallback, useMemo, useRef, useState } from 'react'
import PropTypes from 'prop-types'
import { Link } from '@fs/zion-router'
import { useResizeObserver } from '@fs/zion-frontend-friends'
import { useTranslation } from 'react-i18next'
import { css, cx } from '@linaria/core'
import { trackEvent } from '@fs/zion-analytics'
import { useOverlay, MenuOverlay, ListItem, useMenuOverlay } from '@fs/zion-ui'
import { useUser } from '@fs/zion-user'
import { ArrowCaret } from '@fs/zion-icon'
import { HelperButton, HelperListItem } from '@fs/zion-helper-mode'
import { i18n } from '@fs/zion-locale'
import { useGroupsContext, GroupsNavigation } from '@fs/zion-tree-groups'
import { useFeatureFlag } from '@fs/zion-flags'
import { usePermission, useShowTemple } from '@fs/zion-permissions'
import WhatsNew from './WhatsNew'

// Note: if we were to manage the overlay in this file, the lazy-load of the content of the overlay causes the entire page to re-render for some reason in an actual app. I wasn't able to figure out the reason, but this solution keeps the recents list logic more separate anyway, so I like the solution. If we have a reason we can't do this in the future, this note is to help us remember that it was causing rerenders and how we solved it.
const RecentsListOverlay = lazy(() => import('@fs/zion-tree-recents'))

// https://www.joshwcomeau.com/snippets/javascript/debounce/
function debounce(callback, wait) {
  let timeoutId = null
  return (...args) => {
    window.clearTimeout(timeoutId)
    timeoutId = window.setTimeout(() => callback(...args), wait)
  }
}

const navClassName = css`
  width: 100%;
  padding: 6px 10px;
  background: white;
`

// The `fixedMaxWidth` prop was deprecated as of v6.6.0
const fixedMaxWidthClassName = css`
  max-width: 1440px;
  margin-left: auto;
  margin-right: auto;
`

const listClassName = css`
  display: flex;
  align-items: center;
  list-style: none;
  gap: 2px;
  // Need to position so the list items can reference the correct offsetParent in resize callback:
  position: relative;
`

// Added while the list is recalculating. Used for combinators with other classes.
const listCalculatingClassName = css``

const visibleListItemClassName = css`
  display: flex;
  align-items: center;
  white-space: nowrap;
  padding: 0;
  margin: 0;
`

const groupsNavListItemClassName = css`
  margin: 0;
  margin-inline-end: 0.5rem;
  max-width: 200px;
`

const moreListItemClassName = css`
  margin: 0;

  .${listCalculatingClassName} & {
    visibility: hidden;
  }
`

const visuallyHiddenClassname = css`
  ul:not(.${listCalculatingClassName}) & {
    clip: rect(0 0 0 0);
    clip-path: inset(50%);
    height: 1px;
    overflow: hidden;
    position: absolute;
    white-space: nowrap;
    width: 1px;
  }

  .${listCalculatingClassName} & {
    visibility: hidden;
  }
`

// Pushes these list items to the end by applying auto margin to the first one
const endClassName = css`
  &:not(& ~ &) {
    margin-inline-start: auto;
  }
`

const linkClassName = css`
  display: inline-flex;
  gap: 0.125rem;
  align-items: center;
  background: transparent;
  border: 0;
  border-radius: 4px;
  cursor: pointer;
  font: inherit;
  line-height: inherit;
  padding: 4px 10px;
  margin: 0;
  text-decoration: none;
  white-space: nowrap;
  font-size: 14px;
`

const visibleLinkClassName = cx(
  linkClassName,
  css`
    &:hover,
    &[aria-current='page'] {
      background: #e1edc1;
    }

    &,
    &:visited,
    &:active,
    &:hover {
      color: #666662;
    }
  `
)

const pagesWithDisabledNavigation = ['private-people', 'research-tree', 'family', 'following', 'contributions']

/**
 * Because the "More" menu uses <MenuOverlay> and its API calls for <ListItem>
 * children instead of <li> elements, we need to pull out the raw data so it
 * can be passed to either. This makes the component about 3x more complex. It
 * means we need this ITEMS data and we have to use React state to manage
 * splitting up the menu instead of just moving around DOM elements :(
 */
const ITEMS = {
  contributions: {
    page: 'contributions',
    'data-testid': 'nav-contributions',
    to: '/tree/contributions',
    external: true,
    wayfinding: true,
    linkName: 'Subnav: Contributions',
    label: 'subnav-legacy.subnav.contributions-link',
    className: visibleLinkClassName,
  },
  familyGroups: {
    page: 'family',
    'data-testid': 'nav-family-groups',
    to: '/groups/family',
    external: true,
    wayfinding: true,
    linkName: 'Subnav: Family Groups',
    label: 'subnav-legacy.family-groups.label',
    className: visibleLinkClassName,
  },

  find: {
    // `to` property is dynamic and will be added in the component
    page: 'find',
    'data-testid': 'nav-find',
    external: true,
    wayfinding: true,
    linkName: 'Subnav: Find',
    label: 'common-ui:find.action',
    className: visibleLinkClassName,
  },
  following: {
    page: 'following',
    'data-testid': 'nav-following',
    to: '/tree/following',
    external: true,
    wayfinding: true,
    linkName: 'Subnav: Following',
    label: 'subnav-legacy.subnav.following-link',
    className: visibleLinkClassName,
  },
  helper: {
    page: 'helper',
    as: (props) => <HelperButton {...props} asChip showIcon emphasis="low" />,
    moreAs: HelperListItem,
    'data-testid': 'helper-button',
    linkName: 'Subnav: Helper',
    listItemClassName: endClassName,
  },

  overview: {
    page: 'overview',
    'data-testid': 'nav-overview',
    to: '/tree/overview',
    external: true,
    wayfinding: true,
    linkName: 'Tree Subnav: Overview',
    label: 'subnav-legacy.subnav.overview-link',
    className: visibleLinkClassName,
  },
  pedigree: {
    page: 'pedigree',
    'data-testid': 'nav-pedigree',
    to: '/tree/pedigree',
    external: true,
    wayfinding: true,
    linkName: 'Tree Subnav: Pedigree',
    label: 'subnav-legacy.subnav.pedigree-link',
    className: visibleLinkClassName,
  },
  privatePeople: {
    page: 'private-people',
    'data-testid': 'nav-private-people',
    to: '/tree/private-people',
    external: true,
    wayfinding: true,
    linkName: 'Subnav: Private People',
    label: 'subnav-legacy.subnav.private-people-link',
    className: visibleLinkClassName,
  },
  recents: {
    page: 'recents',
    as: 'button',
    moreAs: ListItem,
    type: 'button',
    'data-testid': 'recents-button',
    label: 'subnav-legacy.subnav.recents-button',
    className: visibleLinkClassName,
  },
  researchTree: {
    page: 'research-tree',
    'data-testid': 'nav-researcher-groups',
    to: '/groups/research-tree',
    external: true,
    wayfinding: true,
    linkName: 'Subnav: Researcher Groups',
    label: 'subnav-legacy.researcher-trees.label',
    className: visibleLinkClassName,
  },
  researcherTreesFeedback: {
    page: 'researcher-trees-feedback',
    to: 'https://community.familysearch.org/en/group/338-researcher-trees-feedback-early-access',
    external: true,
    wayfinding: true,
    target: '_blank',
    label: 'subnav-legacy.give-feedback-researcher.label',
    listItemClassName: endClassName,
    className: linkClassName,
  },
}

// We might use collectionId from treeDetails for the findUrl in the future. Right now the formatting is different, so we hardcode it to 970
const COLLECTION_ID_IN_SEARCH_FORMAT = '970'

// Helper for rendering ITEMS objects as visible elements
function NavItem({ as: As = Link, label, ...props }) {
  const [t] = useTranslation()

  return <As {...props}>{t(label)}</As>
}

export default function SubNav({
  page = 'overview',
  fixedMaxWidth = false,
  showHelpOthers = false,
  readOnlyMode = false,
  className,
  onTreeNavClickOverride,
}) {
  const [t] = useTranslation()
  const { signedIn } = useUser()
  const [canAddPersonalData] = usePermission('CanAddPersonalDataPermission', 'FamilyTree')
  const recentsOverlay = useOverlay()
  const { canAccessFGT, canAccessCET, groups, currentTreeId, isResearcherGroup, isReadOnlyTree } = useGroupsContext()
  const { isOn: useFamilyTreeUrl } = useFeatureFlag('tree-overview_useFamilyTreeUrl')
  const [showTemple] = useShowTemple()
  ITEMS.overview.to = useFamilyTreeUrl ? `/${i18n.language}/family-tree/` : '/tree/overview/'
  const hasTrees = groups?.some(({ treeIds }) => Boolean(treeIds?.[0]))
  const canAccessGroups = canAccessFGT || canAccessCET
  const showGroupsNavigation = (canAccessGroups && hasTrees) || isReadOnlyTree

  // Nav items are included conditionally:
  const items = useMemo(() => {
    const navItems = []
    if (!showGroupsNavigation || page === 'overview') {
      navItems.push(ITEMS.overview)
    }
    navItems.push(ITEMS.pedigree)
    if (signedIn) {
      navItems.push({
        ...ITEMS.recents,
        // Add the onClick here since recentsOverlay is now in scope
        onClick: (event) => {
          trackEvent({ link_name: 'Tree Subnav: Recents' })
          recentsOverlay.handleClick(event)
        },
      })
    }
    navItems.push({
      ...ITEMS.find,
      to: `/search/tree${isResearcherGroup && currentTreeId ? `/${COLLECTION_ID_IN_SEARCH_FORMAT}/${currentTreeId}` : ''}?from=tree`,
    })
    navItems.push(ITEMS.following)
    navItems.push(ITEMS.privatePeople)
    if (!currentTreeId) {
      navItems.push(ITEMS.contributions)
    }
    // We show Family Groups for ordinance sharing even if the user is in a blocked FGT country unless they specifically "cannot add personal data" (Russians)
    if ((canAccessFGT || showTemple) && canAddPersonalData) {
      navItems.push(ITEMS.familyGroups)
    }
    if (canAccessCET) {
      navItems.push(ITEMS.researchTree)
    }

    if (showGroupsNavigation && currentTreeId && isResearcherGroup) {
      navItems.push(ITEMS.researcherTreesFeedback)
    }
    if (showHelpOthers && !currentTreeId) {
      navItems.push({
        ...ITEMS.helper,
        redirectUrl: `/tree/${page}`,
      })
    }

    return navItems
  }, [
    canAddPersonalData,
    showGroupsNavigation,
    page,
    signedIn,
    isResearcherGroup,
    currentTreeId,
    canAccessFGT,
    showTemple,
    canAccessCET,
    showHelpOthers,
    recentsOverlay,
  ])

  // Depending on how much room is available, some nav items will end up under
  // a "More" menu. We need refs to calculate various DOM element dimensions.
  const moreMenuOverlay = useMenuOverlay()
  const nav = useRef()
  const list = useRef()
  const moreListItem = useRef()

  // A count of how many list items will end up in the "More" menu.
  const [moreItemsCount, setMoreItemsCount] = useState(0)
  // When rendering list items, visibly hide any past this index.
  const lastVisibleIndex = items.length - 1 - moreItemsCount

  // These items will render in the "More" menu except the whats new button.
  const moreItems = items.slice(lastVisibleIndex + 1)

  const calculateMoreItems = useCallback(() => {
    if (nav.current && list.current && moreListItem.current) {
      // We need the "More" list item in the layout so we know its width.
      // CSS takes care of visually hiding it.
      moreListItem.current.hidden = false
      // Mark the list as calculating so we affect some other CSS.
      list.current.classList.add(listCalculatingClassName)

      // We will read list items starting at the end and working backwards.
      // This will help us short circuit the loop once we find the first item
      // that does not cause overflow.
      let previousItemFit
      // This will hold the new moreListItem value
      let newMoreItemsCount = 0

      // Reverse the list items so we start with the last one.
      const reversedListItemChildren = Array.from(list.current.children).reverse()

      // Ignore the "More" list item
      reversedListItemChildren.shift()

      // Calculating overflow depends on the text direction.
      const dir = window.getComputedStyle(nav.current).direction

      reversedListItemChildren.forEach((listItem, index) => {
        // Ignore the last item and short circuit if the previous item was not
        // overflowing.
        if (previousItemFit || index === reversedListItemChildren.length - 1) return

        // Include the "More" list item width when calculating overflow on all
        // but the last displayed item (i.e., first of this reversed array).
        const includedMoreListItemWidth = index > 0 ? moreListItem.current.offsetWidth : 0

        // Determine if there is overflow.
        if (
          (dir === 'rtl' && listItem.offsetLeft - includedMoreListItemWidth < 0) ||
          (dir === 'ltr' &&
            // The right side of the list item is greater than the available space:
            listItem.offsetLeft + listItem.offsetWidth >
              (listItem.offsetParent?.offsetWidth ?? Infinity) - includedMoreListItemWidth)
        ) {
          newMoreItemsCount++
        } else {
          previousItemFit = true
        }
      })

      // Hide the "More" menu if it will be empty
      if (newMoreItemsCount === 0) moreListItem.current.hidden = true

      // Save the new state.
      setMoreItemsCount(newMoreItemsCount)

      // We are done calculating.
      list.current.classList.remove(listCalculatingClassName)
    }
  }, [])

  // Listens for (debounced) changes in the nav's size.
  useResizeObserver(nav, debounce(calculateMoreItems, 150))

  return (
    <nav ref={nav} className={cx(navClassName, className)}>
      <ul
        ref={list}
        // Start out with listCalculatingClassName so the "More" menu is not
        // visible. `calculateMoreItems` will then remove this class name once
        // it finishes.
        className={cx(listClassName, listCalculatingClassName, fixedMaxWidth ? fixedMaxWidthClassName : undefined)}
      >
        {showGroupsNavigation && (
          <li className={groupsNavListItemClassName}>
            <GroupsNavigation
              page={page}
              onListItemClickOverride={onTreeNavClickOverride}
              disableNavigation={pagesWithDisabledNavigation.includes(page)}
            />
          </li>
        )}

        {/* Render all the list items so they are available to the accessibility
        API but visually hide the "More" list items. */}
        {items.map(({ page: itemPage, listItemClassName, moreAs, ...item }, index) => (
          <li
            key={itemPage}
            className={cx(
              visibleListItemClassName,
              listItemClassName,
              index > lastVisibleIndex ? visuallyHiddenClassname : undefined
            )}
          >
            <NavItem {...item} aria-current={itemPage === page ? 'page' : 'false'} />
          </li>
        ))}

        {/* Hide the "More" menu from the accessibility API */}
        <li ref={moreListItem} className={moreListItemClassName} aria-hidden="true">
          <MenuOverlay
            menuButton={
              <button type="button" className={visibleLinkClassName} onClick={moreMenuOverlay.handleClick}>
                {t('subnav-legacy.more.label')}
                <ArrowCaret direction="down" size="xs" />
              </button>
            }
          >
            {moreItems.map(
              ({
                as: As = ListItem,
                moreAs: MoreAs = As,
                label,
                page: itemPage,
                to,
                linkName,
                'data-testid': dataTestId,
                target,
                external,
                onClick,
              }) => (
                <MoreAs
                  key={itemPage}
                  primaryText={t(label)}
                  to={to}
                  target={target}
                  linkName={linkName}
                  data-testid={dataTestId}
                  selected={itemPage === page}
                  external={external}
                  onClick={onClick}
                />
              )
            )}
          </MenuOverlay>
        </li>

        <li className={endClassName}>
          <WhatsNew canAccessFGT={canAccessFGT} canAccessCET={canAccessCET} />
        </li>
      </ul>

      {(recentsOverlay.isOpen || recentsOverlay.transitioning) && (
        <Suspense fallback={null}>
          <RecentsListOverlay overlay={recentsOverlay} readOnlyMode={readOnlyMode} currentTreeId={currentTreeId} />
        </Suspense>
      )}
    </nav>
  )
}

// Stryker disable all
SubNav.propTypes = {
  /** Which page the user is on currently. This will control which tab is highlighted. */
  page: PropTypes.oneOf([
    'overview',
    'pedigree',
    'person',
    'find',
    'following',
    'contributions',
    'private-people',
    'family',
    'research-tree',
  ]).isRequired,

  /** Whether to show the "Help Others" link when possible */
  showHelpOthers: PropTypes.bool,

  /**
   * Whether to apply a 1440px max width and center the navigation.
   * @deprecated Please apply a max-width via CSS if needed. */
  fixedMaxWidth: PropTypes.bool,

  /** Determines if the "Recents" menu hides the "Add Connected Person" control. */
  readOnlyMode: PropTypes.bool,

  /** Override default on tree item click behavior; tree navigation menu overlay is still closed afterward.  */
  onTreeNavClickOverride: PropTypes.func,
}
