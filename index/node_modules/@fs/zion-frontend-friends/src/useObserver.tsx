import type { ElementType, ReactNode, RefObject } from 'react'
import React, { createContext, forwardRef, memo, useContext, useEffect, useMemo } from 'react'
import type { PolymorphicRef, PolymorphicComponentPropsWithRef } from '@fs/zion-ui'
import shallowEqual from './shallowEqual'
import useForwardRef from './useForwardRef'

type Observer = {
  observe: (whoDis: Element, whatDoShow: (entry: IntersectionObserverEntry) => void, whatDoFat: () => void) => void
  unObserve: (whoDis: Element) => void
  setOptions: (options: IntersectionObserverInit) => void
  updateWidth: () => void
}

const makeObserver = (): Observer => {
  const intersectRegistry = new Map<Element, (entry: IntersectionObserverEntry) => void>()
  const resizeRegistry = new Map<Element, () => void>()
  const intersections = new Set<Element>()
  const intersectCallback = (entries: IntersectionObserverEntry[]): void => {
    entries.forEach((entry) => {
      const whoDis = entry.target
      const whatDo = intersectRegistry.get(whoDis)
      if (whatDo) {
        whatDo(entry)
      }
      if (entry.isIntersecting) {
        intersections.add(entry.target)
      } else {
        intersections.delete(entry.target)
      }
    })
  }
  let intersectObserver: IntersectionObserver | null = null
  let currentOptions: IntersectionObserverInit
  return {
    observe: (whoDis, whatDoShow, whatDoFat) => {
      intersectRegistry.set(whoDis, whatDoShow)
      intersectObserver?.observe(whoDis)

      resizeRegistry.set(whoDis, whatDoFat)
    },
    unObserve: (whoDis) => {
      intersectRegistry.delete(whoDis)
      intersectObserver?.unobserve(whoDis)

      resizeRegistry.delete(whoDis)
      intersections.delete(whoDis)
    },
    // NOTE: We use this when a new observer is made. The old observer applies the options to the new one.
    setOptions: (newOptions) => {
      if (!shallowEqual<IntersectionObserverInit>(currentOptions, newOptions)) {
        intersectObserver?.disconnect()
        intersectObserver = new IntersectionObserver(intersectCallback, {
          ...newOptions,
          root: newOptions?.root || null,
        })
        currentOptions = newOptions
        intersectRegistry.forEach((_, entry) => {
          intersectObserver?.observe(entry)
        })
      }
    },

    updateWidth: () => {
      intersections.forEach((target) => {
        const whatDoFat = resizeRegistry.get(target)
        if (whatDoFat) {
          whatDoFat()
        }
      })
    },
  }
}

const ObserverContext = createContext<Observer>(null)

export const ObserverRootContext = createContext<RefObject<Element>>(null)

type Props = Partial<IntersectionObserverInit> & {
  children: ReactNode
}

type ObservableComponentProps<C extends ElementType> = PolymorphicComponentPropsWithRef<C, Props>

const ObservableComponent = forwardRef(
  <C extends ElementType = 'div'>(
    { as, children, threshold = 0.01, rootMargin, ...props }: ObservableComponentProps<C>,
    ref: PolymorphicRef<C>
  ): JSX.Element => {
    const TagName = as || 'div'
    const observableRoot = useContext(ObserverRootContext)
    const observer = useMemo(() => makeObserver(), [])
    const widthRef = useForwardRef(ref)
    useEffect(() => {
      observer.setOptions({ root: observableRoot?.current, threshold, rootMargin })
    }, [observableRoot, threshold, observer, rootMargin])
    useEffect(() => {
      const resizeObserver = new ResizeObserver(() => observer.updateWidth())
      resizeObserver.observe(widthRef.current as Element)
      return () => resizeObserver.disconnect()
    }, [observer, widthRef])
    return (
      <TagName ref={widthRef} {...props}>
        <ObserverContext.Provider value={observer}>{children}</ObserverContext.Provider>
      </TagName>
    )
  }
)

ObservableComponent.displayName = 'Observable'

export const Observable = memo(ObservableComponent)

const noOp = (): void => undefined

export const useObserver = (
  ref: RefObject<Element>,
  intersectCallback: (entry: IntersectionObserverEntry) => void,
  resizeCallback: () => void = noOp
): void => {
  const observer = useContext(ObserverContext)
  useEffect(() => {
    const elem = ref.current
    if (elem) {
      observer.observe(elem, intersectCallback, resizeCallback)
    }
    return () => {
      if (elem) observer.unObserve(elem)
    }
  }, [ref, intersectCallback, resizeCallback, observer])
}
