import type { RefObject } from 'react'
import { useEffect } from 'react'
import { useEvent } from '../useStable'

export type MutationListener = (record: MutationRecord) => void

const DEFAULT_CONFIG: MutationObserverInit = {
  childList: true,
  subtree: true,
}

// Allowing multiple listeners for any given dom node.
const mutationRegistry = new Map<Node, MutationListener[]>()

const callAllCallbacks = (records: MutationRecord[]): void => {
  records.forEach((record) => {
    const { target } = record
    let callbacks = mutationRegistry.get(target)

    // if the target is not in the map, go up the DOM to see if we are
    // listening to an ancestor
    if (!callbacks) {
      let pointedTarget = target
      while (!callbacks && pointedTarget.parentElement) {
        pointedTarget = pointedTarget.parentElement
        callbacks = mutationRegistry.get(pointedTarget)
      }
    }
    callbacks?.forEach((callback) => callback(record))
  })
}

let mutationObserver: MutationObserver

export default function useMutationObserver(
  ref: RefObject<HTMLElement>,
  mutationCallback: MutationListener,
  enabled = true,
  config: MutationObserverInit = DEFAULT_CONFIG
): void {
  if (!mutationObserver && typeof MutationObserver !== 'undefined') {
    mutationObserver = new MutationObserver(callAllCallbacks)
  }

  const handleMutation = useEvent<MutationListener>((...args) => ref.current && mutationCallback(...args))

  useEffect(() => {
    const { current } = ref

    if (!enabled || !mutationObserver || !current) return undefined

    mutationObserver.observe(current, config)

    let callbacks = mutationRegistry.get(current)

    // May need to initialize the registry spot with an empty array
    if (!callbacks) {
      callbacks = []
      mutationRegistry.set(current, callbacks)
    }

    // Finally, add the callback to the array of callbacks
    callbacks.push(handleMutation)

    return () => {
      // Throw away the provided callback, keep any others that might exist
      const newCallbacks = mutationRegistry.get(current)?.filter((cb) => cb !== handleMutation)

      // Update the registry with the new list, or just disconnect if there are no other callbacks
      if (newCallbacks?.length) {
        mutationRegistry.set(current, newCallbacks)
      } else {
        mutationRegistry.delete(current)
        if (mutationRegistry.size === 0) {
          mutationObserver.disconnect()
        }
      }
    }
  }, [ref, handleMutation, enabled, config])
}
