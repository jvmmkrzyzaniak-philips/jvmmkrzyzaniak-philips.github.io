import { i18n } from '@fs/zion-locale'
import zionDebug from '@fs/zion-debug'
import { appConfig } from '@fs/zion-config'

const debug = zionDebug('zion:router:localeCodeInPath')

export const langCodePathRegex = /^\/(?<localeCode>[a-z]{2,3}(-[a-zA-Z0-9-]*)?)\// // Copied from DTM haproxy config MATCH_root_lang_path_with_slash acl
const langCodePathExceptionRegex =
  /^\/(api|ask|bff|brb|cas|cis|cmn|das|dc|dna|dz|eng|fb|fhc|fs|fst|hf|lol|oss|paf|pgs|tem|tf)($|\/|-)/ // copied from prod dtm haproxy config in engineering tools

const nonHttpProtocols = [
  'mailto:',
  'tel:',
  'sms:',
  'smsto:',

  // Deliberately leaving these out because we don't anticipate people using them.
  // but I wanted to include them here for the sake of completeness. Also not allowing
  // custom protocols, as it would over complicate our logic:
  //   'javascript:',
  //   'bitcoin:',
  //   'ftp:',
  //   'ftps:',
  //   'geo:',
  //   'im:',
  //   'irc:',
  //   'ircs:',
  //   'magnet:',
  //   'matrix:',
  //   'mms:',
  //   'news:',
  //   'nntp:',
  //   'openpgp4fpr:',
  //   'sftp:',
  //   'sip:',
  //   'ssh:',
  //   'urn:',
  //   'webcal:',
  //   'wtai:',
  //   'xmpp:',
]

const hasWindow = typeof window !== 'undefined'

const pathsThatGetTheQueryLocale = appConfig?.LANG_QUERY_PARAM_PATHS?.split(',') || [
  '/ark:/61903/',
  '/africa',
  '/pacific',
  '/auth/', // All auth routes have a trailing slash
]

const subdomainsExceptions = appConfig?.LANG_CODE_SUBDOMAIN_EXCEPTIONS?.split(',') || ['cms-b-assets', 'cms-z-assets']

const pwasPaths = appConfig?.PWA_PATHS?.split(',') || ['/africa', '/pacific']

const getLangParamFromWindowLocation = () => {
  if (!hasWindow) {
    return null
  }
  const params = new URLSearchParams(window.location.search)
  return params.get('lang')
}

const shouldAddQuery = (path, external) => {
  const windowLocationOnPwaPath = hasWindow
    ? pwasPaths.some((pwaException) => window.location?.pathname?.startsWith(pwaException))
    : false

  // if the url is currently on a PWA, and we are an internal link, then we need to KEEP the query param, no matter what
  // the "to" prop is. If they need to Link to a url with the lang prefixed, then they'll have to use the external prop
  if (!external && windowLocationOnPwaPath) {
    return true
  }

  const pathIsException = pathsThatGetTheQueryLocale.some((exception) => path.startsWith(exception))
  return pathIsException
}

const urlLangOverrides = {
  zh: 'zh-Hant',
  'zh-hant': 'zh-Hant',
  'zh-hans': 'zh-Hans',
}

// MODIFIED from the one in ZionAxios. I couldn't use one that because we handle relative routes differently here
function checkIsFSDomain(hostname) {
  if (hostname === 'localhost') return true

  return (
    hostname.endsWith('.familysearch.org') ||
    hostname === 'familysearch.org' ||
    hostname.endsWith('.researchllm.org') || // Full Text translation service set up by Richard Chesworth and Christian Hargraves. Contact RIP team.
    hostname === 'researchllm.org'
  )
}

/**
 * Util to return the lang code from the beginning of a path
 * @param {string|URL} [rawUrl] -- The URL you wish to grep the language code from. Defaults to `window.location`
 * @returns {string|null} -- the language code found in the url, or null if not found
 */
export function getLangCodeFromUrl(rawUrl, external) {
  debug('getLangCodeFromUrl start', rawUrl?.toString())
  let url = rawUrl ?? (typeof window !== 'undefined' ? new URL(window.location) : '/') // default to the window path

  if (url instanceof URL) {
    url = new URL(url) // copy the URL for later mutation
  }

  if (typeof url === 'string') {
    if (url.startsWith('http')) {
      url = new URL(url)
    } else {
      url = new URL(url, window.location.origin)
    }
  }
  if (!url.pathname.endsWith('/')) {
    url.pathname += '/' // append slash if not given
  }

  const isQueryException = shouldAddQuery(url.pathname, external)
  if (isQueryException) {
    return url.searchParams.get('lang') || (!external && getLangParamFromWindowLocation()) || null
  }

  return (
    (!url.pathname.match(langCodePathExceptionRegex) && url.pathname.match(langCodePathRegex)?.groups?.localeCode) ||
    null
  )
}

/**
 * When langCodeInUrl is true, prepend the locale code to the to path, but only if the
 * consumer hasn't already put it in. Exceptions get a `?locale=<locale>` query param.
 * @param {object} [props]
 * @param {string} [props.to] -- The path or url we want to modify
 * @param {boolean} [props.external] -- Whether the path is an external route
 * @param {boolean} [props.enabled] -- Enable the lang code to be prepended
 * @returns {string}
 */
export function ensureLocaleCodeInUrl({ to: givenTo, external, enabled }) {
  debug('ensureLocaleCodeInUrl start', { type: typeof givenTo, givenTo: givenTo?.toString(), external, enabled })
  let to = givenTo // copying because we mutate later

  if (canSkipLocaleCodeInUrl(givenTo, external, enabled)) {
    return givenTo
  }

  if (to instanceof URL) {
    to = ensureLocaleCodeWithUrl(to, external)
  } else if (to.startsWith('http')) {
    // absolute URL string
    const newUrl = ensureLocaleCodeWithUrl(new URL(to), external)
    to = newUrl.toString()
  } else {
    // relative path
    if (!to.startsWith('/')) {
      to = `/${to}` // prepend slash if not given
    }
    const newUrl = ensureLocaleCodeWithUrl(new URL(to, window.location.origin), external)
    to = `${newUrl.pathname}${newUrl.search}${newUrl.hash}`
  }

  debug('ensureLocaleCodeInUrl end', to)
  return to
}

/**
 *
 * @param {URL} url -- A URL object that will be modified to have the correct language code
 * @returns -- the modified URL object with the correct language code
 */
function ensureLocaleCodeWithUrl(url, external) {
  const urlLang = getLangCodeFromUrl(url, external)
  const isQueryException = shouldAddQuery(url.pathname, external)
  debug('ensureLocaleCodeWithUrl start', { url: url.href, urlLang, isQueryException })
  if (!urlLang) {
    const urlLangCode = getLangParamFromWindowLocation() || urlLangOverrides[i18n.language] || i18n.language
    debug('ensureLocaleCodeWithUrl without lang code. new code:', urlLangCode)
    if (isQueryException) {
      url.searchParams.set('lang', urlLangCode)
    } else {
      url.pathname = `/${urlLangCode}${url.pathname}`
    }
  } else {
    // fix the url lang if it is incorrect
    const urlLangCode = urlLangOverrides[urlLang.toLocaleLowerCase()] ?? urlLang
    debug('ensureLocaleCodeWithUrl fix lang code', { url: url.href, urlLang, isQueryException, urlLangCode })
    if (isQueryException) {
      url.searchParams.set('lang', urlLangCode)
    } else {
      url.pathname = url.pathname.replace(new RegExp(`^/${urlLang}($|/$)`), `/${urlLangCode}/`)
    }
  }
  debug('ensureLocaleCodeWithUrl end', url.href)
  return url
}

function canSkipLocaleCodeInUrl(to, external, enabled) {
  if (!enabled) {
    return true
  }

  // to can be a object or function https://reacttraining.com/react-router/web/api/Link
  if (!to || !(typeof to === 'string' || to instanceof URL)) {
    return true
  }

  let path = to
  if (to instanceof URL) {
    path = to.pathname
  }

  if (path.startsWith('#') || nonHttpProtocols.some((protocol) => path.startsWith(protocol))) {
    return true
  }

  const isFullUrl = path.startsWith('http')
  const url = isFullUrl ? new URL(path) : null
  const isFSDomain = isFullUrl ? checkIsFSDomain(url.hostname) : true
  const isQueryException = shouldAddQuery(isFullUrl ? url.pathname : path, external)
  debug('canSkipLocaleCodeInUrl', !(external || (isFullUrl && isFSDomain) || isQueryException), {
    path,
    external,
    enabled,
    isFullUrl,
    isFSDomain,
    isQueryException,
  })

  // any absolute path that is not an FSDomain should be skipped for locale code in url
  if (isFullUrl && !isFSDomain) {
    return true
  }

  // certain special subdomains of familysearch need to be excluded from adding lang codes
  // that list will be defined in fs-webdev/fs-config called FS_CLIENT_APP_LANG_CODE_SUBDOMAIN_EXCEPTIONS
  // https://icseng.atlassian.net/browse/LANGURLS-433
  if (
    isFullUrl &&
    isFSDomain &&
    subdomainsExceptions.some((subdomainException) => url.hostname.startsWith(subdomainException))
  ) {
    return true
  }

  // We only want to mutate paths that are absolute
  // External paths, and full URLs are absolute
  // Also our exceptions, like arks and auth need
  // to be handled to get the query param
  if (!(external || (isFullUrl && isFSDomain) || isQueryException)) {
    return true
  }

  return false
}

/**
 *
 * @param {string|URL} [url] -- The URL to be augmented with a language code
 * @returns {string} -- the url with the lang code prepended or in lang query param
 */
export function buildLangUrl(url, external = true) {
  if (!url || url?.length === 0) {
    throw new Error('buildLangUrl requires a valid url, received no url or an empty string')
  }
  debug('buildLangUrl', url?.toString(), typeof url)

  return ensureLocaleCodeInUrl({ to: url, enabled: true, external })
}
