import { useCallback } from 'react'
import { useHistory as useHistoryOrig } from 'react-router-dom'

import zionDebug from '@fs/zion-debug'
import { useMemoryRouterContext } from './memory-router-context'
import { useRoutesContext } from './routes-context'

const debug = zionDebug('zion:router:useHistory')

/**
 * This is a wrapper for react router's useHistory() so we can have the new function history.pushWhenLocal().
 * The Frontier react stack is architected with multiple servers (apps), and every link could potentially go to the same
 *  app or a different app.
 * For a zion component to conditionally render on the same page once it has been installed in your app, you'll want to
 *  set up a "handledExternalRoutes" array,
 * listing which of these paths should be routed locally within your app.
 *
 * This hook-wrapper's pushWhenLocal function will decide whether to use React Router's history.push() or the browser's
 *   window.location.assign() to render the next page.
 * The advantages of using React Router to render pages hosted by your app include:
 * - The user saves time waiting for the round-trip to our data centers when rerouting
 * - The server does not get another hit for the new route
 *
 * @returns {{createHref(location: LocationDescriptorObject<LocationState>): Href, goBack(): void, length: number, replace(location: (Path | LocationDescriptor<LocationState>), state?: LocationState): void, go(n: number): void, action: Action, location: Location<LocationState>, goForward(): void, block(prompt?: (boolean | string | TransitionPromptHook<LocationState>)): UnregisterCallback, push(location: (Path | LocationDescriptor<LocationState>), pushWhenLocal(location: (Path | LocationDescriptor<LocationState>), state?: LocationState): void, listen(listener: LocationListener<LocationState>): UnregisterCallback}}
 */
export default function useHistory() {
  const history = useHistoryOrig()
  const isInMemoryRouter = useMemoryRouterContext()
  const routesContext = useRoutesContext()

  /**
   * history.push() or window.location.assign() depending on whether the path is in the handleExternalRoutes path
   *
   * @param {string|object} path - the new path to visit
   * @param {object} [state] - any path state (should be null if path is an object)
   */
  const pushWhenLocal = useCallback(
    (path, state) => {
      // If the app has NOT marked this route as a "handledExternalRoutes,"
      // and the zion component is set up to handle it externally outside its owning app
      const nonAppRoute = !routesContext?.shouldRouteLocally(path)

      // if we need to route to a new app, we use window.location.assign to bypass the router and go all the way to the server.
      // For backwards compatibility with react-router, we only do this if the user uses the "external" parameter here.
      if (nonAppRoute && !isInMemoryRouter) {
        debug(
          'redirecting to ',
          path,
          'using window.assign because',
          !isInMemoryRouter && 'not inside a memory router',
          nonAppRoute && `${path} is external and should not route locally`
        )
        window.location.assign(path)
        return
      }

      // Route this one locally...
      // Relative URLs are routed using React Router. Fully qualified URLs are routed using the browser router.
      history.push(routesContext?.removeBase(path), state)
    },
    [history, isInMemoryRouter, routesContext]
  )

  // History won't exist if its context does not exist yet.
  // This can happen sometimes in Cypress component tests that don't have a router.
  if (history) {
    // NOTE: Spreading history to copy doesn't work well because of how history works, so here I just add a function to
    // the original history object.

    history.pushWhenLocal = pushWhenLocal
  }

  return history
}
