/** *****************************************************************************
 *     FEATURE : Link
 *  MAINTAINER : Frontier Core | Zion UI Team
 * ==============================================================================
 *
 * Links are the canonical replacement for the anchor tag. It should be usable
 * wherever one might use an anchor, and support the same attributes.
 *
 * We have chosen to extend the React Router Link component. This is to allow for
 * all the great things that come with client-side routing, but adapted to better
 * support our routing needs; namely, to allow for external and internal routes.
 *
 * "Internal" routes are URLs that link to items within the current application.
 * "External" routes are URLs that link within the the FS domain, but are under
 * a different app. For example, `/tree/person` is internal when on the Person
 * Page, but external in the Temple app.
 *
 * All routes outside of the FamilySearch domains are considered external.
 *
 * ------------------------------------------------------------------------------
 * RESOURCES
 * - React Router Docs: https://v5.reactrouter.com/web/guides/quick-start
 * - Accessibility patterns, including keyboard behaviors, are outlined under:
 *     https://www.w3.org/WAI/ARIA/apg/patterns/link/
 *
 * ------------------------------------------------------------------------------
 * CONTEXT AND CONSIDERATIONS
 *
 * Since Links are the replacement for anchor tags, they have a myriad of places
 * they are (and will be) used. Styling often changes for each use case. This
 * component allows for flexible styling to fit those use cases (via className
 * and noLinkStyles). It should be known that there are some minor styles applied
 * inside of the globalStyles.js file that effect the underlying anchor tag.
 *
 * ZionUI uses Link in many components internally. There they override the styles
 * and expose all the "linkable" props to the consumer. Styling varies between
 * components, but the paradigm of WhiteText is honored by Link too.
 *
 * As a side-effect, clicking a link with linkName defined will result in a call
 * to the analytics service.
 *
 * Another side-effect is (by default) the page will scroll to the top of the
 * window upon visiting an internal link.
 *
 * Since links are interchangeable with anchor tags, they have a large number of
 * requirements for accessible usages. Complex requirements, like in MenuOverlay,
 * are (or should be) documented inline to their usages.
 *
 * The only special case we handle here is with MemoryRouter. When used in that
 * context, we swap out the anchor for a button element. This is to align with
 * the recommendations found in the spec.
 *   > If pressing the link triggers an action but does not change page location,
 *     authors are advised to consider using the button role instead
 *   See: https://w3c.github.io/aria/#link
 *
 * ------------------------------------------------------------------------------
 * ADDITIONAL INFORMATION
 *
 * It should be noted that some normalization is made to the `to` prop value to
 * optimize for client routing where possible. This is so that when consumers
 * set something like `https://www.familysearch.org/tree/person/PID/`, the value
 * is re-written to `/tree/person/PID` when under the production environment for
 * to allow ReactRouter the option of handling the route as "internal".
 ***************************************************************************** */

import React, { forwardRef, useContext } from 'react'
import PropTypes from 'prop-types'
import { css, cx } from '@linaria/core'
import { colors } from '@fs/zion-ui'
import { WhiteThemeContext } from '@fs/zion-ui/quarks-authorized-use-only'
import { Link as RouterLink, useLocation, useHistory } from 'react-router-dom'
import { trackLink } from '@fs/zion-analytics'
import { boolAttr } from '@fs/zion-frontend-friends'
import { createLocation } from 'history'
import { useFeatureFlag } from '@fs/zion-flags'
import { ensureLocaleCodeInUrl } from './localeCodeInPath'
import { useMemoryRouterContext } from './memory-router-context'
import { useRoutesContext } from './routes-context'

const hasWindow = typeof window !== 'undefined'
const hasDocument = typeof document !== 'undefined'

const linkCss = css`
  /* These 4 lines are needed for when the Link is coerced into a button element */
  border: inherit;
  background-color: inherit;
  padding: 0;
  font-size: inherit;

  color: ${colors.transparent.blue60};
  text-decoration: underline;
  text-decoration-line: underline;
  text-underline-offset: 0.08em;
  text-decoration-thickness: 0.08em;

  &:hover {
    // TODO: I think we should play around with changing the background color just slightly on hover rather than this
    // see https://www.google.org/ and look at their inline links
    color: ${colors.transparent.blue80};
  }
  &:focus-visible {
    outline: solid currentcolor;
    outline-width: 3px;
    outline-offset: 3px;
    border-radius: 2px;
  }
  &[is-gray] {
    color: ${colors.gray100};
  }

  &:visited:not([wayfinding]):not([iswhite]) {
    color: ${colors.transparent.red60};
    text-decoration-color: ${colors.transparent.red30};
    &:hover,
    &:focus {
      color: ${colors.transparent.red80};
      text-decoration-color: ${colors.transparent.red80};
    }
  }

  &[iswhite] {
    color: ${colors.gray100};
    text-decoration-color: ${colors.transparent.gray70};
    transition:
      color 0.3s,
      border-color 0.3s;
    &:hover,
    &:focus {
      text-decoration: none;
      color: ${colors.gray60};
    }
  }
`

const onlyUnderlineOnHoverCss = css`
  text-decoration-color: transparent;
  transition: text-decoration-color 0.3s;

  &:hover,
  &:focus-visible,
  a:hover &,
  a:focus-visible &,
  button:hover &,
  button:focus-visible & {
    text-decoration-color: currentcolor;
  }
`

export const normalizeUrl = (to) => {
  // to can be a object or function https://reacttraining.com/react-router/web/api/Link
  const toIsString = typeof to === 'string'
  const isFullUrl = toIsString && to.match(/^https?:\/\//)

  if (!toIsString || !isFullUrl) return to

  const currentOrigin = hasWindow && window.location.origin
  const { origin } = new URL(to)

  // if full url is on the same subdomain, change to relative path so we can route on the client
  return origin === currentOrigin ? to.split(origin)[1] : to
}

// the next 2 functions were copied out of the locationUtils file that the react-router-dom uses to resolve it's links.
// https://github.com/ReactTraining/react-router/blob/e951e1d78edacbdf72c458e97938f92da3a43512/packages/react-router-dom/modules/utils/locationUtils.js
const resolveToLocation = (to, currentLocation) => (typeof to === 'function' ? to(currentLocation) : to)
const normalizeToLocation = (to, currentLocation) => {
  return typeof to === 'string' ? createLocation(to, null, null, currentLocation) : to
}

const RouterLinkWrapper = forwardRef(
  ({ to, linkClick, noLinkStyles, children, wayfinding, className, external, ...rest }, ref) => {
    const location = useLocation()
    const history = useHistory()
    let endHref = to
    const isInMemoryRouter = useMemoryRouterContext()

    // Although we don't allow for the disabled attribute in links yet, we want to
    // support disabled Buttons with a `to` prop. Button disables the navigation
    // event for normal Links, but we need to check for it here too in the case
    // that we are inside of a MemoryRouter. Otherwise, the Link will still
    // navigate to the route even though the Button is disabled.
    const isDisabled = rest['aria-disabled'] === 'true'

    // external inside this component means it should be routed to the BrowserRouter
    // Also, they should be rendered as anchor tags always since they will not be handled
    // by the MemoryRouter.
    const El = isInMemoryRouter && !external ? 'button' : RouterLink
    const linkProps =
      El !== 'button'
        ? {
            to,
            wayfinding: boolAttr(wayfinding),
          }
        : {}

    // we care about external here because external links handled by the client router go through here now.
    if (!external) {
      const urlLocation = normalizeToLocation(resolveToLocation(to, location), location)
      endHref = urlLocation ? history.createHref(urlLocation) : ''
    }

    return (
      <El
        onClick={(e) => {
          linkClick(e, endHref)

          // If in MemoryRouter, we want to push the to MemoryRouter's history so that it gets routed to the parent BrowserRouter
          // if in a handledExternalRoute. But we ignore the history.push if cmd or ctrl are down (opening in a new tab) so we don't
          // kick the user out of a dialog overlay flow.
          if (!isDisabled && isInMemoryRouter && !(e.metaKey || e.ctrlKey || rest.target === '_blank')) {
            const action = rest.replace ? 'replace' : 'push'
            history[action](to)
            rest.onClick?.(e)
          }
        }}
        className={cx(className, noLinkStyles ? undefined : linkCss)}
        no-link-styles={boolAttr(noLinkStyles)}
        {...linkProps}
        {...rest}
        ref={ref}
      >
        {children}
      </El>
    )
  }
)

export const Link = forwardRef(
  (
    {
      to,
      external,
      action = 'click_action',
      linkName,
      children,
      onClick,
      noScrollTop = false,
      wayfinding = false,
      className,
      isGray,
      noPrependLocaleCode = false,

      /** [HIDDEN]: For internal Zion-UI use only */
      noLinkStyles,
      ...rest
    },
    ref
  ) => {
    const routesContext = useRoutesContext()
    // to can be a object or function https://reacttraining.com/react-router/web/api/Link
    const toIsString = typeof to === 'string'
    const isFullUrl = toIsString && to.match(/^https?:\/\//)
    const isInMemoryRouter = useMemoryRouterContext()

    let url = ensureLocaleCodeInUrl({
      to: normalizeUrl(to),
      external: external || isFullUrl, // normalizeUrl strips off everything but the path (but not if it is a different origin), but full urls are external by definition
      enabled:
        useFeatureFlag('shared_addLangCodeToUrl')?.isOn && !noPrependLocaleCode && !routesContext?.langCodeInUrlOptOut,
    })

    // if Link has external prop but the BrowserRouter says it should handle this path
    const shouldRouteLocally = external && !routesContext?.shouldRouteLocally(url)

    // if routesContext doesn't exist (outside zion router), Links are forced to be external
    // downloads are also forced to be external
    const isExternal = isFullUrl || rest.download || shouldRouteLocally

    // Needed so the base isn't added onto absolute relative paths.
    // e.g. to="/tree/person/MMM-MMMM" would turn into "/tree/person/tree/person/MMM-MMMM"
    // If in memory router, we'll do this in the RouteToParentRouter component (TW-4769)
    if (!isExternal && external && !isInMemoryRouter) {
      url = routesContext?.removeBase(url)
    }

    const isWhite = useContext(WhiteThemeContext)

    // TODO: what do we want to do about local development? How/where should it link to?
    // TODO: make a stand alone function to create the URL itself, expose it, and use it here as well
    // TODO: what if I forget to put a leading '/' ?
    // TODO: What if I want this to be relative? Is that a thing, or not allowed?
    // TODO: Language prefix is happening sometime, right?

    const linkClick = (event, urlToTrack) => {
      const forceNoScroll = event.metaKey || event.ctrlKey

      if (!isExternal && !noScrollTop && !forceNoScroll && hasDocument) {
        document.getElementById('app-content-scroller')?.scrollTo?.(0, 0)
        window?.scrollTo?.(0, 0)
      }
      if (linkName) {
        trackLink(null, urlToTrack, action, linkName)
      }
      onClick?.(event)
    }

    if (isExternal) {
      return (
        <a
          href={url}
          onClick={(e) => linkClick(e, url)}
          ref={ref}
          className={cx(className, noLinkStyles ? undefined : linkCss)}
          no-link-styles={boolAttr(noLinkStyles)}
          wayfinding={boolAttr(wayfinding)}
          iswhite={boolAttr(isWhite)}
          is-gray={boolAttr(isGray)}
          {...rest}
        >
          {children}
        </a>
      )
    }
    return (
      <RouterLinkWrapper
        to={url}
        linkClick={linkClick}
        ref={ref}
        className={className}
        noLinkStyles={noLinkStyles}
        wayfinding={wayfinding}
        external={external}
        iswhite={boolAttr(isWhite)}
        is-gray={boolAttr(isGray)}
        {...rest}
      >
        {children}
      </RouterLinkWrapper>
    )
  }
)
export default Link

Link.propTypes = {
  /**
   * Path to the route.
   * Example: to="/frontier/app/react".
   * See https://reacttraining.com/react-router/web/api/Link for all options.
   */
  to: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object]).isRequired,

  /** For using Link outside of the Router. This prop is not needed for full urls. */
  external: PropTypes.bool,

  /** Action you'd like to see for this link on the analytics dashboard */
  action: PropTypes.string,

  /**
   * If specified, and analytics is enabled for the react app, then analytics click metrics
   * will be sent. The metrics will contain the specified value, which will be available in
   * analytics reports.
   */
  linkName: PropTypes.string,

  /** Optional way to also add an onclick to your link */
  onClick: PropTypes.func,

  /**
   * If true this will prevent the page from scrolling to the top when clicked. Only works
   * on internal links.
   */
  noScrollTop: PropTypes.bool,

  /** When set to true, the link will always be the primary link color even when visited */
  wayfinding: PropTypes.bool,

  /** When set to true the link will display as gray with an underline */
  isGray: PropTypes.bool,

  /**
   * Set to true to opt out of putting the locale code in the url. Most case are handled
   * automatically, this is for cases that aren't already accounted for. You shouldn't
   * need this for ark or auth routes, for example, but rather legacy systems that don't
   * support the locale prefix. This is only needed if your route is external.
   */
  noPrependLocaleCode: PropTypes.bool,
}

/**
 * Sometimes we need something to look like a link, but not be a link!
 * Why? Because. Stop asking questions. This isn't the component for you anyway.
 *
 * No, but seriously. It's because we're using this in things like RecordBlock, where
 * we don't want to underline EVERYTHING. We just want to underline the name part of
 * the block.
 */
export const LinkImposter = ({ className, children, onlyUnderlineOnHover = false, gray = false, props }) => (
  <span
    className={cx(linkCss, className, onlyUnderlineOnHover && onlyUnderlineOnHoverCss)}
    is-gray={boolAttr(gray)}
    {...props}
  >
    {children}
  </span>
)
