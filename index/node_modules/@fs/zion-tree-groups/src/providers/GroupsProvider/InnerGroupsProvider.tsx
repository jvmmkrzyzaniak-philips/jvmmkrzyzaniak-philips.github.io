import type { ReactNode } from 'react'
import React, {
  useRef,
  useReducer,
  useEffect,
  createContext,
  useContext,
  useState,
  useMemo,
  lazy,
  Suspense,
  useCallback,
} from 'react'
import { useQueryParams } from '@fs/zion-router'
import { useEvent } from '@fs/zion-frontend-friends'
import { exhaustiveCheck } from '@fs/zion-tree-types'
import { useFeatureFlag } from '@fs/zion-flags'
import { useOverlay } from '@fs/zion-ui'
import type { GroupSummary, TreeDetails, TreeId } from '@fs/zion-tree-types'
import LoadingSpinner from './LoadingSpinner'
import { queryTreeIdStr } from './utils'
import { getGroups, setSessionTree, getTreeDetails } from '../../services/cacheGroupCalls'
import type { GroupsValue } from '../../types/groups'
import { setPreferredTree, usePreferredTree } from '../../services/preferredTree'
import SetMePersonOverlayProvider from './SetMePersonOverlayProvider'

const GroupsChooseOverlay = lazy(
  () => import('../../components/_flows/family-group-starting-person/GroupsChooseOverlay')
)

const GroupContext = createContext<Partial<GroupsValue>>({})

export const useGroupsContext = (): Partial<GroupsValue> => {
  return useContext(GroupContext)
}

type ReducerState = {
  loadingGroups: boolean
  currentTreeId: TreeId | 'PRIVATE' | undefined
  treeDetails: TreeDetails | undefined
  isReadOnlyTree?: boolean
  groups: GroupSummary[]
}

type SetGroupsAction = { type: 'SET_GROUPS'; groups: GroupSummary[] }
type SetCurrentTreeIdAction = {
  type: 'SET_CURRENT_TREE_ID'
  currentTreeId: TreeId | 'PRIVATE'
  treeDetails: undefined | TreeDetails
}
type SetTreeDetailsAction = { type: 'SET_TREE_DETAILS'; treeDetails: undefined | TreeDetails }

type ReducerAction = Partial<ReducerState> & (SetGroupsAction | SetCurrentTreeIdAction | SetTreeDetailsAction)

const initialState = {
  loadingGroups: true,
  currentTreeId: undefined,
  treeDetails: undefined,
  groups: [],
} satisfies ReducerState

const reducer = (
  state: ReducerState,
  { type, currentTreeId, groups, treeDetails, isReadOnlyTree }: ReducerAction
): ReducerState => {
  switch (type) {
    case 'SET_TREE_DETAILS': {
      return { ...state, treeDetails }
    }
    case 'SET_GROUPS': {
      return { ...state, loadingGroups: false, groups }
    }
    case 'SET_CURRENT_TREE_ID': {
      return { ...state, currentTreeId, treeDetails, isReadOnlyTree }
    }

    default:
      return exhaustiveCheck(type)
  }
}

type InnerGroupsProviderProps = {
  cetPrefIsOn: boolean | undefined
  canAccessFGT: boolean | undefined
  canAccessCET: boolean | undefined
  children: ReactNode
  LoadingComponent?: () => JSX.Element
  treeIdOverride?: TreeId | 'PRIVATE'
}

export const InnerGroupsProvider = ({
  cetPrefIsOn,
  canAccessFGT,
  canAccessCET,
  children,
  LoadingComponent,
  treeIdOverride,
}: InnerGroupsProviderProps): JSX.Element => {
  const isCurrent = useRef(true)
  const { query, removeQuery } = useQueryParams({ replaceState: true })
  const treeIdQuery = query[queryTreeIdStr]

  const [{ currentTreeId, groups, loadingGroups, treeDetails, isReadOnlyTree }, dispatch] = useReducer(
    reducer,
    initialState
  )
  // Split is source of truth for whether the feature flag is on, informed with user preference.
  // Permission being false (can't access) trumps Split.
  const { isOn: cetFlagIsOn } = useFeatureFlag('treeWeb_researcherTrees', {
    pref: Boolean(cetPrefIsOn),
  })

  // If a user has a CET group, we want to show CETs. 3rd party apps can create CET groups.
  const hasCETGroup = groups.some(({ types }) => types.includes('RESEARCHER_TREE'))

  // if both can access CET and FGT are false, then we don't want to fetch groups
  // if only one is false, we still want to fetch groups
  const canAccessCETAndIsOn = Boolean((cetFlagIsOn || hasCETGroup) && canAccessCET)
  const canAccessGroups = canAccessFGT || canAccessCETAndIsOn

  const [pidInvite, setPidInvite] = useState<string>()
  const currentTreeIsPrivate = currentTreeId === 'PRIVATE'
  const overlay = useOverlay()
  const { open } = overlay

  useEffect(() => {
    isCurrent.current = true
    return () => {
      isCurrent.current = false
    }
  })

  // removeQuery is not stable.
  const removeQueryParam = useEvent((key: string) => removeQuery(key))

  const currentTreeGroup = useMemo(
    () => groups?.find((group) => group.treeIds?.[0] === currentTreeId),
    [currentTreeId, groups]
  )

  const selectTree = useEvent(
    async (treeId: TreeId | 'PRIVATE', passedInGroups: GroupSummary[], doSetSessionTree: boolean) => {
      if (canAccessGroups && treeId !== currentTreeId) {
        let details: TreeDetails | undefined
        if (treeId !== 'PRIVATE')
          try {
            details = await getTreeDetails(treeId)
            dispatch({ type: 'SET_TREE_DETAILS', treeDetails: details })
          } catch (err) {
            // No treeDetails so not switching trees
            console.error(err)
            return
          }

        const newCurrentTreeGroup = passedInGroups.find((group) => group.treeIds?.[0] === treeId)
        const treeIdUserIsMemberOf = newCurrentTreeGroup?.treeIds?.[0]

        dispatch({
          type: 'SET_CURRENT_TREE_ID',
          currentTreeId: treeId,
          isReadOnlyTree: Boolean(!treeIdUserIsMemberOf && treeId !== 'PRIVATE'),
          treeDetails: details,
        })

        if ((treeIdUserIsMemberOf || treeId === 'PRIVATE') && doSetSessionTree) {
          // We should only set session tree if user is a member of the tree or if it is the PRIVATE tree
          await setSessionTree(treeIdUserIsMemberOf || 'PRIVATE')
        }
      }
    }
  )

  const getAndSetGroups = useCallback(
    async (ignoreCache?: boolean, treeId?: TreeId | 'PRIVATE') => {
      try {
        const groupData = await getGroups(ignoreCache)
        if (isCurrent.current) {
          const currentSessionTreeGroup = groupData?.memberSummaries?.find((group) => group.preferred)
          const currentSessionTreeId = currentSessionTreeGroup?.treeIds?.[0] ?? 'PRIVATE'
          const newCurrentTreeId = treeId === undefined ? currentSessionTreeId : treeId
          const groupsInnerScope = groupData?.memberSummaries ?? []
          const treeIdToSelect = treeIdOverride || newCurrentTreeId
          const doSetSessionTree = treeIdToSelect !== currentSessionTreeId && !treeIdOverride

          await selectTree(treeIdToSelect, groupsInnerScope, doSetSessionTree)
          dispatch({ type: 'SET_GROUPS', groups: groupsInnerScope })
        }
      } catch (err) {
        console.error(err)
        isCurrent.current && dispatch({ type: 'SET_GROUPS', groups: [], treeDetails: undefined, isReadOnlyTree: false })
      }
    },
    [selectTree, treeIdOverride]
  )

  // TODO make breaking change to remove logic surrounding treeIdQuery and put that in tree-r9. See following of the gist of what you would put in tree-r9.
  // if (treeIdQuery) {
  //   selectTree(treeIdQuery)
  //   const data = await getTreeStartingPid(treeIdQuery)
  //   if (!data?.personId) openGroupOverlay()
  // }
  // removeQueryParam(queryTreeIdStr)

  useEffect(() => {
    const initGroups = async (treeId: TreeId | 'PRIVATE' | undefined): Promise<void> => {
      if (treeIdOverride !== undefined) {
        await getAndSetGroups(true, treeIdOverride)
      } else {
        await getAndSetGroups(false, treeId)
      }

      if (treeIdQuery) removeQueryParam(queryTreeIdStr)
    }

    if (canAccessGroups) {
      initGroups(treeIdQuery)
    } else {
      dispatch({ type: 'SET_GROUPS', groups: [], isReadOnlyTree: false })
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We do not want to re-run this when the query param is removed. We will shortly be modifying this package and moving query logic to tree-r9.
  }, [getAndSetGroups, canAccessGroups, removeQueryParam, treeIdOverride])

  /**  Wrapper that deals with old way of providing treeId of empty string and setDefault = true.
   *  Please just pass PRIVATE for treeId when setting the private tree as the session tree.
   * */
  const selectTreeWrapper = useCallback(
    (
      /** '' is deprecated; use 'PRIVATE' instead. */
      treeId: TreeId | 'PRIVATE' | '',
      /** @deprecated */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- not using this
      _setDefault?: boolean
    ): ReturnType<typeof selectTree> => {
      if (treeId === '') {
        return selectTree('PRIVATE', groups, true)
      }
      return selectTree(treeId, groups, true)
    },
    [groups, selectTree]
  )
  // Note: you can access a CET without being a member of the group
  const treeDetailsWillBeFetched = canAccessGroups && currentTreeId && currentTreeId !== 'PRIVATE'

  const refetchTreeDetails = useCallback(() => {
    if (treeDetailsWillBeFetched) {
      getTreeDetails(currentTreeId, true)
        .then((details) => dispatch({ type: 'SET_TREE_DETAILS', treeDetails: details }))
        .catch((err) => {
          console.error(err)
          // TreeDetails could not be retrieved for currentTreeId so setting tree to private tree
          dispatch({
            type: 'SET_CURRENT_TREE_ID',
            currentTreeId: 'PRIVATE',
            treeDetails: undefined,
          })
        })
    }
  }, [currentTreeId, treeDetailsWillBeFetched])

  // Either a researcher group which user is a member of or which a user is not a member of.
  const isResearcherGroup = currentTreeGroup?.types.includes('RESEARCHER_TREE') || treeDetails?.researcherTree

  const isTreeDetailsSynced =
    (treeDetailsWillBeFetched && currentTreeId === treeDetails?.treeId) ||
    (!treeDetails && (currentTreeIsPrivate || !canAccessGroups))

  const loading = loadingGroups || !isTreeDetailsSynced

  const { preferredTreeId, loading: preferredTreeLoadingRequest, refetch } = usePreferredTree()
  const [isUpdatingPreferredTree, setIsUpdatingPreferredTree] = useState(false)
  const setPreferredTreeId = useCallback(
    async (treeId) => {
      setIsUpdatingPreferredTree(true)
      try {
        await setPreferredTree(treeId)
        await refetch()
      } catch (error) {
        console.error(error)
      }
      setIsUpdatingPreferredTree(false)
    },
    [refetch]
  )

  const loadingPreferredTreeId = preferredTreeLoadingRequest || isUpdatingPreferredTree

  const value = useMemo(
    () =>
      ({
        isOn: Boolean(canAccessFGT), // backwards compatibility
        canAccessFGT: Boolean(canAccessFGT),
        canAccessCET: canAccessCETAndIsOn,
        // TODO: remove legacy support for currentTreeId being empty string when on the PRIVATE tree in next major bump. Some logic that relies on GroupsProvider relies that the currentTreeId is falsy when in a non-"PRIVATE" tree.
        currentTreeId: currentTreeIsPrivate ? '' : currentTreeId,
        currentGroup: currentTreeGroup,
        groups,
        selectTree: selectTreeWrapper,
        loading,
        openGroupOverlay: open,
        isResearcherGroup,
        setPidInvite,
        pidInvite,
        getAndSetGroups,
        treeDetails,
        refetchTreeDetails,
        isReadOnlyTree,
        preferredTreeId,
        loadingPreferredTreeId,
        setPreferredTreeId,
      }) satisfies GroupsValue,
    [
      canAccessFGT,
      canAccessCETAndIsOn,
      currentTreeIsPrivate,
      currentTreeId,
      currentTreeGroup,
      groups,
      selectTreeWrapper,
      loading,
      open,
      isResearcherGroup,
      pidInvite,
      getAndSetGroups,
      treeDetails,
      refetchTreeDetails,
      isReadOnlyTree,
      preferredTreeId,
      loadingPreferredTreeId,
      setPreferredTreeId,
    ]
  )

  const Loader = LoadingComponent || LoadingSpinner

  return (
    <GroupContext.Provider value={value}>
      {loading ? <Loader /> : children}
      <Suspense fallback="">
        <SetMePersonOverlayProvider overlay={overlay} groupsValue={value}>
          {(overlay.isOpen || overlay.transitioning) && <GroupsChooseOverlay overlay={overlay} {...value} />}
        </SetMePersonOverlayProvider>
      </Suspense>
    </GroupContext.Provider>
  )
}
