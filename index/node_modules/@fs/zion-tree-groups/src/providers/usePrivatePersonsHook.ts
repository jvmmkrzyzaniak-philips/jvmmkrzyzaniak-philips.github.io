import { useCallback, useEffect, useState, useRef } from 'react'
import { useUser } from '@fs/zion-user'
import type { Person } from '@fs/zion-tree-types'
import { exhaustiveCheck } from '@fs/zion-tree-types'
import getPrivatePeople from '../services/getPrivatePeople'
import getPrivatePeopleCount from '../services/getPrivatePeopleCount'
import type { SortBy, SortDirection, SortValue } from '../types/privatePersons'

function getSortValue(sortBy: SortBy, sortDirection: SortDirection): SortValue {
  switch (sortBy) {
    case 'fullName': {
      if (sortDirection === 'asc') return 'GIVEN_NAMES_ASC'
      return 'GIVEN_NAMES_DESC'
    }
    // eslint-disable-next-line sonarjs/no-duplicated-branches -- we want to allow the option for fullName sorting, but have it behave the same as firstName.
    case 'firstName': {
      if (sortDirection === 'asc') return 'GIVEN_NAMES_ASC'
      return 'GIVEN_NAMES_DESC'
    }
    case 'lastName': {
      if (sortDirection === 'asc') return 'SURNAME_ASC'
      return 'SURNAME_DESC'
    }
    case 'birth': {
      if (sortDirection === 'asc') return 'LIFESPAN_BEGIN_ASC'
      return 'LIFESPAN_BEGIN_DESC'
    }
    case 'gender': {
      if (sortDirection === 'asc') return 'FEMALE_FIRST'
      return 'MALE_FIRST'
    }
    case 'dateCreated': {
      if (sortDirection === 'asc') return 'CREATED_ASC'
      return 'CREATED_DESC'
    }
    case 'dateModified': {
      if (sortDirection === 'asc') return 'LAST_MODIFIED_ASC'
      return 'LAST_MODIFIED_DESC'
    }
    default:
      return exhaustiveCheck(sortBy)
  }
}

type Props = {
  treeId?: string
  nameFilter?: string
  /** The amount of Persons to fetch must be 20-200 inclusive */
  pageCount?: number
  sortBy?: SortBy
  sortDirection?: SortDirection
  /** If the sort preferences have been loading will be false if provider is not using isSorting */
  loadingSort?: boolean
  /** if set to true, the user profile name for each person creator will be returned */
  includeCreatorNames?: boolean
  /** if set to true, the person portrait will be returned for each person */
  includePhotos?: boolean
  /** if set to false, full person cards will be loaded which include creator contributorId, created timestamp, and last modified timestamp */
  usePersonSummaries?: boolean
}

type ReturnValue = {
  loadingPersons: boolean
  loadingCount: boolean
  privatePersons: Person[]
  privatePersonsCount: number | undefined
  getNextPrivatePersonBatch: () => Promise<void>
  getPreviousPrivatePersonBatch: (pastToken: string | undefined) => Promise<void>
  nextToken: string | undefined
  pageCount: number
  nameFilter: string
  refreshPrivatePeople: (updatedNameFilter?: string) => void
}

export default function usePrivatePersonsHook({
  treeId,
  nameFilter = '',
  pageCount = 50,
  sortBy = 'fullName',
  sortDirection = 'asc',
  loadingSort,
  includeCreatorNames,
  includePhotos,
  usePersonSummaries,
}: Props): ReturnValue {
  const [loadingPersons, setLoadingPersons] = useState(true)
  const [loadingCount, setLoadingCount] = useState(true)
  const [privatePersons, setPrivatePersons] = useState<Person[]>([])
  const [nextToken, setNextToken] = useState<string>()
  const [privatePersonsCount, setPrivatePersonsCount] = useState<number>()
  const treeIdForWhichPrivatePeopleHaveBeenFetched = useRef<string>()
  const sortValueForWhichPrivatePeopleHaveBeenFetched = useRef<SortValue>()

  const { signedIn } = useUser()
  const isCurrent = useRef(true)

  const sortValue = getSortValue(sortBy, sortDirection)

  const fetchPrivatePeopleCount = useCallback(
    (updatedNameFilter?: string) => {
      setLoadingCount(true)
      getPrivatePeopleCount({
        treeId,
        nameFilter: updatedNameFilter,
      })
        .then((data) => {
          if (isCurrent.current) {
            setPrivatePersonsCount(data?.count)
          }
        })
        .catch(console.error)
        .finally(() => {
          isCurrent.current && setLoadingCount(false)
        })
    },
    [treeId]
  )

  const fetchPrivatePeople = useCallback(
    (updatedNameFilter?: string) => {
      setLoadingPersons(true)
      getPrivatePeople({
        treeId,
        nameFilter: updatedNameFilter,
        nextPageToken: 0,
        size: pageCount,
        sort: sortValue,
        includeCreatorNames,
        includePhotos,
        usePersonSummaries,
      })
        .then((data) => {
          if (isCurrent.current) {
            setPrivatePersons(data?.persons ?? [])

            setNextToken(data?.nextPageToken)
          }
        })
        .catch(console.error)
        .finally(() => {
          isCurrent.current && setLoadingPersons(false)
        })
    },
    [includeCreatorNames, includePhotos, pageCount, sortValue, treeId, usePersonSummaries]
  )

  const getPrivatePersonBatch = useCallback(
    async (batchToken) => {
      setLoadingPersons(true)
      try {
        fetchPrivatePeopleCount(nameFilter)
        const { nextPageToken, persons } = await getPrivatePeople({
          treeId,
          nameFilter,
          nextPageToken: batchToken,
          size: pageCount,
          sort: sortValue,
          includeCreatorNames,
          includePhotos,
          usePersonSummaries,
        })
        if (isCurrent.current) {
          setNextToken(nextPageToken)
          setPrivatePersons(() => persons ?? [])
        }
      } catch (error) {
        console.error(error)
      } finally {
        isCurrent.current && setLoadingPersons(false)
      }
    },
    [
      fetchPrivatePeopleCount,
      includeCreatorNames,
      includePhotos,
      nameFilter,
      pageCount,
      sortValue,
      treeId,
      usePersonSummaries,
    ]
  )

  const fetchPersonsAndCount = useCallback(
    (updatedNameFilter) => {
      fetchPrivatePeople(updatedNameFilter)
      fetchPrivatePeopleCount(updatedNameFilter)
    },
    [fetchPrivatePeople, fetchPrivatePeopleCount]
  )

  const getNextPrivatePersonBatch = async (): Promise<void> => {
    getPrivatePersonBatch(nextToken)
  }
  const getPreviousPrivatePersonBatch = async (pastToken: string | undefined): Promise<void> => {
    getPrivatePersonBatch(pastToken)
  }

  useEffect(() => {
    isCurrent.current = true

    if (
      signedIn &&
      !loadingSort &&
      (treeIdForWhichPrivatePeopleHaveBeenFetched.current !== treeId ||
        sortValueForWhichPrivatePeopleHaveBeenFetched.current !== sortValue)
    ) {
      treeIdForWhichPrivatePeopleHaveBeenFetched.current = treeId
      sortValueForWhichPrivatePeopleHaveBeenFetched.current = sortValue
      fetchPrivatePeople()
      fetchPrivatePeopleCount()
    }
    return () => {
      isCurrent.current = false
    }
  }, [fetchPrivatePeople, fetchPrivatePeopleCount, loadingSort, signedIn, sortValue, treeId])

  return {
    loadingPersons,
    loadingCount,
    privatePersons,
    privatePersonsCount,
    getNextPrivatePersonBatch,
    getPreviousPrivatePersonBatch,
    nextToken,
    pageCount,
    nameFilter,
    refreshPrivatePeople: fetchPersonsAndCount,
  }
}
