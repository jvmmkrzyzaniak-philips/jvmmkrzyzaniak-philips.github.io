import { useCallback, useState } from 'react'
import { useStatusOverlay } from '@fs/zion-ui'
import { useTranslation } from 'react-i18next'
import { useHistory } from '@fs/zion-router'
import type { AxiosError } from '@fs/zion-tree-types/zion-axios'
import { type TreeId } from '@fs/zion-tree-types'
import { isAxiosError } from 'axios'
import { clearStartingPidCache } from '../../../../services/cacheGroupCalls'
import { groupsAutoMergeMePerson, groupsCopyPersons } from '../../../../services/groupCalls'
import getAlreadyCopiedPersons, { getPersonCopyResults } from '../../../../helpers/getAlreadyCopiedPersons'
import type { useGroupsContext } from '../../../../providers/GroupsProvider/InnerGroupsProvider'
import type { COPY_ALL_PATH, COPY_ME_PATH } from '../helpers/routes'

type Props = {
  selectTree?: ReturnType<typeof useGroupsContext>['selectTree']
  treeId: TreeId | 'PRIVATE' | '' | undefined
  overLimitPath?: string
  mePersonId?: string
  onCopyComplete: (() => void) | undefined
  stopPathProgression?: boolean
}

type CopyType = Parameters<typeof groupsCopyPersons>[0]['copyType']

type ReturnValue = {
  copyType: CopyType | undefined
  loading: boolean | undefined
  handleCopy: (type: CopyType, pids?: string[]) => Promise<void>
  handleReverseCopyAndMerge: () => Promise<void>
}

export default function useCopyPrivatePersons({
  selectTree,
  treeId,
  overLimitPath,
  mePersonId,
  onCopyComplete,
  stopPathProgression,
}: Props): ReturnValue {
  const [t] = useTranslation()
  const history = useHistory()
  const [copyType, setCopyType] = useState<CopyType>()
  const [loading, setLoading] = useState<boolean>()
  const showStatusOverlay = useStatusOverlay()

  const handleCopy = useCallback(
    async (type: CopyType, pids: string[] = []) => {
      setLoading(true)
      const to = (type === 'ids' ? '/all' : `/${type}`) satisfies typeof COPY_ALL_PATH | typeof COPY_ME_PATH
      async function runOnSuccess(): Promise<void> {
        clearStartingPidCache()
        onCopyComplete?.()
        !stopPathProgression && history.replace(to)
      }

      try {
        if (treeId && type) {
          setCopyType(type)
          await groupsCopyPersons({ treeId, copyType: type, pids })
          await runOnSuccess()
        }
      } catch (error) {
        const personCopyResults = getPersonCopyResults(error)
        const hasFailedPersonCopyResults = Boolean(
          Object.entries(personCopyResults).find(([, result]) => result.status === 'FAILED')
        )
        const personsAlreadyCopied = getAlreadyCopiedPersons(error)

        console.error(error)
        if (isAxiosError(error) && error.response?.headers?.warning === '421 tf "Resource limits exceeded"') {
          history.replace(overLimitPath)
        } else if (
          isAxiosError(error) &&
          error.response?.status === 400 &&
          personsAlreadyCopied.length > 0 &&
          !hasFailedPersonCopyResults
        ) {
          // We don't care if the persons were already copied and there are no failed copies. This usually happens when an error is thrown, like a timeout and then the user tries again (like we told them to in the StatusOverlay)
          await runOnSuccess()
        } else {
          showStatusOverlay({
            type: 'error',
            message: t('groups.copy-error.description'),
          })
        }
      } finally {
        clearStartingPidCache()
        setLoading(false)
      }
    },
    [history, onCopyComplete, overLimitPath, showStatusOverlay, stopPathProgression, t, treeId]
  )

  const handleReverseCopyAndMerge = useCallback(async () => {
    const type = 'me'
    setLoading(true)
    try {
      setCopyType?.(type)
      await groupsAutoMergeMePerson(
        treeId!, // TODO is this a correct assumption that treeId is defined?
        mePersonId!, // TODO is this a correct assumption that mePersonId is defined?
        true
      )
      await selectTree?.(treeId!, true)
      clearStartingPidCache()
      onCopyComplete?.()
      history.replace(`/${type}`)
    } catch (error) {
      console.error((error as AxiosError).response)
      showStatusOverlay({ type: 'error', message: t('groups.copy-from-private-tree-already-copied.error') })
    } finally {
      clearStartingPidCache()
      setLoading(false)
    }
  }, [history, mePersonId, onCopyComplete, selectTree, showStatusOverlay, t, treeId])

  return { copyType, loading, handleCopy, handleReverseCopyAndMerge }
}
