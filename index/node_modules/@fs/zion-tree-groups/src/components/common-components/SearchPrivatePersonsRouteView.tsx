import React, { Suspense, useCallback, useEffect, useState, lazy } from 'react'
import {
  Row,
  Button,
  Paragraph,
  useStatusOverlay,
  Skeleton,
  Separator,
  Bleed,
  DataPreview,
  Grid,
  IconButton,
  useMenuOverlay,
  ListItem,
  useOverlay,
} from '@fs/zion-ui'

import { Person } from '@fs/zion-person'
import { useHistory } from '@fs/zion-router'
import { trackEvent } from '@fs/zion-analytics'
import { NoticeLoading, MenuMore } from '@fs/zion-icon'
import { useTranslation } from 'react-i18next'
import type { Gender } from '@fs/zion-tree-types'
import type { History } from 'history'
import { usePrivatePersons } from '../../providers/PrivatePersonsProvider'
import PrivatePersonsSearch from '../private-persons/PrivatePersonsSearch'
import { useSelectPersonContext } from '../../providers/SelectPersonProvider'
import TreePaginator from './TreePaginator'
import type { Props as DeleteInviteDialogProps } from './DeleteInviteDialog'
import type { Invite } from '../../types/invites'
import { useInvites } from '../../providers/InvitesProvider'
import { useStartingPersonIdContext } from '../../providers/StartingPersonProvider'

const RefreshInviteOverlay = lazy(() => import('./RefreshInviteOverlay'))
const DeleteInviteDialog = lazy(() => import('./DeleteInviteDialog'))
const MenuOverlay = lazy(() => import('./TreeMenuOverlay'))

function filterByGender(persons: Person[], genderFilter): Person[] {
  return genderFilter === 'MALE' || genderFilter === 'FEMALE'
    ? persons.filter((person) => person.gender === genderFilter || person.gender === 'UNKNOWN')
    : persons
}

type Props = {
  to?: string
  pushOrReplaceTo?: 'push' | 'replace'
  buttonText?: string
  searchHeader?: JSX.Element
  alreadySelectedText?: string
  onSelect?: (person: Person, refreshPrivatePeople: () => void) => Promise<void | boolean> | void | boolean
  onSelectLoading?: boolean
  setDialogMinHeight?: (height: number) => void
  linkName?: string
  showDeceasedPersons?: boolean
  alreadyInvitedText?: string
  sexFilter?: Gender
  filterPersons?: (person: Person) => Person[]
  disableUseInvites?: boolean
  /** @deprecated */
  inviteOnlyCopyLink?: boolean
}

/** A route view that displays a list of private persons with a search right above it. This route view is used in many of the flows in tree-groups.
 */
export default function SearchPrivatePersonsRouteView({
  to,
  pushOrReplaceTo = 'replace',
  buttonText,
  searchHeader,
  alreadySelectedText,
  onSelect,
  onSelectLoading,
  setDialogMinHeight,
  linkName,
  showDeceasedPersons,
  alreadyInvitedText,
  sexFilter,
  filterPersons,
  disableUseInvites = false,
}: Props): JSX.Element {
  const [t] = useTranslation()
  const menuOverlay = useMenuOverlay()
  const deleteInviteOverlay = useOverlay()
  const refreshInviteOverlay = useOverlay()
  const [deleteInviteProps, setDeleteInviteProps] = useState<
    Omit<DeleteInviteDialogProps, 'overlay' | 'refetchInvites' | 'groupId'> &
      Partial<Pick<DeleteInviteDialogProps, 'groupId'>>
  >()
  const [inviteToResend, setInviteToResend] = useState<Invite>()
  const { groupId, singleUseInvites, refetchInvites, alreadyInvitedArray } = useInvites(disableUseInvites)
  const startingPersonId = useStartingPersonIdContext()
  const { loading, privatePersons, filterText, refreshPrivatePeople } = usePrivatePersons()
  const livingPrivatePersons = privatePersons.filter((privatePerson) => privatePerson.living)
  const selectPrivatePersons = showDeceasedPersons ? privatePersons : livingPrivatePersons

  const filteredPersons = filterPersons ? filterPersons(selectPrivatePersons) : selectPrivatePersons
  const filteredPrivatePersons = filterByGender(filteredPersons, sexFilter)

  const listIsEmpty = !loading && !filteredPrivatePersons.length

  useEffect(() => {
    const percentageDropped = (filteredPrivatePersons?.length ?? 0) / (selectPrivatePersons?.length ?? 1)
    // if we have filtered to 0 results or a reduced the results by at least 75%
    if (selectPrivatePersons?.length > 0 && (filteredPrivatePersons?.length === 0 || percentageDropped < 0.25))
      // this will help us keep track when users might have ran into issues
      trackEvent({
        eventName: 'Private persons sex filter',
        numberOfFilteredPersons: filteredPrivatePersons?.length,
        percentageDropped,
        filterText,
      })
  }, [filterText, filteredPrivatePersons?.length, selectPrivatePersons?.length])

  const { setSelectedPerson, setPaginatorState } = useSelectPersonContext() || {} // TODO should we error out if not inside the SelectPersonProvider?

  const history: History = useHistory()
  const showStatusOverlay = useStatusOverlay()

  const handleOnSelect = useCallback(
    async (person) => {
      let goToNextRoute: boolean | void = true
      setPaginatorState?.((prev) => ({ ...prev, nameFilter: filterText }))

      try {
        // we expect the onSelect functions to throw the message they want to show
        goToNextRoute = (await onSelect?.(person, refreshPrivatePeople)) ?? true
        if (goToNextRoute && to) {
          // TODO: update all other selectPerson flows to not depend on selectPerson and use the replace state
          setSelectedPerson?.(person)
          history[pushOrReplaceTo](to, { person })
        }
      } catch (error) {
        if (error instanceof Error && error.message) {
          showStatusOverlay({
            message: error.message,
            type: 'error',
            dismissable: true,
          })
        }
      }
    },
    [
      filterText,
      history,
      onSelect,
      refreshPrivatePeople,
      setPaginatorState,
      setSelectedPerson,
      showStatusOverlay,
      to,
      pushOrReplaceTo,
    ]
  )

  useEffect(() => setDialogMinHeight && setDialogMinHeight(900), [setDialogMinHeight])

  if (onSelectLoading) {
    return (
      <Row alignX="center">
        <NoticeLoading size="lg" />
      </Row>
    )
  }

  return (
    <>
      {!!searchHeader && (
        <>
          {searchHeader}
          <Separator size="nano" />
        </>
      )}

      <PrivatePersonsSearch debounceTime={500} initialSearchText={filterText} />

      <DataPreview.Loading loading={loading}>
        <Skeleton.PersonBlock size="sm" />
        <Separator size="xs" />
        <Skeleton.PersonBlock size="sm" />
        <Separator size="xs" />
        <Skeleton.PersonBlock size="sm" />
        <Separator size="xs" />
        <Skeleton.PersonBlock size="sm" />
        <Separator size="xs" />
        <Skeleton.PersonBlock size="sm" />
      </DataPreview.Loading>

      <DataPreview.Ready loading={loading}>
        <Grid gutters="sm">
          {listIsEmpty && <Paragraph>{t('groups.no-match-found.title')}</Paragraph>}
          {!listIsEmpty &&
            filteredPrivatePersons.map((person) => {
              const personInvite = singleUseInvites?.find((invite) => person.id === invite.personId)
              const alreadyClaimed = !!person.mePersonCisId || startingPersonId === person.id
              const alreadyInvited = alreadyInvitedArray?.includes(person.id)
              const alreadyClaimedOrInvitedText =
                (alreadyClaimed && alreadySelectedText) || (alreadyInvited && alreadyInvitedText)
              let testIdText = ''
              if (alreadyClaimedOrInvitedText) {
                testIdText = alreadyClaimed && alreadySelectedText ? '-selected' : '-invited'
              }
              return (
                <div key={person.id} data-testid={`${person.id}${testIdText}`}>
                  <Row alignItemsY="middle">
                    <Person
                      noBoldName
                      personObj={person}
                      doNotLinkToPersonPage
                      avatarSize="smaller"
                      componentSize="md"
                      growX
                    />
                    {/* eslint-disable-next-line no-nested-ternary -- It is simpler for this to be a nested ternary. */}
                    {alreadyClaimedOrInvitedText ? (
                      <div style={{ textAlign: 'end' }} alignY="middle">
                        <Paragraph size="xs">{alreadyClaimedOrInvitedText}</Paragraph>
                      </div>
                    ) : buttonText ? (
                      <Button
                        noShrinkX
                        data-testid={`select-person-button:${person.id}`}
                        onClick={() => handleOnSelect(person)}
                        linkName={linkName}
                      >
                        {buttonText}
                      </Button>
                    ) : null}
                    {alreadyInvited && !alreadyClaimed && (
                      <IconButton
                        data-testid={`open-menuoverlay-button:${person.id}`}
                        Icon={MenuMore}
                        title={t('groups.open-menu.action')}
                        onClick={(e) => {
                          setDeleteInviteProps((prev) => ({
                            ...prev,
                            groupId,
                            inviteId: personInvite?.inviteId,
                            pid: personInvite?.personId,
                          }))
                          setInviteToResend(personInvite)
                          menuOverlay.handleClick(e)
                        }}
                      />
                    )}
                  </Row>
                </div>
              )
            })}
        </Grid>
      </DataPreview.Ready>

      <TreePaginator />
      {/* We only are doing this so that scrolling to top when we switch pages works reliably */}
      <Bleed all>
        <Separator size="nano" />
      </Bleed>

      {(menuOverlay.isOpen || menuOverlay.transitioning) && (
        <Suspense fallback="">
          <MenuOverlay {...menuOverlay} inline={false}>
            <ListItem
              data-testid="invite-dialog-resend-invite"
              primaryText={t('groups.resend-invite.action')}
              onClick={refreshInviteOverlay.handleClick}
            />
            <ListItem
              data-testid="invite-dialog-remove-invite"
              primaryText={t('groups.remove-invite.action')}
              onClick={deleteInviteOverlay.handleClick}
            />
          </MenuOverlay>
        </Suspense>
      )}

      {(deleteInviteOverlay.isOpen || deleteInviteOverlay.transitioning) &&
        deleteInviteProps &&
        deleteInviteProps.groupId && (
          <Suspense fallback={null}>
            <DeleteInviteDialog
              {...deleteInviteProps}
              groupId={deleteInviteProps.groupId}
              refetchInvites={refetchInvites}
              overlay={deleteInviteOverlay}
            />
          </Suspense>
        )}

      {(refreshInviteOverlay.isOpen || refreshInviteOverlay.transitioning) && inviteToResend && (
        <Suspense fallback={null}>
          <RefreshInviteOverlay
            invite={inviteToResend}
            overlay={refreshInviteOverlay}
            refetchInvites={refetchInvites}
          />
        </Suspense>
      )}
    </>
  )
}
