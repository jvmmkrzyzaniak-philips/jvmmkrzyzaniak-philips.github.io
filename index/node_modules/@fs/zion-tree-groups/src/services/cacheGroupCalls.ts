import { useState, useEffect } from 'react'
import axiosUntyped, { useZionAxios as useZionAxiosUntyped } from '@fs/zion-axios'
import CacheService, { useCacheService as useCacheServiceUnTyped } from '@fs/zion-cache-service'
import Cache from '@fs/zion-cache'
import type CacheType from '@fs/zion-tree-types/zion-cache'
import type { CacheConfig } from '@fs/zion-tree-types/zion-cache'
import type CacheServiceType from '@fs/zion-tree-types/zion-cache-service'
import type {
  CacheServiceConfig,
  useCacheService as useCacheServiceTyped,
} from '@fs/zion-tree-types/zion-cache-service'
import type { GroupSummary, TreeDetails } from '@fs/zion-tree-types'
import type axiosTyped from '@fs/zion-tree-types/zion-axios'
import { type useZionAxios as useZionAxiosTyped, type AxiosResponse } from '@fs/zion-tree-types/zion-axios'
import type { Invite, InvitesResponse, MultiUseInvite, SingleUseInvite } from '../types/invites'
import type { TreeMatchResultMatch } from '../types/matchMePersons'

const useCacheService = useCacheServiceUnTyped as typeof useCacheServiceTyped
const useZionAxios = useZionAxiosUntyped as typeof useZionAxiosTyped
const axios = axiosUntyped as typeof axiosTyped

const cacheServiceConfig = { cache: { storeName: 'startingPerson' } } satisfies CacheServiceConfig
const groupsCacheServiceConfig = { cache: { storeName: 'familyGroups', type: 'memory' } } satisfies CacheServiceConfig

// Exported for tests only
export const cacheService = new CacheService(cacheServiceConfig) as CacheServiceType
export const groupsCacheService = new CacheService(groupsCacheServiceConfig) as CacheServiceType
// Briefly cached, mainly to prevent multiple duplicate calls made between shared components that each need the data
const TEN_SECOND_LIFETIME = 10_000

export const cache = new Cache({
  storeName: 'group_management',
  type: 'memory',
  lifetime: TEN_SECOND_LIFETIME,
} satisfies CacheConfig) as CacheType

export const clearGroupsCache = (): Promise<void> => groupsCacheService.cacheInstance.clear()

export const clearStartingPidCache = (): Promise<void> => cacheService.cacheInstance.clear()

type StartingPersonResponse = { personId: string; treeId?: string }

export const getTreeStartingPid = async (treeId?: string, noCache?: boolean): Promise<StartingPersonResponse> => {
  const url = `/service/tree/tree-data/user/CURRENT/starting-person-id?treeId=${treeId || 'PRIVATE'}`
  const key = url
  if (noCache) {
    await cacheService.cacheInstance.removeItem(key)
  }
  const res = await cacheService.get<StartingPersonResponse>(url, key)

  // If no starting person exists for a tree, we don't want the cache to stick around for that treeId
  if (!res?.personId) {
    await cacheService.cacheInstance.removeItem(key)
  }
  return res
}

const duplicatesCache = { storeName: 'treeDuplicates', type: 'memory' }

const duplicatesCacheService = new CacheService({ cache: duplicatesCache })

type CurrentGroupsResponse = {
  memberSummaries: GroupSummary[]
}

export const getTreeDetails = (treeId: string, ignoreCache?: boolean): Promise<TreeDetails> => {
  const url = `/service/tree/tree-data/groups/trees/${treeId}`
  return groupsCacheService.get<TreeDetails>(url, url, {
    ignoreCache,
  })
}

export const getGroups = (ignoreCache?: boolean): Promise<CurrentGroupsResponse> => {
  return groupsCacheService.get<CurrentGroupsResponse>(
    '/service/tree/tree-data/groups/current-groups?includePending=false',
    'familyGroups',
    {
      ignoreCache,
    }
  )
}

export const setSessionTree = (treeId?: string): Promise<AxiosResponse<''>> => {
  return axios.post<''>('/service/tree/tree-data/user/CURRENT/tree/session', { treeId: treeId ?? 'PRIVATE' })
}

/**
 * Member leaves the group.
 * @param {string} groupId - the group's ID.
 * @throws 400 - The Group id wasn't valid.
 * @throws 400 - The last admin of a group cannot be removed.
 * @throws 403 - The user isn't a member of the group.
 * @throws 404 - Group not found.
 * @throws 404 - Group member not found.
 * @returns {Promise} Promise of axios.delete
 */
export async function leaveGroup(groupId: string): Promise<void> {
  cache.removeItem('group-list')
  return axios.delete(`/service/tree/tree-data/groups/${groupId}/members/CURRENT`)
}

export const useTreeStartingPid = (
  treeId: string | undefined,
  noCache?: boolean
): { loading?: boolean; data: undefined | StartingPersonResponse } => {
  const [data, setData] = useState<StartingPersonResponse>()
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    let mounted = true
    treeId &&
      getTreeStartingPid(treeId, noCache)
        .then((res) => {
          return mounted && setData(res)
        })
        .catch(console.error)
        .finally(() => {
          mounted && setLoading(false)
        })

    return () => {
      mounted = false
    }
  }, [noCache, treeId])

  if (!treeId) return { loading: false, data: undefined }
  return { loading, data }
}

type PendingInvitesProps = {
  groupId: string | undefined
  isAdmin?: boolean
  onlySingleUseInvites?: boolean
}

type PendingInvitesReturn = {
  singleUseInvites: SingleUseInvite[]
  multiUseInvites: MultiUseInvite[]
  refetchInvites: ReturnType<typeof useZionAxios<InvitesResponse>>[1]
}

export const usePendingInvites = ({
  groupId,
  willFetch,
  onlySingleUseInvites,
}: Omit<PendingInvitesProps, 'isAdmin'> & { willFetch: boolean }): PendingInvitesReturn => {
  const singleUseInvitesQuery = onlySingleUseInvites ? '?singleUse=true' : ''
  const url =
    willFetch && groupId ? `/service/tree/tree-data/groups/${groupId}/invites${singleUseInvitesQuery}` : undefined
  const [{ data }, execute] = useZionAxios<InvitesResponse>({ url })

  const { singleUseInvites, multiUseInvites } = (data?.invites ?? []).reduce<
    Omit<PendingInvitesReturn, 'refetchInvites'>
  >(
    (allInvites, invite) => {
      if (invite.singleUse) allInvites.singleUseInvites.push(invite)
      else {
        allInvites.multiUseInvites.push(invite as MultiUseInvite) // non-strict does not recognize this as MultiUseInvite but strict does
      }
      return allInvites
    },
    { singleUseInvites: [], multiUseInvites: [] }
  )

  return {
    singleUseInvites,
    multiUseInvites,
    refetchInvites: execute,
  }
}

/** @deprecated use usePendingInvites instead */
export const useGroupPendingInvites = ({
  groupId,
  isAdmin,
  onlySingleUseInvites,
}: {
  groupId: string | undefined
  isAdmin?: boolean
  onlySingleUseInvites?: boolean
}): {
  singleUseInvites: Invite[] | undefined
  multiUseInvites: Invite[] | undefined
  refetchInvites: () => void
} => {
  const singleUseInvitesQuery = onlySingleUseInvites ? '?singleUse=true' : ''
  const url = `/service/tree/tree-data/groups/${groupId}/invites${singleUseInvitesQuery}`
  const [{ data }, execute] = useZionAxios<InvitesResponse>(url, { manual: true })

  useEffect(() => {
    if (isAdmin && groupId) {
      execute().catch(console.error)
    }
  }, [isAdmin, execute, groupId])

  if (!Array.isArray(data?.invites))
    return {
      singleUseInvites: undefined,
      multiUseInvites: undefined,
      refetchInvites: execute,
    }

  if (!isAdmin) return { singleUseInvites: [], multiUseInvites: [], refetchInvites: () => () => undefined }

  const { singleUseInvites, multiUseInvites } =
    data?.invites?.reduce(
      (allInvites, invite) => {
        if (invite.singleUse) allInvites.singleUseInvites.push(invite)
        else {
          allInvites.multiUseInvites.push(invite)
        }
        return allInvites
      },
      { singleUseInvites: [] as Invite[], multiUseInvites: [] as Invite[] }
    ) ?? {}

  return {
    singleUseInvites,
    multiUseInvites,
    refetchInvites: execute,
  }
}

export function usePrivatePersonsDuplicates(
  treeId: string | undefined
): ReturnType<typeof useCacheService<TreeMatchResultMatch[], 'cache-first'>> {
  const url = treeId ? `/service/tree/tree-data/user/CURRENT/tree/${treeId}/match-all-persons` : null
  const key = treeId
  const [{ data, loading, error }, refetch] = useCacheService<TreeMatchResultMatch[], 'cache-first'>(
    duplicatesCacheService,
    url,
    key! // it will be defined when url is defined
  )
  return [{ data, loading: loading || !url, error }, refetch]
}
