import { useMemo, useCallback, useEffect, useRef, useState } from 'react'
import axiosUntyped from '@fs/zion-axios'
import Cache from '@fs/zion-cache'
import CacheService, { useCacheService as useCacheServiceUnTyped } from '@fs/zion-cache-service'
import type { Dispatch, SetStateAction } from 'react'
import type { Axios, AxiosResponse, AxiosPromise, GenericAbortSignal } from '@fs/zion-tree-types/zion-axios'
import type CacheServiceType from '@fs/zion-tree-types/zion-cache-service'
import {
  type CacheServiceConfig,
  type useCacheService as useCacheServiceTyped,
} from '@fs/zion-tree-types/zion-cache-service'
import type { GroupDetails, GroupId, GroupMember, Person, WrappedResponse } from '@fs/zion-tree-types'
import { exhaustiveCheck } from '@fs/zion-tree-types'
import type { CacheConfig } from '@fs/zion-tree-types/zion-cache'
import type CacheType from '@fs/zion-tree-types/zion-cache'
import type { InviteMessage } from '../types/invites'
import { type TfTreeCopyResult, type TfTreeCopyResults } from '../types/copy'
import createInviteLink from '../helpers/createInviteLink'

const useCacheService = useCacheServiceUnTyped as typeof useCacheServiceTyped

const axios = axiosUntyped as Axios

const cacheService = new CacheService({
  cache: {
    storeName: 'privatePersonsCount',
  },
  strategy: 'cache-and-network',
} satisfies CacheServiceConfig<unknown, 'cache-and-network'>) as CacheServiceType<unknown, 'cache-and-network'>

export default function getPersonDetails(pid: string): Promise<AxiosResponse<Person>> {
  return axios.get<Person>(`/service/tree/tree-data/person/${pid}/details`)
}

/**
 * This is used to access personSharingAccepted and recommendedPersonId properties of a group member
 * @param {string} groupId - The groupId the member belongs to
 * @param {string} cisId - The cisId of the groupMember
 * @returns
 */
export async function getMemberDetails(groupId: string, cisId: string): Promise<AxiosResponse<GroupMember>> {
  return axios.get<GroupMember>(`/service/tree/tree-data/groups/${groupId}/members/by-id/${cisId}`)
}

export function useGroupMemberDetails({
  groupId,
  cisId,
  defaultState,
  ignoreDataCall,
}: {
  groupId: string | undefined
  cisId: string | undefined
  defaultState?: GroupMember
  ignoreDataCall?: boolean
}): {
  memberDetails: GroupMember | undefined
  setMemberDetails: Dispatch<SetStateAction<GroupMember | undefined>>
} {
  const [memberDetails, setMemberDetails] = useState<GroupMember | undefined>(defaultState)

  useEffect(() => {
    let isCurrent = true
    if (
      groupId &&
      cisId &&
      !ignoreDataCall &&
      (memberDetails ? memberDetails.groupId !== groupId || memberDetails.memberCisId !== cisId : true)
    ) {
      getMemberDetails(groupId, cisId).then(({ data }) => {
        isCurrent && setMemberDetails(data)
        return undefined
      })
    }

    return () => {
      isCurrent = false
    }
  }, [cisId, groupId, ignoreDataCall, memberDetails])

  return { memberDetails, setMemberDetails }
}

/**
 * @description Gets a list of members in the group.
 * @param {string} groupId - The group's ID.
 * @throws 400 - The group id wasn't valid.
 * @throws 403 - Only un-banished admins can view all members.
 * @throws 404 - Group not found.
 * @throws 410 - Group is tombstoned.
 */
export async function getGroupMembers(
  groupId: string
): Promise<{ members: GroupMember[]; joinRequests: GroupMember[] }> {
  return axios.get<{ members: GroupMember[] }>(`/service/tree/tree-data/groups/${groupId}/members`).then((res) => {
    const members = res.data.members.filter((member) => ['ADMIN', 'MEMBER'].includes(member.status))
    const joinRequests = res.data.members.filter((member) => member.status === 'PENDING')
    return { members, joinRequests }
  })
}

export function useGroupMembers({
  groupId,
  defaultState,
}: {
  groupId: string | undefined
  defaultState?: GroupMember[]
}): {
  adminCisIds: string[]
  groupMembersArray: GroupMember[] | undefined
  refetch: (groupId?: string) => void
  isLoading: boolean
} {
  const [groupMembersArray, setGroupMembersArray] = useState<GroupMember[] | undefined>(defaultState)
  const isCurrent = useRef(true)
  const isLoading = !groupMembersArray || groupMembersArray.length === 0
  const adminCisIds = useMemo(() => {
    return (
      groupMembersArray?.reduce<string[]>((cisIds, member) => {
        if (member.status === 'ADMIN') {
          cisIds.push(member.memberCisId)
        }
        return cisIds
      }, []) ?? []
    )
  }, [groupMembersArray])

  const fetchGroupMembers = useCallback(
    (groupIdPassedIn?: string) => {
      const finalGroupId = groupIdPassedIn || groupId
      if (finalGroupId) {
        getGroupMembers(finalGroupId).then(({ members }) => {
          isCurrent.current && setGroupMembersArray(members)
          return undefined
        })
      }
    },
    [groupId]
  )
  useEffect(() => {
    isCurrent.current = true
    const noAdminsInGroup = groupMembersArray?.filter((member) => member.status === 'ADMIN')?.length === 0
    if ((!groupMembersArray || noAdminsInGroup) && groupId) {
      isCurrent && fetchGroupMembers()
    }
    return () => {
      isCurrent.current = false
    }
  }, [fetchGroupMembers, groupId, groupMembersArray])

  return { adminCisIds, groupMembersArray, refetch: fetchGroupMembers, isLoading }
}

// POST
export function groupsCreateMePerson(treeId: string): AxiosPromise<TfTreeCopyResults> {
  return axios.post<TfTreeCopyResults>(`/service/tree/tree-data/user/CURRENT/tree/${treeId}/person/copy`)
}

export async function groupsCopyPersons({
  treeId,
  copyType,
  pids,
  signal,
}: {
  treeId: string
  copyType: 'me' | 'all' | 'ids'
  pids?: string[]
  signal?: GenericAbortSignal
}): Promise<AxiosResponse<TfTreeCopyResults>> {
  const ids = pids?.map((pid) => `id=${pid}`).join('&')
  const idString = ids ? `&${ids}` : ''
  const url = `/service/tree/tree-data/user/CURRENT/tree/${treeId}/person/copy?copyType=${copyType}${idString}`

  return axios.post<TfTreeCopyResults>(url, undefined, {
    timeout: 30_000,
    signal,
  })
}

export function groupsAutoMergeMePerson(
  treeId: string,
  personId: string,
  treePersonIsSurvivor?: boolean
): AxiosPromise<TfTreeCopyResult> {
  const reverseMerge = treePersonIsSurvivor ? '&treePersonIsSurvivor=true' : ''
  return axios.post<TfTreeCopyResult>(
    `/service/tree/tree-data/user/CURRENT/tree/${treeId}/person/copy-and-merge?treeMePersonId=${personId}${reverseMerge}`
  )
}

export function setGroupStartingPerson(groupId: string, personId: string): AxiosPromise<Partial<GroupDetails>> {
  return axios.post<Partial<GroupDetails>>(`/service/tree/tree-data/groups/${groupId}`, { startingPersonId: personId })
}

export function usePrivatePersonsCount(
  treeId: string | undefined
): ReturnType<typeof useCacheService<{ count: number }, 'cache-and-network'>> {
  const url = treeId ? `/service/tree/tree-data/trees/${treeId}/persons/count` : null
  const key = url
  const [{ data, loading, error }, refetch] = useCacheService<{ count: number }, 'cache-and-network'>(
    cacheService,
    url,
    key! // it will be defined when url is defined
  )

  return [{ data, loading: loading || !url, error }, refetch]
}

// Copied from add-find-flow
export function createRelationshipCall(
  relationshipType: 'child' | 'parent' | 'spouse',
  pid: string,
  relationship?: unknown,
  treeId?: string
): AxiosPromise<WrappedResponse<unknown>> {
  let url
  switch (relationshipType) {
    // child and parent use the same url
    case 'child':
    case 'parent':
      url = `/service/tree/tree-data/person/${pid}/relationships/parents`
      break
    case 'spouse':
      url = `/service/tree/tree-data/person/${pid}/relationships/spouses`
      break
    default:
      exhaustiveCheck(relationshipType)
      break
  }

  if (treeId) url += `?treeId=${treeId}`

  return axiosUntyped({
    url,
    method: 'post',
    data: relationship,
  })
}

export function setPreferredSpouse(personId: string, spouseId: string): AxiosPromise<unknown> {
  return axios.post(`/service/tree/tree-data/person/${personId}/preferredSpouse/${spouseId}`)
}
export function setPreferredParent(personId: string, coupleId: string): AxiosPromise<unknown> {
  return axios.post(`/service/tree/tree-data/person/${personId}/preferredParents/${coupleId}`)
}

const TEN_SECOND_LIFETIME = 10_000

export const cache = new Cache({
  storeName: 'group_management',
  type: 'memory',
  lifetime: TEN_SECOND_LIFETIME,
} satisfies CacheConfig) as CacheType

/**
 * @description generates and returns the data for sending an email invite.
 * @deprecated please use getInviteMessage instead
 * @param {string} groupId - The group's ID.
 * @param {bool} singleUse - If to create a single use invite
 * @param {string} pid - Person id of the person the invite is intended for.
 * @throws 400 - Invalid group id
 * @throws 400 - Invited group member count already at max
 * @throws 403 - Only un-banished group members can invite users to join the group
 * @throws 404 - Group not found
 * @throws 410 - Group is tombstoned
 */
export function createInviteMessage(
  groupId: GroupId,
  singleUse?: boolean,
  pid?: string,
  redirectUrl?: string,
  isResearcherGroup?: boolean
): ReturnType<typeof getInviteMessage> {
  return getInviteMessage({ groupId, singleUse, pid, redirectUrl, isResearcherGroup })
}

export type InviteMessageInfo = Omit<InviteMessage, 'inviteLink' | 'body'> & {
  message: InviteMessage['body']
  /** URL to join via group-management app */
  url: string
}

export const getInviteCacheId = ({ groupId, pid }: { groupId: string; pid?: string }): string =>
  pid ? `group-invite-${groupId}-${pid}` : `group-invite-${groupId}`

/**
 * @description generates and returns the data for sending an email invite.
 * @throws 400 - Invalid group id
 * @throws 400 - Invited group member count already at max
 * @throws 403 - Only un-banished group members can invite users to join the group
 * @throws 404 - Group not found
 * @throws 410 - Group is tombstoned
 */
export async function getInviteMessage({
  groupId,
  singleUse,
  pid,
  redirectUrl,
  isResearcherGroup,
}: {
  groupId: GroupId
  singleUse?: boolean
  pid?: string
  redirectUrl?: string
  isResearcherGroup?: boolean
}): Promise<InviteMessageInfo> {
  const cacheId = getInviteCacheId({ groupId, pid })
  const groupInvite = await cache.getItem<InviteMessageInfo>(cacheId)
  const personId = pid ? `&personId=${pid}` : ''
  const singleUseInvite = singleUse ? `?singleUse=true${personId}` : ''

  if (groupInvite && !isResearcherGroup) return Promise.resolve(groupInvite)

  return axios
    .post<InviteMessage>(`/service/tree/tree-data/groups/${groupId}/invites${singleUseInvite}`)
    .then((res) => {
      const redirectUrlParam = redirectUrl ? `&redirect_url=${redirectUrl}` : ''
      const optInUrlCET = '&cet_test=true'
      const inviteId = res.data.inviteId

      let inviteLink = createInviteLink({ isCet: isResearcherGroup, groupId, inviteId })

      if (singleUse && !isResearcherGroup) {
        inviteLink = `${inviteLink}${redirectUrlParam}`
      } else if (isResearcherGroup) {
        inviteLink = `${inviteLink}${optInUrlCET}${redirectUrlParam}`
      }

      const inviteInfo = {
        subject: res.data.subject,
        url: inviteLink,
        message: res.data.body,
        inviteId,
        groupId,
      }
      cache.setItem<InviteMessageInfo>(cacheId, inviteInfo)
      return inviteInfo
    })
}

// PUT
export function setMePerson(treeId: string, mePersonId: string): AxiosPromise<unknown> {
  return axios.put(`/service/tree/tree-data/user/CURRENT/tree/${treeId}/person/${mePersonId}`)
}
