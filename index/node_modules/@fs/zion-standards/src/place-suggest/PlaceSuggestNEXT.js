import React, { forwardRef } from 'react'
import { useFeatureFlag } from '@fs/zion-flags'
import PropTypes from 'prop-types'
import { PlaceSuggestion } from '@fs/zion-icon'
import { useTranslation } from 'react-i18next'
import { ListItem } from '@fs/zion-ui'
import { EventTypeEnum, getPlaceEventByType, ValidEventTypes } from '../standard-suggest/eventTypes'
import useProposedPlaces from './useProposedPlaces'
import StandardSuggestNEXT from '../standard-suggest/StandardSuggestNEXT'
import ProvisionalPlaceSuggestOverlay from './ProvisionalPlaceSuggestOverlay'
import { fetchPlaceSuggestionsFromApi } from './fetchPlaceSuggestions'

/**
 * Fetches place suggestions based on a search term, with optional filtering.
 * @param {string} searchTerm - The text to search for (e.g., "New York").
 * @param {Object} [options] - Configuration options.
 * @param {boolean} [options.showRepIds] - Include representative IDs (default: true).
 * @param {boolean} [options.noCache] - Bypass cache (default: false).
 * @param {boolean} [options.isExact] - Require exact matches (default: false).
 * @param {Object} [options.placeFilterOptions] - Filters for place suggestions (e.g., { reqTypes: ["City"] }).
 * @returns {Promise<Array>} Array of suggestion objects (e.g., [{ primaryText: "New York, NY" }]).
 */
export function getPlaceSuggestions(searchTerm, options = {}) {
  const config = {
    showRepIds: true,
    noCache: false,
    isExact: false,
    placeFilterOptions: {},
    ...options,
  }

  return fetchPlaceSuggestionsFromApi({
    placesSearchTerm: searchTerm,
    showRepIds: config.showRepIds,
    noCache: config.noCache,
    isExact: config.isExact,
    placeFilterOptions: config.placeFilterOptions,
  })
}

/**
 * PlaceSuggestNEXT
 *
 * A component for suggesting and selecting places, with optional provisional place creation.
 * Uses StandardSuggestNEXT for core suggestion functionality, adding place-specific features like
 * proposed place suggestions and overlay management.
 */
const PlaceSuggestNEXT = forwardRef(function PlaceSuggest(
  {
    label,
    standardize,
    eventType = EventTypeEnum.NONE,
    isPartial,
    isProposed = false,
    excludePlaceId,
    showRepIds,
    noCache,
    isExact,
    placeFilterOptions,
    simplified,
    getSuggestions,
    config,
    ...props
  },
  ref
) {
  const { t } = useTranslation()
  const proposeNewPlacesFeature = useFeatureFlag('standards_placeSuggest_proposedPlaces')
  const inputLabel = label || getPlaceEventByType(eventType)?.label
  const { proposedSuggestions, reloadProposedSuggestions, createSuggestionFromProposedPlaceRep } = useProposedPlaces()

  /**
   * Fetches place suggestions, including proposed places and a "Suggest New Place" option if applicable.
   * @param {string} searchTerm - The text to search for.
   * @returns {Promise<Array>} Array of suggestion objects.
   */
  const getPlaceSuggestionsWithConfig = async (searchTerm) => {
    // Only include defined props in options
    const options = {}
    if (placeFilterOptions !== undefined) options.placeFilterOptions = placeFilterOptions
    if (showRepIds !== undefined) options.showRepIds = showRepIds
    if (noCache !== undefined) options.noCache = noCache
    if (isExact !== undefined) options.isExact = isExact
    if (excludePlaceId !== undefined) options.excludePlaceId = excludePlaceId
    if (isPartial !== undefined) options.isPartial = isPartial

    const regularSuggestions = await getPlaceSuggestions(searchTerm, options)
    let allSuggestions = regularSuggestions || []

    if (
      isProposed &&
      proposeNewPlacesFeature?.isOn &&
      searchTerm &&
      searchTerm.length >= 2 &&
      proposedSuggestions?.length
    ) {
      const matchingProposed = proposedSuggestions.filter((suggestion) =>
        suggestion.primaryText.toLowerCase().includes(searchTerm.toLowerCase())
      )
      if (matchingProposed.length > 0) {
        allSuggestions = [...matchingProposed, ...(allSuggestions.length > 0 ? allSuggestions : [])]
      }
    }

    if (isProposed && proposeNewPlacesFeature?.isOn && searchTerm && searchTerm.trim().length > 0) {
      allSuggestions.push({
        key: 'LAST_RESORT',
        primaryText: t('place-suggest.new-place.label', 'Suggest New Place'),
        startElement: <ListItem.Icon Icon={PlaceSuggestion} />,
      })
    }

    return allSuggestions
  }

  return (
    <>
      <StandardSuggestNEXT
        label={inputLabel}
        type="place"
        getSuggestions={getSuggestions || getPlaceSuggestionsWithConfig}
        config={config}
        {...props}
        ref={ref}
      />
      {isProposed && proposeNewPlacesFeature?.isOn && (
        <ProvisionalPlaceSuggestOverlay
          config={config}
          reloadProposedSuggestions={reloadProposedSuggestions}
          createSuggestionFromProposedPlaceRep={createSuggestionFromProposedPlaceRep}
        />
      )}
    </>
  )
})

export default PlaceSuggestNEXT
export const meta = {
  name: 'PlaceSuggestNEXT',
  isZionFormComponent: true,
}

PlaceSuggestNEXT.meta = meta

// Shape of the standardized place object from the API
const placeStandardShape = PropTypes.shape({
  standardizedText: PropTypes.string,
  id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired, // Allow string or number
  countryId: PropTypes.number,
  relevanceScore: PropTypes.number,
  placeType: PropTypes.string,
  yearRange: PropTypes.string,
  location: PropTypes.shape({
    latitude: PropTypes.number,
    longitude: PropTypes.number,
  }),
  matchedAlternateName: PropTypes.string,
})

// Shape of the config object from useStandardSuggestNEXT
const configShape = PropTypes.shape({
  userInput: PropTypes.string.isRequired,
  fieldValue: PropTypes.string.isRequired,
  selectedItem: PropTypes.shape({
    primaryText: PropTypes.string.isRequired,
    isStandard: PropTypes.bool,
    standard: placeStandardShape,
  }),
  standardSuggestSuggestion: PropTypes.shape({
    originalText: PropTypes.string,
    standard: placeStandardShape,
  }),
  set: PropTypes.func.isRequired,
  standardize: PropTypes.bool.isRequired,
})

PlaceSuggestNEXT.propTypes = {
  /** Configuration object from useStandardSuggestNEXT, controlling state and behavior */
  config: configShape.isRequired,
  /** The event type influencing suggestion context (e.g., 'birth', 'death') */
  eventType: PropTypes.oneOf(ValidEventTypes),
  /** Place ID to exclude from suggestions */
  excludePlaceId: PropTypes.string,
  /** Function to fetch place suggestions based on user input */
  getSuggestions: PropTypes.func,
  /** The isExact option modifies the default search from "partial" to "exact" match.
   * This "partial" search considers characters slightly misplaced as potential matches, enhancing search flexibility.
   */
  isExact: PropTypes.bool,
  /** Whether to allow partial matches in search results */
  isPartial: PropTypes.bool,
  /** The isProposed feature allows signed-in users to create a proposed place when the required place is not available in
   * the existing standardized places. This initiates a standardization process for the new place, which typically takes
   * 20 minutes but can extend up to 24 hours. The proposed place is cached locally for immediate use. Consultation
   * with the standards team is advised before enabling isProposed
   */
  isProposed: PropTypes.bool,
  /** The label associated with the Autosuggest input TextField */
  label: PropTypes.string,
  /** Whether user should be guided through the standardization process. */
  standardize: PropTypes.bool,
  /** Whether to bypass cache for fresh suggestions */
  noCache: PropTypes.bool,
  /**
   * `placeFilterOptions` is an optional prop to direct and filter place search results.
   * It is an object that can have the following properties:
   *
   * - `reqTypes`: An array of type identifiers or type codes.
   *    Only Place Representations of a type in this list will be included.
   *
   * - `filterTypes`: An array of place type IDs or codes. Place Representations with these types are filtered out.
   *
   * - `reqTypeGroups`: An array of type group identifiers.
   *    The Place Representation must have a type that is a member of a group in this list.
   *
   * - `filterTypeGroups`: An array of group identifiers.
   *    Place Representations with types in these groups are filtered out.
   *
   * - `placeHint`: A place to use as a hint for finding the proper Place Representation.
   *    Can be a comma-delimited list of Place Rep IDs or a semi-colon-delimited list of names.
   *
   * - `placeHintLevel`: Affects how impactful the place hint can be in the results.
   *    Can be one of 'STRICT', 'STRONG', 'NORMAL', 'WEAK'.
   */
  placeFilterOptions: PropTypes.shape({
    reqTypes: PropTypes.arrayOf(PropTypes.string),
    filterTypes: PropTypes.arrayOf(PropTypes.string),
    reqTypeGroups: PropTypes.arrayOf(PropTypes.string),
    filterTypeGroups: PropTypes.arrayOf(PropTypes.string),
    placeHint: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.string]),
    placeHintLevel: PropTypes.oneOf(['STRICT', 'STRONG', 'NORMAL', 'WEAK']),
  }),
  /** Ref forwarded to the underlying input element */
  ref: PropTypes.oneOfType([PropTypes.func, PropTypes.shape({ current: PropTypes.any })]),
  /** Whether to show representative IDs in suggestions */
  showRepIds: PropTypes.bool,
  /** Search for place sets rather than time-based place representation. Recommended for wide searches. Not recommended
   * for life events or use-cases requiring a place represented within a timeframe. */
  simplified: PropTypes.bool,
}

export { PlaceSuggestNEXT }
