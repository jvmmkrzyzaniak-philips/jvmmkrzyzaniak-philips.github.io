import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import { ListItem, useStatusOverlay } from '@fs/zion-ui'
import Cache from '@fs/zion-cache'
import { i18n } from '@fs/zion-locale'
import { PlaceSuggestion } from '@fs/zion-icon'
import { LOG_LEVEL, stdLog } from '../stdLog'
import { validateProposedPlaces } from './placeRepService'

const proposedPlacesCache = new Cache({ storeName: 'proposedPlaces', type: 'session' })

function createSuggestionFromProposedPlaceRep(placeRep) {
  return {
    key: `${placeRep?.id}`,
    primaryText: placeRep?.fullDisplay?.name,
    secondaryText: placeRep?.type?.localizedName?.find((name) => name?.locale === i18n?.language)?.name,
    isProposed: true,
    isStandard: true,
    startElement: <ListItem.Icon Icon={PlaceSuggestion} />,
    group: i18n.t('place-suggest.suggested-places.label', 'Places You Suggested'),
    place: placeRep,
  }
}

function mapProposedPlaceRepsToSuggestions(proposedPlaceReps) {
  return proposedPlaceReps?.map(createSuggestionFromProposedPlaceRep) ?? []
}
async function getProposedPlaces({ isMounted }) {
  let cachedPlaces
  let validatedPlaces = []
  let removedPlacesMessages = []

  try {
    cachedPlaces = await proposedPlacesCache?.getItem('proposedPlaces')
  } catch {
    cachedPlaces = []
    stdLog({
      msg: `PlaceSuggest Failed to get proposedPlaces from local cache!`,
      component: 'PlaceSuggest',
      logLevel: LOG_LEVEL.ERROR,
    })
  }

  if (cachedPlaces?.length > 0 && isMounted.current) {
    try {
      const validatedAndProposed = await validateProposedPlaces(cachedPlaces)
      validatedPlaces = validatedAndProposed?.validatedPlaces ?? []
      removedPlacesMessages = validatedAndProposed?.removedPlacesMessages ?? []
    } catch {
      const cachedPlaceSummary = JSON.stringify(
        cachedPlaces.map((placeRep) => ({ name: placeRep?.fullDisplay?.name, id: placeRep.id }))
      )
      stdLog({
        msg: `PlaceSuggest Failed to validate proposedPlaces ${cachedPlaceSummary} from local cache!`,
        component: 'PlaceSuggest',
        logLevel: LOG_LEVEL.ERROR,
      })
    }
  }

  if (validatedPlaces?.length && isMounted.current) {
    try {
      await proposedPlacesCache?.setItem('proposedPlaces', validatedPlaces)
    } catch {
      const validatedPlaceSummary = JSON.stringify(
        validatedPlaces.map((placeRep) => ({ name: placeRep?.fullDisplay?.name, id: placeRep.id }))
      )
      stdLog({
        msg: `PlaceSuggest Failed to save validated and proposedPlaces ${validatedPlaceSummary} to local cache!`,
        component: 'PlaceSuggest',
        logLevel: LOG_LEVEL.ERROR,
      })
    }
  }
  return { validatedPlaces, removedPlacesMessages }
}

export default function useProposedPlaces() {
  const isMountedRef = useRef(true)
  const statusOverlay = useStatusOverlay()
  const [proposedPlaces, setProposedPlaces] = useState([])
  const proposedSuggestions = useMemo(() => {
    return mapProposedPlaceRepsToSuggestions(proposedPlaces)
  }, [proposedPlaces])

  const addProposedPlaceRep = useCallback(
    async (placeRep) => {
      try {
        const newProposedPlaces = proposedPlaces?.length > 0 ? [...proposedPlaces, placeRep] : [placeRep]
        await proposedPlacesCache?.setItem('proposedPlaces', newProposedPlaces)
        setProposedPlaces(newProposedPlaces)
      } catch {
        stdLog({
          msg: `PlaceSuggest Failed to save proposed place with name:${placeRep?.fullDisplay?.name} id:${placeRep?.id}  to local cache!`,
          component: 'PlaceSuggest',
          logLevel: LOG_LEVEL.ERROR,
        })
      }
    },
    [proposedPlaces]
  )

  const loadProposedSuggestions = useCallback(async () => {
    getProposedPlaces({ isMounted: isMountedRef }).then(({ validatedPlaces, removedPlacesMessages }) => {
      if (isMountedRef.current) {
        setProposedPlaces(validatedPlaces)
        removedPlacesMessages?.forEach((message) => {
          statusOverlay({
            message,
            dismissable: true,
          })
        })
      }
    })
  }, [statusOverlay])

  useEffect(() => {
    if (isMountedRef.current) {
      loadProposedSuggestions({ isMounted: isMountedRef })
    }
    return () => {
      isMountedRef.current = false
    }
  }, [isMountedRef, statusOverlay, loadProposedSuggestions])

  return {
    proposedSuggestions,
    addProposedPlaceRep,
    reloadProposedSuggestions: loadProposedSuggestions,
    createSuggestionFromProposedPlaceRep,
  }
}
