import React from 'react'
import axios from '@fs/zion-axios'
import { ThingMapPin } from '@fs/zion-icon'
import zionDebug from '@fs/zion-debug'
import { i18n } from '@fs/zion-locale'
import { ListItem } from '@fs/zion-ui'
import { baseUrl } from '@fs/zion-config'

const standardIcon = <ListItem.Icon Icon={ThingMapPin} />

const debug = zionDebug('standards:place-suggest:fetch-place-suggestions')
let cacheBusterCounter = 1

function getCacheBuster() {
  return new Date().getTime() + cacheBusterCounter++
}

function getTokenWithAlternateName(fullDisplayName, tokenMatches = []) {
  if (
    tokenMatches[0]?.name?.name &&
    !fullDisplayName?.toLowerCase().includes(tokenMatches[0].name.name.toLowerCase())
  ) {
    return tokenMatches[0]
  }
  return null
}

/**
 * This function gets a string that helps a patron match
 * typed-in text to a place returned by the places API.
 *
 * The tertiary text is only helpful if it is not already
 * displayed in the primaryText field (i.e. fullDisplayName).
 *
 * @param {string} fullDisplayName - The place name with all of it's jurisdiction levels.
 * @param {Object} tokenMatches - The tokens matched from Places 2.0 API.
 * @returns {string}
 */
function getTertiaryText(fullDisplayName, tokenMatches = []) {
  const firstTokenWithAlternateName = getTokenWithAlternateName(fullDisplayName, tokenMatches)
  if (firstTokenWithAlternateName) {
    const alternateName = firstTokenWithAlternateName?.name?.name
    return i18n.t('place-suggest.alternate-name.label', 'Alternate Name: {alternateName}', { alternateName })
  }
  return ''
}

function getJurisdictionChain(jurisdiction) {
  const chain = []
  while (jurisdiction) {
    chain.push(jurisdiction.id)
    jurisdiction = jurisdiction.jurisdiction
  }
  return chain
}

/**
 * Transform Place 2.0 API format to a simple UI format.
 * A place id (repId) can be used to lookup details of a place through the Places 2.0 API.
 * https://www.familysearch.org/service/standards/place/ws-ui/request/reps/{id}
 *
 * The placeType and yearRange help distinguish places that share the same location.
 *
 * The location provides the latitude and longitude geoLocation.
 *
 * MatchedTokenName helps a patron understand why the place standard was matched to the input text.
 *
 * The jurisdictionChain is an array of jurisdiction ids from each level.
 *
 * @param {Object} place - The place object from the Places 2.0 API.
 * @returns {Object} - The transformed place object for UI.
 * @property {string} id - The place id.
 * @property {string} standardizedText - The standardized name of the place.
 * @property {string} placeType - The type of the place.
 * @property {string} yearRange - The year range of the place.
 * @property {Object} location - The latitude and longitude of the place.
 * @property {string} matchedAlternateName - The matched alternate name, if any.
 * @property {Array} jurisdictionChain - The array of jurisdiction ids from each level.
 * @property {number} relevanceScore - The relevance score of the place.
 */
function convertApiPlaceFormatToUIPlaceFormat(place) {
  const { tokenMatches, relevanceScore } = place ?? {}
  const { fromYear, toYear, fullDisplay, type, id } = place?.rep ?? {}
  const standardizedText = fullDisplay?.name
  const unknownLabel = i18n.t('place-suggest.date-unknown.label', 'Unknown')
  const presentLabel = i18n.t('place-suggest.date-present.label', 'Present')
  const yearRange = fromYear || toYear ? `${fromYear || unknownLabel} - ${toYear || presentLabel}` : ''
  const placeType = type?.localizedName && type.localizedName[0]?.name ? `${type.localizedName[0]?.name}, ` : ''
  const location = place?.rep?.location?.centroid
  const matchedAlternateName = getTokenWithAlternateName(fullDisplay?.name, tokenMatches)?.name?.name
  const jurisdictionChain = getJurisdictionChain(place?.rep)
  const countryId = jurisdictionChain.length > 0 ? jurisdictionChain[jurisdictionChain.length - 1] : null

  return {
    id,
    standardizedText,
    placeType,
    yearRange,
    location,
    matchedAlternateName,
    countryId,
    jurisdictionChain,
    relevanceScore,
  }
}

function getPlaceIdText(placeId, showPlaceId, standard) {
  if (placeId) {
    return ` (${placeId})`
  }
  if (showPlaceId && !!standard?.id) {
    return ` (${standard.id})`
  }
  return ''
}

export function getPlaceOptionsFromApiResponse(response, placeId, showPlaceId = false) {
  return response.data.searchResults[0].result.map((apiPlace) => {
    const { tokenMatches } = apiPlace || {}
    const { fullDisplay, id, preferredLocale } = apiPlace?.rep || {}
    const tertiaryText = getTertiaryText(fullDisplay?.name, tokenMatches)
    const standard = convertApiPlaceFormatToUIPlaceFormat(apiPlace)
    const placeIdText = getPlaceIdText(placeId, showPlaceId, standard)
    return {
      primaryText: standard?.standardizedText,
      secondaryText: `${standard?.placeType}${standard?.yearRange}${placeIdText}`,
      key: id,
      startElement: standardIcon,
      standard,
      tertiaryText,
      isStandard: true,
      preferredLocale,
    }
  })
}

export function getSimplifiedPlaceOptionsFromApiResponse(response) {
  return response.data.simplifiedResults.map((apiPlace) => {
    return {
      primaryText: apiPlace.placeName,
      key: `${apiPlace.originalRep}-${apiPlace.placeName}`,
      result: apiPlace,
    }
  })
}

async function fetchSingleRep(placeServiceUrl, id) {
  const repUrl = `${placeServiceUrl}/places/reps`
  const cacheBuster = getCacheBuster()
  debug(`fetchPlaceSuggestions.fetchSingleRep: {repUrl: ${repUrl}, id: ${id}}`)
  // Get place rep from id
  const response = await axios.get(
    `${repUrl}/${id}?includeIsParent=true&variants=true&altJuris=true&samePlace=true&_=${cacheBuster}`,
    {
      placesAPI: true,
      headers: {
        'Content-Type': 'application/standards-places-v2+json',
        Accept: 'application/json',
      },
    }
  )
  response.data.relevanceScore = 100
  return { data: { searchResults: [{ result: [response.data], count: 1 }] } }
}

async function fetchMultipleReps({ placeServiceUrl, placesSearchTerm, isExact = false, placeFilterOptions }) {
  const repUrl = `${placeServiceUrl}/places/request`
  debug(`fetchPlaceSuggestions.fetchMultipleReps: {repUrl: ${repUrl}, text: ${placesSearchTerm}}`)

  // TODO -  Remove the acceptLanguage=${i18n.language} query param when the DTM is fixed to syncronize with the Zion Laguage picker
  let url = `${repUrl}?text=${encodeURIComponent(placesSearchTerm.trim())}&limit=15&output=summary&acceptLanguage=${
    i18n?.language || 'en'
  }${isExact ? '' : '&partial=true'}`

  // Add any additional placeTypeFilters parameters
  if (placeFilterOptions) {
    Object.keys(placeFilterOptions).forEach((key) => {
      url += `&${encodeURIComponent(key)}=${encodeURIComponent(placeFilterOptions[key])}`
    })
  }

  return axios.get(url, {
    placesAPI: true,
    headers: {
      'Content-Type': 'application/standards-places-v2+json',
    },
  })
}

function getPlaceIdFromSearchTerm(searchTerm) {
  const placeId = Number.parseInt(searchTerm, 10)
  if (searchTerm === String(placeId)) {
    return placeId
  }
  return undefined
}

async function internalFetchPlaceSuggestions({ placesSearchTerm, noCache, showPlaceId, exact, placeFilterOptions }) {
  try {
    const trimmedPlacesSearchTerm = placesSearchTerm.trim()
    if (!trimmedPlacesSearchTerm) return []

    const basePath = `${baseUrl || ''}/service/standards/place/${noCache ? 'ws-write' : 'ws-ui'}`
    const placeId = getPlaceIdFromSearchTerm(trimmedPlacesSearchTerm)
    let response
    if (placeId) {
      response = await fetchSingleRep(basePath, placeId)
    } else {
      response = await fetchMultipleReps({
        placeServiceUrl: basePath,
        placesSearchTerm: trimmedPlacesSearchTerm,
        exact,
        placeFilterOptions,
      })
    }
    return getPlaceOptionsFromApiResponse(response, placeId, showPlaceId)
  } catch (err) {
    debug('Request err:', err?.message)
    // Return empty list of options on error
    return []
  }
}

async function simplifiedInternalFetchPlaceSuggestions({
  placesSearchTerm,
  noCache,
  showPlaceId,
  exact,
  placeFilterOptions,
}) {
  try {
    const trimmedPlacesSearchTerm = placesSearchTerm.trim()
    if (!trimmedPlacesSearchTerm) return []

    const basePath = `${baseUrl || ''}/service/standards/place/${noCache ? 'ws-write' : 'ws-ui'}`
    const placeId = getPlaceIdFromSearchTerm(trimmedPlacesSearchTerm)
    let response
    if (placeId) {
      response = await fetchSingleRep(basePath, placeId)
      return getPlaceOptionsFromApiResponse(response, placeId, showPlaceId)
    }
    response = await fetchMultipleReps({
      placeServiceUrl: basePath,
      placesSearchTerm: trimmedPlacesSearchTerm,
      exact,
      placeFilterOptions: { ...placeFilterOptions, simplified: true },
    })
    return getSimplifiedPlaceOptionsFromApiResponse(response)
  } catch (err) {
    debug('Request err:', err?.message)
    // Return empty list of options on error
    return []
  }
}

export function fetchPlaceSuggestionsFromApi({ placesSearchTerm, showRepIds, noCache, isExact, placeFilterOptions }) {
  return internalFetchPlaceSuggestions({ placesSearchTerm, noCache, showRepIds, isExact, placeFilterOptions })
}

export function fetchSimplifiedPlaceSuggestionsFromApi({
  placesSearchTerm,
  showRepIds,
  noCache,
  isExact,
  placeFilterOptions,
}) {
  return simplifiedInternalFetchPlaceSuggestions({ placesSearchTerm, noCache, showRepIds, isExact, placeFilterOptions })
}

/**
 * Retrieve the appropriate list of Autosuggest options for the provided places search term.
 *
 * Only one outstanding place search request is allowed. If there are any outstanding requests
 * they are canceled before issueing a new request.
 *
 * @param {string} placesSearchTerm - The user input text to use in finding the list of matching places.
 * @param {boolean} useCache - Whether to hit the read-only places cache server instance.
 * @param {boolean} showPlaceId - Whether to include the place ID in each suggestion found in the place standard.
 * @param {boolean} exact - When true, returns only exact matches. When false (default), includes partial matches.
 * @returns {Promise<Array>} - A promise that resolves to an array of place suggestion objects.
 */
export default async function fetchPlaceSuggestions(
  placesSearchTerm,
  useCache = true,
  showPlaceId = false,
  exact = false
) {
  return internalFetchPlaceSuggestions({ placesSearchTerm, useCache, showPlaceId, exact })
}
