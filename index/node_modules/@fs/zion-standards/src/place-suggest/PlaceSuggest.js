import React, { forwardRef, Suspense } from 'react'
import { useFeatureFlag } from '@fs/zion-flags'
import PropTypes from 'prop-types'
import { useTranslation } from 'react-i18next'
import { EventTypeEnum, ValidEventTypes } from '../standard-suggest/eventTypes'

const StandardSuggestCore = React.lazy(() => import('../standard-suggest/StandardSuggestCore'))
const StandardSuggest = React.lazy(() => import('../standard-suggest/StandardSuggest'))
const ProposeNewPlaceSuggest = React.lazy(() => import('./ProposeNewPlaceSuggest'))

const PlaceSuggest = forwardRef(function PlaceSuggest(
  {
    label: inputLabel,
    onSuggestionSelected,
    standardize,
    eventType = EventTypeEnum.NONE,
    externalLinkType = 'none',
    mapKey = '',
    isPartial,
    isProposed = false,
    ...props
  },
  ref
) {
  const { t } = useTranslation()
  const proposeNewPlacesFeature = useFeatureFlag('standards_placeSuggest_proposedPlaces')
  const label = [true, false, null].includes(inputLabel)
    ? inputLabel
    : inputLabel || t('date-suggest.place.label', 'Place')

  if (standardize) {
    return (
      <Suspense fallback={null}>
        <StandardSuggest
          onSuggestionSelected={(suggestion) => {
            onSuggestionSelected(suggestion)
          }}
          label={label}
          type="place"
          eventType={eventType}
          externalLinkType={externalLinkType}
          mapKey={mapKey}
          {...props}
          ref={ref}
        />
      </Suspense>
    )
  }

  if (isProposed && proposeNewPlacesFeature?.isOn) {
    return (
      <Suspense fallback={null}>
        <ProposeNewPlaceSuggest label={label} onSuggestionSelected={onSuggestionSelected} {...props} ref={ref} />
      </Suspense>
    )
  }

  return (
    <Suspense fallback={null}>
      <StandardSuggestCore
        type="place"
        label={label}
        onSuggestionSelected={onSuggestionSelected}
        {...props}
        ref={ref}
      />
    </Suspense>
  )
})

export default PlaceSuggest
export const meta = {
  name: 'PlaceSuggest',
  isZionFormComponent: true,
}

PlaceSuggest.meta = meta

const placeStandardShape = PropTypes.shape({
  standardizedText: PropTypes.string.isRequired,
  id: PropTypes.string.isRequired,
  countryId: PropTypes.number,
  relevanceScore: PropTypes.number,
  placeType: PropTypes.string,
  yearRange: PropTypes.string,
  location: PropTypes.shape({
    latitude: PropTypes.number,
    longitude: PropTypes.number,
  }),
  matchedAlternateName: PropTypes.string,
})

PlaceSuggest.propTypes = {
  /** The label associated with the Autosuggest input TextField */
  label: PropTypes.string,
  /** An event handler called whenever a new Autosuggest option is selected from keyboard, mouse, or finger tap */
  onSuggestionSelected: PropTypes.func,
  /** Whether user should be guided through the standardization process. */
  standardize: PropTypes.bool,
  /** The event type */
  eventType: PropTypes.oneOf(ValidEventTypes),
  /** The Type of External link to places Map  */
  externalLinkType: PropTypes.oneOf(['none', 'map', 'link']),
  /** Your apps google Map developer key (required for externalLinkType = 'map')  */
  mapKey: PropTypes.string,
  /** Search for place sets rather than time-based place representation. Recommended for wide searches. Not recommended
   * for life events or use-cases requiring a place represented within a timeframe. */
  simplified: PropTypes.bool,
  /** Initialize PlaceSuggest with a given selected item */
  initialSelectedItem: PropTypes.oneOfType([
    /** Use this format when standardize prop is NOT set. */
    PropTypes.shape({
      primaryText: PropTypes.string.isRequired,
      isStandard: PropTypes.bool,
      secondaryText: PropTypes.string,
      tertiaryText: PropTypes.string,
      /** standard is only necessary when isStandard is true. */
      standard: placeStandardShape,
    }),
    /** Use this format when standardize prop is set. */
    PropTypes.shape({
      originalText: PropTypes.string,
      standard: placeStandardShape,
    }),
  ]),

  /** The isExact option modifies the default search from "partial" to "exact" match.
   *  This "partial" search considers characters slightly misplaced as potential matches, enhancing search flexibility.
   */
  isExact: PropTypes.bool,

  /** The isProposed feature allows signed-in users to create a proposed place when the required place is not available in
   *  the existing standardized places. This initiates a standardization process for the new place, which typically takes
   *  20 minutes but can extend up to 24 hours. The proposed place is cached locally for immediate use. Consultation
   *  with the standards team is advised before enabling isProposed */
  isProposed: PropTypes.bool,

  /**
   * `placeFilterOptions` is an optional prop to direct and filter place search results.
   *  It is an object that can have the following properties:
   *
   * - `reqTypes`: An array of type identifiers or type codes.
   *    Only Place Representations of a type in this list will be included.
   *
   * - `filterTypes`: An array of place type IDs or codes. Place Representations with these types are filtered out.
   *
   * - `reqTypeGroups`: An array of type group identifiers.
   *    The Place Representation must have a type that is a member of a group in this list.
   *
   * - `filterTypeGroups`: An array of group identifiers.
   *    Place Representations with types in these groups are filtered out.
   *
   * - `placeHint`: A place to use as a hint for finding the proper Place Representation.
   *    Can be a comma-delimited list of Place Rep IDs or a semi-colon-delimited list of names.
   *
   * - `placeHintLevel`: Affects how impactful the place hint can be in the results.
   *    Can be one of 'STRICT', 'STRONG', 'NORMAL', 'WEAK'.
   */

  placeFilterOptions: PropTypes.shape({
    reqTypes: PropTypes.arrayOf(PropTypes.string),
    filterTypes: PropTypes.arrayOf(PropTypes.string),
    reqTypeGroups: PropTypes.arrayOf(PropTypes.string),
    filterTypeGroups: PropTypes.arrayOf(PropTypes.string),
    placeHint: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.string]),
    placeHintLevel: PropTypes.oneOf(['STRICT', 'STRONG', 'NORMAL', 'WEAK']),
  }),
}
