import React from 'react'
import axios from '@fs/zion-axios'
import { ThingCalendar } from '@fs/zion-icon'
import zionDebug from '@fs/zion-debug'
import { i18n } from '@fs/zion-locale'
import { ListItem } from '@fs/zion-ui'
import { defaultYearRangeEstimate } from './defaultYearRange'

const standardIcon = <ListItem.Icon Icon={ThingCalendar} />
const debug = zionDebug('zion:date-suggest:fetch-date-suggestions')

function isInternationalDate(text) {
  const re = /[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f\u3131-\uD79D]/
  return re.test(text)
}

function getPrimaryText(date) {
  return date?.localizedDate?.value
}

function getSecondaryText(date, dateSearchTerm) {
  const international = isInternationalDate(dateSearchTerm)
  // return international ? date.localizedDate.value : null
  const matches = date?.localizedDate?.value === dateSearchTerm
  return international && !matches ? dateSearchTerm : null
}

function getTertiaryText(date) {
  const dynasty = date?.cjkDetail?.dynasty || date?.cjkDetail?.dynastyAlt
  return dynasty ? i18n.t('date-suggest.date.dynasty.heading', `Dynasty: {dynasty}`, { dynasty }) : null
}

function calculateYearRange(simpleDates) {
  const earliestYear = simpleDates && simpleDates[0] ? simpleDates[0].year : undefined
  const latestYear = simpleDates && simpleDates[1] ? simpleDates[1].year : undefined

  if (earliestYear && latestYear) {
    return `${earliestYear}-${latestYear}`
  }
  if (earliestYear) {
    return `${earliestYear}`
  }
  return ''
}

/**
 * Transform Date 2.0 api format to a simple UI format.
 *
 * Since dates are calculated from input rather than read from a database, the most important parameters are
 * originalText and standardizedText.
 *
 * sortKeyShort, earliestAstro and latestAstro are often used together for sorting.
 *
 * formalText, and Year range can also be useful for display.
 *
 * @param date
 * @returns {{originalText: *, formalText: *, yearRange: string, standardText: *, earliestAstro: *, latestAstro: *, id: *, sortKeyShort: *}}
 */
function convertApiDateFormatToUIDateFormat(date) {
  const sortKey = date?.sortKeys?.sortKeyShort
  const standardizedText = date?.localizedDate?.value
  const originalText = date?.original
  const simpleDates = date?.detail?.simpleDates
  const earliestAstro = simpleDates && simpleDates[0] ? simpleDates[0].astroday : undefined
  const latestAstro = simpleDates && simpleDates[1] ? simpleDates[1].astroday : undefined
  const yearRange = calculateYearRange(simpleDates)
  const formalText = date?.gedcomx
  return { sortKey, standardizedText, originalText, earliestAstro, latestAstro, yearRange, formalText }
}
function isMissingInternationalSearchTermOption({ international, dateOptions, dateSearchTerm }) {
  return international && !dateOptions.find((option) => option.primaryText === dateSearchTerm)
}

function getDateOptionsFromApiResponse({ dates, dateSearchTerm }) {
  const international = isInternationalDate(dateSearchTerm)
  const dateOptions = dates.map((apiDate) => {
    const primaryText = getPrimaryText(apiDate)
    const secondaryText = getSecondaryText(apiDate, dateSearchTerm)
    const tertiaryText = getTertiaryText(apiDate)
    const standard = convertApiDateFormatToUIDateFormat(apiDate)
    const key = apiDate.repId || `${primaryText}|${secondaryText ?? ''}`
    return {
      primaryText,
      secondaryText,
      tertiaryText,
      international,
      key,
      startElement: standardIcon,
      standard,
      isStandard: true,
    }
  })
  if (isMissingInternationalSearchTermOption({ international, dateOptions, dateSearchTerm })) {
    dateOptions.unshift({
      key: 'INPUT_TEXT_OPTION',
      primaryText: dateSearchTerm,
      type: 'INPUT_TEXT_OPTION',
    })
  }
  return dateOptions
}

function isValidDateInput(input) {
  // Regular expression to match CJK characters
  const cjkPattern = /[\u4E00-\u9FFF\u3400-\u4DBF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF]/
  // Regular expression to match any numeral (ASCII, CJK, Khmer)
  const numeralPattern = /^[\d\u4E00-\u9FFF\u3400-\u4DBF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF\u17E0-\u17E9]{1,4}$/

  // Check if input contains CJK characters
  if (cjkPattern.test(input)) {
    return true
  }

  // Check if input is purely numeric (ASCII, CJK, or Khmer) and has exactly four digits
  if (numeralPattern.test(input)) {
    return input.length === 4
  }

  // Allow other variations without specific date pattern checks
  return true
}

function applyYearRangeEstimate(dates, yearRangeEstimate) {
  const { startYear, endYear } = yearRangeEstimate || {}

  // Helper function to create a sort key from a year
  function createSortKey(year) {
    const eraIndicator = year < 0 ? 'B' : 'C'
    const yearString = String(Math.abs(year)).padStart(4, '0')
    return `${eraIndicator}${yearString}0000000000`
  }

  // Create sort keys for the start and end years
  const startSortKey = createSortKey(startYear)
  const endSortKey = createSortKey(endYear)

  // Sort the dates
  const sortedDates = dates.sort((a, b) => {
    const aSortKey = a.sortKeys.sortKeyShort
    const bSortKey = b.sortKeys.sortKeyShort

    const aIsBC = aSortKey.startsWith('B')
    const bIsBC = bSortKey.startsWith('B')

    const aInRange =
      (aIsBC && aSortKey >= endSortKey && aSortKey <= startSortKey) ||
      (!aIsBC && aSortKey >= startSortKey && aSortKey <= endSortKey)
    const bInRange =
      (bIsBC && bSortKey >= endSortKey && bSortKey <= startSortKey) ||
      (!bIsBC && bSortKey >= startSortKey && bSortKey <= endSortKey)

    if (aInRange && !bInRange) return -1
    if (!aInRange && bInRange) return 1

    if (aIsBC && bIsBC) {
      // Both dates are BC, sort in ascending order (newest first)
      return aSortKey.localeCompare(bSortKey)
    }
    if (!aIsBC && !bIsBC) {
      // Both dates are AD, sort in descending order (newest first)
      return bSortKey.localeCompare(aSortKey)
    }
    // One date is BC and the other is AD, AD dates should come first
    return aIsBC ? 1 : -1
  })

  return sortedDates
}

/**
 * Retrieve the appropriate list of Autosuggest options for the provided dateSearchTerm.
 *
 * @param {string} dateSearchTerm - The user input text to use in finding the list of matching dates.
 * @param {Object} [yearRangeEstimate=defaultYearRangeEstimate] - An optional object containing the start and end year for filtering dates.
 * @param {number} yearRangeEstimate.startYear - The start year for the date range estimate.
 * @param {number} yearRangeEstimate.endYear - The end year for the date range estimate.
 * @returns {Promise<Array<Object>>} A promise that resolves to an array of date options.
 */
export default async function fetchDateSuggestions(dateSearchTerm, yearRangeEstimate = defaultYearRangeEstimate) {
  try {
    const text = dateSearchTerm.trim()
    if (!isValidDateInput(text)) return []

    // TODO -  Remove the acceptLanguage=${i18n.language} query param when the DTM is fixed to synchronize with the Zion Language picker
    const response = await axios.get(
      `/service/standards/date/ws/dates/interp?text=${encodeURIComponent(text)}&noCache=true&acceptLanguage=${
        i18n?.language || 'en'
      }`
    )

    const dates = applyYearRangeEstimate(response.data.dates, yearRangeEstimate)

    return getDateOptionsFromApiResponse({ dates, dateSearchTerm: text })
  } catch (err) {
    debug('Request err:', err.message)
    // Return empty list of options on error
    return []
  }
}
