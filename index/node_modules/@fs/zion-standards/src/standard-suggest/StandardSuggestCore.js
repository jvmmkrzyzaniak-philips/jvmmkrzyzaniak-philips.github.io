import React, { useState, useMemo, forwardRef, useCallback } from 'react'
import { sanitizeProps } from '@fs/zion-frontend-friends'
import { ThingCalendar, ThingMapPin, PlaceSuggestion } from '@fs/zion-icon'
import { Autosuggest, useDebouncedSuggestions } from '@fs/zion-ui'
import { useTranslation } from 'react-i18next'
import fetchDateSuggestions from '../date-suggest/fetchDateSuggestions'
import {
  fetchPlaceSuggestionsFromApi,
  fetchSimplifiedPlaceSuggestionsFromApi,
} from '../place-suggest/fetchPlaceSuggestions'
import trackPlaceSuggestionSelected from '../place-suggest/trackPlaceSuggestionSelected'

const ICONS = { place: ThingMapPin, date: ThingCalendar }

function getAutosuggestIcon(selectedItem, inputText, type) {
  if (selectedItem?.primaryText === inputText) {
    if (selectedItem?.isStandard) {
      return ICONS[type]
    }
    if (selectedItem?.isProposed) {
      return PlaceSuggestion
    }
  }
  return undefined
}

const StandardSuggestCore = forwardRef(function StandardSuggestCore(
  {
    type,
    label,
    onInputTextChange,
    onSuggestionSelected,
    handleInput,
    warningValidate,
    initialSelectedItem,
    selectedItem,
    excludePlaceId,
    showRepIds,
    noCache,
    lastResort,
    isExact = false,
    proposedSuggestions = [],
    yearRangeEstimate = {},
    placeFilterOptions = {},
    simplified = false,
    ...props
  },
  ref
) {
  const { t } = useTranslation()
  const { value } = props
  const initialSuggestions = useMemo(() => {
    return initialSelectedItem?.isStandard ? [initialSelectedItem] : []
  }, [initialSelectedItem])
  const fetchSuggestions = useCallback(
    (searchTerm) => {
      if (type === 'date') {
        return fetchDateSuggestions(searchTerm, yearRangeEstimate)
      }
      if (simplified) {
        return fetchSimplifiedPlaceSuggestionsFromApi({
          placesSearchTerm: searchTerm,
          showRepIds,
          noCache,
          isExact,
          placeFilterOptions,
        })
      }
      return fetchPlaceSuggestionsFromApi({
        placesSearchTerm: searchTerm,
        showRepIds,
        noCache,
        isExact,
        placeFilterOptions,
      })
    },
    [type, showRepIds, noCache, isExact, placeFilterOptions, yearRangeEstimate, simplified]
  )

  const { inputText, setInputText, suggestions } = useDebouncedSuggestions(
    fetchSuggestions,
    250,
    initialSelectedItem?.primaryText || value?.primaryText,
    initialSuggestions
  )
  const [selectedSuggestion, setSelectedSuggestion] = useState(initialSelectedItem)
  const Icon = getAutosuggestIcon(selectedItem || selectedSuggestion, inputText, type)

  const filteredSuggestions = useMemo(() => {
    let filtered = excludePlaceId ? suggestions.filter((s) => s?.standard?.id !== excludePlaceId) : suggestions
    if (proposedSuggestions?.length && inputText) {
      filtered = [
        ...(proposedSuggestions?.filter((suggestion) =>
          suggestion?.primaryText?.toLocaleLowerCase()?.includes(inputText?.toLocaleLowerCase())
        ) ?? []),
        ...(filtered?.map((suggestion) => ({
          ...suggestion,
          group: t('place-suggest.standardized-places.label', 'Standardized Places'),
        })) ?? []),
      ]
    }
    return filtered
  }, [suggestions, excludePlaceId, proposedSuggestions, t, inputText])

  const handleInputTextChange = (newText = '') => {
    if (newText !== inputText) {
      setInputText(newText)
      onInputTextChange?.(newText)
      if (!newText) {
        onSuggestionSelected(null, filteredSuggestions)
        setSelectedSuggestion(null)
      }
    }
  }

  return (
    <Autosuggest
      {...sanitizeProps(props)}
      inputText={inputText}
      initialSelectedItem={initialSelectedItem}
      selectedItem={selectedItem}
      Icon={Icon}
      onInputTextChange={handleInputTextChange}
      suggestions={filteredSuggestions}
      label={label}
      handleInput={handleInput}
      warningValidate={warningValidate}
      noFilter
      onSuggestionSelected={(option) => {
        const suggestion = option || null
        const lastInputText = selectedItem?.inputText
        if (type === 'place') {
          trackPlaceSuggestionSelected({ suggestion, suggestions: filteredSuggestions, inputText, lastInputText })
        }
        onSuggestionSelected(suggestion, filteredSuggestions)
        setInputText(suggestion?.primaryText || '')
        setSelectedSuggestion(suggestion)
      }}
      highlightMatchingText
      maxLength={150}
      lastResort={lastResort}
      ref={ref}
    />
  )
})

export default StandardSuggestCore
