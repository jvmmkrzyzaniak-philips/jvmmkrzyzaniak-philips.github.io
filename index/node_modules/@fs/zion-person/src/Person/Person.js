import React, { lazy, Suspense, useState, useCallback, createContext, useContext } from 'react'
import PropTypes from 'prop-types'
import { useTranslation } from 'react-i18next'
import { VisuallyHidden } from '@reach/visually-hidden' // this can come from zion at some point - its getting wrapped in there
import { PersonBlock, Skeleton, ListItem, useOverlay, useInfoSheet, Row, Grid, Cell } from '@fs/zion-ui'
import {
  usePerson,
  normalizePersonObj,
  unknownPerson,
  getNameInPreferredScript,
  getNameRelatedData,
} from '@fs/zion-person-service'
import { trackEvent } from '@fs/zion-analytics'
import { usePreference } from '@fs/zion-preferences'
import { css } from '@linaria/core'
import { boolAttr } from '@fs/zion-frontend-friends'
import Lifespan from './components/Lifespan'
import Pid from './components/Pid'
import PrimaryName from '../Name/PrimaryName'
import SecondaryName from '../Name/SecondaryName'
import usePersonSheet from '../PersonSheet/usePersonSheet'

const personWrapperCss = css`
  max-width: 100%;
  position: relative; // for backwards compatibility with positioning in the pedigree
`

const LinkContext = createContext()

export const useLinkContext = () => {
  return useContext(LinkContext)
}
// lazy import to help mitigate this cycle
const PersonOverlay = lazy(() => import('../PersonOverlay/PersonOverlay'))
const PersonSheet = lazy(() => import('../PersonSheet/PersonSheet'))

/**
 * @param {object} props - The props passed in to the component.
 * @param {string} [props.avatarSize] - Increment/Decrement the size of the avatar by a t-shirt size.
 * @param {string} [props.componentSize] - The size of the avatar or placeholder and name text.
 * @param {string} [props.centered] - Basically if we are in portrait orientation.
 * @returns {HTMLElement} - The React element itself.
 */
export const PersonSkeleton = (props) => {
  // Translate relevant props into the corresponding size to pass into Skeleton.PersonBlock.
  const { avatarSize, componentSize, centered, orientation, asListItem, noAvatar, inline } = props
  const sizeOptions = ['xs', 'sm', 'md', 'lg', 'xl', 'xxl']
  let indexOfSizeToPass = asListItem ? 1 : sizeOptions.indexOf(componentSize)

  switch (avatarSize) {
    case 'bigger':
      if (indexOfSizeToPass < sizeOptions.length - 1) {
        indexOfSizeToPass++
      }
      break
    case 'smaller':
      if (indexOfSizeToPass > 0) {
        indexOfSizeToPass--
      }
      break
    default:
      break
  }

  // xxl is not supported by Skeleton.PersonBlock--downsize if we are too big
  if (indexOfSizeToPass === sizeOptions.length - 1) {
    indexOfSizeToPass--
  } // xs is not supported by Skeleton.PersonBlock--upsize if we are too small
  else if (indexOfSizeToPass <= 0) {
    indexOfSizeToPass = 1
  }

  const sizeToPassToSkeleton = !inline ? sizeOptions[indexOfSizeToPass] : 'sm'
  const style = orientation === 'portrait' ? { maxWidth: 150 } : { width: 200 }

  return (
    <div data-testid="person:loading-skeleton">
      <Skeleton.PersonBlock
        centered={centered}
        size={sizeToPassToSkeleton}
        noAvatar={noAvatar}
        maxWidth={style.maxWidth}
      />
    </div>
  )
}

// JSX Snippets - mini components
// screen reader component to read out the sex of the person
export const AriaSex = ({ gender }) => {
  const [t] = useTranslation()
  const genderTranslations = {
    MALE: t('person.sex.male'),
    FEMALE: t('person.sex.female'),
    UNKNOWN: t('person.sex.unknown'),
  }
  const translatedGender = genderTranslations[(gender || 'unknown').toUpperCase()]
  return <VisuallyHidden>{translatedGender}</VisuallyHidden>
}

const SingleLineDetails = ({ disableTruncation, ...props }) => (
  <Row alignY="middle" wrap={disableTruncation} {...props} />
)

const MultilineDetails = ({ disableTruncation, ...props }) => <Grid {...props} />

/**
 * React person: the canonical source of truth for how we will display persons on the site.
 * @see {@link https://github.com/fs-webdev/zion/blob/master/packages/person/src/Person/README.mdx | Person's README}
 *
 * @param {object} props - The props passed into the element, that become destructured into their respective destinations.
 * @param {string} [props.asListItem] - render the person as a ListItem so that it can be displayed in a List component.
 * @param {string} [props.componentSize="medium"] - The size of the avatar or placeholder and name text. Possible values: 'x-small', 'small', 'medium', 'large' - this is only effective with orientation="landscape"
 * @param {string} [props.doNotLinkToPersonPage=false] - turns off destination link. This supersedes all other link-related options (when this is set to true it will open person overlay or custom overlay).
 * @param {boolean} [props.hideLifespan=false] - Do not show the lifespan.
 * @param {boolean} [props.hidePid=false] - Do not show the PID.
 * @param {boolean} [props.showGenderText=false] - Show the sex.
 * @param {string} [props.lifespanSize="short"] - Which lifespan value to display - tree-data returns both a lifespan which is short and a fullLifeSpan which is longer. Valid values are "short" or "long".
 * @param {object} [props.customPersonLink] - The URL (instead of the person page URL) to go to when name is clicked. If the "${pid}" string is in the URL, it will be replaced with the person ID.
 * @param {boolean} [props.openPersonOverlay=false] - Whether to open the person overlay when the name is clicked on.
 * @param {object} [props.personOverlaySubheaderLink] - Options for displaying a link (Icon, text, onClick, linkName, to, external, target) below the header in the PersonOverlay.
 * @param {string} [props.orientation="landscape"] - Which orientation to display the person in. Valid values are "landscape" and "portrait".
 * @param {string} [props.personId] - The person id for the component to fetch information about. This will overwrite any personObj that is passed in. Do not set this property unless you want the component to make a network call for the personObj.
 * @param {object} [props.personObj] - A tree-data person to display. If passed in with `props.personId`, this person will be displayed until the data is returned.
 * @param {object} [props.personOverlayProps] - QuickGlanceOverlay props you want to use such as placement
 * @param {boolean} [props.usePortraitUrl=true] - If set to true, we will download and show the portrait image. If url is "broken" or fails to load, the avatar will fallback on the placeholder instead of a broken image icon. If set to false we will not attempt to show the portrait image, just the placeholder icon.
 * @param {string} [props.avatarSize='default'] - Increment/Decrement the size of the avatar by a t-shirt size if orientation = 'portrait'.
 * @param {boolean} [props.disableTruncation=false] - If set to true, the person name and lifespan will not be truncated with ellipses and the content will wrap if the width is restricted by the container.
 * @param {boolean} [props.openPersonSheet=false] - If set to true, the person infosheet will be used instead of the overlay.
 * @param {boolean} [props.cjk=false] - If set to true, the cjk monogram will show if person has a cjk nameform and person does not have a portrait. Also, two nameforms will show if person does have portrait.
 * @param {boolean} [props.displayMonogram=false] - If set to true, pass along a monogram to the avatar.
 * @param {boolean} [props.linksOpenNewTab=] - Optionally have person links open in a new tab.
 * @param {boolean} [props.noBoldName=false] - If true, the name will not be bold.
 * @param {boolean} [props.tag] - Render the element passed here in PersonListItem
 *
 * @param {boolean} [props.personHasFocus=false] - (@deprecated Since v6.4) Setting this to true changes styling to make this person more obviously in focus
 *
 * @returns {HTMLElement} - The React element itself.
 */
export default function Person({
  componentSize,
  doNotLinkToPersonPage,
  hideLifespan,
  hidePid,
  showGenderText,
  lifespanSize,
  customPersonLink,
  onClick,
  openPersonOverlay,
  personOverlaySubheaderLink,
  orientation,
  overline,
  personHasFocus,
  personId,
  personObj,
  relation,
  usePortraitUrl,
  avatarSize,
  disableTruncation,
  'data-testid': dataTestId,
  cjk,
  asListItem,
  endElement,
  loading,
  openPersonSheet,
  sheetInitialHeight,
  personSheetFamilyMembers,
  displayMonogram,
  linksOpenNewTab,
  noBoldName,
  // hideAvatar is not a public prop, as it is only meant for the person and pedigree page right now.
  hideAvatar,
  tag,
  sheetSize = 'md',
  linkName,
  personOverlayProps,
  alwaysShowSecondaryName,
  dense,
  inline,
  showPQSTag = false,
  ...listItemProps
}) {
  // Fetch person if personId was provided
  const fetchedPerson = usePerson(personId, 'summary', personId ? personObj : undefined)
  let person = fetchedPerson || personObj
  if (!person?.normalized) {
    person = normalizePersonObj(person)
  }

  // The loading and unknown flags are additional data returned by the PersonService on top of a typical tree-data person. This logic may need further analysis to always show loading state as expected.
  // Note: normalizePersonObj removes the loading flag, so check it on fetchedPerson.
  loading = loading || (fetchedPerson?.loading && person?.unknown)

  // SPECIAL CASE: A person that needs to display like a tree person, but needs to not actually provide any links because we are not allowed to see the person. We use this in the relationship viewer for people in the path who are private/living for the other contributor who we are viewing our relationship to. We explicitly pass an id of PRIVATE from the relationship viewer to reliably trigger this scenario.
  const personIsPrivatePerson = person.id === 'PRIVATE'
  if (personIsPrivatePerson) {
    person.id = unknownPerson.id

    // TREEWEB-7879 - Manually override display settings for private persons
    hidePid = true
    openPersonOverlay = false
    openPersonSheet = false
  }

  // get the title/hover text - do not show the pid for private persons, and do not show hover text at all for unknown persons
  const showNameInRomanScriptPreference = usePreference('tree.showNamesInRomanScript')
  const { fullName, cjkNameForm } = getNameInPreferredScript(person, showNameInRomanScriptPreference)
  const { cjkNoBold } = getNameRelatedData(person, showNameInRomanScriptPreference)

  let personTitle = person.unknown ? '' : `${fullName}\n${person.lifespan}`
  if (!personIsPrivatePerson && !person.unknown) {
    personTitle += ` ${String.fromCharCode(183)} ${person.id}`
  }

  const personOverlayOverlay = useOverlay()
  const personSheet = useInfoSheet({ initialBottomSheetHeight: sheetInitialHeight })
  const personSheetContext = usePersonSheet()

  // person overlay opener function
  const openOverlayOrSheet = (evt) => {
    // the event was a keypress, but not one that mimics a click - do nothing
    if (evt.type === 'keypress' && evt.key !== 'Enter' && evt.key !== ' ') return

    const pidWasClicked = !!evt.target.closest('[data-testid="pid"]')
    // When the user clicks with the cmd/ctrl key, we want to just let the browser do its thing in case the user clicked on a link that should then open in a new tab - or whatever the browsers are doing these days.
    // We also want to just let the event continue to do its thing if the pid is what was clicked on. ClickToCopy will stop propagating the event on its own,
    // but since we do things here on the capture (to work around some routing issues in apps), we need to detect those clicks and let them get down to that element.
    // Associated user button and overlay were added since they're inside the big Person button as well.
    const letDefaultBehaviorContinue = Boolean(evt.metaKey || evt.ctrlKey || pidWasClicked)

    if (letDefaultBehaviorContinue) return

    if (person.unknown) {
      // Do not open the person overlay or link to the person for unknown persons
      evt.preventDefault()
      evt.nativeEvent.preventDefault()
      trackEvent({ event_name: 'clicked_unknown_person' })
      // console.warn('Opening a person overlay for an unknown person is not permitted') // this is commented out so it doesn't show up in our tests
    } else if (onClick) {
      evt.preventDefault()
      evt.nativeEvent.preventDefault()
      onClick(evt)
    } else if (openPersonSheet) {
      evt.preventDefault()
      evt.nativeEvent.preventDefault()
      evt.stopPropagation() // without this the pid is copied as well

      trackEvent({ event_name: 'open_person_sheet' })
      if (personSheetContext) {
        personSheetContext.setPerson({
          personId: person.id,
          personObj: person,
          cjk,
          loading,
          showFamilyMembersNotFacts: personSheetFamilyMembers,
        })

        sheetInitialHeight && personSheetContext.setSheetHeight(sheetInitialHeight)

        !personSheetContext.personSheet.isOpen && personSheetContext.personSheet.open(evt)
      } else {
        personSheet.open(evt)
      }
    } else if (openPersonOverlay) {
      evt.preventDefault()
      evt.nativeEvent.preventDefault()
      evt.stopPropagation() // TW-4352 - we need to stop propagation so that the Link component doesn't navigate
      trackEvent({ event_name: 'open_person_overlay' })
      // we need a way to determine how to open this differently/special when we are inside a zoom/pan so that the person card scales and positions appropriately
      personOverlayOverlay.open({ target: evt.currentTarget })
    }
  }

  // grab props that need to be passed down
  const multiLineDisplay = orientation === 'portrait' && !inline

  // we don't need to handle the opening of the overlay from both name and person, just person - the event chain will still fire properly
  const nameProps = {
    doNotLinkToPersonPage: doNotLinkToPersonPage || personIsPrivatePerson,
    multiLineDisplay,
    disableTruncation,
    personObj: person,
    customPersonLink,
    linksOpenNewTab,
    linkName,
  }

  const [imageFailed, setImageFailed] = useState()
  const imageFailedCallback = useCallback(() => {
    setImageFailed(true)
  }, [])

  const avatarProps = {
    sex: person.gender && person.gender.toLowerCase(),
    imageFailedCallback,
    monogram: displayMonogram ? fullName[0] : undefined,
    'data-testid': displayMonogram ? 'monogram' : 'normal',
  }
  if (usePortraitUrl) {
    avatarProps.src = person.portraitUrl
  }

  let clickablePropsAndAttrs = {}
  let avatarElement

  if (asListItem) {
    avatarProps.cjk = cjk
    nameProps.multiLineDisplay = false
    avatarElement = <ListItem.Avatar {...avatarProps} />
    clickablePropsAndAttrs =
      !personIsPrivatePerson && (openPersonOverlay || openPersonSheet) && !onClick
        ? {
            'aria-haspopup': 'true',
            onClick: openOverlayOrSheet,
          }
        : {
            onClick,
          }
  } else {
    clickablePropsAndAttrs =
      !personIsPrivatePerson && (openPersonOverlay || openPersonSheet || onClick)
        ? {
            tabIndex: 0,
            'aria-haspopup': 'true',
            onClick: openOverlayOrSheet || onClick,
            onKeyPressCapture: openOverlayOrSheet || onClick,
          }
        : {}
  }

  const showBullet = Boolean(!hideLifespan && person.lifespan && !multiLineDisplay && !hidePid)

  const DetailsWrapper = multiLineDisplay ? MultilineDetails : SingleLineDetails

  /**
   * @deprecated Since v6.4
   * These attributes we used for styling the element in the past, but are no longer
   * functionally needed. Many tests rely on them to select specific nodes, so we
   * stamp them on the DOM for backwards compatibility only.
   */
  const infoAttrs = {
    'unknown-person': boolAttr(person.unknown),
    orientation: orientation || 'landscape',
    'person-has-focus': boolAttr(personHasFocus),
  }

  return loading ? (
    <PersonSkeleton
      asListItem={asListItem}
      componentSize={componentSize}
      orientation={orientation}
      avatarSize={avatarSize}
      centered={multiLineDisplay}
      noAvatar={hideAvatar}
      dense={dense}
      inline={inline}
    />
  ) : (
    // We add in a bit of context here so that handledExternalRoutes will not cause issues for us when openPersonOverlay/openPersonSheet is true
    <LinkContext.Provider value={Boolean(openPersonOverlay || openPersonSheet)}>
      {asListItem ? (
        <ListItem
          data-testid={dataTestId || 'person-list-item'}
          primaryText={
            <PrimaryName
              avatarShowing={avatarProps.src && !imageFailed}
              cjk={cjk}
              {...nameProps}
              hasCJKName={Boolean(cjkNameForm)}
            />
          }
          secondaryText={
            <>
              <AriaSex gender={person.gender} />
              <SingleLineDetails gutters="pico" disableTruncation={disableTruncation}>
                <SecondaryName
                  cjk={cjk}
                  avatarShowing={avatarProps.src && !imageFailed}
                  hasCJKName={Boolean(cjkNameForm)}
                  alwaysShowName={alwaysShowSecondaryName}
                  {...nameProps}
                />
                {!hideLifespan && (
                  <Lifespan personObj={person} noShrinkX={disableTruncation} lifespanSize={lifespanSize} />
                )}
                {showBullet && <Cell noShrinkX>•</Cell>}
                {!hidePid && <Pid personObj={person} inline noShrinkX />}
                {tag}
              </SingleLineDetails>
            </>
          }
          startElement={(!hideAvatar && avatarElement) || undefined} // using undefined avoids propType errors
          endElement={endElement}
          overline={overline}
          dense={dense}
          {...clickablePropsAndAttrs}
          {...listItemProps}
          {...infoAttrs}
        />
      ) : (
        <div
          title={personTitle}
          className={personWrapperCss}
          role="group"
          data-testid={dataTestId || 'person'}
          {...clickablePropsAndAttrs}
          {...infoAttrs}
        >
          <PersonBlock
            size={componentSize}
            centered={multiLineDisplay}
            avatarSize={avatarSize}
            noAvatar={hideAvatar}
            avatarProps={(!hideAvatar && avatarProps) || undefined} // using undefined avoids propType errors
            cjkMonogram={cjk ? cjkNameForm?.fullText : ''}
            cjkMonogramLang={cjkNameForm?.lang || ''}
            noBold={noBoldName || cjkNoBold}
            inline={inline}
            name={
              <PrimaryName
                avatarShowing={avatarProps.src && !imageFailed}
                orientation={orientation}
                cjk={cjk}
                {...nameProps}
                hasCJKName={Boolean(cjkNameForm)}
              />
            }
            overline={overline}
            details={
              <>
                <AriaSex gender={person.gender} />
                <DetailsWrapper gutters="pico" disableTruncation={disableTruncation}>
                  <SecondaryName
                    cjk={cjk}
                    avatarShowing={avatarProps.src && !imageFailed}
                    hasCJKName={Boolean(cjkNameForm)}
                    alwaysShowName={alwaysShowSecondaryName}
                    {...nameProps}
                  />
                  {!hideLifespan && (
                    <Lifespan
                      personObj={person}
                      noShrinkX={disableTruncation}
                      lifespanSize={multiLineDisplay ? 'short' : lifespanSize}
                    />
                  )}
                  {showBullet && <Cell noShrinkX>•</Cell>}
                  {!hidePid && <Pid personObj={person} inline noShrinkX centered={multiLineDisplay} />}
                </DetailsWrapper>
              </>
            }
          />
        </div>
      )}
      {openPersonOverlay && (personOverlayOverlay.isOpen || personOverlayOverlay.transitioning) && (
        <Suspense fallback="">
          <PersonOverlay
            personId={person.id}
            personObj={person}
            overlay={personOverlayOverlay}
            linksOpenNewTab={linksOpenNewTab}
            subheaderLink={personOverlaySubheaderLink}
            personOverlayProps={personOverlayProps}
            showPQSTag={showPQSTag}
          />
        </Suspense>
      )}
      {openPersonSheet && !personSheetContext && person.id !== 'UNKNOWN' && (
        <Suspense fallback="">
          <PersonSheet
            sheet={personSheet}
            sheetSize={sheetSize}
            personId={person.id}
            personObj={person}
            cjk={cjk}
            loading={loading}
            showFamilyMembersNotFacts={personSheetFamilyMembers}
            linksOpenNewTab={linksOpenNewTab}
            showPQSTag={showPQSTag}
          />
        </Suspense>
      )}
    </LinkContext.Provider>
  )
}

Person.propTypes = {
  /** 'sm' 'md' 'lg' or 'xl' - the size of the component passed through to PersonBlock. */
  componentSize: PropTypes.oneOf(['sm', 'md', 'lg', 'xl']),
  /** If true, clicking on the person will not link to the person page. */
  doNotLinkToPersonPage: PropTypes.bool, // must have person overlay on if we're not linking
  /** Do not show the lifespan. */
  hideLifespan: PropTypes.bool,
  /** Do not show the person id. */
  hidePid: PropTypes.bool,
  /** If true, this will show the person's sex next to the lifespan only if the pid is hidden. */
  showGenderText: PropTypes.bool,
  /** Display the lifespan in its abbreviated form with just years (default) or its full form. If orientation is 'portrait', only 'short' will be available. */
  lifespanSize: PropTypes.oneOf(['short', 'long']),
  /** The URL (instead of the person page URL) to go to when name is clicked. If the "${pid}" string is in the URL, it will be replaced with the person ID. e.g. /cool/tree/${pid} */
  customPersonLink: PropTypes.string,
  /** If true, a sidesheet will be opened with more information about the person. */
  openPersonSheet: PropTypes.bool, // currently only for use in approved tree apps
  /** If true, a QuickGlanceOverlay will be opened with more information about the person. */
  openPersonOverlay: PropTypes.bool,
  /** Options for displaying a link (Icon, text, onClick, linkName, to, external, target) below the header in the PersonOverlay. */
  personOverlaySubheaderLink: PropTypes.shape({
    Icon: PropTypes.func,
    text: PropTypes.string,
    onClick: PropTypes.func,
    linkName: PropTypes.string,
    to: PropTypes.string,
    external: PropTypes.bool,
    target: PropTypes.string,
  }),
  /** Whether to show Person horizontally or vertically. */
  orientation: PropTypes.oneOf(['landscape', 'portrait']),
  /** An overline text passed to PersonBlock */
  overline: PropTypes.string,
  /** @deprecated Please handle focus styles via CSS.
   *
   * If true, the Person will be dispalyed with a grey background (selected or focused) */
  personHasFocus: PropTypes.bool,
  /** If personId (and no personObj) is passed, the person info will be fetched from tree-data. */
  personId: PropTypes.string,
  /** If personObj is passed, no data call will be made. The data shape must follow tree-data's format, defined below. */
  personObj: PropTypes.shape({
    fullLifespan: PropTypes.string,
    gender: PropTypes.string,
    id: PropTypes.string,
    lifespan: PropTypes.string,
    name: PropTypes.string,
    nameConclusion: PropTypes.shape({
      details: PropTypes.shape({
        nameForms: PropTypes.array,
      }),
    }),
    portraitUrl: PropTypes.string,
  }),
  /** QuickGlanceOverlay Props that will be passed to the PersonOverlay */
  personOverlayProps: PropTypes.shape({}),
  /** Initial height of personSheet, if used */
  sheetInitialHeight: PropTypes.number,
  sheetSize: PropTypes.oneOf(['sm', 'md']),
  /** If false, the portrait image will not be shown and will be replaced by the colored gender silhouette icon. */
  usePortraitUrl: PropTypes.bool,
  /** If true, a monogram (first letter of first name) is shown as a fallback if no portrait exists for the person. */
  displayMonogram: PropTypes.bool,
  /** The size of the avatar passed to PersonBlock. */
  avatarSize: PropTypes.oneOf(['smaller', 'default', 'bigger']),
  /** If true, the PersonSheet will show family members instead of other facts. */
  personSheetFamilyMembers: PropTypes.bool,
  /** If true, all links will open new tabs. */
  linksOpenNewTab: PropTypes.bool,
  /** If true, the name will not be bold. */
  noBoldName: PropTypes.bool,
  /** Useful if you're fetching your own data via personObj, otherwise, you probably should not use this. Person manages it's own loading state in many cases. If true, the loading skeleton for PersonBlock will be shown. */
  loading: PropTypes.bool,
  /** If true, and if there is a chinese or japanese nameform, they will be shown as well as the roman nameform if it exists. */
  cjk: PropTypes.bool,
  /** If passed, the element will be rendered in PersonListItem. ONLY TAG ELEMENTS */
  tag: PropTypes.element,
  /** Whether to prevent the secondary text from wrapping */
  disableTruncation: PropTypes.bool,
  /** Switches Person to be inline.  If inline is true, it will cause various props such as avatarSize and componentSize not to work since they are hard coded values in the PersonBlock component, which Person is built on. */
  inline: PropTypes.bool,
}

Person.defaultProps = {
  componentSize: 'md',
  doNotLinkToPersonPage: false,
  hideLifespan: false,
  hidePid: false,
  showGenderText: false,
  lifespanSize: 'short',
  customPersonLink: undefined,
  openPersonSheet: false,
  openPersonOverlay: false,
  orientation: 'landscape',
  overline: undefined,
  personHasFocus: false,
  personId: '',
  personObj: {},
  usePortraitUrl: true,
  avatarSize: 'default',
  displayMonogram: false,
  linksOpenNewTab: false,
  noBoldName: false,
  inline: false,
}

export function PersonListItem({ endElement, ...props }) {
  return <Person {...props} asListItem endElement={endElement} />
}

PersonListItem.propTypes = {
  /** Must be one of these: ListItem.Icon, ListItem.IconButton, ListItem.MetaText */
  endElement: PropTypes.element,
}

PersonListItem.defaultProps = {
  endElement: undefined,
}
