import React from 'react'
import i18n from 'i18next'
import { I18nextProvider, initReactI18next } from 'react-i18next'
import LanguageDetector from 'i18next-browser-languagedetector'
import Pseudo from 'i18next-pseudo'
import ICU from 'i18next-icu'
import { appName } from '@fs/zion-config'
import debug, { debugVerbose } from '@fs/zion-debug'
import intersection from 'lodash.intersection'
import isEqual from 'lodash.isequal'
import memoize from 'lodash.memoize'
import pullAll from 'lodash.pullall'
import range from 'lodash.range'
import Cookies from 'js-cookie'
import { showEx } from '@fs/zion-experiments/core'
import { getFeatureFlag } from '@fs/zion-flags'
import resourcesToBackend from 'i18next-resources-to-backend'
import chainBackends from 'i18next-chained-backend'
import { format, getDaysInMonth, updateLocale } from './date-fns'
import { formatValue, updateLocale as updateFormatLocale } from './formats'
import supportedLocales, {
  baseLocales,
  essentialLocales,
  allLocales,
  languageFlags,
  langText,
  extendedLocales,
} from './supportedLocales'
// eslint-disable-next-line import/no-absolute-path,import/no-unresolved -- this absolute path import is a custom alias needed to solve a webpack issue
import enAppTranslations from '/coalesced-locales/dist/en/translation.json'
// eslint-disable-next-line import/no-absolute-path,import/no-unresolved -- this absolute path import is needed
import enCommonTranslations from '/coalesced-locales/dist/en/common-ui.json'
import intlFormat from './intlFormat'

import './locales' // this is how we tell the app to include these translations

const langCodePathRegex = /^\/(?<localeCode>[a-z]{2,3}(-[a-zA-Z0-9-]*)?)\// // Copied from DTM haproxy config MATCH_root_lang_path_with_slash acl

// essentialLocales, extendededLocales, allLocales and supportedLocales may get globally modified by experiments, so keep original length for comparison
const origEssentialLangs = [...essentialLocales]
const origAllLocalesLangs = [...allLocales]
const origExtendedLocalesLangs = [...extendedLocales]
const origSupportedLocalesLangs = [...supportedLocales]

/**
 * Modifies existing array to remove duplicates
 * @param {*} array the array to modify
 */
function removeDuplicates(array) {
  array.splice(0, array.length, ...new Set(array))
}

const log = debug('zion:locale')
const logVerbose = debugVerbose('zion:locale')
log(enCommonTranslations)
log(enAppTranslations)

// debugConfig.enable('fs:zion:locale*,fsverbose:zion:locale*')
// console.log('debug enabled', log.enabled, logVerbose.enabled)
// console.log('commonTranslations', commonTranslations)

// we want this export to stay in sync with i18n.language, so it's okay to be mutable in this case
// let locale = i18n.language

// eslint-disable-next-line import/no-mutable-exports -- we want this export to stay in sync with setAppLocales, so allowing it to be mutable
export let appLocales = baseLocales
export const availableLangs = langText

const hasWindow = typeof window !== 'undefined'

// console.log('isInit', i18n.isInitializedFrontier, i18n.language, i18n)
if (!i18n.isInitializedFrontier) {
  logVerbose.enabled && console.trace('setting up i18next ...')
  _initializeI18nInstance(i18n, appLocales)
  i18n.isInitializedFrontier = true

  logVerbose('i18n is set up', i18n)
} else {
  logVerbose.enabled && console.trace('i18n already initialized, skipping ...')
}

// eslint-disable-next-line no-underscore-dangle -- this is a private function not to be used anywhere else; it is for use in tests where we need the configuration updated with new settings
function _initializeI18nInstance(i18nInstance, locales = appLocales) {
  logVerbose('_initializeI18nInstance called', i18nInstance.language, i18nInstance.isInitializedFrontier, locales)
  if (!i18nInstance.isInitializedFrontier) {
    i18nInstance.on('languageChanged', (lng) => {
      logVerbose('languageChanged called', lng, i18n.language, i18n.isLanguageChangingTo)
      // locale = i18n.language
      updateLocale(lng)
      updateFormatLocale(lng)
      log('languageChanged updated language and setting for other libraries:', lng, i18n.language)
    })
  }
  let cookieDomain
  if (hasWindow) {
    cookieDomain = window.location.hostname.includes('.familysearch.org')
      ? '.familysearch.org'
      : window.location.hostname
  }

  const languageDetector = new LanguageDetector()
  // this custom detector will be needed as long as the URL differs from the internal code, for example `zh-Hant` in the URL vs `zh` in i18n.language
  languageDetector.addDetector({
    name: 'fsZhHant',
    lookup() {
      if (typeof window === 'undefined') return undefined
      logVerbose('fsZhHant detector lookup called', window?.location?.toString())
      const url = new URL(window.location)
      return url.pathname.startsWith('/zh-Hant') || url.searchParams.get('lang') === 'zh-Hant' ? 'zh' : undefined
    },
  })

  const instanceSetup = i18nInstance
    .use(languageDetector)
    .use(
      new ICU({
        formats: {
          number: {
            integer: {
              maximumFractionDigits: 0,
            },
          },
        },
      })
    )
    .use(
      new Pseudo({
        languageToPseudo: 'eo',
      })
    )
    .use(initReactI18next)

  if (typeof jest === 'undefined') {
    instanceSetup.use(chainBackends)
  }

  return instanceSetup.init({
    // since we load translations async, this waits until the backend resources are loaded before actually initializing.
    // English is loaded async, but bundled. All other languages are downloaded via webpack async.
    initImmediate: false,
    fallbackLng: {
      'zh-hans': ['zh', 'en'],
      'zh-Hans': ['zh-hans', 'zh', 'en'],
      'zh-hant': ['zh', 'en'],
      'zh-Hant': ['zh-hant', 'zh', 'en'],
      default: ['en'],
    },
    lowerCaseLng: true,
    interpolation: { escapeValue: false, format: formatValue },
    detection: {
      order: ['fsZhHant', 'querystring', 'path', 'cookie', 'htmlTag', 'navigator'],
      lookupQuerystring: 'lang',
      lookupCookie: 'fslanguage',
      lookupFromPathIndex: 0,
      caches: [],
      excludeCacheFor: ['eo', 'cimode'], // languages to not persist (cookie, localStorage)
      // Set the language cookie to be shared across all fs.org subdomains, the
      // same way we share the session cookie across all subdomains.
      cookieDomain,
    },
    ns: ['translation', 'common-ui'],
    postProcess: ['pseudo'],
    backend: {
      backends: [
        // resourcesToBackend({ en: { translation: enAppTranslations, 'common-ui': enCommonTranslations } }),
        resourcesToBackend((language, namespace, callback) => {
          import(
            /* webpackChunkName: "locales-[request]-[index]" */ `/coalesced-locales/dist/${language}/${namespace}.json`
          )
            .then(({ default: resources }) => {
              callback(null, resources)
            })
            .catch((error) => {
              callback(error, null)
            })
        }),
      ],
    },
    partialBundledLanguages: true,
    resources: { en: { translation: enAppTranslations, 'common-ui': enCommonTranslations } },
    // resources: typeof jest === 'undefined' ? undefined : {},
    returnEmptyString: false, // i18next-scanner sometimes generates empty strings
    keySeparator: false, // keeps dotted key paths flat instead of nested
    debug: log.enabled,
    supportedLngs: locales.concat('eo'),
    react: {
      transSupportBasicHtmlNodes: true, // allow <br/> and simple html elements in translations
      transKeepBasicHtmlNodesFor: ['br', 'strong', 'i'], // don't convert to <1></1> if simple react elements
    },
  })
}

function I18nProvider({ i18nInstance = i18n, children }) {
  return React.createElement(I18nextProvider, { i18n: i18nInstance }, children)
}

function addTranslations(componentTranslations = {}) {
  log(`addTranslations`, componentTranslations, i18n)
  // iterate over every language found
  Object.keys(componentTranslations).forEach((lang) => {
    // iterate over each namespace in each language
    Object.keys(componentTranslations[lang]).forEach((namespace) => {
      logVerbose(`adding translations for ${lang} [${namespace}]`, componentTranslations[lang][namespace])
      i18n.addResources(lang, namespace, componentTranslations[lang][namespace])
    })
  })
  // log('i18n data', i18n.store.data)
}

function calculateActiveLangs(languageFlagList) {
  logVerbose('calculateActiveLangs', languageFlagList)
  return languageFlagList.reduce((acc, entry) => {
    logVerbose('calculateActiveLangs entry', entry)
    if ((entry.experiment && showEx(entry.experiment)) || (entry.flag && getFeatureFlag(entry.flag)?.isOn)) {
      log('calculateActiveLangs adding locale to active list due to experiment or flag', entry.locale)
      acc.push(entry.locale)
    }
    return acc
  }, [])
}

export function setAppLocales(appSpecificLocales = []) {
  logVerbose('setAppLocales called', appSpecificLocales.length, appLocales.length)
  const activeExperimentalLocales = {
    essential: calculateActiveLangs(languageFlags.essential),
    extended: calculateActiveLangs(languageFlags.extended),
    supported: calculateActiveLangs(languageFlags.supported),
  }
  const experimentsAreActive =
    [
      ...activeExperimentalLocales.essential,
      ...activeExperimentalLocales.extended,
      ...activeExperimentalLocales.supported,
    ].length > 0

  // the code below modifies essentialLocales and allLocales globally

  // reset essentialLocales, extendedLocales, allLocales, and supportedLocales to default state
  essentialLocales.splice(0, essentialLocales.length, ...origEssentialLangs)
  extendedLocales.splice(0, extendedLocales.length, ...origExtendedLocalesLangs)
  allLocales.splice(0, allLocales.length, ...origAllLocalesLangs)
  supportedLocales.splice(0, supportedLocales.length, ...origSupportedLocalesLangs)

  if (experimentsAreActive) {
    // add back new experimental locales
    essentialLocales.push(...activeExperimentalLocales.essential)
    // experiments moving from extended to essential need to be removed from extended
    pullAll(extendedLocales, ...activeExperimentalLocales.essential)
    extendedLocales.push(...activeExperimentalLocales.extended)
    allLocales.push(...activeExperimentalLocales.extended, ...activeExperimentalLocales.essential)
    supportedLocales.push(...activeExperimentalLocales.supported)
    log(
      'additionalLang experiments are active, adding experimental locales',
      activeExperimentalLocales,
      essentialLocales,
      extendedLocales,
      allLocales,
      supportedLocales
    )
  }
  removeDuplicates(essentialLocales)
  removeDuplicates(extendedLocales)
  removeDuplicates(allLocales)
  removeDuplicates(supportedLocales)

  logVerbose('setAppLocales b4 combinedLocales', supportedLocales, baseLocales, appSpecificLocales)
  const combinedLocales = intersection(supportedLocales, baseLocales.concat(appSpecificLocales))
  logVerbose('setAppLocales combinedLocales', combinedLocales, appLocales)
  if (!isEqual(appLocales, combinedLocales)) {
    appLocales = combinedLocales
    _initializeI18nInstance(i18n, appLocales)
  }
}

const jan2000 = new Date(2000, 0)

export function daysOfMonth(date) {
  return range(1, getDaysInMonth(date) + 1).map((dayNum) => format(new Date(2000, 0, dayNum), 'd'))
}

export function daysOfWeek() {
  return range(2, 9).map((dayNum) => format(new Date(2000, 0, dayNum), 'cccc'))
}

function resolver() {
  return i18n.language
}

export const listOfDays = memoize(() => daysOfMonth(jan2000), resolver)
export const listOfDaysInWeek = memoize(() => daysOfWeek(), resolver)

export const listOfMonths = memoize(
  () => range(12).map((monthNum) => format(new Date(2000, monthNum, 1), 'MMMM')),
  resolver
)

export function listOfYears(startYear, endYear) {
  const endOfRange = endYear < startYear ? endYear - 1 : endYear + 1
  return range(startYear, endOfRange).map((yearNum) => format(new Date(yearNum, 0, 1), 'yyyy'))
}

export function setLocalePreference(newLocale) {
  let cookieDomain
  if (hasWindow && window.location.hostname.match('familysearch.org')) {
    cookieDomain = '.familysearch.org'
  }
  if (supportedLocales.includes(newLocale)) {
    const langCookie = Cookies.get('fslanguage')
    if (langCookie !== newLocale) {
      Cookies.set('fslanguage', newLocale, { domain: cookieDomain })
    }
    if (hasWindow) {
      const zhHantOn = getFeatureFlag('shared_addLangCodeToUrl', { appName })?.isOn
      const url = new URL(window.location.href)
      const langMatch = url.pathname?.match(langCodePathRegex)
      if (langMatch && i18n.language !== newLocale) {
        const alternateNewLocale = zhHantOn && newLocale === 'zh' ? 'zh-Hant' : newLocale
        if (langMatch.groups.localeCode !== alternateNewLocale) {
          url.pathname = url.pathname.replace(
            new RegExp(`^/${langMatch.groups.localeCode}/`),
            `/${alternateNewLocale}/`
          )
          window.location.assign(url)
        }
      } else if (url.searchParams.get('lang') && i18n.language !== newLocale) {
        const alternateNewLocale = zhHantOn && newLocale === 'zh' ? 'zh-Hant' : newLocale
        if (url.searchParams.get('lang') !== alternateNewLocale) {
          url.searchParams.set('lang', alternateNewLocale)
          window.location.assign(url.href)
        }
      } else if (langCookie !== newLocale) {
        window.location.reload()
      }
    }
  } else {
    log(`setLocalePreference for ${newLocale} request ignored as locale is not supported`)
  }
}

// We could attempt to leverage i18n.exists with only a fallbackLng prop – but exists uses a different function underneath than t, which does not handle namespaces the same.
// This can leads to behavior that is not as intuitive as we would like. (People have filed multiple issues about this due to confusion)
// Granted, our logic with namespaces should be pretty stable, but this feels safer.
const isTranslationAvailable = (key) => Boolean(i18n.t(key, { defaultValue: ' ', fallbackLng: 'none' }).trim())

// console.log('locale export', locale)
log('i18n export', i18n)
export { i18n, I18nProvider, addTranslations, formatValue, _initializeI18nInstance, intlFormat, isTranslationAvailable }
export * from './supportedLocales'
// I cannot get this export to stay in sync with i18n.language, so disabling default export until we can figure it out
// export default locale
