import zionDebug from '@fs/zion-debug'
import memoizeIntlConstructor from 'intl-format-cache'
import { format } from './date-fns'

const debug = zionDebug('zion:locale:formats')

// cannot depend directly on i18n.language due to circular dependency, so using an update method to keep current locale in sync
let locale = 'en'
function updateLocale(newLocale) {
  // console.log('setting format locale', newLocale)
  locale = newLocale
}

const getNumberFormat = memoizeIntlConstructor(Intl.NumberFormat)

function isNumber(n) {
  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n)
}

const dateFormats = {
  default: 'd MMMM yyyy',
  short: 'P',
  medium: 'PP',
  long: 'PPP',
  full: 'PPPP',
}

// TODO finish date time formats
// const dateTimeFormats = {
//   default: 'd MMMM yyyy h:m:ss',
//   short: 'Pp',
//   medium: 'PPpp',
//   long: 'PPPppp',
//   full: 'PPPPpppp',
// }

function formatValue(value, formatString = '') {
  // console.log('formatValue', value, formatString)
  if (typeof value === 'undefined' || value == null || !formatString) {
    debug('falling back to default type since formatValue was passed invalid value or format:', value, formatString)
    // return value
  }

  const [type, variant] = formatString.split(',').map((item) => item.trim())
  // console.log(`formatValue tv [${type}] [${variant}]`, type, variant, typeof value)
  switch (type) {
    case 'number':
      if (variant === 'integer') return formatInteger(value)
      return formatNumber(value)
    case 'percent':
      return formatPercent(value)
    case 'currency':
      return formatCurrency(value, variant)
    case 'date':
      return formatDate(value, variant)
    case 'upper':
      return value.toLocaleUpperCase()
    case 'lower':
      return value.toLocaleLowerCase()
    default:
      return formatDefault(value)
  }
}

function formatNumber(value) {
  return getNumberFormat(locale).format(value)
}

function formatInteger(value) {
  return getNumberFormat(locale, { maximumFractionDigits: 0 }).format(value)
}

function formatPercent(value) {
  return getNumberFormat(locale, { style: 'percent' }).format(value)
}

function formatCurrency(value, currency = 'USD') {
  // console.log('formatCurrency', value, currency, locale, hasFullICU)
  const fn = getNumberFormat(locale, { style: 'currency', currency })
  return fn.format(value)
}

function formatDate(value, variant) {
  const variantFormat = dateFormats[variant] || dateFormats.default
  // console.log('variantFormat', variantFormat)
  switch (variant) {
    case 'relative':
      return value // moment(value).fromNow()
    case 'calendar':
      return value // moment(value).calendar(null, {
    //   sameDay: '[today]',
    //   nextDay: '[tomorrow]',
    //   nextWeek: 'dddd',
    //   lastDay: '[yesterday]',
    //   lastWeek: '[last] dddd',
    //   sameElse: 'LL',
    // })
    default:
      return format(value, variantFormat)
  }
}

function formatDefault(value) {
  if (value instanceof Date) return value
  if (isNumber(value)) return getNumberFormat(locale).format(value)
  return value
}

/**
 * Convert given date to UTC
 * @link https://github.com/date-fns/date-fns/issues/556#issuecomment-391048347
 * @param date | plain JS date object
 * @return {Date | *}
 */
// function toUTC(date) {
//   const offset = date.getTimezoneOffset()
//
//   return Math.sign(offset) !== -1 ? addMinutes(date, offset) : subMinutes(date, Math.abs(offset))
// }

export { formatValue, formatDate, formatNumber, updateLocale }
