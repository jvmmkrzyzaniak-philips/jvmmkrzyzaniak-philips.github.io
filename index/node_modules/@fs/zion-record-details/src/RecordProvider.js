import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react'
import axios from '@fs/zion-axios'
import zionDebug from '@fs/zion-debug'
import {
  getAdditionalPersons,
  getAllPersonFields,
  getCollectionDetails,
  getContributorDetails,
  getDocumentInformation,
  getImageArkId,
  getImageMediaType,
  getImageMeta,
  getImageURL,
  getFactTypeLabel,
  getFocusPerson,
  getPerson,
  getPersonBestName,
  getPersonCharacteristics,
  getPersonCitation,
  getPersonFacts,
  getPersonSex,
  getPersonSexFullString,
  getPersonTitle,
  getPersonURL,
  getPersonURLFull,
  getRecordPermissions,
  getRecordPrincipal,
  getRecordRetiredURL,
  getRecordType,
  getRecordURL,
  getRelationshipType,
  getRelationshipLabel,
  isRoboKey,
  getEditableFieldMap,
  getPersonGivenAndSurname,
  getPersonBestBirthYear,
} from '@fs/zion-gedcomx'
import { useUser } from '@fs/zion-user'
import { useFeatureFlag } from '@fs/zion-flags'
import useSearchCache from './cacheHook'

const debug = zionDebug('search:record:recordProvider')

const RecordContext = createContext({})
const RecordStateUpdateContext = createContext({})

/**
 * Provides data needed for a record in a set of easy-to-use hooks
 * @param {Object} children - context children
 * @param {Object} recordData - all record data
 * @param {Boolean} linkViaNewTab - true if links should be opened in new tabs, otherwise false
 * @param {Array} discoveryCollections - array of collection ids that should show discovery features on their records
 * @param {Boolean} isInInfoSheet - true if we are in the infosheet. Used for the discovery button
 * @returns {RecordProvider} - context provider
 * @constructor
 */
export default function RecordProvider({
  children,
  recordData = { attachments: [] },
  linkViaNewTab = false,
  discoveryCollections = [],
  isInInfoSheet = false,
}) {
  recordData.linkViaNewTab = isInInfoSheet || linkViaNewTab
  recordData.hasDiscovery = discoveryCollections.length > 0 && discoveryCollections.includes(recordData.collectionId)
  recordData.isInInfoSheet = isInInfoSheet
  const expanderState = useExpanderState()
  const { possibleTreeMatches, resolvePossibleTreeMatch } = usePossibleTreeMatchSync(recordData)

  // GedcomX parsing is expensive so we use useMemo to prevent re-calculating it
  const recordInfo = useMemo(() => {
    if (recordData.record) {
      const collectionDetails = getCollectionDetails(recordData.record)
      const focusPerson = getFocusPerson(recordData.record)
      const principal = getRecordPrincipal(recordData.record)
      const allPersonFields = getAllPersonFields(recordData.record, recordData.collection, focusPerson, false)
      return {
        // record-specific data
        collectionDetails,
        contributorDetails: getContributorDetails(recordData.record),
        documentFields: getDocumentInformation(recordData.record, recordData.collection),
        imageArkId: getImageArkId(recordData.record),
        imageMediaType: recordData.imageData?.imageMediaType || getImageMediaType(recordData.record),
        imageMeta: recordData.imageData?.imageMeta || getImageMeta(recordData.record, focusPerson.id),
        imageURL: recordData.imageData?.imageURL || getImageURL(recordData.record, focusPerson.id),
        recordType: getRecordType(recordData.record),
        recordURL: getRecordURL(recordData.record),
        principal,
        principalName: getPersonBestName(principal),

        // focus-person-specific data
        focusPerson,
        allPersonFields,
        personaFields: focusPerson.principal ? allPersonFields : getPersonCharacteristics(focusPerson),
        title: getPersonTitle(recordData.record, focusPerson),
        additionalPersons: getAdditionalPersons(recordData.record, focusPerson),
        citation: getPersonCitation(recordData.record, focusPerson),
        ark: getPersonURL(focusPerson),
        arkFull: getPersonURLFull(focusPerson),
        facts: getPersonFacts(focusPerson),
        name: getPersonBestName(focusPerson),
        sex: getPersonSex(focusPerson),
      }
    }
    return {}
  }, [recordData.collection, recordData.record, recordData.imageData])

  const recordStateUpdateValue = useMemo(
    () => ({ resolvePossibleTreeMatch, ...expanderState }),
    [expanderState, resolvePossibleTreeMatch]
  )
  const recordValue = useMemo(
    () => ({ ...recordData, recordInfo, possibleTreeMatches }),
    [possibleTreeMatches, recordData, recordInfo]
  )

  return (
    <RecordStateUpdateContext.Provider value={recordStateUpdateValue}>
      <RecordContext.Provider value={recordValue}>{children}</RecordContext.Provider>
    </RecordStateUpdateContext.Provider>
  )
}

export function useAdjustedBodyCopy() {
  const { isInInfoSheet } = useRecordData({ functionName: 'useAdjustedBodyCopy' })
  return { isInInfoSheet }
}

/**
 * Provides current collection ID
 * @returns {{collectionId: string}}
 */
export function useCollectionId() {
  const { ark, collectionDetails } = useRecordData({ functionName: 'useCollectionId' })
  return { ark, collectionId: collectionDetails.collectionId }
}

/**
 * Provides data needed to set up a record copy
 * @returns {{
 *  citation: String,
 *  personaFields: Array,
 *  documentFields: Array
 * }}
 */
export function useCopyRecord() {
  const { additionalPersons, citation, collectionDetails, documentFields, personaFields } = useRecordData({
    functionName: 'useCopyRecord',
  })
  return { citation, collectionId: collectionDetails.collectionId, documentFields, personaFields, ...additionalPersons }
}

/**
 * Provides data needed to display dismiss possible tree matches
 *
 * @returns {{name, collectionName, sex}} tree person info
 */
export function useDismissMatch() {
  const { name, sex, arkFull, collectionDetails } = useRecordData({ functionName: 'useDismissMatch' })
  return { name, collectionName: collectionDetails.collectionName, recordURL: arkFull, sex }
}

/**
 * Provides data needed to display document information
 *
 * @returns {{citation: String, wikiURL: *, documentFields: *, collectionName: *, collectionWebURL: *, linkViaNewTab: boolean}} document information
 */
export function useDocumentInformation() {
  const { citation, collectionDetails, documentFields, recordData } = useRecordData({
    functionName: 'useDocumentInformation',
  })
  const { collectionName, collectionWebURL } = collectionDetails

  return {
    citation,
    collectionName,
    collectionWebURL,
    documentFields,
    linkViaNewTab: recordData.linkViaNewTab,
    wikiURL: recordData.wikiURL,
  }
}

/**
 * Provides data needed to display document citation
 *
 * @returns {String} document citation
 */
export function useDocumentCitation() {
  const { citation } = useRecordData({ functionName: 'useDocumentCitation' })
  return citation
}

/**
 * Provides data needed to display the edit menu (inside the record menu)
 *
 * @returns {{attachments: Array, ark: String, title: String, recordData: object, collectionId: string}}
 */
export function useEditMenuData() {
  const { ark, allPersonFields, imageArkId, imageURL, linkViaNewTab, personaFields, recordData } = useRecordData({
    functionName: 'useEditMenuData',
  })
  const { cachedExpanders, setCachedExpanders, editExpanders, setEditExpanders } = useContext(RecordStateUpdateContext)
  const { signedIn } = useUser()
  const enableCDSEdits = useFeatureFlag('rip_sharedImageViewer_turnOnCDSEdits').isOn

  const isEdited = personaFields.some((field) => field.values?.length > 1)

  const editableFields = useMemo(() => {
    const editableFieldsMap = getEditableFieldMap(recordData.record, recordData.collection)
    return allPersonFields.filter((field) => {
      return !!editableFieldsMap[field.labelId]
    })
  }, [allPersonFields, recordData.collection, recordData.record])

  const isSLSRecord = checkIsSLS(recordData.record)

  const isEditable =
    signedIn &&
    imageURL &&
    recordData.imageData.imageDataResponse?.allowed &&
    !recordData.imageData.imageDataResponse?.bornDigitalContent &&
    // Allow editing for CDS records when feature flag enables it
    (isSLSRecord ? editableFields.length > 0 : enableCDSEdits)

  debug('IsEditable: ', {
    signedIn,
    imageURL,
    recordData,
    allowed: recordData.imageData.imageDataResponse?.allowed,
    bornDigitalContent: !recordData.imageData.imageDataResponse?.bornDigitalContent,
    editableFields,
    slsImage: isSLSRecord,
    enableCDSEdits,
  })
  return {
    ark,
    editableFields,
    imageArkId,
    imageURL,
    imageDataResponse: recordData.imageData.imageDataResponse,
    isEditable,
    isEdited,
    linkViaNewTab,
    personaFields,
    record: recordData.record,

    signedIn,

    cachedExpanders,
    setCachedExpanders,
    editExpanders,
    setEditExpanders,
  }
}

export function useFieldDetails() {
  const recordInfo = useRecordData({ functionName: 'useFieldDetails' })
  const { ark } = recordInfo
  const { cachedExpanders, editExpanders, setEditExpanders } = useContext(RecordStateUpdateContext)

  return {
    cachedExpanders,
    editExpanders,
    focusPersonURL: ark,
    linkViaNewTab: recordInfo?.recordData?.linkViaNewTab,
    setEditExpanders,
  }
}

/**
 * Provides data needed to display Persona Facts for a non-focus person
 *
 * @returns {{}|{facts: *[]}}
 */
export function usePersonaFields(id) {
  const {
    allPersonFields: allFocusPersonFields,
    ark,
    focusPerson,
    isInInfoSheet,
    linkViaNewTab,
    principal,
    principalName,
    recordData,
  } = useRecordData({
    functionName: 'usePersonaFields',
  })
  const updateContext = useContext(RecordStateUpdateContext)

  const personData = useMemo(() => {
    if (!recordData.record) {
      return {}
    }

    const person = getPerson(recordData.record, id) || focusPerson
    const name = getPersonBestName(person)
    let allPersonFields = []

    // getAllPersonFields is very expensive, so don't call if we don't have to
    if (person === focusPerson) {
      allPersonFields = allFocusPersonFields
    } else if ((!person.principal && !principal) || person.principal) {
      allPersonFields = getAllPersonFields(recordData.record, recordData.collection, person, false)
    }

    const fields = person.principal ? allPersonFields : getPersonCharacteristics(person)
    let principalFields = null
    if (!person.principal) {
      // getAllPersonFields is very expensive, so don't call if we don't have to
      if (principal === focusPerson) {
        principalFields = allFocusPersonFields
      } else {
        principalFields = getAllPersonFields(recordData.record, recordData.collection, principal, false)
      }
    }

    // this is a special case where this person isn't the principal person and there is no principal person,
    // so we want to show all of the person fields that we have without including duplicates
    if (!person.principal && !principal) {
      allPersonFields.forEach((field) => {
        if (!fields.includes(field)) {
          fields.push(field)
        }
      })
    }

    return { person, fields, principalFields, name }
  }, [allFocusPersonFields, focusPerson, id, principal, recordData.record, recordData.collection])

  if (!recordData.record) {
    return {}
  }

  return {
    isPrincipal: Boolean(personData.person.principal),
    focusPersonURL: ark,
    fields: personData.fields,
    principalName,
    principalFields: personData.principalFields,
    linkViaNewTab,
    isInInfoSheet,
    name: personData.name,
    ...updateContext,
  }
}

/**
 * Provides data needed to display Possible Tree Matches
 *
 * @returns {{attachments: [], possibleTreeMatches: [{
 *  score: number,
 *  confidence: number,
 *  focusPerson: object,
 *  matchInfo: [{collection: string, status: string}],
 *  id: string,
 *  published: number,
 *  content: {gedcomx: {persons, relationships}}
 * }], linkViaNewTab, hasDiscovery, isInInfoSheet}} possible tree matches
 */
export function useMatchAttach() {
  const { ark, focusPerson, recordData } = useRecordData({ functionName: 'useMatchAttach' })

  const updateContext = useContext(RecordStateUpdateContext)

  return {
    ark,
    attachments: recordData.attachments,
    collectionId: recordData.collectionId,
    focusPerson,
    hasDiscovery: recordData.hasDiscovery,
    possibleTreeMatches: recordData.possibleTreeMatches,
    resolvePossibleTreeMatch: updateContext.resolvePossibleTreeMatch,
    isInInfoSheet: recordData.isInInfoSheet,
  }
}

/**
 * Provides data needed for the RecordConnectCard
 *
 * @returns {{ ark: String, attachments: Array, birthYear: String, gender: String, givenName: String, matchesNotAttached: Array }}
 */
export function useRecordConnectInfo() {
  const { ark, focusPerson, recordData } = useRecordData({ functionName: 'useRecordConnectInfo' })
  const { givenNames } = getPersonGivenAndSurname(focusPerson)
  const birthYear = getPersonBestBirthYear(focusPerson)
  const gender = getPersonSexFullString(focusPerson)?.toLowerCase() || ''
  const { attachments, possibleTreeMatches } = recordData

  const matchesNotAttached = possibleTreeMatches?.filter(
    (possibleMatch) =>
      !attachments.find(
        (attachment) => attachment.persons !== undefined && possibleMatch.id === attachment.persons[0].entityId
      )
  )

  return { ark, attachments, birthYear, gender, givenName: givenNames, matchesNotAttached }
}

/**
 * Provides data needed to display the Record Header
 *
 * @returns {{collection: Object, name: String, recordType: String}|{}} (or empty object if recordData is not initialized)
 */
export function useRecordHeader() {
  const {
    focusPerson,
    collectionDetails,
    name,
    principal,
    principalName,
    recordType: untranslatedRecordType,
    recordData,
  } = useRecordData({
    functionName: 'useRecordHeader',
  })
  const { hasRestrictions, principalArk, relationshipLabel, recordType, updatedRecord } = useMemo(() => {
    const relationshipType = getRelationshipType(recordData.record, principal, focusPerson)
    return {
      recordType: getFactTypeLabel(untranslatedRecordType),
      hasRestrictions: getRecordPermissions(recordData.record).length > 0,
      principalArk: getPersonURL(principal),
      relationshipLabel: getRelationshipLabel(relationshipType),
      updatedRecord: getRecordRetiredURL(recordData.record),
    }
  }, [focusPerson, principal, recordData.record, untranslatedRecordType])

  return {
    collection: collectionDetails,
    hasRestrictions,
    isPrincipal: Boolean(focusPerson.principal),
    name,
    principal,
    principalArk,
    principalName,
    recordType,
    recordData,
    relationshipLabel,
    person: focusPerson,
    updatedRecord,
  }
}

/**
 * Provides data needed to display Record Additional Personas
 *
 * @returns {{
 *   name: String,
 *   parentsAndSiblings: [{person, relationship}],
 *   spousesAndChildren: [{person, relationship}],
 *   others: [{person, relationship}],
 *   extendedFamily: [{person, relationship}]
 *   linkViaNewTab: Boolean
 * }} (or empty object if recordData is not initialized)
 */
export function useRecordAdditionalPersons() {
  const { additionalPersons, name, recordData } = useRecordData({
    functionName: 'useRecordAdditionalPersons',
  })
  if (!recordData.record) {
    return {}
  }
  additionalPersons.name = name
  return { ...additionalPersons, linkViaNewTab: recordData.linkViaNewTab, isInInfoSheet: recordData.isInInfoSheet }
}

/**
 * Provides data needed to display the Record Image
 *
 * @returns {{imageURL: String, imageMediaType: String, imageMeta: Object, linkViaNewTab: Boolean, personaURL: String}}
 */
export function useRecordImage() {
  const { recordData, imageURL, imageMediaType, imageMeta } = useRecordData({
    functionName: 'useRecordImage',
  })

  const { imageDataResponse, dgsLinkData, personaURL } = recordData.imageData

  return {
    imageURL,
    imageMediaType,
    imageMeta,
    imageDataResponse,
    dgsLinkData,
    linkViaNewTab: recordData.linkViaNewTab,
    personaURL,
  }
}

/**
 * Provides data needed to display Record Menus
 *
 * @returns {{attachments: Array, ark: String, title: String, recordData: object, collectionId: string}}
 */
export function useRecordMenuData() {
  const { arkFull, collectionDetails, name, recordData, title } = useRecordData({
    functionName: 'useRecordMenuData',
  })

  return {
    attachments: recordData.attachments,
    ark: arkFull,
    collectionId: collectionDetails.collectionId,
    linkViaNewTab: recordData?.linkViaNewTab,
    name,
    possibleTreeMatches: recordData.possibleTreeMatches,
    title,
  }
}

export function checkIsSLS(record) {
  return Boolean(
    record.fields.find((field) => field.type === 'http://familysearch.org/types/fields/SystemOfRecord')?.values[0]
      .text === 'SLS'
  )
}

/**
 * Provides data needed to determine if the Rii Viewer should be used
 * @returns {{ riiEnabled: Boolean}}
 */
export function useRiiViewer() {
  const { recordData } = useRecordData({
    functionName: 'useRiiViewer',
  })

  const riiEnabled = useMemo(() => {
    return checkIsSLS(recordData.record)
  }, [recordData.record])

  return { riiEnabled }
}

/**
 * Provides url needed to access the new Rii experience
 * @param action
 * @param collectionId
 * @returns {{ riiUrl: String }}
 */
export function useRiiUrl(action, collectionId) {
  const { imageURL, personaURL } = useRecordImage()
  if (imageURL && personaURL) {
    const urlObj = new URL(imageURL)
    urlObj.searchParams.append('view', 'index')
    urlObj.searchParams.append('personArk', personaURL)
    urlObj.searchParams.append('action', action)
    if (collectionId) {
      urlObj.searchParams.append('cc', collectionId)
    }
    return { riiUrl: urlObj.toString() }
  }
  return { riiUrl: '' }
}

/**
 * Provides data needed to display RoboKey Feedback
 *
 * @returns {{isRoboKey: Boolean}}
 */
export function useRoboKeyFeedback() {
  const { ark, imageURL, recordData, recordURL } = useRecordData({ functionName: 'useRoboKeyFeedback' })
  return { isRoboKey: isRoboKey(recordData.record), imageURL, personaURL: ark, recordURL }
}

/**
 * Sends a message thanking the indexer of the current record for indexing it.
 *
 * @returns {function(...[*]=)}
 */
export function useSendIndexingMessage() {
  const { ark, contributorDetails } = useRecordData({ functionName: 'useSendIndexingMessage' })
  return {
    contributorDetails,
    sendIndexingMessage: () => {
      const params = { recordLink: ark }
      // To test, insert params.testing = true, which will redirect the message to the logged in user.
      axios.post('/search/orchestration/indexer-thanks', params)
    },
  }
}

/**
 * Provides data for similar records component
 *
 * @returns {Array} - array of similar records
 */
export function useSimilarRecords() {
  const { recordData } = useRecordData({ functionName: 'useSimilarRecords' })
  return recordData.similarRecords
}

/** Private Functions */

/**
 * This is how children will access the record content, including the collection
 *
 * @param {String} functionName - name of function for error message
 * @returns {{
 *  attachments: Array,
 *  collection: Object,
 *  collectionId: String,
 *  collectionURL: String, similarRecords: Array,
 *  record: Object,
 *  possibleTreeMatches: Array,
 *  linkViaNewTab: Boolean,
 *  wikiURL: String}}
 */
function useRecordData({ functionName = 'useRecordData' } = {}) {
  const recordData = useContext(RecordContext)
  if (typeof recordData.record === 'undefined') {
    throw new Error(`${functionName} must be used within a RecordProvider`)
  }
  return { recordData, ...recordData.recordInfo }
}

/**
 * Hook to keep possible tree matches in sync on the page after a user has dismissed a match.
 *
 * @param recordData - the record data object
 * @returns {{possibleTreeMatches: unknown, resolvePossibleTreeMatch: ((function(*): void)|*)}}
 */
function usePossibleTreeMatchSync(recordData) {
  // Store our own list of possible tree matches to sync after user dismisses one as not a match
  const [possibleTreeMatches, setPossibleTreeMatches] = useState(recordData.possibleTreeMatches)

  // Refresh list if the parent changes (e.g., user browses to a new record)
  useEffect(() => {
    setPossibleTreeMatches(recordData.possibleTreeMatches)
  }, [recordData.possibleTreeMatches])

  // Function to resolve a match (used in MatchAttach)
  const resolvePossibleTreeMatch = useCallback(
    (possibleMatch) => {
      const updatedMatches = [...possibleTreeMatches.filter((m) => m !== possibleMatch)]
      setPossibleTreeMatches(updatedMatches)
    },
    [possibleTreeMatches]
  )

  return { possibleTreeMatches, resolvePossibleTreeMatch }
}

/**
 * Hook to manage edit expander state (and cache it)
 * @returns {{setCachedExpanders: setCachedExpanders, editExpanders: {}, cachedExpanders: undefined, setEditExpanders: setEditExpanders}}
 */
function useExpanderState() {
  const [editExpanders, privateSetEditExpanders] = useState({})
  const [cachedExpanders, privateSetCachedExpanders] = useState()
  const cache = useSearchCache()

  useEffect(() => {
    let cancelled = false
    // This hook will check if the user has previously toggled the "Show All Edits" menu option
    cache.getItem('editInfoExpanded').then((value) => {
      if (value === '1' && !cancelled) {
        privateSetCachedExpanders(true)
      }
    })

    return () => {
      cancelled = true
    }
  }, [cache])

  const setEditExpanders = (newValue) => {
    // only call setter when our value changed to prevent an infinite loop
    if (JSON.stringify(newValue) !== JSON.stringify(editExpanders)) {
      privateSetEditExpanders(JSON.parse(JSON.stringify(newValue)))
    }
  }

  const setCachedExpanders = (newValue) => {
    privateSetCachedExpanders(JSON.parse(JSON.stringify(newValue)))
    cache.setItem('editInfoExpanded', newValue ? '1' : '0').catch((err) => debug(err))
  }

  return { editExpanders, setEditExpanders, cachedExpanders, setCachedExpanders }
}
