import axios from '@fs/zion-axios'
import zionDebug from '@fs/zion-debug'
import { baseUrl } from '@fs/zion-config'
import { getCollectionDetails } from '@fs/zion-gedcomx'

// turn on in browser console with: localStorage.debug = 'fs:search:record:*'
const debug = zionDebug('search:record:recordServices')
const treeURLRegex = /.{4}-.{3,4}/i

/**
 * Returns all record data needed for displaying record details
 *
 * @param {String} personaURL - URL for the record persona to display
 * @param {Boolean} signedIn - true if the user has signed in
 * @param {Boolean} fromSLS - record request is sent to the SLS server instead of CDS (recapi)
 * @param {Boolean} [isPreview] - default false; if true, don't fetch things that aren't needed in preview mode (like similar records)
 * @param {Boolean} [showAttachments] - default true; if false, don't fetch attachment data
 * @returns {Promise<{attachments: Array, collection: Object, collectionId: String, collectionURL: String, similarRecords: Array, record: Object, possibleTreeMatches: Array, wikiURL: String}>}
 */
export async function getAllRecordData({
  personaURL,
  signedIn,
  fromSLS = false,
  isPreview = false,
  showAttachments = true,
}) {
  debug('is user signed in?', signedIn)
  const [recordAndCollectionResults, attachmentsResults, similarRecordsResults, possibleTreeMatchesResults] =
    await Promise.allSettled([
      getRecordThenCollectionData(personaURL, fromSLS, isPreview),
      getAttachments(personaURL, signedIn, showAttachments),
      getSimilarRecords(personaURL, signedIn, isPreview),
      getPossibleTreeMatches(personaURL, signedIn, showAttachments),
    ])

  // if we don't have results, error out; we can't do anything more
  if (recordAndCollectionResults.status === 'rejected') {
    return Promise.reject(recordAndCollectionResults.reason)
  }

  const {
    value: { record, collection, collectionId, collectionURL, wikiURL },
  } = recordAndCollectionResults

  // use only person attachments; disregard relationship attachments
  const attachments = attachmentsResults?.value?.data.filter((attachment) => attachment.persons) || []
  const similarRecords = similarRecordsResults.value?.sort(getSimilarRecordsSorter(attachments)) || []
  const possibleTreeMatches = possibleTreeMatchesResults?.value?.data?.entries || []

  return { attachments, collection, collectionId, collectionURL, similarRecords, record, possibleTreeMatches, wikiURL }
}

/**
 * Get the record and collection data and the collection wiki URL
 * We get the record first because the collection and wiki APIs require record data in the URL
 *
 * @param {String} personaURL - ARK URL for the persona
 * @param {Boolean} fromSLS - record request is sent to the SLS server instead of CDS (recapi)
 * @param {Boolean} [isPreview] - default false; if true, don't fetch things that aren't needed in preview mode (like similar records)
 * @returns {Promise<{wikiURL: String, collection: Object, record: Object, collectionId: String, collectionURL: String}>}
 */
export async function getRecordThenCollectionData(personaURL, fromSLS = false, isPreview = false) {
  // First get record data (await will throw & exit the function if it fails
  const { data: record } = await getGedcomXData(personaURL, fromSLS)
  debug('returned record data:', record)

  // If something happened with the record data, error out; nothing else will work
  const { collectionURL, collectionId } = getCollectionDetails(record)

  // TODO: require collectionURL to be present like we used to. This is a temp fix for (FULLTEXT24-525)
  if (collectionURL) {
    // get collection and wiki results in parallel after getting record data
    const [collectionResults, wikiResults] = await Promise.allSettled([
      getGedcomXData(collectionURL, fromSLS),
      getCollectionWikiURL(collectionId, isPreview),
    ])

    // If the collection promise was rejected, error out
    if (collectionResults.status === 'rejected') {
      throw new Error(`${collectionResults.reason}`)
    }

    // If the wiki promise was fulfilled, include its data; ignore if it was rejected (this is considered a flaky API)
    const wikiURL = wikiResults.status === 'fulfilled' ? wikiResults?.value?.data?.data : ''

    return { record, collection: collectionResults.value.data, collectionId, collectionURL, wikiURL }
  }

  return { record, collection: {}, collectionId: '', collectionURL: '', wikiURL: '' }
}

// internal functions

/**
 * Call to get attachments for the persona URL
 * @param {String} personaURL - ARK URL for the persona
 * @param {Boolean} signedIn - true if the user is signed in
 * @param {Boolean} [showAttachments] - default true; if false, don't fetch attachment data
 * @returns {Promise<{data: []}>} Resolves to an array of attachments if the user is signed in
 */
async function getAttachments(personaURL, signedIn, showAttachments = true) {
  // we need to use our own instance to prevent auto-login
  const axiosInstance = axios.create()
  // zion-config does not work in StoryBook, so we fall back to window.location. Does not work in localhost.
  const fallbackBaseUrl = window.location.origin

  if (signedIn && showAttachments) {
    // if our ark has no domain, add the current base URL
    const attachmentArk = personaURL.indexOf('http') > -1 ? personaURL : `${baseUrl || fallbackBaseUrl}${personaURL}`
    return axiosInstance.get(`/service/tree/links/sources/attachments?uri=${attachmentArk}`)
  }
  // if user is not signed in, we just resolve with an empty array
  return { data: [] }
}

/**
 * Call to Search Web's collection wiki URL endpoint
 * Because the wiki API is flaky, we keep our own Redis cache of wiki URLs
 * @param {String} collectionId - Id for the collection to look up
 * @param {Boolean} [isPreview] - default false; if true, don't fetch things that aren't needed in preview mode (like similar records)
 * @returns {Promise<String>} Resolves to a string that's the wiki URL
 */
async function getCollectionWikiURL(collectionId, isPreview = false) {
  if (isPreview) {
    return ''
  }
  // we need to use our own instance to prevent auto-login
  const axiosInstance = axios.create()

  return axiosInstance.get(`/search/orchestration/wikiurl/${collectionId}`)
}

/**
 * Call for retrieving record and collection data
 *
 * @param {String} url - record or collection URL
 * @param {Boolean} fromSLS - record request is sent to the SLS server instead of CDS (recapi)
 * @returns {Promise} Axios response with record or collection data
 */
export async function getGedcomXData(url, fromSLS = false) {
  // we need to use our own instance to prevent auto-login
  const axiosInstance = axios.create()
  const headers = { Accept: 'application/x-gedcomx-v1+json', 'x-fs-feature-tag': 'collectionAPI' }

  let newUrl = url
  if (fromSLS) {
    // The Platform Team (Dave Nash), started out with forwarding the param to using x-fs-feature-tag.
    // I am using both because he is going to possibly remove the param and start using the feature tag instead
    newUrl = newUrl.includes('?') ? `${newUrl}&useSLS=true` : `${newUrl}?useSLS=true`
    headers['x-fs-feature-tag'] = 'records.use.sls'
  }

  return axiosInstance.get(newUrl, {
    headers,
  })
}

/**
 * Call for retrieving reverse hints (tree persons) for a record
 * https://www.familysearch.org/platform/records/personas/Q2MB-9FX4/matches?collection=tree&status=accepted&status=pending
 *
 * @param {String} personaURL - ARK URL for the persona
 * @param {Boolean} signedIn - true if the user is signed in
 * @param {Boolean} [showAttachments] - default true; if false, don't fetch attachment data
 * @returns {Promise<[Object]>} Axios response with reverse hints
 */
export async function getPossibleTreeMatches(personaURL, signedIn, showAttachments = true) {
  if (signedIn && showAttachments) {
    // we need to use our own instance to prevent auto-login
    const axiosInstance = axios.create()

    // API call needs ark id out of persona URL
    const match = treeURLRegex.exec(personaURL)
    return axiosInstance.get(
      `/platform/records/personas/${match[0]}/matches?collection=tree&status=accepted&status=pending&includeSummary=true`
    )
  }
  return {}
}

/**
 * Call for getting similar records (record-to-record hints) for a record
 * https://www.familysearch.org/platform/records/personas/Q2MB-9FX4/matches?collection=records&includeSummary=true&count=10
 *
 * @param {String} personaURL - ARK URL for the persona
 * @param {Boolean} signedIn - true if this user is signed in
 * @param {Boolean} [isPreview] - default false; if true, don't fetch things that aren't needed in preview mode (like similar records)
 * @returns {Promise<[{ark: String, attachments: Array, record: Object}]>} Resolves to an Array of objects with ark and attachments fields
 */
async function getSimilarRecords(personaURL, signedIn, isPreview = false) {
  // we need to use our own instance to prevent auto-login
  const axiosInstance = axios.create()

  const personaMatch = treeURLRegex.exec(personaURL)
  const result = await axiosInstance.get(
    `/platform/records/personas/${personaMatch[0]}/matches?collection=records&includeSummary=true&count=10`
  )
  const matches = result?.data?.entries || []
  const arkList = matches.map((match) => match.id)

  // If the user is signed in, get attachments for these similar records
  let attachments = []
  if (signedIn && arkList?.length && !isPreview) {
    const postParams = { uris: arkList }

    const attachmentData = await axiosInstance.post('/service/tree/links/sources/attachments', postParams, {
      headers: {
        'Content-Type': 'application/json',
      },
    })
    attachments = arkList.map((ark) => attachmentData.data?.attachedSourcesMap?.[ark] || [])
  }

  // Return ark list bundled with any attachments
  return arkList.map((fullArk, index) => {
    const ark = new URL(fullArk).pathname // remove the domain name for these arks so we don't have to use CORS
    return { ark, attachments: attachments[index] || [], record: matches[index].content.gedcomx || [] }
  })
}

/**
 * Sets a tree person match for a record as "not a match"
 * @param {String} treePID - tree person Id
 * @param {String} recordURL - record ARK
 * @param {String} reason - crafted reason statement
 * @returns {Promise<*>}
 */
export async function setNotAMatch({ treePID, recordURL, reason }) {
  return axios.post(
    `/platform/tree/persons/${treePID}/matches?status=rejected&collection=records`,
    {
      persons: [
        {
          attribution: {
            changeMessage: reason,
          },
          identifiers: {
            $: [recordURL],
          },
        },
      ],
    },
    {
      headers: {
        'Content-Type': 'application/x-gedcomx-v1+json',
      },
    }
  )
}

/**
 * Undismisses a record hint previously set as "not a match"
 * @param {String} treePID - tree person Id
 * @param {String} notAMatchId - ID for the not-a-match declaration to remove
 * @param {String} reason - crafted reason statement
 * @returns {Promise<*>}
 */
export async function setMayBeAMatch({ treePID, notAMatchId, reason = '' }) {
  return axios.delete(`/platform/tree/persons/${treePID}/not-a-match?id=${notAMatchId}`, {
    headers: {
      'Content-Type': 'application/json',
      'X-Reason': reason,
    },
  })
}

/**
 * @param {Array} attachments - record attachments list
 * @returns {function(*=, *=): number} return a function that sorts similar records based on their attachments, using the record's attachment list
 */
function getSimilarRecordsSorter(attachments) {
  return (a, b) => {
    const aAttachment = attachments.find(isRecordAttached, a)
    const bAttachment = attachments.find(isRecordAttached, b)

    // if there is an attachment to the same tree person as the actual record, that one goes to the bottom
    if (aAttachment && !bAttachment) {
      return 1
    }
    if (bAttachment && !aAttachment) {
      return -1
    }
    if (bAttachment && aAttachment) {
      return 0
    }

    // if there are attachments not to the same tree person, that one goes to the bottom above exact attachments
    if (a.attachments.length) {
      return 1
    }
    if (b.attachments.length) {
      return -1
    }
    return 0
  }
}

/**
 * private find function to find an attachment in a different attachment list
 * @param recordAttachment
 * @returns {boolean}
 */
function isRecordAttached(recordAttachment) {
  const similarRecordAttachmentPersonId = this?.attachments?.[0]?.persons?.[0]?.entityId
  const recordAttachmentPersonId = recordAttachment?.persons?.[0]?.entityId
  return similarRecordAttachmentPersonId && similarRecordAttachmentPersonId === recordAttachmentPersonId
}
