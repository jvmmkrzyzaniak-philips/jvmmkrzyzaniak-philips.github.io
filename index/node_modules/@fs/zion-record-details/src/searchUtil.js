import { parse } from 'qs'

/**
 * Overrides for numerical HTML character references that don’t directly correspond
 * to Unicode code points. This list is static and will not need to change.
 * From this table in the HTML spec: https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
 */
const charReferenceOverrides = {
  0x80: 0x20ac,
  0x82: 0x201a,
  0x83: 0x0192,
  0x84: 0x201e,
  0x85: 0x2026,
  0x86: 0x2020,
  0x87: 0x2021,
  0x88: 0x02c6,
  0x89: 0x2030,
  0x8a: 0x0160,
  0x8b: 0x2039,
  0x8c: 0x0152,
  0x8e: 0x017d,
  0x91: 0x2018,
  0x92: 0x2019,
  0x93: 0x201c,
  0x94: 0x201d,
  0x95: 0x2022,
  0x96: 0x2013,
  0x97: 0x2014,
  0x98: 0x02dc,
  0x99: 0x2122,
  0x9a: 0x0161,
  0x9b: 0x203a,
  0x9c: 0x0153,
  0x9e: 0x017e,
  0x9f: 0x0178,
}

/**
 * There are over 2,000 named character references, so only include ones we need.
 * See all at https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references
 */
const namedCharReferences = {
  bull: '•',
}

const htmlEntityRegex = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-f]{1,6});/gi

/**
 * Add the query parameters fromthe window.location to the URL
 * @param url
 * @returns {*}
 */
export function appendQueryParamsToURL(url) {
  let queryParams = ''
  const location = `${window.location}`
  const index = location.indexOf('?')
  if (index !== -1) {
    queryParams = location.substring(index + 1)
  }
  const parsedQuery = parse(queryParams)
  const addToQuery = (param, value) => {
    if (url.indexOf('?') === -1) {
      url += `?${param}=${value}`
    } else {
      url += `&${param}=${value}`
    }
  }

  // If there already is an id param in the URL, keep it, otherwise get the treeref (if there is one) and append it to the URL
  const treeref = parsedQuery?.treeref
  const idInURL = url.match(/\bid(=|%3D)\b/i)
  if (!idInURL && parsedQuery.id) addToQuery('id', parsedQuery.id)
  else if (!idInURL && treeref) addToQuery('id', treeref)

  // Get the value of the icid query parameter (if there is one) and append it to the URL
  const icidValue = parsedQuery?.icid
  if (icidValue) addToQuery('icid', icidValue)

  return url
}

/**
 * Return the treeRef parameter from the window.location (if its there)
 * @returns {String|null} The treeRef param, or null if its not there.
 */
export function getTreeRefParam() {
  let treeRef = null
  let queryParams = ''
  const location = `${window.location}`
  const index = location.indexOf('?')
  if (index !== -1) {
    queryParams = location.substring(index + 1)
    const parsedQuery = parse(queryParams)
    treeRef = parsedQuery.treeref
  }

  return treeRef
}

/**
  Expects a query string
    e.g. ?collectionId=9&foo=2

  Returns each paramter/value in an object
    e.g.  {'collection': '9', 'foo': '2'}
*/
export function parseQueryParams(queryString) {
  if (queryString) {
    queryString = queryString.replace(/^\?/, '')
    const query = {}
    const pairs = queryString.split('&')
    for (let i = 0; i < pairs.length; i++) {
      const pair = pairs[i].split('=')
      const key = decodeURIComponent(pair[0]).replace('?', '')
      query[key] = decodeURIComponent(pair[1] || '')
    }
    return query
  }

  return {}
}

/**
 * Removes HTML and decodes entities (e.g., &#x201c; or &bull;) from a string.
 * @param {string} text - text to process
 * @param {string} recordArk
 * @returns {string} text with HTML removed and entities decoded
 */
export function removeHtml(text, recordArk) {
  // Decode HTML entitites
  text = text.replace(htmlEntityRegex, (match, group) => {
    // Numerical character references
    if (group.startsWith('#')) {
      let charReference = group.replace('#', '').toLowerCase()
      let radix = 10
      // Hexadecimal references start with “x”
      if (charReference.startsWith('x')) {
        charReference = charReference.replace('x', '')
        radix = 16
      }

      let charCode = Number.parseInt(charReference, radix)
      // Handle overrides for HTML character references that don’t directly correspond to Unicode code points
      charCode = charReferenceOverrides[charCode] || charCode
      return String.fromCharCode(charCode)
    }
    // Named character references, or fallback to original
    return namedCharReferences[group] || match
  })

  // Change <p/> to \n, while having double \n
  text = text.replace(/<p\/>\n/g, '\n')
  text = text.replace(/<p\/>/g, '\n')

  // Match expression breakdown:
  //   1: <   (open tag)
  //   2: zero or one '/' (delineating an end tag)
  //   3: followed by any set of characters 'a-z' or '0-9', beginning with 'a-z'
  //   4: followed by any character that is not >  (this allows for spaces, attributes, etc.)
  //   5: >   (end tag)
  // This will match on all beginning and ending tags:
  //      eg. <a>, <a >, </a>, <p/>, <p/ >, <div href="abc">
  // It will not match on tags like: < a> or <2a> or < /a>
  if (text !== text.replace(/<\/?[a-z][a-z0-9]*>/gi, '') && recordArk) {
    console.error(`Found an HTML tag - ${recordArk}`)
  }

  if (text.match(htmlEntityRegex) && recordArk) {
    console.error(`Found an HTML entity - ${recordArk}`)
  }

  return text
}

/**
 * Strip the domain from the URL and return a root relative version of it.
 * @param {String} urlStr the url in string form.
 * @returns {string} the root relative version of the url string.
 */
export function relativizeURL(urlStr) {
  if (urlStr) {
    const urlObj = new URL(urlStr, 'http://localhost')
    return urlObj.pathname + urlObj.search
  }
  return '/'
}
