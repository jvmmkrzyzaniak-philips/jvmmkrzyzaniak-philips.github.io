import axios from '@fs/zion-axios'
import zionDebug from '@fs/zion-debug'
import { targetEnv } from '@fs/zion-config'
import { convertImageURLToArk, getArkId, getArkType } from '@fs/zion-ark'
import { relativizeURL } from './searchUtil'

// turn on in browser console with: localStorage.debug = 'fs:search:record:*'
const debug = zionDebug('search:record:imageServices')

export const REMEDY_ROLES = ['REG_PAT', 'LDS', 'FHC', 'AFFILIATE', 'LOG_OR_DISC']

export const LOCATION_REMEDY_ROLES = ['FHC', 'AFFILIATE']

const ROLE_MAP = {
  CrxRoleRegisteredPatron: 'REG_PAT',
  ThemisRoleRegisteredPatron: 'REG_PAT',
  CrxRoleLdsMember: 'LDS',
  ThemisRoleLdsMember: 'LDS',
  CrxRoleFhlc: 'FHC',
  ThemisRoleFhlc: 'FHC',
  CrxRoleAffiliate: 'AFFILIATE',
  ThemisRoleAffiliate: 'AFFILIATE',
  CrxRoleAnyone: 'LOG_OR_DISC',
  ThemisRoleAnyone: 'LOG_OR_DISC',
}

/**
 * Get the born digital content (if there is such a thing) for this image.
 *
 * @param {String} imageURL The image URL (e.g. https://www.familysearch.org/ark:/61903/3:1:3QSQ-G9MR-19YH)
 * @param {Object} imageData The image metadata (see #getPlatformImageInfo())
 * @returns {Promise<{imageURL: {String}, digitalContent: {Object}} | {error}>}
 */
export async function getBornDigitalContent(imageURL, imageData) {
  debug(`imageServices.getBornDigitalContent(${imageURL}, ${JSON.stringify(imageData)})`)
  if (!imageURL) {
    throw new Error('No imageURL provided')
  }
  if (!imageData || !imageData?.links?.['image-deepzoom']?.href) {
    // Apparently we don't get the image-deepzoom link if we aren't logged in or don't have permissions to the image
    throw new Error('No imageData provided or imageData.links.image-deepzoom missing')
  }

  const url = imageData.links['image-deepzoom'].href.replace('image.xml', 'dist.json')
  const response = await axios.get(url, {
    headers: {
      from: 'search-react.imageServices.getBornDigitalContent@familysearch.org',
    },
  })
  if (response.status === 200) {
    return { imageURL, digitalContent: response.data }
  }
  const e = new Error(`Unable to retrieve digital content for ${imageURL}${getSafeRootMessage(response?.error)}`)
  e.code = response?.status
  throw e
}

/**
 * Retrieving film permission information
 *
 * @param {Number/String} dgs - digital film number
 * @returns {Promise<{dgs: {String}, allowed: {Boolean}, permissions: {Array}} | {error}>}
 */
export async function getFilmPermissions(dgs) {
  debug(`imageServices.getFilmPermissions(${dgs})`)

  if (!dgs) {
    // if running the code in a test, we need the error not to throw so as not to break the test
    if (process.env.NODE_ENV === 'test' && dgs !== null) return
    throw new Error('No dgs provided')
  }

  const url = '/platform/artifacts/groups/permissions?showFailedRoles=true'
  const postParams = { sourceDescriptions: [{ id: `${dgs.padStart(9, '0')}` }] }
  const response = await axios.post(url, postParams, {
    headers: {
      accept: 'application/x-gedcomx-v1+json',
      'content-type': 'application/x-gedcomx-v1+json',
      from: 'search-react.dgsServices.getDgsPermissions@familysearch.org',
    },
  })
  // rights[0] = http://familysearch.org/v1/Allowed | http://familysearch.org/v1/Denied
  const allowed = response?.data?.sourceDescriptions?.[0]?.rights?.[0] === 'http://familysearch.org/v1/Allowed'
  if (!allowed && !response?.data?.sourceDescriptions?.[0]?.rights?.[2] && targetEnv !== 'prod') {
    // Permissions don't work in anything but prod so we will mock the response here
    debug(`imageServices.getFilmPermissions doesn't work in ${targetEnv}. Mocking response.`)
    // eslint-disable-next-line consistent-return
    return { dgs, allowed: true, permissions: [] }
  }
  const rolesArray =
    response?.data?.sourceDescriptions?.[0]?.rights?.[allowed ? 1 : 2]
      .substring('https://www.familysearch.org/accessControl?requiredRoles='.length)
      .split(',') || []
  const recognizedRoles = []
  const otherRoles = []
  rolesArray.forEach((r) => {
    if (ROLE_MAP[r] && !recognizedRoles.includes(ROLE_MAP[r])) {
      recognizedRoles.push(ROLE_MAP[r])
    } else if (!ROLE_MAP[r]) {
      otherRoles.push(`Other (${r})`)
    }
  })
  // eslint-disable-next-line consistent-return
  return { dgs, allowed, permissions: recognizedRoles.concat(otherRoles) }
}

/**
 * Get the film number and permissions for an image
 *
 * @param {String} imageURL The image URL (e.g. https://www.familysearch.org/ark:/61903/3:1:3QSQ-G9MR-19YH)
 * @returns {Promise<{imageURL: {String}, dgs: {String}, allowed: {Boolean}, permissions: {Array}} | {error}>}
 */
export async function getFilmThenPermissions(imageURL) {
  debug(`imageServices.getFilmThenPermissions(${imageURL})`)

  if (!imageURL) {
    throw new Error('No imageURL provided')
  }

  const { dgs } = await getImageParent(imageURL)
  const { allowed, permissions } = await getFilmPermissions(dgs)
  return { imageURL, dgs, allowed, permissions }
}

/**
 * Retrieve the image information for the given image based on a record.
 * @param {String} imageURL The image URL (e.g. https://www.familysearch.org/ark:/61903/3:1:3QSQ-G9MR-19YH)
 * @param {String} imageMediaType The media type for the image (e.g. 'image/jpeg' or 'application/json')
 * @param {String} recordURL The record URL (e.g. https://www.familysearch.org/ark:/61903/1:1:V1RM-331).
 *          May be null.
 * @returns {Promise<{imageURL: {String}, imageMediaType: {String}, recordURL: {String}, imageData: {Object},
 *    parentDGS: {String}, allowed: {Boolean}, permissions: {Array}, bornDigitalContent: {Object}} | {error}>}
 */
export async function getImageData(imageURL, imageMediaType, recordURL) {
  debug(`imageServices.getImageData(${imageURL}, ${imageMediaType}, ${recordURL})`)

  if (!imageURL) {
    throw new Error('No imageURL provided')
  }
  const { imageData } = await getPlatformImageInfo(imageURL, recordURL)
  const { dgs, allowed, permissions } = await getFilmThenPermissions(imageURL)
  let bornDigitalContent = null
  if (imageMediaType === 'application/json' && allowed) {
    try {
      const { digitalContent } = await getBornDigitalContent(imageURL, imageData)
      bornDigitalContent = digitalContent
    } catch (err) {
      // In this case we will log the error but try to continue without the digital data
      console.error(`getBornDigitalContent can't identify digital-content because we caught err=${err}`)
    }
  }
  return {
    imageURL,
    imageMediaType,
    recordURL,
    imageData,
    parentDGS: dgs,
    allowed,
    permissions,
    bornDigitalContent,
  }
}

/**
 * Retrieve the parent (film or DGS) for the image
 * @param {String} imageURL The image URL (e.g. https://www.familysearch.org/ark:/61903/3:1:3QSQ-G9MR-19YH)
 * @returns {Promise<imageURL: {String}, dgs: {String} | {error}>}
 */
export async function getImageParent(imageURL) {
  debug(`imageServices.getImageParent(${imageURL})`)

  if (!imageURL) {
    throw new Error('No imageURL provided')
  }

  // We will use the DAS call to get the parent (DGS) since it doesn't require authentication
  const imageURLObj = new URL(imageURL)
  imageURLObj.pathname += '/name'
  // Empty the search parameters first
  imageURLObj.searchParams.forEach((value, key) => imageURLObj.searchParams.delete(key))
  imageURLObj.searchParams.set('namespace', 'dgs')
  const url = relativizeURL(imageURLObj.toString())
  const response = await axios.get(url, {
    headers: {
      from: 'search-react.imageServices.getImageParent@familysearch.org',
    },
  })
  if (response.status === 200) {
    // response = dgs:<dgsnum>.<dgsnum>_<imagenum>
    const data = response?.data || 'dgs:.'
    const dgsParts = data.split('.')
    const dgs = dgsParts[0].substring('dgs:'.length)
    return { imageURL, dgs }
  }
  const e = new Error(`Unable to retrieve image parent for ${imageURL}${getSafeRootMessage(response?.error)}`)
  e.code = response?.status
  throw e
}

/**
 * Get image information
 *
 * @param {String} imageURL The image URL (e.g. https://www.familysearch.org/ark:/61903/3:1:3QSQ-G9MR-19YH)
 * @param {String} recordURL The record that was extracted from the image (e.g. https://www.familysearch.org/ark:/61903/1:1:V1RM-331).
 *          May be null. Used for supporting bounding regions on external viewers.
 * @param {Boolean} processURL - true if being used to test the process URL logic
 * @returns {Promise<{imageURL: {String}, recordURL: {String}, imageData: {Object}} | {url: {String} (if processURL is true)} | {error}>}
 *          imageData includes the following:
 *            sourceDescriptions
 *              [0] resourceType: http://gedcomx.org/DigitalArtifact
 *                citations
 *                notes (if notification is enabled)
 *                  id: notification
 *                  text: (notification text to be displayed to patron when the image is viewed)
 *                rights (URL with query parameters):
 *                  restricted: true/false
 *                  allowDownload: true/false
 *                  allowPrint: true/false
 *                  contractHandle: string
 *                  failedRole: string
 *                  authorized: true/false
 *              [1..N] Waypoints and Collections this image belongs to
 *              (if 3rd party image)
 *              [N]
 *                id: #sd_variant1
 *                titles (name of 3rd party provider)
 *                identifiers (link to 3rd party image)
 *                about (link to 3rd party image)
 *            agents (if 3rd party image or attribution)
 *              [0]
 *                addresses
 *                links
 *                  siteUrl
 *                names
 *            links
 *              next - ARK for next image
 *              records - platform relative path to get the records for the image
 *              prev - ARK for previous image
 *              self - ARK for this image
 *              -- new with DTM 5 work ---
 *              image-name - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28/name
 *              image-node - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28
 *              image-deepzoom - e.g. https://www.familysearch.org/dz/v1/TH-1942-27779-1718-28/image.xml
 *              image-children - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28/children
 *              image-permission - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28/permissions
 *              image-parents - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28/parents
 *              image-security - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28/security
 *              image-streams - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28/streams
 *              ---------- JPG image -------------
 *              image-stream-image-thumb_p200 - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28/thumb_p200.jpg
 *              image-stream-image-thumb_[16|32|64|128] - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28/thumb_[16|32|64|128].jpg
 *              image-stream-meta-artifactmetadata - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28/artifactmetadata.xml
 *              image-stream-image-dist - e.g. https://www.familysearch.org/das/v2/TH-1942-27779-1718-28/dist.jpg
 *              ---------- born digital -----------
 *              image-stream-meta-pres_image - e.g. https://www.familysearch.org/das/v2/TH-909-63321-20066-86/pres_image.xml
 *              image-stream-doc-dist - e.g. https://www.familysearch.org/das/v2/TH-909-63321-20066-86/dist.json
 *              image-stream-meta-original - e.g. https://www.familysearch.org/das/v2/TH-909-63321-20066-86/original.xml
 */
export async function getPlatformImageInfo(imageURL, recordURL, processURL) {
  debug(`imageServices.getPlatformImageInfo(${imageURL}, ${recordURL}, ${processURL})`)

  if (!imageURL) {
    throw new Error('No imageURL provided')
  }

  const arkId = convertImageURLToArk(imageURL)
  if (!arkId?.length) {
    throw new Error(`Unable to get ark identifier for ${imageURL}`)
  }

  const imageURLObj = new URL(imageURL)
  imageURLObj.searchParams.delete('cc')
  if (recordURL) {
    const recordArk = getArkType(recordURL) + getArkId(recordURL)
    imageURLObj.searchParams.append('recordArkName', recordArk)
  }

  let wc = imageURLObj.searchParams.get('wc')
  if (wc) {
    const idx = wc.lastIndexOf('/')
    if (idx !== -1) {
      // Strip off paths, leaving us with just the id
      wc = wc.substring(idx + 1).replace(/\?cc=\d+/, '')
      imageURLObj.searchParams.delete('wc')
      imageURLObj.searchParams.append('wc', wc)
    }
  }
  const queryStr = imageURLObj.searchParams.toString()

  const url = new URL(`${window.location.origin}/platform/records/images/${arkId}`)
  if (queryStr.length) {
    url.search = queryStr
  }
  const urlString = url.toString()

  if (processURL) {
    return { url: urlString }
  }

  const response = await axios.get(urlString, {
    headers: {
      'cache-control': 'no-cache,no-store,must-revalidate,max-age=-1',
      from: 'search-react.imageServices.getPlatformImageInfo@familysearch.org',
    },
  })
  if (response.status === 200) {
    return { imageURL, recordURL, imageData: response?.data }
  }
  const e = new Error(`Unable to retrieve image data for ${imageURL}${getSafeRootMessage(response?.error)}`)
  e.code = response?.status
  throw e
}

/**
 * Return the root message or an empty string
 * @param {Object} error The root error object (should have {code: {Number}, message: {String}})
 * @returns {String} The root error message or an empty string
 */
function getSafeRootMessage(error) {
  return error?.message ? ` - ${error.message}` : ''
}
