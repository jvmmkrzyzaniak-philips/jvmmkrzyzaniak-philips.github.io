import Cookies from 'js-cookie'
import { extractCorrelationId, getCorrelationId, getSessionId } from '@fs/zion-session'
import zionDebug from '@fs/zion-debug'
import axios from 'axios'
import * as rax from 'retry-axios'
import * as Sentry from '@sentry/react'
import { appName, appPath, targetEnv, baseUrl } from '@fs/zion-config'
import { makeUseAxios } from 'axios-hooks'
import mobile from 'is-mobile'
import unproxiedDomains from './unproxiedDomains'

const debug = zionDebug('zion:axios')

const originalAxiosCreate = axios.create
const hasWindow = typeof window !== 'undefined'
const langCodePathRegex = /^\/(?<localeCode>[a-z]{2,3}(-[a-zA-Z0-9-]*)?)\// // Copied from DTM haproxy config MATCH_root_lang_path_with_slash acl

export async function requireUserInterceptor(res) {
  const status = res?.response?.status
  if (status === 401 || status === 453) {
    // first validate the session is actually bad, and this isn't just a bogus 401 from a broken backend
    try {
      const sessionId = getSessionId()
      // we cannot use the same axios to make this request or it will also get intercepted resulting in an infinite loop
      // so create new axios instance without 401 listener
      const localAxios = createInstanceWithHeaderInterceptors()
      debug(
        `request (${
          res?.response?.config?.url
        }) returned a 401 or 453, so revalidating the session (${extractCorrelationId(sessionId)})`
      )
      const sessionResponse = await localAxios.get(`/service/ident/session/sessions/${sessionId}`, {
        headers: {
          Accept: 'application/session-v1+json',
        },
      })
      debug('sessionResponse', sessionResponse)
      // session is still good, so backend response is bogus. Don't clear cookie, just reject the existing broken response
      // log Sentry error to get the service fixed
      Sentry.captureMessage(`Invalid 401 from service but session is still valid: url=${res?.response?.config?.url}`)
    } catch (sessionErr) {
      debug('sessionErr', sessionErr)
      // session endpoint will return a 404 or a 401 on invalid/expired sessions
      if ([404, 401].includes(sessionErr?.response?.status)) {
        // session is expired or invalid, so clear the fssessionid cookie before reloading to help prevent infinite loop/redirects
        debug(
          `requireUserInterceptor detected an expired/invalid session (${getCorrelationId()}) so clearing session cookie and reloading page`
        )
        const base = new URL(appPath)
        const host = base.host.includes('familysearch.org') ? '.familysearch.org' : ''
        Cookies.remove('fssessionid', { secure: base.protocol === 'https:', path: '/', domain: host })
        // reload the page to get a new fresh session
        hasWindow && window.location.reload()
      }
    }
  }

  // always reject since we're in the error callback
  return Promise.reject(res)
}

export async function unproxiedDomainsInterceptor(config) {
  const hostname = hasWindow ? window.location.host : ''
  if (unproxiedDomains.includes(hostname) && config.url.startsWith('/')) {
    config.url = `${baseUrl}${config.url}`
  }
  return config
}

export function isFSDomain(url) {
  if (!url) return false

  // relative URLs should match the app domain and therefore are valid
  if (url.startsWith('/') && !url.startsWith('//')) return true

  const hostname = new URL(url).hostname
  // localhost URLs we will assume are valid
  if (hostname === 'localhost') return true

  return (
    hostname.endsWith('.familysearch.org') ||
    hostname === 'familysearch.org' ||
    hostname.endsWith('.researchllm.org') || // Full Text translation service set up by Richard Chesworth and Christian Hargraves. Contact RIP team.
    hostname === 'researchllm.org'
  )
}

function abortMissingUrlInterceptor(config) {
  const controller = new AbortController()

  // Abort the request if the url is falsy
  if (!config.url) {
    controller.abort()
  }

  return {
    ...config,
    signal: controller.signal,
  }
}

export async function langHeaderInterceptor(config) {
  const { i18n } = await import('@fs/zion-locale')
  config.headers.set('Accept-Language', i18n.language, false) // do not override existing header
  return config
}

export function authHeaderInterceptor(config) {
  const sessionId = getSessionId()

  // only send the session id if it's a FamilySearch domain
  if (sessionId && isFSDomain(config.url)) {
    config.headers.setAuthorization(`Bearer ${sessionId}`)
  } else {
    // TODO do we allow zion-axios to be used for other types of auth?
    config.headers.delete('Authorization')
  }
  return config
}

export function userAgentChainInterceptor(config) {
  // only send the FS-User-Agent-Chain if it's an FS domain
  if (isFSDomain(config.url)) {
    config.headers.set(
      'FS-User-Agent-Chain',
      `${appName}-${targetEnv}${hasWindow ? ` (${window.location.pathname})` : ''}`,
      false
    )
  } else {
    config.headers.delete('FS-User-Agent-Chain')
  }

  return config
}

export function productHeaderInterceptor(config) {
  if (!isFSDomain(config.url)) return config

  try {
    const pathname = hasWindow ? window.location.pathname : ''
    const pathnameLangStripped = pathname.replace(langCodePathRegex, '/')
    // For now, this is only used for knowing persons added to the tree
    const isMutationMethod = ['POST', 'PUT', 'DELETE'].includes(config.method.toUpperCase())

    const configUrlLangStripped = config.url?.replace(langCodePathRegex, '/')
    const urlsTrackingProductHeader = ['/service/tree/tree-data', '/platform', '/service/tree/mytrees']
    const isTrackingProductHeader = urlsTrackingProductHeader.some((url) => configUrlLangStripped?.startsWith?.(url))

    const internal = 'int'
    const isMobile = mobile() // tablets are not included, if we want them, pass {tablet: true}
    const platform = isMobile ? 'mweb' : 'web'
    const app = pathnameLangStripped.split('/').filter(Boolean)[0]?.replace('-', '') || 'home' // top level path
    const page = pathnameLangStripped.split('/').filter(Boolean)[1]?.replace('-', '') // second level path
    const feature = page ? `${app}:${page}` : app
    const version = '000'
    const productHeader = `${internal}-${platform}-${feature}-${version}`

    if (isTrackingProductHeader && isMutationMethod) {
      config.headers.set('Product', productHeader, false)
      debug('Product header was set: ', productHeader)
    }
  } catch (err) {
    /* empty */
  }

  return config
}

export function createInstanceWithHeaderInterceptors(config) {
  const instance = originalAxiosCreate(config)
  instance.interceptors.request.use(authHeaderInterceptor, (err) => Promise.reject(err))
  instance.interceptors.request.use(langHeaderInterceptor, (err) => Promise.reject(err))
  instance.interceptors.request.use(userAgentChainInterceptor, (err) => Promise.reject(err))
  return instance
}

axios.create = createInstanceWithHeaderInterceptors

export const useZionAxios = makeUseAxios({
  axios,
})

// these interceptors put on the axios object itself don't apply to created instances, so up above I had
// to tweak axios.create with our own little wrapper function
//
// .use callback - Takes in two functions as params: First is called for a success
//                  and the second is called for a failure

axios.interceptors.response.use(
  (res) => res,
  (err) => {
    if (axios.isCancel(err)) return { data: null }
    return Promise.reject(err)
  }
)
axios.interceptors.response.use((res) => res, requireUserInterceptor)
axios.interceptors.request.use(unproxiedDomainsInterceptor, (err) => Promise.reject(err))
axios.interceptors.request.use(abortMissingUrlInterceptor, (err) => Promise.reject(err))
axios.interceptors.request.use(authHeaderInterceptor, (err) => Promise.reject(err))
axios.interceptors.request.use(langHeaderInterceptor, (err) => Promise.reject(err))
axios.interceptors.request.use(userAgentChainInterceptor, (err) => Promise.reject(err))
axios.interceptors.request.use(productHeaderInterceptor, (err) => Promise.reject(err))

/**
 * Adds an interceptor to an Axios instance that will retry on certain errors.
 * See `https://github.com/JustinBeckwith/retry-axios` for details.
 * This is useful for handling throttling errors, such as 429s.
 * Standard configuration retries up to 3 times on 5xx, 1xx, and 429 responses.
 * Can be used on global axios instance as:
 *   import axios, { retryOnErrors } from '@fs/zion-axios'
 *   retryOnErrors(axios, { retry: 5 })
 * Can be used on your own axios instance as:
 *   const axiosInstance = axios.create()
 *   retryOnErrors(axiosInstance, { instance: axiosInstance })
 * @param {Axios} axios The Axios instance to retry on.
 * @param {RetryConfig} config Any configuration desired from `retry-axios`.
 */
export function retryOnErrors(axiosInstance, config) {
  axiosInstance.defaults.raxConfig = config
  rax.attach(axiosInstance)
}

/*
 * For some reason, using waitFor in a test with FakeTimers causes the setTimeout call count
 * to be reset, so we can't use that to make sure the scheduler was called. Until that can
 * be understood and fixed, this variable can be used to check how many times the scheduler
 * was called and with which wait times.
 * This should only be used in tests!
 */
export const test_Waits = []
/**
 * Adds an interceptor to an Axios instance that will throttle requests.
 * This is likely most useful on a separate axios instance.
 * Usage:
 *   import axios, { throttleRequests } from '@fs/zion-axios'
 *   const axiosInstance = axios.create()
 *   throttleRequests(axiosInstance, 100)
 * @param {Axios} axiosInstance The Axios instance to retry on.
 * @param {number} intervalMs Minimum interval between requests, in milliseconds.
 */
export function throttleRequests(axiosInstance, intervalMs) {
  let lastInvocationTime

  function scheduler(config) {
    const now = Date.now()
    if (lastInvocationTime) {
      lastInvocationTime += intervalMs
      const waitMs = lastInvocationTime - now
      if (waitMs > 0) {
        if (process.env.NODE_ENV === 'test') test_Waits.push(intervalMs)
        return new Promise((resolve) => {
          setTimeout(resolve, waitMs, config)
        })
      }
    }
    lastInvocationTime = now
    return config
  }

  axiosInstance.interceptors.request.use(scheduler)
}

export default axios
