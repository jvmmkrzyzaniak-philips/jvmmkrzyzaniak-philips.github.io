import CacheService from '@fs/zion-cache-service'
import Cache from '@fs/zion-cache'
import { i18n } from '@fs/zion-locale'
import { showTemple } from '@fs/zion-permissions'
import './locales'
import { publish, subscribe, getTopicKeys } from './PubSubService'
import realNormalizePersonObj from './separateImports'

// NOTE: we are adding translations here so that the translations wil be ready when we create unknownPerson

const service = {} // HACK: this service is created so we can have a default export so that we can have a mutable object so that we can do spies in our tests.
const personSizes = {
  full: 2,
  card: 1,
  summary: 0,
}
export const unknownPerson = {
  gender: 'UNKNOWN',
  // We removed this because there does not seem to be a need to translate the id. In all known cases, the UI displays what is returned from the back end, which is currently 'UNKNOWN', regardless of language.
  // This was only being used for comparisions in Person, which resulted in inconsistent behavior across locales.
  // id: i18n.t('person-service.unknown-pid', 'UNKNOWN'),
  // Also removed instance below.
  id: 'UNKNOWN',
  lifespan: '',
  name: i18n.t('person-service.unknown-name', '[Unknown Name]'),
  deleted: false,
  visibleToAll: true,
  visibleToAllWhenUsingFamilySearchApps: true,
  living: true,
  readOnly: false,
  skeleton: false,
  unknown: true,
  size: 'UNKNOWN',
  version: 'UNKNOWN',
}

i18n.on('languageChanged', () => {
  // See above comment in unknownPerson object ^
  // unknownPerson.id = i18n.t('person-service.unknown-pid', 'UNKNOWN')
  unknownPerson.name = i18n.t('person-service.unknown-name', '[Unknown Name]')
})

const cache = new Cache({ storeName: 'persons', encrypted: true })
const queueConfig = {
  dedupe: (oldItem, newItem) => {
    const oldSize = personSizes[oldItem.key.split(':')[1]]
    const newSize = personSizes[newItem.key.split(':')[1]]
    return oldSize > newSize ? oldItem : newItem
  },
}

// this is only exported for testing purposes
const personCacheService = new CacheService({ cache, strategy: 'cache-and-network', queueConfig })
const preferCachePersonCacheService = new CacheService({ cache, strategy: 'cache-first', queueConfig })

/**
 * @description - return an array of all the sizes smaller than the specified size
 * @param {string} size - full, card, summary
 * @returns {Array} - the smaller sizes
 */
function smallerSizes(size) {
  const personSizesString = 'full card summary'
  return (personSizesString.split(size)[1] || '') // get the string of all the sizes past the size passed in
    .trim() // trim off trailing spaces
    .split(' ') // turn the sizes into an array
    .filter((value) => value) // filter out any empty strings that ended up there still
}

// REMOVE THIS AFTER TREE-DATA REMOVES SCRIPT FROM NAMEFORMS
export const removeScriptFromNameforms = (nameConclusion) => {
  if (!nameConclusion?.details?.nameForms) return nameConclusion

  const nameForms = nameConclusion.details.nameForms

  nameConclusion.details.nameForms = nameForms.map((nameForm) => {
    delete nameForm.script
    return nameForm
  })

  return nameConclusion
}
// END REMOVE THIS AFTER TREE-DATA REMOVES SCRIPT FROM NAMEFORMS

/**
 * @description - Getter for a person object from cache.
 * @param {string} pid - The pid of the person to fetch.
 * @param {string} size - Size of the person (summary|card|full).
 * @param {boolean} preferCache - if the person is cached, do not make the call to get the person, just use the cached value
 * @param {boolean} ignoreCache - make the call to get the person, even if they are cached.
 * @returns {Array} An array of promises returned from the cache service with the person data [serverPromise, cachePromise]
 */
export async function getPersonObj(pid, size, preferCache, ignoreCache) {
  size = size || 'summary'
  const key = `${pid}:${size}`

  let sizePath = 'summary'

  if (size === 'full') {
    sizePath = 'details'
  } else if (size === 'card') {
    sizePath = 'card'
  }

  let url = `/service/tree/tree-data/v8/person/${pid}/${sizePath}`
  const canViewTempleInfo = await showTemple()
  if (canViewTempleInfo) url += '?includeTempleRollupStatus=true'
  if (preferCache) {
    const personPromise = service.preferCachePersonCacheService.get(url, key, { queueId: pid })
    return [personPromise, personPromise]
  }
  return service.personCacheService.get(url, key, { queueId: pid, ignoreCache })
}

/**
 * @description - fetch the person and call our subscribed callbacks.
 * @param {string} pid - The pid of the person to fetch.
 * @param {string} size - Size of the person (SUMMARY|CARD|FULL).
 * @param {boolean} preferCache - if the person is cached, do not make the call to get the person, just use the cached value
 * @param {boolean} ignoreCache - make the call to get the person, even if they are cached.
 * @returns {Array} - serverPromise then cachePromise
 */
async function fetchPerson(pid, size, preferCache, ignoreCache) {
  // [TW-774] Sometimes the pid can be bad. Though consumers of
  // zion-person-service should ensure that they are giving good
  // PIDs to the service, this gate stops bad network calls.
  if (!pid || !size || pid === 'undefined') {
    throw new Error('Missing pid or size')
  }

  const thisKey = `${pid}:${size}`
  const allKeys = service.smallerSizes(size).map((smallerSize) => `${pid}:${smallerSize}`)
  allKeys.push(thisKey)

  // defined inside another function because it depends on knowing allKeys, but we can't specify what gets passed in to handleError
  const handleError = (error) => {
    const personToPublish = { ...service.unknownPerson }
    if ([500, 403, 429].includes(error?.response?.status)) {
      personToPublish.unavailablePerson = true
    }
    service.publisher(allKeys, { ...personToPublish, id: pid })
    // swallow the error here since we show the unknown person and we don't expose fetchPerson in docs
  }

  // defined inside another function because it depends on knowing allKeys, but we can't specify what gets passed in to handleSuccess
  const handleSuccess = (personObj) => {
    if (!personObj) return

    // REMOVE THIS AFTER TREE-DATA REMOVES SCRIPT FROM NAMEFORMS
    personObj.nameConclusion = removeScriptFromNameforms(personObj.nameConclusion)
    // END REMOVE THIS AFTER TREE-DATA REMOVES SCRIPT FROM NAMEFORMS

    service.publisher(allKeys, personObj)
  }

  const [serverPromise, cachePromise] = await service.getPersonObj(pid, size, preferCache, ignoreCache)
  // we don't actually use these return values except for in tests
  return [serverPromise.then(handleSuccess, handleError), cachePromise.then(handleSuccess, handleError)]
}

/**
 * @description - call all the subscribed callbacks for the keys provided with the personObj provided
 * @param {Array} keys - the keys that need their person object updated - keys will be in the form of pid:size
 * @param {object} personObj - the person object to update subscribers with
 */
function publisher(keys, personObj) {
  if (!keys || !personObj) return
  keys.forEach((key) => {
    publish(key, personObj)
  })
}

/**
 * @description - format the person object so that it looks like a tree-data person
 * @param {object} personObj - any accepted format of person object - right now this is only tree-data persons, but we intend to add more
 * @returns {object} the normalized person object or an unknown person if there isn't enough info. A person will have an id, name, lifespan (if none is provided it will be an empty string) and uppercase gender (if none is provided, it will default to unknown).
 */
export function normalizePersonObj(personObj) {
  // REMOVE THIS AFTER TREE-DATA REMOVES SCRIPT FROM NAMEFORMS
  if (personObj?.nameConclusion) {
    personObj.nameConclusion = removeScriptFromNameforms(personObj.nameConclusion)
  }
  // END REMOVE THIS AFTER TREE-DATA REMOVES SCRIPT FROM NAMEFORMS

  return realNormalizePersonObj(personObj, service.unknownPerson)
}

/**
 * @description - Fetch the person object from the server again
 * @param {string} pid - The pid of the person to fetch.
 * @param {string} size - Size of the person (summary|card|full). Defaults to summary.
 * @param {boolean} preferCache - if the person is cached, do not make the call to get the person, just use the cached value
 * @param {boolean} ignoreCache - make the call to get the person, even if they are cached.
 */
export function updatePersonObject(pid, size = 'summary', preferCache, ignoreCache) {
  if (!pid) return
  // if the person has been requested before, get the biggest size
  size = service.getBiggestSizeRequested(pid, size, getTopicKeys())

  service.fetchPerson(pid, size, preferCache, ignoreCache)
}

/**
 * @description - returns the biggest size that has been queued, subscribed to, or passed in to the function
 * @param {string} pid - The pid of the person to fetch.
 * @param {string} size - Size of the person (summary|card|full). Defaults to summary.
 * @param {Array} existingSubscriptions - a list of all existing topics that have been subscribed to in our pub/sub service
 * @returns {string} - the new size - biggest of all queued and subscribed sizes
 */
function getBiggestSizeRequested(pid, size, existingSubscriptions) {
  if (!size) {
    size = 'summary'
  }

  const possibleKeys = [`${pid}:full`, `${pid}:card`, `${pid}:summary`]
  let biggestExistingKey = ''
  possibleKeys.some((key) => {
    if (existingSubscriptions.includes(key)) {
      biggestExistingKey = key
      return true
    }
    return false
  })
  const biggestExistingSize = biggestExistingKey ? biggestExistingKey.split(':')[1] : size
  // we need to make sure that if the size passed in is bigger than the biggest key subscribed to that we use it instead - we are very likely to enter into this case because we call updatePersonObject before we call subscribe (so that we can return the subscription)
  size = biggest(size, biggestExistingSize)

  return size
}

function biggest(first, second) {
  return personSizes[first] > personSizes[second] ? first : second
}

/**
 * @description - subscribe the provided callback for the provided pid and size
 * @param {string} pid - person id
 * @param {string} size - size of the person
 * @param {Function} callback - the callback that we want called whenever the person obj changes
 * @param {boolean} preferCache - if the person is cached, do not make the call to get the person, just use the cached value
 * @param {boolean} ignoreCache - make the call to get the person, even if they are cached.
 * @returns {object} - a subscription object containing the remove function for the subscription
 */
export function subscribeToPersonObj(pid, size, callback, preferCache, ignoreCache) {
  // fire off the thing that gets the person obj with dequeuing and debouncing
  service.updatePersonObject(pid, size, preferCache, ignoreCache)
  return subscribe(`${pid}:${size}`, callback)
}

// BEGIN: default export for testing purposes - jest can't spy on module functions, only object functions, so we are exporting a default object that has all the things we need for testing
service.fetchPerson = fetchPerson
service.unknownPerson = unknownPerson
service.personCacheService = personCacheService
service.preferCachePersonCacheService = preferCachePersonCacheService
service.smallerSizes = smallerSizes
service.getPersonObj = getPersonObj
service.publisher = publisher
service.normalizePersonObj = normalizePersonObj
service.updatePersonObject = updatePersonObject
service.getBiggestSizeRequested = getBiggestSizeRequested
service.subscribeToPersonObj = subscribeToPersonObj
export default service
// END: default export for testing purposes
