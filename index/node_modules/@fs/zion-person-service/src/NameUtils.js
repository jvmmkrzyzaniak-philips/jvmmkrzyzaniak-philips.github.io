import { i18n } from '@fs/zion-locale'
import { languageToScriptMap } from '@fs/zion-name-template/utils'
import { unknownPerson } from './PersonService'
/**
 * Retrieves the fullName, namePart1 and namePart2, and determines whether we will display on a single line or not. Also returns the language of the name if different from the user's language, so that screen readers will pronounce things better.
 * @param {object} personObj - The person to parse nameforms out of.
 * @param {boolean} showNameInRomanScriptPreference - [false] - Whether we are showing roman names.
 * @returns {object} - An object containing fullName, namePart1, namePart2, nameLangIfDifferentFromCurrentLang, cjkNoBold and forceSingleLineDisplay
 */
export function getNameRelatedData(personObj, showNameInRomanScriptPreference = false) {
  personObj = personObj || {}
  let { name, nameConclusion } = personObj
  name = (name || '').trim()
  nameConclusion = nameConclusion || {}

  const details = nameConclusion.details || {}
  const nameForms = details.nameForms || []
  // The name system of the name: [eurotypic](http://bdespain.org/S&L/angs/glos/ngs-euro.htm) or [sinotypic](http://bdespain.org/S&L/angs/glos/ngs-sino.htm). Used to determine what goes in namePart1 and namePart2 that is used in displaying person in multiLineDisplay mode
  const style = details.style || ''
  // if users have turned on the showNameInRomanScript preference, we will use the first roman script, if there is one, instead of the primary name form
  const firstNameForm = nameForms[0] || {}
  const primaryNameForm = showNameInRomanScriptPreference
    ? getFirstRomanNameForm(nameForms, firstNameForm)
    : firstNameForm
  // Trim values of all properties in the primaryNameForm object and giving them a default value of empty string
  const propertiesNeeded = ['familyPart', 'fullText', 'givenPart', 'lang', 'prefixPart']
  propertiesNeeded.forEach((property) => {
    primaryNameForm[property] = (primaryNameForm[property] || '').trim()
  })

  // Set to undefined if the lang is provided as an empty string to prevent it showing up as an empty attribute in the dom
  // Because English names are stored as 'x-Latn' in the database, we need to re-map 'x-Latn' to 'en' to avoid adding non-existent Lang tags. https://icseng.atlassian.net/browse/TREEWEB-7838
  const nameLang = primaryNameForm.lang === 'x-Latn' ? 'en' : primaryNameForm.lang || undefined

  // Will be used as the `lang` attribute on the name element. This allows screen readers to [properly pronounce the name](https://www.paciellogroup.com/blog/2016/06/using-the-html-lang-attribute/) when it's in a different language than the rest of the page.
  const nameLangIfDifferentFromCurrentLang = nameLang === i18n.language ? undefined : nameLang

  // Some languages always have their names displayed on a single line even in portrait mode
  // https://icseng.atlassian.net/wiki/spaces/Product/pages/133595799/TreeWeb+Design+Name+Form+Language+Support
  const forceSingleLineDisplay =
    nameLang && !nameLang.includes('Latn') && ['ja', 'ko', 'zh'].includes(nameLang.split('-')[0])
  // cjkNoBold may not always be the same calculations in the future, but for now they are.
  const cjkNoBold = forceSingleLineDisplay

  const namePieces = calculateNamePieces(primaryNameForm, style, name)
  const { fullName, namePart1, namePart2, prefixPart, suffixPart } = namePieces
  const shortName = getShortName(primaryNameForm, fullName)

  return {
    cjkNoBold,
    forceSingleLineDisplay,
    fullName,
    nameLangIfDifferentFromCurrentLang,
    namePart1,
    namePart2,
    prefixPart,
    shortName,
    suffixPart,
  }
}

export function getNameInPreferredScript(person, showRomanScriptPreference) {
  const { fullName } = getNameRelatedData(person, showRomanScriptPreference)
  const cjkNameForm = getFirstCJKNameForm(person?.nameConclusion?.details?.nameForms)

  return {
    fullName,
    cjkNameForm,
  }
}

// Languages that require the full name as the short (personalized) name
const shortNameIsFullName = ['ja', 'km', 'ko', 'mg', 'ro', 'th', 'zh']

/**
 * Get the short (personalized) name.
 * @param {object} nameForm - the name form that you want to get the information from.
 * @param {string} fullName - full name from the primary name form.
 * @returns {string} - the short name
 */
export function getShortName(nameForm, fullName) {
  const langCode = nameForm.lang.split('-')[0]
  const useFullName = shortNameIsFullName.includes(langCode)
  return useFullName ? nameForm.fullText || fullName : nameForm.givenPart || fullName
}

/**
 * Get the fullName, namePart1 and namePart2 for a name, based on name style.
 * @param {object} nameForm - the name form that you want to get the information from
 * @param {string} style - the style of the name - either eurotypic or sinotypic
 * @param {string} name - the text of the name of the person to use if there is nothing in the name form
 * @returns {object} - fullName, namePart1, namePart2
 */
function calculateNamePieces(nameForm, style, name) {
  let fullName = ''
  let namePart1 = ''
  let namePart2 = ''
  let prefixPart = ''
  let suffixPart = ''

  fullName = nameForm.fullText || name

  const emptyGivenPart = !nameForm.givenPart
  const emptyFamilyPart = !nameForm.familyPart
  if (style.toLowerCase() === 'sinotypic') {
    // when there is no given name, we display the prefix as namePart1 and the family name as namePart2
    const emptyPrefixPart = !nameForm.prefixPart
    namePart1 = emptyGivenPart ? nameForm.prefixPart : nameForm.familyPart
    namePart2 = emptyGivenPart ? nameForm.familyPart : nameForm.givenPart
    prefixPart = emptyGivenPart ? '' : nameForm.prefixPart
    suffixPart = nameForm.suffixPart

    if (emptyGivenPart && emptyPrefixPart && nameForm.familyPart && nameForm.suffixPart) {
      namePart1 = nameForm.familyPart
      namePart2 = nameForm.suffixPart
      suffixPart = ''
    }
  } else {
    // when there is no given name, display the prefix as namePart1 instead of the given name
    namePart1 = nameForm.givenPart || nameForm.prefixPart
    namePart2 = nameForm.familyPart || nameForm.suffixPart || ''
    prefixPart = emptyGivenPart ? '' : nameForm.prefixPart
    suffixPart = emptyFamilyPart ? '' : nameForm.suffixPart
  }

  // if we don't have the name parts, we need to use the name as namePart1 and fullName
  if (!nameForm.prefixPart && !nameForm.suffixPart && !nameForm.givenPart && !nameForm.familyPart) {
    namePart1 = fullName
  }

  if (!fullName || fullName === unknownPerson.name) {
    namePart1 = unknownPerson.name
    fullName = unknownPerson.name
  }

  return {
    prefixPart,
    suffixPart,
    fullName,
    namePart1,
    namePart2,
  }
}

/**
 * Retrieve the first nameform with a lang that maps to ROMAN script.
 * @param {object} nameForms - All of the nameforms that we have on the person.
 * @param {object} fallback - the return value if there is no roman name form
 * @returns {object} - The first roman nameform, or the default, or undefined, if none exist.
 */
export function getFirstRomanNameForm(nameForms, fallback) {
  nameForms = nameForms && nameForms.filter ? nameForms : []
  const romanForms = nameForms.filter((nameForm) => languageToScriptMap[nameForm.lang] === 'ROMAN')
  // we will always return the first value in the array - if the array is empty, it will return undefined
  return romanForms[0] || fallback
}

/**
 * Return name only if it's one of the nameform lang ja or zh. (Korean was removed since korean should not be displayed vertically)
 * @param {object} nameForms - All of the nameforms that we have on the person.
 * @returns {object} - The first cjk nameform object or undefined, if none exist.
 */
export function getFirstCJKNameForm(nameForms) {
  return nameForms?.find((nameForm) => nameForm?.lang?.startsWith('zh') || nameForm?.lang?.startsWith('ja'))
}
