import type {
  Conclusion,
  ConclusionType,
  FullAssociationConclusionType,
  LegacyConclusionType,
  LineageType,
  NameConclusionDetails,
  NonVitalEventType,
  NonVitalFactType,
  RelationshipEventType,
  RelationshipFactType,
  VitalEventType,
  VitalFactType,
  AssociationEventConclusionDetails,
  EventDate,
  EventPlace,
  Gender,
  NameForm,
  VitalEventConclusion,
  NonVitalEventConclusion,
  CustomFactConclusion,
  CustomEventConclusion,
  LifeSketchConclusion,
  CharacteristicFactConclusion,
  AlternateNameConclusion,
  NameConclusion,
  GenderConclusion,
  LineageConclusion,
  AssociationEventConclusion,
  RelationshipFactConclusion,
  RelationshipEventConclusion,
  Person,
  RelationshipLineageType,
  PersonId,
  BasePerson,
  SummaryPerson,
  FamilyMemberPerson,
} from '@fs/zion-tree-types'
import type { TFunction } from 'i18next'
import {
  isValidAndDirtyNameForms,
  convertFormToTreeData as nameFormsToTreeData,
  convertTreeDataToForm as nameFormsFromTreeData,
} from '@fs/zion-name-template'
import { formatTreeDataToStandardSuggest, formatStandardSuggestToTreeData } from '@fs/zion-tree-converter'
import { getNameRelatedData } from '@fs/zion-person-service'
import { i18n } from '@fs/zion-locale'
import {
  conclusionLabelKeyMap,
  deleteTranslationKeyMap,
  lineageLabelKeyMap,
  nameTypeKeyMap,
} from './translationKeyMaps'
import type { FieldType, FormValues, FormValuesBasic } from '../types/form'
import type { ConclusionCategory, FullAlternateNameType, PropertyType } from '../types/conclusion'
import {
  ALTERNATE_NAME_TYPES,
  CHINESE_ALTERNATE_NAME_TYPES,
  CONCLUSION_PROPERTIES_MAP,
  LINEAGE_TYPES,
  changelogTypeMap,
  relationshipConclusionCategories,
} from './maps'

/**
 * Determine if the given conclusion type is one of the accepted valid conclusion types.
 * @param {string} conclusionType - The conclusion type to check.
 * @returns {boolean} - Whether the conclusion type is valid.
 */
export function isValidConclusionType(
  conclusionType?: ConclusionType | 'SLAVERY' | LegacyConclusionType
): conclusionType is ConclusionType | 'SLAVERY' | LegacyConclusionType {
  return Boolean(conclusionType ? CONCLUSION_PROPERTIES_MAP[conclusionType] : false)
}

export function getConclusionDisplayLabel(t: TFunction, conclusionType?: ConclusionType): string {
  if (!conclusionType || !isValidConclusionType(conclusionType))
    throw new Error(`Invalid conclusionType: ${conclusionType}`)
  if (CONCLUSION_PROPERTIES_MAP[conclusionType].category === 'parentChildRelationshipEvent') {
    return t('conclusion.relationship-to-child.label')
  }
  return t(conclusionLabelKeyMap[conclusionType])
}

export const getRelationshipType = (type: ConclusionType): 'parent-child' | 'couple' | 'association' | null => {
  if (CONCLUSION_PROPERTIES_MAP[type].category === 'parentChildRelationshipEvent') return 'parent-child'
  if (
    CONCLUSION_PROPERTIES_MAP[type].category === 'coupleEvent' ||
    CONCLUSION_PROPERTIES_MAP[type].category === 'coupleFact'
  ) {
    return 'couple'
  }
  if (CONCLUSION_PROPERTIES_MAP[type].category === 'associationEvent') return 'association'
  return null
}

export function getConclusionDeleteLabel(t: TFunction, type?: ConclusionType): string {
  if (!type || !isDeletable(type)) return ''
  const relationshipType = getRelationshipType(type)
  const deleteTranslationKey = relationshipType === 'association' ? relationshipType : type
  return t(deleteTranslationKeyMap[deleteTranslationKey], { conclusionType: getConclusionDisplayLabel(t, type) })
}

function isDeletable(conclusionType: ConclusionType): boolean {
  if (!isValidConclusionType(conclusionType)) throw new Error(`Invalid conclusionType: ${conclusionType}`)
  return CONCLUSION_PROPERTIES_MAP[conclusionType].deletable
}

function isConclusionDataValid(
  formValues: FormValues,
  originalConclusion: Conclusion
): { isValid: boolean; errors: Record<string, unknown> } {
  let isValid = false
  let errors = {}
  const conclusionType = originalConclusion.type
  const type = formValues.coupleEventType || formValues.coupleFactType || conclusionType
  const requiredFields: FieldType[] = CONCLUSION_PROPERTIES_MAP[type].requiredFields
  if (!requiredFields.length) {
    isValid = true
  } else {
    // return as soon as we find one valid fields since all of our validation is at-least-one of the fields is required
    requiredFields.some((conclusionFieldKey) => {
      const isDateOrPlaceFieldKey = conclusionFieldKey === 'date' || conclusionFieldKey === 'place'
      if (isDateOrPlaceFieldKey && isDateOrPlaceValid(formValues, conclusionFieldKey)) {
        isValid = true
      } else if (conclusionFieldKey === 'nameTemplate') {
        const nameFormInfo = isValidAndDirtyNameForms(
          formValues,
          (originalConclusion?.details as NameConclusionDetails)?.nameForms
        )
        isValid = nameFormInfo.isValid
        errors = { ...errors, ...nameFormInfo.errors }
      } else if (!isDateOrPlaceFieldKey && formValues[conclusionFieldKey]?.trim()) {
        isValid = true
      }
      if (!isValid) {
        const errorKey = `missing_valid_${conclusionFieldKey}`
        errors[errorKey] = { message: '' }
      }
      return isValid
    })
  }
  return { isValid, errors: isValid ? {} : errors }
}

/**
 * Is the conclusion a valid conclusion? This also verifies in the case of names that the name form is dirty. Also returns the errors.
 * @param {object} formValues - values that come out of the form - it is assumed they are using the names from CONCLUSION_FIELDS as the names for the form fields
 * @param {object} originalConclusion - the original conclusion to compare against. If this is a new conclusion, it'll be a conclusion with only the type property and nothing else.
 * @returns {object} - the errors, and isValid
 */
export function isConclusionDataValidAndDirty(
  formValues: FormValues,
  originalConclusion: Conclusion
): { isValid: boolean; isDirty: boolean; errors: Record<string, unknown> } {
  const { isValid, errors } = isConclusionDataValid(formValues, originalConclusion)
  const isDirty = isConclusionDataDirty(formValues, originalConclusion)
  if (!isDirty) {
    errors.notDirty = { message: '' }
  }
  return { isValid, isDirty, errors }
}

export function isDateOrPlaceValid(formValues: Partial<Record<FieldType, unknown>>, type: 'date' | 'place'): boolean {
  const formDateOrPlace = formValues[type] as { standard: string | null; originalText: string | null }
  return Boolean(formDateOrPlace?.standard || formDateOrPlace?.originalText)
}

function isConclusionDataDirty(formValues: FormValues, originalConclusion: Conclusion): boolean {
  let isDirty = false
  const conclusionType = originalConclusion.type
  if (!originalConclusion.id && conclusionType !== 'DEATH') {
    isDirty = true
  } else {
    const originalValues = convertTreeDataToFormData(originalConclusion)
    const fields = getFieldsForConclusion(conclusionType)
    fields.some((fieldName) => {
      if (
        // we are on the nameForm field and nameForm isDirty
        (fieldName === 'nameTemplate' &&
          isValidAndDirtyNameForms(formValues, (originalConclusion?.details as NameConclusionDetails)?.nameForms)
            .isDirty) ||
        // we are on the date field and date isDirty
        (fieldName === 'date' && isDateOrPlaceDirty(formValues, originalConclusion, 'date')) ||
        // we are on the place field and place isDirty
        (fieldName === 'place' && isDateOrPlaceDirty(formValues, originalConclusion, 'place')) ||
        // we are on another field and other field isDirty (loosely - we let all falsy things be equal like null/undefined/'')
        (!['nameTemplate', 'date', 'place'].includes(fieldName) &&
          (originalValues[fieldName] || '') !== (formValues[fieldName] || ''))
      ) {
        isDirty = true
      }
      return isDirty
    })
  }
  return isDirty
}

/**
 * Get the fields that this conclusion may contain (e.g. birth would have place, date, and reason).
 * @param {string} conclusionType - The type of the conclusion to check.
 * @returns {Array} - An array of fields that the conclusion may contain.
 */
export function getFieldsForConclusion(conclusionType?: ConclusionType): FieldType[] {
  if (!isValidConclusionType(conclusionType)) throw new Error(`Invalid conclusionType: ${conclusionType}`)
  return conclusionType ? CONCLUSION_PROPERTIES_MAP[conclusionType].fields : []
}

export function getFocusRefFieldForConclusion(conclusionType?: ConclusionType): PropertyType['focusRefField'] {
  if (!isValidConclusionType(conclusionType)) throw new Error(`Invalid conclusionType: ${conclusionType}`)
  return CONCLUSION_PROPERTIES_MAP[conclusionType].focusRefField
}

export function isDateOrPlaceDirty(
  formValues: FormValues,
  originalConclusion: Conclusion,
  type: 'date' | 'place'
): boolean {
  let isDirty = false
  const formDateOrPlace = formValues[type]
  const originalDateOrPlace = originalConclusion?.details?.[type]
  const standardComparator = type === 'date' ? 'formalText' : 'id'
  const convertedOriginal = formatTreeDataToStandardSuggest(originalDateOrPlace)
  if (
    convertedOriginal?.originalText !== formDateOrPlace?.originalText ||
    convertedOriginal?.standard?.[standardComparator] !== formDateOrPlace?.standard?.[standardComparator]
  ) {
    isDirty = true
  }
  return isDirty
}

export const addFormDefaultValues: FormValuesBasic = {
  nameType: 'AKA',
  coupleFactType: 'COUPLE_NEVER_HAD_CHILDREN',
  sex: null,
  date: { standard: null, originalText: null },
  place: { standard: null, originalText: null },
  title: '',
  type: 'BIOLOGICAL',
  living: 'LIVING',
  coupleEventType: 'MARRIAGE',
  description: '',
  justification: '',
  certified: false,
  text: '',
  generationNumber: '2',
}

type ConclusionListByCategory<T extends ConclusionCategory> = (T extends 'otherEvent'
  ? NonVitalEventType
  : T extends 'otherFact'
    ? NonVitalFactType
    : T extends 'coupleEvent'
      ? RelationshipEventType
      : T extends 'coupleFact'
        ? RelationshipFactType
        : T extends 'vitalEvent'
          ? VitalEventType
          : T extends 'vitalFact'
            ? VitalFactType
            : T extends 'parentChildRelationshipEvent'
              ? LineageType
              : T extends 'lifesketch'
                ? 'LIFE_SKETCH'
                : T extends 'historicalFact'
                  ? 'HISTORICAL_FACT'
                  : FullAssociationConclusionType)[]

// Opposite of ConclusionListByCategory
type CategoryByConclusionType<T extends ConclusionType | 'SLAVERY' | LegacyConclusionType> = T extends NonVitalEventType
  ? 'otherFact'
  : T extends NonVitalFactType
    ? 'otherFact'
    : T extends RelationshipEventType
      ? 'coupleEvent'
      : T extends RelationshipFactType
        ? 'coupleFact'
        : T extends VitalEventType
          ? 'vitalEvent'
          : T extends VitalFactType
            ? 'vitalFact'
            : T extends LineageType
              ? 'parentChildRelationshipEvent'
              : T extends 'LIFE_SKETCH'
                ? 'lifesketch'
                : T extends 'HISTORICAL_FACT'
                  ? 'historicalFact'
                  : 'associationEvent'

/**
 * Get a list of conclusions that are of the requested category.
 * @param {string} conclusionCategory - The category of the conclusions to retrieve.
 * @returns {Array} - A list of all conclusions that match the given category.
 */
function getConclusionListByCategory<T extends ConclusionCategory>(conclusionCategory: T): ConclusionListByCategory<T> {
  return Object.keys(CONCLUSION_PROPERTIES_MAP).filter(
    (type) => getConclusionCategory(type) === conclusionCategory
  ) as ConclusionListByCategory<T>
}

/**
 * Get the conclusion category based on the conclusion type.
 * @param {string} conclusionType - The type of the conclusion to check.
 * @returns {string} - The corresponding category for the conclusion type.
 */
export function getConclusionCategory<T extends ConclusionType | 'SLAVERY' | LegacyConclusionType>(
  conclusionType?: T
): CategoryByConclusionType<T> {
  if (!conclusionType || !isValidConclusionType(conclusionType)) {
    throw new Error(`Invalid conclusionType: ${conclusionType}`)
  }
  return CONCLUSION_PROPERTIES_MAP[conclusionType].category as CategoryByConclusionType<T>
}

export const OTHER_EVENT_TYPES = getConclusionListByCategory('otherEvent')

export const OTHER_FACT_TYPES = getConclusionListByCategory('otherFact')

export function getCoupleEventTypeOptions(t: TFunction): { value: RelationshipEventType; label: string }[] {
  return getConclusionListByCategory('coupleEvent').map((type) => ({
    value: type,
    label: getConclusionDisplayLabel(t, type),
  }))
}

export function getCoupleFactTypeOptions(t: TFunction): { value: RelationshipFactType; label: string }[] {
  return getConclusionListByCategory('coupleFact').map((type) => ({
    value: type,
    label: getConclusionDisplayLabel(t, type),
  }))
}

export function isDeathLikeConclusionType(conclusionType: ConclusionType): boolean {
  return ['BURIAL', 'CREMATION', 'STILLBORN'].includes(conclusionType)
}

/**
 * Convert the form data to the expected tree-data format for proper saving of conclusions.
 * @param {object} formValues - The assorted values collected from the form.
 * @param {object} originalConclusion - The original conclusion details, so that we can use the ID to modify the correct conclusion for editing, or use the type for adding.
 * @returns {object} - A tree-data-formatted object containing the only the fields required for that conclusion type.
 * Search terms: data munger/manipulator/transmorgrifier
 */
export function convertFormDataToTreeData(
  formValues: FormValues,
  originalConclusion: { type: Conclusion['type'] | 'SLAVERY'; id?: string }
): Conclusion {
  const type = formValues.coupleEventType || formValues.coupleFactType || originalConclusion?.type
  const text = formValues.text ?? ''
  const formDate = formValues.date
  const formPlace = formValues.place
  const date = formDate ? formatStandardSuggestToTreeData(formDate) : undefined
  const place = formPlace ? formatStandardSuggestToTreeData(formPlace) : undefined
  const nameForms = ['NAME', 'ALTERNATE_NAME'].includes(type) ? nameFormsToTreeData(formValues) : undefined
  const title = formValues.title ?? ''
  const description = formValues.description ?? ''
  const justification = formValues.justification ?? ''
  const nameType = formValues.nameType
  const gender = formValues.sex ?? 'UNKNOWN'
  const userCertified = formValues.certified
  const id = originalConclusion?.id || undefined
  const generationNumber = formValues.generationNumber ? Number(formValues.generationNumber) : undefined

  if (type === 'BIRTH' || type === 'DEATH' || type === 'CHRISTENING' || type === 'BURIAL') {
    const conclusion: VitalEventConclusion = {
      details: {
        type,
        detailsType: 'EventDetails',
        sourceCount: 0,
        date,
        place,
        title,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }

    return conclusion
  }

  if (type === 'OTHER_FACT') {
    const conclusion: CustomFactConclusion = {
      details: {
        type,
        detailsType: 'EventDetails',
        sourceCount: 0,
        date,
        place,
        title,
        description,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }

  if (type === 'OTHER_EVENT') {
    const conclusion: CustomEventConclusion = {
      details: {
        type,
        detailsType: 'EventDetails',
        sourceCount: 0,
        date,
        place,
        title,
        description,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }
  if (type === 'LIFE_SKETCH') {
    const conclusion: LifeSketchConclusion = {
      details: {
        detailsType: 'LifeSketchDetails',
        text,
        userCertified,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }
  if (
    type === 'PHYSICAL_DESCRIPTION' ||
    type === 'TRIBE_NAME' ||
    type === 'RACE' ||
    type === 'NO_COUPLE_RELATIONSHIPS' ||
    type === 'NATIONAL_ORIGIN' ||
    type === 'NATIONAL_ID' ||
    type === 'CLAN_NAME' ||
    type === 'CASTE_NAME' ||
    type === 'NO_CHILDREN'
  ) {
    const conclusion: CharacteristicFactConclusion = {
      details: {
        detailsType: 'CharacteristicDetails',
        sourceCount: 0,
        type,
        date,
        description,
        place,
        title,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }
  if (type === 'ALTERNATE_NAME') {
    const conclusion: AlternateNameConclusion = {
      details: {
        detailsType: 'NameDetails',
        sourceCount: 0,
        nameForms,
        nameType,
        preferredName: false,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }

  if (type === 'NAME') {
    const conclusion: NameConclusion = {
      details: {
        detailsType: 'NameDetails',
        sourceCount: 0,
        nameForms,
        nameType,
        preferredName: true,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }

  if (type === 'GENDER') {
    const conclusion: GenderConclusion = {
      details: {
        detailsType: 'GenderDetails',
        sourceCount: 0,
        gender,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }

  if (type === 'PARENT1_LINEAGE' || type === 'PARENT2_LINEAGE') {
    const conclusion: LineageConclusion = {
      details: {
        detailsType: 'EventDetails',
        sourceCount: 0,
        title: formValues.type ?? 'BIOLOGICAL',
        type,
        date,
        place,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }
  if (
    type === 'GENERATION' ||
    type === 'APPRENTICESHIP' ||
    type === 'EMPLOYMENT' ||
    type === 'GODPARENTHOOD' ||
    type === 'HOUSEHOLD' ||
    type === 'NEIGHBORHOOD' ||
    type === 'RELATION' ||
    type === 'EMANCIPATION' ||
    type === 'ENSLAVEMENT' ||
    type === 'SLAVERY'
  ) {
    // When ADDING or EDITING, formValues.event are defined. When deleting, it is not.
    // Slavery is only used when ADDING an ENSLAVEMENT or EMANCIPATION type.
    const associationType = (
      (type === 'SLAVERY' || type === 'ENSLAVEMENT' || type === 'EMANCIPATION') && formValues.event
        ? formValues.event
        : (type as Exclude<typeof type, 'SLAVERY'>)
    )!
    const conclusion: AssociationEventConclusion = {
      details: {
        detailsType: 'AssociationDetails',
        sourceCount: 0,
        description,
        type: associationType,
        date,
        generationNumber,
        place,
        title,
      },
      type: associationType,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }
  if (
    type === 'AFFILIATION' ||
    type === 'BAR_MITZVAH' ||
    type === 'BAS_MITZVAH' ||
    type === 'CREMATION' ||
    type === 'IMMIGRATION' ||
    type === 'MILITARY_SERVICE' ||
    type === 'NATURALIZATION' ||
    type === 'NOBILITY_TITLE' ||
    type === 'OCCUPATION' ||
    type === 'RELIGIOUS_AFFILIATION' ||
    type === 'RESIDENCE' ||
    type === 'STILLBORN'
  ) {
    const conclusion: NonVitalEventConclusion = {
      details: {
        type,
        detailsType: 'EventDetails',
        sourceCount: 0,
        date,
        place,
        title,
        description,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }
  if (type === 'COUPLE_NEVER_HAD_CHILDREN') {
    const conclusion: RelationshipFactConclusion = {
      details: {
        type,
        detailsType: 'CharacteristicDetails',
        sourceCount: 0,
        title,
      },
      type,
      justification,
      id,
      multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
    }
    return conclusion
  }

  const conclusion: RelationshipEventConclusion = {
    details: {
      type,
      detailsType: 'EventDetails',
      sourceCount: 0,
      title,
      date,
      place,
    },
    type,
    justification,
    id,
    multiValued: CONCLUSION_PROPERTIES_MAP[type].multiValued,
  }
  return conclusion
}

export function convertTreeDataToFormData(conclusion?: Conclusion): Partial<Record<FieldType, unknown>> {
  if (!conclusion) return {}
  const { type, justification, id, details = {} } = conclusion
  if (!id) {
    if (type === 'DEATH') {
      return { living: 'LIVING' }
    }
    return {}
  }
  const {
    date,
    place,
    nameForms: tdNameForms,
    nameType,
    gender,
    description,
    title,
    text,
    userCertified,
  } = details as {
    date?: EventDate
    place?: EventPlace
    nameForms?: NameForm[]
    nameType?: string
    gender?: Gender
    description?: string
    title?: string
    text?: string
    userCertified?: boolean
  }

  const fields = getFieldsForConclusion(type)
  const formDate = fields.includes('date') ? formatTreeDataToStandardSuggest(date) : undefined
  const formPlace = fields.includes('place') ? formatTreeDataToStandardSuggest(place) : undefined
  const nameForms = fields.includes('nameTemplate') ? nameFormsFromTreeData(tdNameForms) : {}

  let template = tdNameForms?.[0]?.lang?.split('-')[0]
  // x-Latn is the only exception to the rule of language being `template-addition`
  if (template === 'x') template = 'und'

  const isLineageConclusion = type.includes('LINEAGE')
  const generationNumber = (conclusion.details as AssociationEventConclusionDetails)?.generationNumber

  let livingStatus
  if (fields.includes('living')) {
    livingStatus = 'DECEASED'
  }
  return {
    ...nameForms,
    nameType,
    sex: gender,
    title: isLineageConclusion ? undefined : title,
    text,
    date: formDate,
    type: isLineageConclusion ? title : undefined,
    living: livingStatus,
    coupleEventType: fields.includes('coupleEventType') ? type : undefined,
    coupleFactType: fields.includes('coupleFactType') ? type : undefined,
    place: formPlace,
    description,
    justification,
    template,
    generationNumber,
    certified: userCertified,
  }
}

export function getLineageConclusionSummary(
  conclusion: Conclusion,
  /** Supports many person types. These types were tested to work */
  parent: BasePerson | Person | SummaryPerson | FamilyMemberPerson
): string {
  if (conclusion?.details && (conclusion.type === 'PARENT1_LINEAGE' || conclusion.type === 'PARENT2_LINEAGE')) {
    const date = conclusion.details.date?.originalText
    // TODO, next major version change this to not use i18n, but the t func instead by passing in t: TFunction.
    const title = i18n.t(lineageLabelKeyMap[conclusion.details.title])
    const name = getNameRelatedData(parent).fullName
    let formattedString = ''

    if (date) {
      formattedString += `${date}\xa0•\xa0`
    }
    formattedString += `${title}\xa0\u2013\xa0${name}`

    return formattedString
  }
  return ''
}

/**
 * Create the url to get/delete/post/put the conclusion based off of the conclusion, ids, and what type of url you want.
 * @param {*} conclusion - The conclusion to get - must have the id (if its an existing conclusion) and the type
 * @param {string} personIdOrRelationshipId - The personId or relationshipId to attach the conclusion to
 * @param {('get'|'post'|'put'|'delete')} action - What action you will want to perform with the url
 * @returns {string} - The resulting service endpoint url.
 */
export function createConclusionUrl(
  conclusion: { type: Conclusion['type']; id?: Conclusion['id'] },
  personIdOrRelationshipId: string,
  action?: string
): string {
  if (!personIdOrRelationshipId) throw new Error('Missing personOrRelationshipId')
  if (!isValidConclusionType(conclusion.type)) throw new Error(`Invalid conclusionType: ${conclusion.type}`)
  const urlSuffix = conclusion.id ? `/${conclusion.id}` : ''
  let url = `/service/tree/tree-data/person/${personIdOrRelationshipId}/conclusion${urlSuffix}`
  const relationshipType = getRelationshipType(conclusion.type)

  if (relationshipType) {
    url = `/service/tree/tree-data/relationship/${relationshipType}/${personIdOrRelationshipId}/conclusions${urlSuffix}`
  }

  if (action === 'delete' && relationshipType !== 'association') {
    url = `${url}/${action}`
  }
  return url
}

export function getChangelogLink({
  type,
  personId,
  relationshipId,
}: {
  type: ConclusionType
  personId: PersonId
  relationshipId?: string
}): string {
  let changelogLink = `/tree/person/changelog/${personId}/${changelogTypeMap[type]}`
  const conclusionCategory = getConclusionCategory(type)
  if (
    relationshipConclusionCategories.includes(
      conclusionCategory as (typeof relationshipConclusionCategories)[number]
    ) &&
    relationshipId
  ) {
    changelogLink = `${changelogLink}/${relationshipId}`
  }
  return changelogLink
}

export function getDeleteSuggestedReasonsType(
  conclusionType: ConclusionType | 'SLAVERY' | LegacyConclusionType
): string | undefined {
  if (!isValidConclusionType(conclusionType)) throw new Error(`Invalid conclusionType: ${conclusionType}`)
  return (CONCLUSION_PROPERTIES_MAP[conclusionType] as PropertyType).deleteSuggestedReasonsType
}

export function getAddOrEditSuggestedReasonsType(
  conclusionType?: ConclusionType | 'SLAVERY' | LegacyConclusionType
): string | undefined {
  if (!isValidConclusionType(conclusionType)) throw new Error(`Invalid conclusionType: ${conclusionType}`)
  return (CONCLUSION_PROPERTIES_MAP[conclusionType] as PropertyType).addOrEditSuggestedReasonsType
}

export function getPartialNameTypeOptions(t: TFunction): { value: FullAlternateNameType; label: string }[] {
  return nameTypesToNameTypeOptions(ALTERNATE_NAME_TYPES, t)
}

export function getFullNameTypeOptions(t: TFunction): { value: FullAlternateNameType; label: string }[] {
  return nameTypesToNameTypeOptions([...ALTERNATE_NAME_TYPES, ...CHINESE_ALTERNATE_NAME_TYPES], t)
}

function nameTypesToNameTypeOptions(
  nameTypes: FullAlternateNameType[],
  t: TFunction
): { value: FullAlternateNameType; label: string }[] {
  return nameTypes.map((type) => ({ value: type, label: t(nameTypeKeyMap[type]) }))
}

export function getLineageTypeOptions(t: TFunction): { value: RelationshipLineageType; label: string }[] {
  return LINEAGE_TYPES.map((type) => ({ value: type, label: t(lineageLabelKeyMap[type]) }))
}

export function getGenerationNumberOptions(): { value: string; label: string }[] {
  return [2, 3, 4, 5, 6, 7, 8, 9, 10].map((number) => ({ value: `${number}`, label: `${number}` }))
}
