import getPermission from '@fs/zion-permissions'
import { getUser } from '@fs/zion-user'
import { hasActivatorFailure, hasRoleFailure } from '../utils'

export const errors = {
  GENERIC: 'GENERIC', // CAS/getUser calls failed
  PROFILE: 'PROFILE', // Does not have contactName
  BLOCKED: 'BLOCKED', // Is in cannotViewTreeGroup in CAS
  COUNTRY: 'COUNTRY', // Has IP from blocked country and not a member
}

let cachedResponse

export default async function isAuthorizedToViewTree(ignoreCache) {
  let error
  if (cachedResponse && !ignoreCache) return cachedResponse

  const viewTreePermissionPromise = getPermission(['FtLoginPermission', 'FtWritePermission'], 'FamilyTree')

  try {
    const [
      { authorized: canViewTree, activatorFailures: canViewTreeFailures, roleResults: canViewTreeRoleResults },
      { contactName },
    ] = await Promise.all([viewTreePermissionPromise, getUser()])

    const inCannotViewTreeGroup = hasRoleFailure(canViewTreeRoleResults, 'FtUserRole', 'Cannot view tree')
    const isReadOnlyUser = hasRoleFailure(canViewTreeRoleResults, 'FtContributorRole', 'Cannot edit tree')
    const ipNotInRange = hasActivatorFailure(canViewTreeFailures, 'IpAddressNotInRange Activator')
    const isBadProfileUser = !contactName
    let isAuthorized = canViewTree

    // block if user has bad profile
    if (isBadProfileUser) {
      isAuthorized = false
      error = errors.PROFILE
    }

    // block if IP not in range
    if (ipNotInRange) {
      isAuthorized = false
      error = errors.COUNTRY
    }

    // allow in readOnly mode if in canNotEditTreeGroup
    if (isReadOnlyUser) {
      isAuthorized = true
    }

    // block if in cannotViewTreeGroup
    if (inCannotViewTreeGroup) {
      isAuthorized = false
      error = errors.BLOCKED
    }

    cachedResponse = { isAuthorized, isReadOnlyUser, error }
    return cachedResponse
  } catch (e) {
    return { isAuthorized: false, error: errors.GENERIC }
  }
}
