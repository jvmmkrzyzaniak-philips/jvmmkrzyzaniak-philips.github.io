import Cookies from 'js-cookie'
import axios from 'axios'
import zionDebug, { printDeprecationWarning } from '@fs/zion-debug'
import { isLoggedIn } from '@fs/zion-config'
import { getCachedSession, setCachedSession } from './cache'

import getIp from './ip'

const debug = zionDebug('zion:session:index')

const CLIENT_DEV_KEY = 'a02f100000TnN56AAF'
const sessionUrl = '/service/ident/cis/cis-public-api/v4/session'
const anonSessionUrl = '/service/ident/cis/cis-web/oauth2/v3/token'
let pendingPromise = false

export function clearSessionIdCache() {
  printDeprecationWarning(
    'There is no longer a sessionId cache in zion-session, `clearSessionIdCache()` is deprecated and a no-op and will be removed in the next major version'
  )
}

export function getSessionId() {
  // caching the sessionId in memory seems to cause issues with cross-tab behavior, so do not cache this, always read it fresh from the cookie
  return Cookies.get('fssessionid')
}

export const sessionTypes = {
  unknown: 'UNKNOWN',
  noSession: 'NO_SESSION',
  anonymousSession: 'ANONYMOUS_SESSION',
  userSession: 'USER_SESSION',
}
export function getSessionType() {
  const windowDefined = typeof window !== 'undefined'
  debug('getSessionType', { windowDefined, isLoggedIn })
  if (!windowDefined || typeof isLoggedIn === 'undefined') return sessionTypes.unknown
  if (!getSessionId()) return sessionTypes.noSession
  if (isLoggedIn) return sessionTypes.userSession
  return sessionTypes.anonymousSession
}

export class NoUserSessionError extends Error {
  constructor(message) {
    super(message)
    this.name = 'NoUserSessionError'
  }
}
export class NoSessionError extends Error {
  constructor(message) {
    super(message)
    this.name = 'NoSessionError'
  }
}
export function validUserSessionOrError() {
  const sessionType = getSessionType()
  if (
    sessionType === sessionTypes.noSession ||
    sessionType === sessionTypes.anonymousSession ||
    (sessionType === sessionTypes.unknown && !getSessionId())
  ) {
    throw new NoUserSessionError('No User Session Id')
  }
}
export function validAnonSessionOrError() {
  const sessionType = getSessionType()
  if (sessionType === sessionTypes.noSession || (sessionType === sessionTypes.unknown && !getSessionId())) {
    throw new NoSessionError('No Session Id')
  }
}

export function extractCorrelationId(fullSessionId) {
  // https://icseng.atlassian.net/wiki/spaces/Product/pages/133597684/Session+ID+Format
  return fullSessionId?.split('.')[0]
}

export function getCorrelationId() {
  return extractCorrelationId(getSessionId())
}

export async function getSession(ignoreCache) {
  const fssessionid = getSessionId()
  // if no fssessionid cookie
  if (!fssessionid) {
    return false
  }
  if (!ignoreCache) {
    const cachedSession = getCachedSession(fssessionid)

    if (cachedSession) return cachedSession
  }

  pendingPromise = pendingPromise || axios.get(`${sessionUrl}/${fssessionid}`)

  try {
    const { data } = await pendingPromise

    if (data?.session) {
      setCachedSession(data)
      return data
    }
  } finally {
    pendingPromise = false
  }
  return false
}

export async function getNewAnonSession(ipAddress, devKey) {
  if (!ipAddress || !devKey) {
    throw new Error('ipAddress and devKey required')
  }
  let currSession = false
  try {
    const sessionRes = await getSession()

    if (sessionRes.session) {
      // valid user session
      currSession = sessionRes
    }
  } catch (error) {
    // if no valid session, move along
    // console.error('getCurrentSession Error:', error);
  }
  if (currSession) {
    // if user session valid, don't continue to make an anon session
    return currSession.session
  }
  const body = `grant_type=unauthenticated_session&ip_address=${ipAddress}&client_id=${devKey}`
  const anonOptions = {
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
  }

  const { data } = await axios.post(anonSessionUrl, body, anonOptions)

  if (data && data.token) {
    let cookieDomain
    if (typeof window !== 'undefined' && window.location.hostname.match('familysearch.org')) {
      cookieDomain = '.familysearch.org'
    }
    Cookies.set('fssessionid', data.token, { domain: cookieDomain })
    return { id: data.token }
  }
  throw new Error('No session found.')
}

export async function getAnonSession() {
  // get ip
  const ip = await getIp()
  // get devkey
  const devKey = CLIENT_DEV_KEY
  // get new session
  if (!ip || !devKey) {
    throw new Error('getAnonSession requires valid ip and devkey')
  }
  const anonSession = await getNewAnonSession(ip, devKey)

  return anonSession
}
