import axios from '@fs/zion-axios'
import { useEffect, useState, useRef } from 'react'
import { getEffectiveUser } from '@fs/zion-user'

export function usePreference(...keys) {
  const [pref, setPref] = useState()

  // Since keys above is a rest param, a new array is created everytime the function is called (every render)
  // which causes an infinite loop in the useEffect below. The fix is to use a ref and compare it ourself.
  const ref = useRef(keys)
  if (JSON.stringify(ref.current) !== JSON.stringify(keys)) {
    ref.current = keys
  }
  const { current } = ref

  useEffect(() => {
    let isCurrent = true
    getPreference(...current)
      .then((...args) => {
        isCurrent && setPref(...args)
      })
      .catch(() => {
        // Network call failed.  The user might not be signed in.
        // For a single key, leave original default.
        // For multiple keys, return the object with undefined values.
        if (ref.current.length > 1) {
          setPref(
            ref.current.reduce((acc, key) => {
              acc[key] = { value: undefined }
              return acc
            }, {})
          )
        }
      })
    return () => {
      isCurrent = false
    }
  }, [current])
  return pref
}

const defer = () => {
  const deferred = {}
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve
    deferred.reject = reject
  })
  return deferred
}

const deferredCache = {}

// for testing
export const clearPrefsCache = () => {
  Object.keys(deferredCache).forEach((cacheKey) => delete deferredCache[cacheKey])
}

export async function getPreference(...prefKeys) {
  let cisId
  try {
    const user = await getEffectiveUser()
    cisId = user.cisId
  } catch (e) {
    // If the user is not logged in, fail gracefully
    if (e.name === 'NoUserSessionError') {
      return null
    }
    throw e
  }

  const getCacheKey = (key) => `name=${key}${cisId}`

  const getCache = (key) => deferredCache[getCacheKey(key)]

  const newKeys = []
  prefKeys.forEach((key) => {
    if (!getCache(key)) {
      deferredCache[getCacheKey(key)] = defer()
      newKeys.push(key)
    }
  })

  if (newKeys.length) {
    try {
      const preferenceString = newKeys.map((pref) => `name=${pref}`).join('&')
      const url = `/service/cmn/user-preferences/users/${cisId}/preferences?${preferenceString}`
      const { data } = await axios.get(url)
      newKeys.forEach((key) => {
        getCache(key)?.resolve(data[key]?.value ?? '')
      })
    } catch (e) {
      const handleError =
        e.name === 'NoUserSessionError' ? (cache) => cache?.resolve(null) : (cache) => cache?.reject(e)
      newKeys.forEach((key) => {
        handleError(getCache(key))
      })
    }
  }

  if (prefKeys.length === 1) {
    return getCache(prefKeys[0])?.promise
  }

  const promises = prefKeys.map((key) => {
    return getCache(key)?.promise
  })

  const results = await Promise.all(promises)
  const result = {}
  prefKeys.forEach((key, index) => {
    result[key] = { value: results[index] }
  })
  return result
}

async function getUserId() {
  const { cisId } = await getEffectiveUser()
  if (!cisId) {
    throw new Error('no user signed in.')
  }
  return cisId
}

function removeItemFromCache(key) {
  // clear memory cache if it includes the current key
  Object.keys(deferredCache)
    .filter((cacheKey) => cacheKey.includes(key))
    .forEach((cacheKey) => delete deferredCache[cacheKey])
}

export async function setPreference(key, value) {
  if (!key || value === undefined) {
    throw new Error('Must pass preference key and value')
  }

  const cisId = await getUserId()

  removeItemFromCache(key)

  const url = `/service/cmn/user-preferences/users/${cisId}/preferences/${key}`
  await axios.put(url, { value })

  return value
}

export async function deletePreference(key) {
  if (!key) {
    throw new Error('Must pass preference key to remove')
  }

  const cisId = await getUserId()

  removeItemFromCache(key)

  const url = `/service/cmn/user-preferences/users/${cisId}/preferences/${key}`
  return axios.delete(url)
}

export const preCachePreferences = async (...prefKeys) => {
  return getPreference(...prefKeys)
}
