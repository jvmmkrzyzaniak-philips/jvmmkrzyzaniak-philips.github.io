import localforage from 'localforage/dist/localforage.nopromises'
import memoryStorageDriver from 'localforage-memoryStorageDriver'
import sessionStorageWrapper from 'localforage-sessionstoragewrapper'
import { setLifetime, calculateDbName, setStoreName, setDriver } from './setupConfig'
import { handleError, saveDB, failSafe } from './utils'
import { periodicClear } from './clear'

// set up session storage and memory drivers since localforage doesn't ship with them
localforage.defineDriver(sessionStorageWrapper)
localforage.defineDriver(memoryStorageDriver)

export default class Cache {
  /**
   * Creates a loccalforage instance and returns it with some defaults set.
   * @param {Object} config - config for cache creation
   * @param {string} config.dbName Top level namespace for cache. defaults to helpee's cisId, cisId or fs (probably shouldn't define this)
   * @param {string} config.storeName Second level namespace for cache. Should always be defined
   * @param {string|Number} config.storeVersion version for store
   * @param {string} config.lifetime Defines how long cache should live. 'hour', 'day', 'week', 'twoWeeks', or a number in milliseconds
   * @param {string} config.type Defines store type. 'local' for localStorage, 'session' for sessionStorage, 'memory' to store in memory, defaults to indexedDB
   * @param {string} config.size Defines db size. defaults to 4500000 (4.5MB)
   * @param {string} config.encrypted Whether or not to encrypt data. default: false
   */
  constructor(opts = {}) {
    this.opts = opts
    this.ready()
  }

  async ready() {
    if (this.localforage) return true
    this.encrypted = this.opts.encrypted || false

    if (this.pending) return this.pending

    this.pending = calculateDbName(this.opts)
    const dbName = await this.pending

    const dbConfig = {
      name: dbName,
      storeName: setStoreName(this.opts),
      lifetime: setLifetime(this.opts.lifetime),
      /**
       * Setup size from config or default to 4.5MB (to prevent safari bug)
       */
      size: this.opts.size || 4500000,
      driver: setDriver(this.opts.type, localforage, memoryStorageDriver, sessionStorageWrapper),
    }
    this.localforage = localforage.createInstance(dbConfig)

    failSafe(this.localforage)

    saveDB(dbConfig)
      // TODO; run periodicClear just one time on startup
      .then(() => periodicClear())
      .catch(handleError)

    return true
  }

  get getItem() {
    if (this.encrypted) {
      return this.getEncrypted
    }
    return this.getItemData
  }

  get setItem() {
    if (this.encrypted) {
      return this.setEncrypted
    }
    return this.setItemData
  }

  get updateItem() {
    if (this.encrypted) {
      return this.updateEncrypted
    }
    return this.updateItemData
  }

  async getItemData(key) {
    await this.ready()

    const getItemTimeout = new Promise((resolve) => {
      setTimeout(() => {
        resolve(null)
      }, 1500)
    })
    return Promise.race([getItemTimeout, this.localforage.getItem(key).catch(handleError)])
  }

  async setItemData(key, value) {
    await this.ready()

    const setItemTimeout = new Promise((resolve) => {
      setTimeout(() => {
        resolve(value)
      }, 1500)
    })
    return Promise.race([setItemTimeout, this.localforage.setItem(key, value).catch(handleError)])
  }

  async updateItemData(key, value) {
    await this.ready()
    const oldValue = await this.getItemData(key)
    return this.setItemData(key, { ...oldValue, ...value })
  }

  async getEncrypted(key) {
    try {
      const { decrypt } = await import('@fs/zion-crypto')
      const encryptedValue = await this.getItemData(key)
      if (!encryptedValue) {
        return null
      }
      return decrypt(encryptedValue)
    } catch (err) {
      return this.clear()
    }
  }

  async setEncrypted(key, value) {
    const { encrypt } = await import('@fs/zion-crypto')
    const encryptedValue = await encrypt(value)
    return this.setItemData(key, encryptedValue)
  }

  async updateEncrypted(key, value) {
    const oldValue = await this.getEncrypted(key)
    return this.setEncrypted(key, { ...oldValue, ...value })
  }

  async clear() {
    await this.ready()

    return this.localforage.clear()
  }

  async keys() {
    await this.ready()

    return this.localforage.keys()
  }

  async removeItem(key) {
    await this.ready()

    return this.localforage.removeItem(key)
  }
}

export { clearAll } from './clear'

// TODO: look at this when experiments work. and access window only after checking `typeof window !== 'undefined'`
// if (window.FS.showEx('clearCacheEx')) {
//   window.FS.cache.clearAll();
//   window.FS.setEx('clearCacheEx', false);
//   window.location.reload();
// }
