import localforage from 'localforage/dist/localforage.nopromises'
import { v4 as uuid } from 'uuid'
import { getSession } from '@fs/zion-session'
import debug from '@fs/zion-debug'
import { clearAll } from './clear'

const log = debug('cache:utils:warn')

/**
 * Helper function to get all failed DBs in session storage.
 * @returns {Array} Array of failed dbs.
 */
export function getFailedDBs() {
  let failedDbs = sessionStorage.FAILED_DBS || '[]'

  try {
    failedDbs = JSON.parse(failedDbs)
  } catch (err) {
    failedDbs = []
  }
  return failedDbs
}
/**
 * If DB fails to be created, add it to list here.
 * @param {String} dbName Name of db.
 */
export function addFailedDB(dbName) {
  if (!dbName) return

  let failedDbs = getFailedDBs()

  failedDbs.push(dbName)
  try {
    failedDbs = JSON.stringify(failedDbs)
  } catch (err) {
    failedDbs = []
  }
  try {
    // TW-3190: This was another place that could cause QuotaExceededError
    sessionStorage.FAILED_DBS = failedDbs
  } catch (error) {
    log('failSafe: ', error)
  }
}
export function isValidDBName(dbName) {
  return !getFailedDBs().includes(dbName)
}

/**
 * Generates a valid dbName if the previous one failed to be created.
 * Just adds __1 incrementing up to 10.
 * @param  {String} name             Name of DB.
 * @param  {Number} [dbNameNumber=1] Iteration number.
 * @return {String}                  Valid db name.
 */
export function generateDBName(name, dbNameNumber = 1) {
  // this prevents this recursive function from maxing out.
  if (dbNameNumber > 9) throw new Error("Can't generate a db name.")

  const tempName = `${name}__${dbNameNumber}`
  if (isValidDBName(tempName)) {
    return tempName
  }
  return generateDBName(name, dbNameNumber + 1)
}

export class QuotaExceededError extends Error {
  constructor(message) {
    super(message) // (1)
    this.name = 'StorageQuotaExceeded'
    this.code = 22
    this.message = message || 'Storage Quota Exceeded'
    this.stack = new Error().stack
  }
}

/**
 * Quota Exceeded Errors
 *
 * iOS Safari 10.2 throws SQLError
 * {
 *   message: "there was not enough remaining storage space, or the storage quota was reached and the user declined to allow more space"
 *   code: 4
 * }
 *
 * Firefox 51 throws DOMError
 * {
 *   message: "The current transaction exceeded its quota limitations.",
 *   name: "QuotaExceededError"
 * }
 *
 * Safari 10 throws a null error. Real cool safari
 * null
 *
 * Chrome 56 throws DOMException
 * {
 *   code: 22,
 *   name: "QuotaExceededError"
 * }
 *
 */
const isQuotaExceededError = (err) => {
  const quotaStringToCheck = 'quota'
  const errorNameIncludesQuota = err?.name?.toLowerCase().includes(quotaStringToCheck)
  const errorMessageIncludesQuota = err?.message?.toLowerCase().includes(quotaStringToCheck)

  return err === null || (err && err.code === 22) || errorNameIncludesQuota || errorMessageIncludesQuota
}

/**
 * A method that sends error logs to splunk
 * @param {Error} err
 */

export function handleError(err) {
  if (isQuotaExceededError(err)) {
    clearAll()
    log(err?.message)
  } else if (err?.name === 'InvalidStateError') {
    // TW-2814 - Firefox in incognito doesn't have indexedDB
    log(err)
  } else if (err?.message.indexOf("DB didn't respond") !== -1) {
    log(err.message)
  } else if (err?.message.indexOf('Internal error opening backing store for indexedDB.open') !== -1) {
    // TW-3056 - For now, there is nothing to be done, but log the error to Splunk.
    log(err.message)
  } else {
    log('zion cache threw: ', err)
    throw err
  }
}

export const dbSaveQueue = []
let dbSaving = false

/**
 * Saves a unique list of all localforage instances created
 * through window.FS.cache.instance so we can clear/delete them later
 * @param {Object} config
 * @returns {Promise}
 */
export async function saveDB(config) {
  log('config is\n', config)
  if (dbSaving) {
    dbSaveQueue.push(config)
    return
  }
  dbSaving = true
  const dbs = (await localforage.getItem('DBs')) || []

  const inCache = dbs.filter((db) => {
    const tempDb = { storeName: db.storeName, driver: db.driver, tempConfigName: db.name }
    const tempConfig = {
      storeName: config.storeName,
      driver: config.driver,
      tempConfigName: config.name,
    }
    log('leaving saveDb')
    return JSON.stringify(tempDb) === JSON.stringify(tempConfig)
  })

  if (!inCache.length) {
    config.id = uuid()
    dbs.push(config)
  } else {
    dbs.forEach((db) => {
      if (db.id === inCache[0].id) {
        db.lifetime = config.lifetime
      }
    })
  }
  try {
    await localforage.setItem('DBs', dbs)
    dbSaving = false
    log('length\n', dbSaveQueue.length)
    if (dbSaveQueue.length) {
      const db = dbSaveQueue.shift()
      await saveDB(db)
    }
  } catch (err) {
    dbSaving = false
    handleError(err)
  }
}

function handleFailSafe() {
  /* eslint-disable no-underscore-dangle */
  if (isValidDBName(this._config.name)) {
    addFailedDB(this._config.name)
    /* eslint-enable no-underscore-dangle */
    handleError(new Error("DB didn't respond within 5 seconds."))
  }
}
/**
 * Failsafe if indexedDB gets corrupted
 *
 */
export function failSafe(db) {
  // if db isn't ready within 5 seconds, browser needs to be restarted.
  const dbReadyTimout = setTimeout(handleFailSafe.bind(db), 5000)

  // if db gets ready within 5 seconds, clear timeout
  db.ready()
    .then(() => {
      clearTimeout(dbReadyTimout)
    })
    .catch(handleError)
}
/**
 * Get the current role of the user. (used for detecting admin mode)
 * HUGE NOTE: We copied this directly from @fs/zion-admin-mode to prevent
 * a circular dependency.
 *
 */
export async function getActiveRole() {
  try {
    const { session } = await getSession()
    if (!session) return ''

    const val = session.values && session.values.find((v) => v.name === 'AssignmentServiceAssignment')
    return val ? val.value : ''
  } catch (error) {
    console.error(error)
    return ''
  }
}
