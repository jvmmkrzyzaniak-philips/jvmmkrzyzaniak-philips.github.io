import { useState, useEffect, useCallback, useMemo, useRef } from 'react'
import Cache from './cache'

export default function useCache({ cache: cacheConfig, key, initialValue }) {
  if (!cacheConfig) {
    throw new Error('`cache` must be defined. Either a Zion Cache instance or cache config object.')
  }
  if (!key) {
    throw new Error('`key` must be defined.')
  }

  // if we don't use `useMemo` here, it keeps creating a new cache and continuously calling useEffect below.
  const cache = useMemo(() => (cacheConfig.pending ? cacheConfig : new Cache(cacheConfig)), [cacheConfig])

  const [cachedDataState, setCachedDataState] = useState()

  // Keep track of whether setCachedData has been called so that we don't
  // return the initial or cached value after it's been changed.
  // Had to use useRef() instead of useState() because we need to examine
  // the value in the async response handler of cache.getItem(); if we used
  // useState then it'd have a stale value in the closure.
  // The idea to use useRef came from:
  // https://reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often
  const dataChanged = useRef(false)

  const setCachedData = useCallback(
    (data) => {
      dataChanged.current = true
      cache.setItem(key, data).then((cachedData) => setCachedDataState(cachedData))
    },
    [cache, key]
  )

  useEffect(() => {
    let cancelled = false
    cache.getItem(key).then((data) => {
      // Only return the cached or initial value if the value hasn't already been changed.
      if (!cancelled && !dataChanged.current) {
        if (!data && initialValue !== undefined) {
          setCachedData(initialValue)
        } else {
          setCachedDataState(data)
        }
      }
    })
    return () => {
      cancelled = true
    }
  }, [cache, initialValue, key, setCachedData])

  return [cachedDataState, setCachedData]
}
