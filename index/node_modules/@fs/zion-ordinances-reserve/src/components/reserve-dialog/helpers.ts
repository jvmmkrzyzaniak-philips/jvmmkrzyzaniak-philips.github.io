import { useEffect, useRef, useState } from 'react'
import type { BCIEOrdinance, Ordinance, SPOrdinance, SSOrdinance } from '@fs/zion-tree-types'
import { ordToLetterMap } from '../../helpers/typeHelpers'
import type { SubjectCouple, SubjectMainPerson, SubjectOrdinances, SupportCases } from '../../types'

const MAX_RETRY = 15

export const ordinanceTranslationKeyMap = {
  BAPTISM: 'ordinances-reserve.BAPTISM.label',
  CONFIRMATION: 'ordinances-reserve.CONFIRMATION.label',
  INITIATORY: 'ordinances-reserve.INITIATORY.label',
  ENDOWMENT: 'ordinances-reserve.ENDOWMENT.label',
  SEALING_TO_SPOUSE: 'ordinances-reserve.SEALING_TO_SPOUSE.label',
  SEALING_TO_PARENTS: 'ordinances-reserve.SEALING_TO_PARENTS.label',
}

export const usePollRefetch = (
  condition: boolean,
  refetch: () => void | Promise<void>
): { retryLimitReached: boolean; reset: () => void } => {
  const [retryLimitReached, setRetryLimitReached] = useState(false)
  const [canRefetch, setCanRefetch] = useState(true)
  const isCurrent = useRef(true)
  const retryCount = useRef(0)

  useEffect(() => {
    isCurrent.current = true
    let timeoutId: NodeJS.Timeout
    if (retryCount.current < MAX_RETRY && condition && canRefetch) {
      retryCount.current++
      timeoutId = setTimeout(() => {
        setCanRefetch(false)
        Promise.all([refetch()])
          .then(() => {
            if (isCurrent.current) {
              setCanRefetch(true)
            }
            return undefined
          })
          .catch(console.error)
      }, 1000)
    }
    if (retryCount.current === MAX_RETRY) {
      setRetryLimitReached(true)
    }
    return () => {
      if (timeoutId) clearTimeout(timeoutId)
      isCurrent.current = false
    }
  }, [canRefetch, condition, refetch])

  const reset = (): void => {
    retryCount.current = 0
    setRetryLimitReached(false)
  }

  return { retryLimitReached, reset }
}

export function getCaseIdsForOrdinance(
  ordinance: Ordinance,
  personId: string,
  supportCases: SupportCases
): { allCaseIds: string[]; approvedCaseIds: string[] } {
  const supportCasesForOrdinance = Object.entries(supportCases || {}).filter(([, { subject }]) => {
    if (!subject) return false
    return isSupportCaseForOrdinance([ordinance], subject, personId)
  })

  const approvedSupportCasesObjects = supportCasesForOrdinance.reduce<
    {
      supportCaseNumber: string
      spouse1Id: string | undefined
      spouse2Id: string | undefined
      mainPersonId: string | undefined
      parent1Id: string | undefined
      parent2Id: string | undefined
      ordinances: string | undefined
    }[]
  >((approvedSupportCasesObject, [supportCaseNumber, { status, subject }]) => {
    if (status === 'AutoApproved') {
      const [subjectOrdinanceTypes, subjectMainPersonOrCouple, subjectParents] = subject.split(',') as [
        SubjectOrdinances,
        SubjectMainPerson | SubjectCouple,
        SubjectCouple | undefined,
      ]
      const ordinances = subjectOrdinanceTypes
        .match(/\(\w*\)/)?.[0]
        .replace('(', '')
        .replace(')', '')
      let spouse1Id: string | undefined
      let spouse2Id: string | undefined
      let mainPersonId: string | undefined
      let parent1Id: string | undefined
      let parent2Id: string | undefined
      if (/~/.test(subjectMainPersonOrCouple)) {
        // isCouple
        const [spouse1, spouse2] = subjectMainPersonOrCouple.split('~')
        spouse1Id = spouse1.match(/\(\.*\)/)?.[0]
        spouse2Id = spouse2.match(/\(\.*\)/)?.[0]
      } else {
        // isMainPerson
        mainPersonId = subjectMainPersonOrCouple.match(/\(\.*\)/)?.[0]
      }
      if (subjectParents) {
        const [parent1, parent2] = subjectParents.split('~')
        parent1Id = parent1.match(/\(\.*\)/)?.[0]
        parent2Id = parent2.match(/\(\.*\)/)?.[0]
      }

      return [
        ...approvedSupportCasesObject,
        { supportCaseNumber, spouse1Id, spouse2Id, mainPersonId, parent1Id, parent2Id, ordinances },
      ]
    }

    return approvedSupportCasesObject
  }, [])

  // Remove eclipsed cases from approved case objects
  const filteredApprovedSupportCaseObjs = approvedSupportCasesObjects.filter(
    (approvedSupportCaseObj, currentIndex, currentArray) => {
      for (let i = 0; i < currentArray.length; i++) {
        const caseObj = currentArray[i]

        if (
          i !== currentIndex &&
          (caseObj.mainPersonId === approvedSupportCaseObj.mainPersonId ||
            (caseObj.spouse1Id === approvedSupportCaseObj.spouse1Id &&
              caseObj.spouse2Id === approvedSupportCaseObj.spouse2Id)) &&
          ((caseObj.parent1Id &&
            caseObj.parent1Id === approvedSupportCaseObj.parent1Id &&
            caseObj.parent2Id === approvedSupportCaseObj.parent2Id) ||
            !caseObj.parent1Id ||
            !approvedSupportCaseObj.parent1Id) &&
          caseObj.ordinances &&
          approvedSupportCaseObj.ordinances &&
          caseObj.ordinances.includes(approvedSupportCaseObj.ordinances) &&
          !(caseObj.ordinances === approvedSupportCaseObj.ordinances && i > currentIndex)
        ) {
          return false
        }
      }
      return true
    },
    []
  )

  return {
    allCaseIds: Object.keys(Object.fromEntries(supportCasesForOrdinance)) as string[],
    approvedCaseIds: filteredApprovedSupportCaseObjs.map(({ supportCaseNumber }) => supportCaseNumber),
  }
}

export function isSupportCaseForOrdinance(ordinanceGroup: Ordinance[], subject: string, personId: string): boolean {
  const [subjectOrdinanceTypes, subjectMainPersonOrCouple, subjectParents] = subject.split(',')
  const needsPermissionOrdinances = ordinanceGroup.filter((ord) => ord.status === 'NeedsPermission')
  return (
    needsPermissionOrdinances.length > 0 &&
    needsPermissionOrdinances.every(
      (ord) =>
        new RegExp(`110 Year Ordinance Request for: (.*${ordToLetterMap[ord.type]}.*)`).test(subjectOrdinanceTypes) &&
        new RegExp(personId).test(subjectMainPersonOrCouple) &&
        !(
          ord.type === 'SEALING_TO_SPOUSE' &&
          !new RegExp(ord.relationships?.spouseId ?? '').test(subjectMainPersonOrCouple)
        ) &&
        !(
          ord.type === 'SEALING_TO_PARENTS' &&
          !(
            new RegExp(ord.relationships?.parent1Id ?? '').test(subjectParents) &&
            new RegExp(ord.relationships?.parent2Id ?? '').test(subjectParents)
          )
        )
    )
  )
}

export function groupByCheckboxOrdinances(
  ordinances: Ordinance[]
): (BCIEOrdinance[] | BCIEOrdinance | SPOrdinance | SSOrdinance)[] {
  // [B,C,I,E]
  const bcieOrdinances = ordinances.filter(
    (ord): ord is BCIEOrdinance => ord.type !== 'SEALING_TO_PARENTS' && ord.type !== 'SEALING_TO_SPOUSE'
  )

  const ssspOrdinances = ordinances.filter(
    (ord): ord is SPOrdinance | SSOrdinance => ord.type === 'SEALING_TO_PARENTS' || ord.type === 'SEALING_TO_SPOUSE'
  )

  const hideCompletedPersonOrd = bcieOrdinances.every((ord) => ord.status === 'Completed')

  // [[B,C],I,E,SP,SS]
  return [
    bcieOrdinances.filter((ord) => (ord.type === 'BAPTISM' || ord.type === 'CONFIRMATION') && !hideCompletedPersonOrd),
    ...bcieOrdinances.filter(
      (ord) => (ord.type === 'INITIATORY' || ord.type === 'ENDOWMENT') && !hideCompletedPersonOrd
    ),
    ...ssspOrdinances.filter((ord) => ord.status !== 'Completed'),
  ].filter((item) => (item instanceof Array ? item.length !== 0 : true))
}
